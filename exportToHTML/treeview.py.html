<html>
<head>
<title>treeview.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
treeview.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Tree View 
========= 
 
.. image:: images/treeview.png 
    :align: right 
 
.. versionadded:: 1.0.4 
 
 
:class:`TreeView` is a widget used to represent a tree structure. It is 
currently very basic, supporting a minimal feature set. 
 
Introduction 
------------ 
 
A :class:`TreeView` is populated with :class:`TreeViewNode` instances, but you 
cannot use a :class:`TreeViewNode` directly. You must combine it with another 
widget, such as :class:`~kivy.uix.label.Label`, 
:class:`~kivy.uix.button.Button` or even your own widget. The TreeView 
always creates a default root node, based on :class:`TreeViewLabel`. 
 
:class:`TreeViewNode` is a class object containing needed properties for 
serving as a tree node. Extend :class:`TreeViewNode` to create custom node 
types for use with a :class:`TreeView`. 
 
For constructing your own subclass, follow the pattern of TreeViewLabel which 
combines a Label and a TreeViewNode, producing a :class:`TreeViewLabel` for 
direct use in a TreeView instance. 
 
To use the TreeViewLabel class, you could create two nodes directly attached 
to root:: 
 
    tv = TreeView() 
    tv.add_node(TreeViewLabel(text='My first item')) 
    tv.add_node(TreeViewLabel(text='My second item')) 
 
Or, create two nodes attached to a first:: 
 
    tv = TreeView() 
    n1 = tv.add_node(TreeViewLabel(text='Item 1')) 
    tv.add_node(TreeViewLabel(text='SubItem 1'), n1) 
    tv.add_node(TreeViewLabel(text='SubItem 2'), n1) 
 
If you have a large tree structure, perhaps you would need a utility function 
to populate the tree view:: 
 
    def populate_tree_view(tree_view, parent, node): 
        if parent is None: 
            tree_node = tree_view.add_node(TreeViewLabel(text=node['node_id'], 
                                                         is_open=True)) 
        else: 
            tree_node = tree_view.add_node(TreeViewLabel(text=node['node_id'], 
                                                         is_open=True), parent) 
 
        for child_node in node['children']: 
            populate_tree_view(tree_view, tree_node, child_node) 
 
 
    tree = {'node_id': '1', 
            'children': [{'node_id': '1.1', 
                          'children': [{'node_id': '1.1.1', 
                                        'children': [{'node_id': '1.1.1.1', 
                                                      'children': []}]}, 
                                       {'node_id': '1.1.2', 
                                        'children': []}, 
                                       {'node_id': '1.1.3', 
                                        'children': []}]}, 
                          {'node_id': '1.2', 
                           'children': []}]} 
 
 
    class TreeWidget(FloatLayout): 
        def __init__(self, **kwargs): 
            super(TreeWidget, self).__init__(**kwargs) 
 
            tv = TreeView(root_options=dict(text='Tree One'), 
                          hide_root=False, 
                          indent_level=4) 
 
            populate_tree_view(tv, None, tree) 
 
            self.add_widget(tv) 
 
The root widget in the tree view is opened by default and has text set as 
'Root'. If you want to change that, you can use the 
:attr:`TreeView.root_options` 
property. This will pass options to the root widget:: 
 
    tv = TreeView(root_options=dict(text='My root label')) 
 
 
Creating Your Own Node Widget 
----------------------------- 
 
For a button node type, combine a :class:`~kivy.uix.button.Button` and a 
:class:`TreeViewNode` as follows:: 
 
    class TreeViewButton(Button, TreeViewNode): 
        pass 
 
You must know that, for a given node, only the 
:attr:`~kivy.uix.widget.Widget.size_hint_x` will be honored. The allocated 
width for the node will depend of the current width of the TreeView and the 
level of the node. For example, if a node is at level 4, the width 
allocated will be: 
 
    treeview.width - treeview.indent_start - treeview.indent_level * node.level 
 
You might have some trouble with that. It is the developer's responsibility to 
correctly handle adapting the graphical representation nodes, if needed. 
'''</span>

<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">clock </span><span class="s2">import </span><span class="s1">Clock</span>
<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">uix</span><span class="s3">.</span><span class="s1">label </span><span class="s2">import </span><span class="s1">Label</span>
<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">uix</span><span class="s3">.</span><span class="s1">widget </span><span class="s2">import </span><span class="s1">Widget</span>
<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">properties </span><span class="s2">import </span><span class="s1">BooleanProperty</span><span class="s3">, </span><span class="s1">ListProperty</span><span class="s3">, </span><span class="s1">ObjectProperty</span><span class="s3">, </span><span class="s1">\</span>
    <span class="s1">AliasProperty</span><span class="s3">, </span><span class="s1">NumericProperty</span><span class="s3">, </span><span class="s1">ReferenceListProperty</span><span class="s3">, </span><span class="s1">ColorProperty</span>


<span class="s2">class </span><span class="s1">TreeViewException</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s0">'''Exception for errors in the :class:`TreeView`. 
    '''</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TreeViewNode</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">'''TreeViewNode class, used to build a node class for a TreeView object. 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">is </span><span class="s1">TreeViewNode</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TreeViewException</span><span class="s3">(</span><span class="s4">'You cannot use directly TreeViewNode.'</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">TreeViewNode</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s1">is_leaf </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s4">'''Boolean to indicate whether this node is a leaf or not. Used to adjust 
    the graphical representation. 
 
    :attr:`is_leaf` is a :class:`~kivy.properties.BooleanProperty` and defaults 
    to True. It is automatically set to False when child is added. 
    '''</span>

    <span class="s1">is_open </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">'''Boolean to indicate whether this node is opened or not, in case there 
    are child nodes. This is used to adjust the graphical representation. 
 
    .. warning:: 
 
        This property is automatically set by the :class:`TreeView`. You can 
        read but not write it. 
 
    :attr:`is_open` is a :class:`~kivy.properties.BooleanProperty` and defaults 
    to False. 
    '''</span>

    <span class="s1">is_loaded </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">'''Boolean to indicate whether this node is already loaded or not. This 
    property is used only if the :class:`TreeView` uses asynchronous loading. 
 
    :attr:`is_loaded` is a :class:`~kivy.properties.BooleanProperty` and 
    defaults to False. 
    '''</span>

    <span class="s1">is_selected </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">'''Boolean to indicate whether this node is selected or not. This is used 
    adjust the graphical representation. 
 
    .. warning:: 
 
        This property is automatically set by the :class:`TreeView`. You can 
        read but not write it. 
 
    :attr:`is_selected` is a :class:`~kivy.properties.BooleanProperty` and 
    defaults to False. 
    '''</span>

    <span class="s1">no_selection </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">'''Boolean used to indicate whether selection of the node is allowed or 
     not. 
 
    :attr:`no_selection` is a :class:`~kivy.properties.BooleanProperty` and 
    defaults to False. 
    '''</span>

    <span class="s1">nodes </span><span class="s3">= </span><span class="s1">ListProperty</span><span class="s3">([])</span>
    <span class="s4">'''List of nodes. The nodes list is different than the children list. A 
    node in the nodes list represents a node on the tree. An item in the 
    children list represents the widget associated with the node. 
 
    .. warning:: 
 
        This property is automatically set by the :class:`TreeView`. You can 
        read but not write it. 
 
    :attr:`nodes` is a :class:`~kivy.properties.ListProperty` and defaults to 
    []. 
    '''</span>

    <span class="s1">parent_node </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">allownone</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s4">'''Parent node. This attribute is needed because the :attr:`parent` can be 
    None when the node is not displayed. 
 
    .. versionadded:: 1.0.7 
 
    :attr:`parent_node` is an :class:`~kivy.properties.ObjectProperty` and 
    defaults to None. 
    '''</span>

    <span class="s1">level </span><span class="s3">= </span><span class="s1">NumericProperty</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s4">'''Level of the node. 
 
    :attr:`level` is a :class:`~kivy.properties.NumericProperty` and defaults 
    to -1. 
    '''</span>

    <span class="s1">color_selected </span><span class="s3">= </span><span class="s1">ColorProperty</span><span class="s3">([</span><span class="s5">.3</span><span class="s3">, </span><span class="s5">.3</span><span class="s3">, </span><span class="s5">.3</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">])</span>
    <span class="s4">'''Background color of the node when the node is selected. 
 
    :attr:`color_selected` is a :class:`~kivy.properties.ColorProperty` and 
    defaults to [.1, .1, .1, 1]. 
 
    .. versionchanged:: 2.0.0 
        Changed from :class:`~kivy.properties.ListProperty` to 
        :class:`~kivy.properties.ColorProperty`. 
    '''</span>

    <span class="s1">odd </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">''' 
    This property is set by the TreeView widget automatically and is read-only. 
 
    :attr:`odd` is a :class:`~kivy.properties.BooleanProperty` and defaults to 
    False. 
    '''</span>

    <span class="s1">odd_color </span><span class="s3">= </span><span class="s1">ColorProperty</span><span class="s3">([</span><span class="s5">1.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">.0</span><span class="s3">])</span>
    <span class="s4">'''Background color of odd nodes when the node is not selected. 
 
    :attr:`odd_color` is a :class:`~kivy.properties.ColorProperty` and defaults 
    to [1., 1., 1., 0.]. 
 
    .. versionchanged:: 2.0.0 
        Changed from :class:`~kivy.properties.ListProperty` to 
        :class:`~kivy.properties.ColorProperty`. 
    '''</span>

    <span class="s1">even_color </span><span class="s3">= </span><span class="s1">ColorProperty</span><span class="s3">([</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">])</span>
    <span class="s4">'''Background color of even nodes when the node is not selected. 
 
    :attr:`bg_color` is a :class:`~kivy.properties.ColorProperty` and defaults 
    to [.5, .5, .5, .1]. 
 
    .. versionchanged:: 2.0.0 
        Changed from :class:`~kivy.properties.ListProperty` to 
        :class:`~kivy.properties.ColorProperty`. 
    '''</span>


<span class="s2">class </span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">Label</span><span class="s3">, </span><span class="s1">TreeViewNode</span><span class="s3">):</span>
    <span class="s0">'''Combines a :class:`~kivy.uix.label.Label` and a :class:`TreeViewNode` to 
    create a :class:`TreeViewLabel` that can be used as a text node in the 
    tree. 
 
    See module documentation for more information. 
    '''</span>


<span class="s2">class </span><span class="s1">TreeView</span><span class="s3">(</span><span class="s1">Widget</span><span class="s3">):</span>
    <span class="s0">'''TreeView class. See module documentation for more information. 
 
    :Events: 
        `on_node_expand`: (node, ) 
            Fired when a node is being expanded 
        `on_node_collapse`: (node, ) 
            Fired when a node is being collapsed 
    '''</span>

    <span class="s1">__events__ </span><span class="s3">= (</span><span class="s4">'on_node_expand'</span><span class="s3">, </span><span class="s4">'on_node_collapse'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout </span><span class="s3">= </span><span class="s1">Clock</span><span class="s3">.</span><span class="s1">create_trigger</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_do_layout</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">TreeView</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">tvlabel </span><span class="s3">= </span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Root'</span><span class="s3">, </span><span class="s1">is_open</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root_options</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">tvlabel</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_root </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">add_node</span><span class="s3">(</span><span class="s1">tvlabel</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s1">trigger </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span>
        <span class="s1">fbind </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fbind</span>
        <span class="s1">fbind</span><span class="s3">(</span><span class="s4">'pos'</span><span class="s3">, </span><span class="s1">trigger</span><span class="s3">)</span>
        <span class="s1">fbind</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">, </span><span class="s1">trigger</span><span class="s3">)</span>
        <span class="s1">fbind</span><span class="s3">(</span><span class="s4">'indent_level'</span><span class="s3">, </span><span class="s1">trigger</span><span class="s3">)</span>
        <span class="s1">fbind</span><span class="s3">(</span><span class="s4">'indent_start'</span><span class="s3">, </span><span class="s1">trigger</span><span class="s3">)</span>
        <span class="s1">trigger</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">add_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">'''Add a new node to the tree. 
 
        :Parameters: 
            `node`: instance of a :class:`TreeViewNode` 
                Node to add into the tree 
            `parent`: instance of a :class:`TreeViewNode`, defaults to None 
                Parent node to attach the new node. If `None`, it is added to 
                the :attr:`root` node. 
 
        :returns: 
            the node `node`. 
        '''</span>
        <span class="s6"># check if the widget is &quot;ok&quot; for a node</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TreeViewNode</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TreeViewException</span><span class="s3">(</span>
                <span class="s4">'The node must be a subclass of TreeViewNode'</span><span class="s3">)</span>
        <span class="s6"># create node</span>
        <span class="s2">if </span><span class="s1">parent </span><span class="s2">is None and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root</span><span class="s3">:</span>
            <span class="s1">parent </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root</span>
        <span class="s2">if </span><span class="s1">parent</span><span class="s3">:</span>
            <span class="s1">parent</span><span class="s3">.</span><span class="s1">is_leaf </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">parent</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">parent_node </span><span class="s3">= </span><span class="s1">parent</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">level </span><span class="s3">= </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">level </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">fbind</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">remove_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s0">'''Removes a node from the tree. 
 
        .. versionadded:: 1.0.7 
 
        :Parameters: 
            `node`: instance of a :class:`TreeViewNode` 
                Node to remove from the tree. If `node` is :attr:`root`, it is 
                not removed. 
        '''</span>
        <span class="s6"># check if the widget is &quot;ok&quot; for a node</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TreeViewNode</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TreeViewException</span><span class="s3">(</span>
                <span class="s4">'The node must be a subclass of TreeViewNode'</span><span class="s3">)</span>
        <span class="s1">parent </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">parent_node</span>
        <span class="s2">if </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span><span class="s3">:</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">is_selected </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">nodes </span><span class="s3">= </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">nodes</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes</span><span class="s3">:</span>
                <span class="s1">nodes</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">parent</span><span class="s3">.</span><span class="s1">is_leaf </span><span class="s3">= </span><span class="s2">not </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">nodes</span><span class="s3">))</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">parent_node </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">funbind</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">on_node_expand</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">on_node_collapse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">select_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s0">'''Select a node in the tree. 
        '''</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">no_selection</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span><span class="s3">.</span><span class="s1">is_selected </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">is_selected </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node </span><span class="s3">= </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">deselect_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">'''Deselect any selected node. 
 
        .. versionadded:: 1.10.0 
        '''</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span><span class="s3">.</span><span class="s1">is_selected </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">toggle_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s0">'''Toggle the state of the node (open/collapsed). 
        '''</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">is_open </span><span class="s3">= </span><span class="s2">not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_open</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_open</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_func </span><span class="s2">and not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_loaded</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_node_load</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dispatch</span><span class="s3">(</span><span class="s4">'on_node_expand'</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dispatch</span><span class="s3">(</span><span class="s4">'on_node_collapse'</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_trigger_layout</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_node_at_pos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">):</span>
        <span class="s0">'''Get the node at the position (x, y). 
        '''</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">pos</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterate_open_nodes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right </span><span class="s2">and </span><span class="s1">\</span>
               <span class="s1">node</span><span class="s3">.</span><span class="s1">y </span><span class="s3">&lt;= </span><span class="s1">y </span><span class="s3">&lt;= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">top</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">iterate_open_nodes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">'''Generator to iterate over all the expended nodes starting from 
        `node` and down. If `node` is `None`, the generator start with 
        :attr:`root`. 
 
        To get all the open nodes:: 
 
            treeview = TreeView() 
            # ... add nodes ... 
            for node in treeview.iterate_open_nodes(): 
                print(node) 
 
        '''</span>
        <span class="s2">if not </span><span class="s1">node</span><span class="s3">:</span>
            <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">hide_root </span><span class="s2">and </span><span class="s1">node </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">node</span>
        <span class="s2">if not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_open</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterate_open_nodes</span>
        <span class="s2">for </span><span class="s1">cnode </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">ynode </span><span class="s2">in </span><span class="s1">f</span><span class="s3">(</span><span class="s1">cnode</span><span class="s3">):</span>
                <span class="s2">yield </span><span class="s1">ynode</span>

    <span class="s2">def </span><span class="s1">iterate_all_nodes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">'''Generator to iterate over all nodes from `node` and down whether 
        expanded or not. If `node` is `None`, the generator start with 
        :attr:`root`. 
        '''</span>
        <span class="s2">if not </span><span class="s1">node</span><span class="s3">:</span>
            <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span>
        <span class="s2">yield </span><span class="s1">node</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterate_all_nodes</span>
        <span class="s2">for </span><span class="s1">cnode </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">ynode </span><span class="s2">in </span><span class="s1">f</span><span class="s3">(</span><span class="s1">cnode</span><span class="s3">):</span>
                <span class="s2">yield </span><span class="s1">ynode</span>

    <span class="s6">#</span>
    <span class="s6"># Private</span>
    <span class="s6">#</span>
    <span class="s2">def </span><span class="s1">on_load_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">Clock</span><span class="s3">.</span><span class="s1">schedule_once</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_do_initial_load</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_do_initial_load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">largs</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_func</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_node_load</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_do_node_load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s1">gen </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">:</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">is_loaded </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if not </span><span class="s1">gen</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">cnode </span><span class="s2">in </span><span class="s1">gen</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_node</span><span class="s3">(</span><span class="s1">cnode</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">on_root_options</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">value</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_do_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">largs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">clear_widgets</span><span class="s3">()</span>
        <span class="s6"># display only the one who are is_open</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_open_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">)</span>
        <span class="s6"># now do layout</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_layout_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">top</span><span class="s3">)</span>
        <span class="s6"># now iterate for calculating minimum size</span>
        <span class="s1">min_width </span><span class="s3">= </span><span class="s1">min_height </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">count</span><span class="s3">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterate_open_nodes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">)):</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">odd </span><span class="s3">= </span><span class="s2">False if </span><span class="s1">count </span><span class="s3">% </span><span class="s5">2 </span><span class="s2">else True</span>
            <span class="s1">min_width </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">min_width</span><span class="s3">, </span><span class="s1">node</span><span class="s3">.</span><span class="s1">right </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">min_height </span><span class="s3">+= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">height</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">minimum_size </span><span class="s3">= (</span><span class="s1">min_width</span><span class="s3">, </span><span class="s1">min_height</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_do_open_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">hide_root </span><span class="s2">and </span><span class="s1">node </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">:</span>
            <span class="s1">height </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_widget</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">height </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">height</span>
            <span class="s2">if not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_open</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">height</span>
        <span class="s2">for </span><span class="s1">cnode </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">:</span>
            <span class="s1">height </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_do_open_node</span><span class="s3">(</span><span class="s1">cnode</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">height</span>

    <span class="s2">def </span><span class="s1">_do_layout_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">level</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">hide_root </span><span class="s2">and </span><span class="s1">node </span><span class="s2">is </span><span class="s1">self</span><span class="s3">.</span><span class="s1">root</span><span class="s3">:</span>
            <span class="s1">level </span><span class="s3">-= </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indent_start </span><span class="s3">+ </span><span class="s1">level </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indent_level</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">top </span><span class="s3">= </span><span class="s1">y</span>
            <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">size_hint_x</span><span class="s3">:</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">width </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">width </span><span class="s3">- (</span><span class="s1">node</span><span class="s3">.</span><span class="s1">x </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)) </span><span class="s1">\</span>
                    <span class="s3">* </span><span class="s1">node</span><span class="s3">.</span><span class="s1">size_hint_x</span>
            <span class="s1">y </span><span class="s3">-= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">height</span>
            <span class="s2">if not </span><span class="s1">node</span><span class="s3">.</span><span class="s1">is_open</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">y</span>
        <span class="s2">for </span><span class="s1">cnode </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">:</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_do_layout_node</span><span class="s3">(</span><span class="s1">cnode</span><span class="s3">, </span><span class="s1">level </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">on_touch_down</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">touch</span><span class="s3">):</span>
        <span class="s1">node </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_node_at_pos</span><span class="s3">(</span><span class="s1">touch</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">node</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">disabled</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s6"># toggle node or selection ?</span>
        <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">x </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indent_start </span><span class="s3">&lt;= </span><span class="s1">touch</span><span class="s3">.</span><span class="s1">x </span><span class="s3">&lt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">toggle_node</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">node</span><span class="s3">.</span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s1">touch</span><span class="s3">.</span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">select_node</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">dispatch</span><span class="s3">(</span><span class="s4">'on_touch_down'</span><span class="s3">, </span><span class="s1">touch</span><span class="s3">)</span>
        <span class="s2">return True</span>

    <span class="s6">#</span>
    <span class="s6"># Private properties</span>
    <span class="s6">#</span>
    <span class="s1">_root </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">_selected_node </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">allownone</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s6">#</span>
    <span class="s6"># Properties</span>
    <span class="s6">#</span>

    <span class="s1">minimum_width </span><span class="s3">= </span><span class="s1">NumericProperty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s4">'''Minimum width needed to contain all children. 
 
    .. versionadded:: 1.0.9 
 
    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 0. 
    '''</span>

    <span class="s1">minimum_height </span><span class="s3">= </span><span class="s1">NumericProperty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s4">'''Minimum height needed to contain all children. 
 
    .. versionadded:: 1.0.9 
 
    :attr:`minimum_height` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 0. 
    '''</span>

    <span class="s1">minimum_size </span><span class="s3">= </span><span class="s1">ReferenceListProperty</span><span class="s3">(</span><span class="s1">minimum_width</span><span class="s3">, </span><span class="s1">minimum_height</span><span class="s3">)</span>
    <span class="s4">'''Minimum size needed to contain all children. 
 
    .. versionadded:: 1.0.9 
 
    :attr:`minimum_size` is a :class:`~kivy.properties.ReferenceListProperty` 
    of (:attr:`minimum_width`, :attr:`minimum_height`) properties. 
    '''</span>

    <span class="s1">indent_level </span><span class="s3">= </span><span class="s1">NumericProperty</span><span class="s3">(</span><span class="s4">'16dp'</span><span class="s3">)</span>
    <span class="s4">'''Width used for the indentation of each level except the first level. 
 
    Computation of indent for each level of the tree is:: 
 
        indent = indent_start + level * indent_level 
 
    :attr:`indent_level` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 16. 
    '''</span>

    <span class="s1">indent_start </span><span class="s3">= </span><span class="s1">NumericProperty</span><span class="s3">(</span><span class="s4">'24dp'</span><span class="s3">)</span>
    <span class="s4">'''Indentation width of the level 0 / root node. This is mostly the initial 
    size to accommodate a tree icon (collapsed / expanded). See 
    :attr:`indent_level` for more information about the computation of level 
    indentation. 
 
    :attr:`indent_start` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 24. 
    '''</span>

    <span class="s1">hide_root </span><span class="s3">= </span><span class="s1">BooleanProperty</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">'''Use this property to show/hide the initial root node. If True, the root 
    node will be appear as a closed node. 
 
    :attr:`hide_root` is a :class:`~kivy.properties.BooleanProperty` and 
    defaults to False. 
    '''</span>

    <span class="s2">def </span><span class="s1">get_selected_node</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_selected_node</span>

    <span class="s1">selected_node </span><span class="s3">= </span><span class="s1">AliasProperty</span><span class="s3">(</span><span class="s1">get_selected_node</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                                  <span class="s1">bind</span><span class="s3">=(</span><span class="s4">'_selected_node'</span><span class="s3">, ))</span>
    <span class="s4">'''Node selected by :meth:`TreeView.select_node` or by touch. 
 
    :attr:`selected_node` is a :class:`~kivy.properties.AliasProperty` and 
    defaults to None. It is read-only. 
    '''</span>

    <span class="s2">def </span><span class="s1">get_root</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root</span>

    <span class="s1">root </span><span class="s3">= </span><span class="s1">AliasProperty</span><span class="s3">(</span><span class="s1">get_root</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">bind</span><span class="s3">=(</span><span class="s4">'_root'</span><span class="s3">, ))</span>
    <span class="s4">'''Root node. 
 
    By default, the root node widget is a :class:`TreeViewLabel` with text 
    'Root'. If you want to change the default options passed to the widget 
    creation, use the :attr:`root_options` property:: 
 
        treeview = TreeView(root_options={ 
            'text': 'Root directory', 
            'font_size': 15}) 
 
    :attr:`root_options` will change the properties of the 
    :class:`TreeViewLabel` instance. However, you cannot change the class used 
    for root node yet. 
 
    :attr:`root` is an :class:`~kivy.properties.AliasProperty` and defaults to 
    None. It is read-only. However, the content of the widget can be changed. 
    '''</span>

    <span class="s1">root_options </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">({})</span>
    <span class="s4">'''Default root options to pass for root widget. See :attr:`root` property 
    for more information about the usage of root_options. 
 
    :attr:`root_options` is an :class:`~kivy.properties.ObjectProperty` and 
    defaults to {}. 
    '''</span>

    <span class="s1">load_func </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s4">'''Callback to use for asynchronous loading. If set, asynchronous loading 
    will be automatically done. The callback must act as a Python generator 
    function, using yield to send data back to the treeview. 
 
    The callback should be in the format:: 
 
        def callback(treeview, node): 
            for name in ('Item 1', 'Item 2'): 
                yield TreeViewLabel(text=name) 
 
    :attr:`load_func` is a :class:`~kivy.properties.ObjectProperty` and 
    defaults to None. 
    '''</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">'__main__'</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">app </span><span class="s2">import </span><span class="s1">App</span>

    <span class="s2">class </span><span class="s1">TestApp</span><span class="s3">(</span><span class="s1">App</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">build</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s1">tv </span><span class="s3">= </span><span class="s1">TreeView</span><span class="s3">(</span><span class="s1">hide_root</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s1">add </span><span class="s3">= </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">add_node</span>
            <span class="s1">root </span><span class="s3">= </span><span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Level 1, entry 1'</span><span class="s3">, </span><span class="s1">is_open</span><span class="s3">=</span><span class="s2">True</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">5</span><span class="s3">):</span>
                <span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Element %d' </span><span class="s3">% </span><span class="s1">x</span><span class="s3">), </span><span class="s1">root</span><span class="s3">)</span>
            <span class="s1">root2 </span><span class="s3">= </span><span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Level 1, entry 2'</span><span class="s3">, </span><span class="s1">is_open</span><span class="s3">=</span><span class="s2">False</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">24</span><span class="s3">):</span>
                <span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Element %d' </span><span class="s3">% </span><span class="s1">x</span><span class="s3">), </span><span class="s1">root2</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">5</span><span class="s3">):</span>
                <span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Element %d' </span><span class="s3">% </span><span class="s1">x</span><span class="s3">), </span><span class="s1">root</span><span class="s3">)</span>
            <span class="s1">root2 </span><span class="s3">= </span><span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Element childs 2'</span><span class="s3">, </span><span class="s1">is_open</span><span class="s3">=</span><span class="s2">False</span><span class="s3">),</span>
                        <span class="s1">root</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">24</span><span class="s3">):</span>
                <span class="s1">add</span><span class="s3">(</span><span class="s1">TreeViewLabel</span><span class="s3">(</span><span class="s1">text</span><span class="s3">=</span><span class="s4">'Element %d' </span><span class="s3">% </span><span class="s1">x</span><span class="s3">), </span><span class="s1">root2</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">tv</span>
    <span class="s1">TestApp</span><span class="s3">().</span><span class="s1">run</span><span class="s3">()</span>
</pre>
</body>
</html>