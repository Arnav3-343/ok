<html>
<head>
<title>support.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
support.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Assorted utilities for use in tests. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">cmath</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">gc</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">signal</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">ctypes</span>
<span class="s2">import </span><span class="s1">multiprocessing </span><span class="s2">as </span><span class="s1">mp</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">import </span><span class="s1">uuid</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">types </span><span class="s2">as </span><span class="s1">pytypes</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">cached_property</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numba </span><span class="s2">import </span><span class="s1">testing</span><span class="s3">, </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">errors</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">utils</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">cpu</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cffi_utils</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">compiler </span><span class="s2">import </span><span class="s3">(</span><span class="s1">compile_extra</span><span class="s3">, </span><span class="s1">Flags</span><span class="s3">,</span>
                                 <span class="s1">DEFAULT_FLAGS</span><span class="s3">, </span><span class="s1">CompilerBase</span><span class="s3">,</span>
                                 <span class="s1">DefaultPassBuilder</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typed_passes </span><span class="s2">import </span><span class="s1">IRLegalization</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">untyped_passes </span><span class="s2">import </span><span class="s1">PreserveIR</span>
<span class="s2">import </span><span class="s1">unittest</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">runtime </span><span class="s2">import </span><span class="s1">rtsys</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np </span><span class="s2">import </span><span class="s1">numpy_support</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">runtime </span><span class="s2">import </span><span class="s1">_nrt_python </span><span class="s2">as </span><span class="s1">_nrt</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">overload_method</span><span class="s3">,</span>
    <span class="s1">typeof_impl</span><span class="s3">,</span>
    <span class="s1">register_model</span><span class="s3">,</span>
    <span class="s1">unbox</span><span class="s3">,</span>
    <span class="s1">NativeValue</span><span class="s3">,</span>
    <span class="s1">models</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">datamodel</span><span class="s3">.</span><span class="s1">models </span><span class="s2">import </span><span class="s1">OpaqueModel</span>

<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">scipy</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">scipy </span><span class="s3">= </span><span class="s2">None</span>

<span class="s4"># Make sure that coverage is set up.</span>
<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">coverage</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s2">pass</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">coverage</span><span class="s3">.</span><span class="s1">process_startup</span><span class="s3">()</span>

<span class="s1">enable_pyobj_flags </span><span class="s3">= </span><span class="s1">Flags</span><span class="s3">()</span>
<span class="s1">enable_pyobj_flags</span><span class="s3">.</span><span class="s1">enable_pyobject </span><span class="s3">= </span><span class="s2">True</span>

<span class="s1">force_pyobj_flags </span><span class="s3">= </span><span class="s1">Flags</span><span class="s3">()</span>
<span class="s1">force_pyobj_flags</span><span class="s3">.</span><span class="s1">force_pyobject </span><span class="s3">= </span><span class="s2">True</span>

<span class="s1">no_pyobj_flags </span><span class="s3">= </span><span class="s1">Flags</span><span class="s3">()</span>

<span class="s1">nrt_flags </span><span class="s3">= </span><span class="s1">Flags</span><span class="s3">()</span>
<span class="s1">nrt_flags</span><span class="s3">.</span><span class="s1">nrt </span><span class="s3">= </span><span class="s2">True</span>


<span class="s1">tag </span><span class="s3">= </span><span class="s1">testing</span><span class="s3">.</span><span class="s1">make_tag_decorator</span><span class="s3">([</span><span class="s5">'important'</span><span class="s3">, </span><span class="s5">'long_running'</span><span class="s3">, </span><span class="s5">'always_test'</span><span class="s3">])</span>

<span class="s4"># Use to mark a test as a test that must always run when sharded</span>
<span class="s1">always_test </span><span class="s3">= </span><span class="s1">tag</span><span class="s3">(</span><span class="s5">'always_test'</span><span class="s3">)</span>

<span class="s1">_32bit </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">maxsize </span><span class="s3">&lt;= </span><span class="s6">2 </span><span class="s3">** </span><span class="s6">32</span>
<span class="s1">is_parfors_unsupported </span><span class="s3">= </span><span class="s1">_32bit</span>
<span class="s1">skip_parfors_unsupported </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span>
    <span class="s1">is_parfors_unsupported</span><span class="s3">,</span>
    <span class="s5">'parfors not supported'</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s1">skip_unless_py10_or_later </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span>
    <span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s3">&gt;= (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">10</span><span class="s3">),</span>
    <span class="s5">&quot;needs Python 3.10 or later&quot;</span>
<span class="s3">)</span>

<span class="s1">skip_unless_py10 </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span>
    <span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s3">== (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">10</span><span class="s3">),</span>
    <span class="s5">&quot;needs Python 3.10&quot;</span>
<span class="s3">)</span>

<span class="s1">skip_unless_py312 </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span>
    <span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s3">== (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">12</span><span class="s3">),</span>
    <span class="s5">&quot;needs Python 3.12&quot;</span>
<span class="s3">)</span>

<span class="s1">skip_if_32bit </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">_32bit</span><span class="s3">, </span><span class="s5">&quot;Not supported on 32 bit&quot;</span><span class="s3">)</span>

<span class="s1">IS_NUMPY_2 </span><span class="s3">= </span><span class="s1">numpy_support</span><span class="s3">.</span><span class="s1">numpy_version </span><span class="s3">&gt;= (</span><span class="s6">2</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
<span class="s1">skip_if_numpy_2 </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">IS_NUMPY_2</span><span class="s3">,</span>
                                  <span class="s5">&quot;Not supported on numpy 2.0+&quot;</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">expected_failure_py311</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s3">== (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">11</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">expectedFailure</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fn</span>

<span class="s2">def </span><span class="s1">expected_failure_py312</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s3">== (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">12</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">expectedFailure</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fn</span>

<span class="s2">def </span><span class="s1">expected_failure_np2</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">numpy_support</span><span class="s3">.</span><span class="s1">numpy_version </span><span class="s3">== (</span><span class="s6">2</span><span class="s3">, </span><span class="s6">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">expectedFailure</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fn</span>

<span class="s1">_msg </span><span class="s3">= </span><span class="s5">&quot;SciPy needed for test&quot;</span>
<span class="s1">skip_unless_scipy </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">scipy </span><span class="s2">is None</span><span class="s3">, </span><span class="s1">_msg</span><span class="s3">)</span>

<span class="s1">skip_unless_cffi </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span><span class="s1">cffi_utils</span><span class="s3">.</span><span class="s1">SUPPORTED</span><span class="s3">, </span><span class="s5">'requires cffi'</span><span class="s3">)</span>

<span class="s1">_lnx_reason </span><span class="s3">= </span><span class="s5">'linux only test'</span>
<span class="s1">linux_only </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s2">not </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'linux'</span><span class="s3">), </span><span class="s1">_lnx_reason</span><span class="s3">)</span>

<span class="s1">_win_reason </span><span class="s3">= </span><span class="s5">'Windows-only test'</span>
<span class="s1">windows_only </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s2">not </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'win'</span><span class="s3">), </span><span class="s1">_win_reason</span><span class="s3">)</span>

<span class="s1">_is_armv7l </span><span class="s3">= </span><span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() == </span><span class="s5">'armv7l'</span>

<span class="s1">disabled_test </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s5">'Test disabled'</span><span class="s3">)</span>

<span class="s4"># See issue #4563, PPC64LE LLVM bug</span>
<span class="s1">skip_ppc64le_issue4563 </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() == </span><span class="s5">'ppc64le'</span><span class="s3">,</span>
                                         <span class="s3">(</span><span class="s5">&quot;Hits: 'Parameter area must exist &quot;</span>
                                          <span class="s5">&quot;to pass an argument in memory'&quot;</span><span class="s3">))</span>

<span class="s4"># Typeguard</span>
<span class="s1">has_typeguard </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'NUMBA_USE_TYPEGUARD'</span><span class="s3">, </span><span class="s6">0</span><span class="s3">))</span>

<span class="s1">skip_unless_typeguard </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span>
    <span class="s1">has_typeguard</span><span class="s3">, </span><span class="s5">&quot;Typeguard is not enabled&quot;</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s1">skip_if_typeguard </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span>
    <span class="s1">has_typeguard</span><span class="s3">, </span><span class="s5">&quot;Broken if Typeguard is enabled&quot;</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s4"># See issue #6465, PPC64LE LLVM bug</span>
<span class="s1">skip_ppc64le_issue6465 </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() == </span><span class="s5">'ppc64le'</span><span class="s3">,</span>
                                         <span class="s3">(</span><span class="s5">&quot;Hits: 'mismatch in size of &quot;</span>
                                          <span class="s5">&quot;parameter area' in &quot;</span>
                                          <span class="s5">&quot;LowerCall_64SVR4&quot;</span><span class="s3">))</span>

<span class="s4"># LLVM PPC issue.</span>
<span class="s4"># Sample error message:</span>
<span class="s4">#   Invalid PPC CTR loop!</span>
<span class="s4">#   UNREACHABLE executed at /llvm/lib/Target/PowerPC/PPCCTRLoops.cpp:179!</span>
<span class="s1">skip_ppc64le_invalid_ctr_loop </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span>
    <span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() == </span><span class="s5">'ppc64le'</span><span class="s3">,</span>
    <span class="s5">&quot;Invalid PPC CTR loop&quot;</span><span class="s3">)</span>

<span class="s4"># fenv.h on M1 may have various issues:</span>
<span class="s4"># https://github.com/numba/numba/issues/7822#issuecomment-1065356758</span>
<span class="s1">_uname </span><span class="s3">= </span><span class="s1">platform</span><span class="s3">.</span><span class="s1">uname</span><span class="s3">()</span>
<span class="s1">IS_OSX_ARM64 </span><span class="s3">= </span><span class="s1">_uname</span><span class="s3">.</span><span class="s1">system </span><span class="s3">== </span><span class="s5">'Darwin' </span><span class="s2">and </span><span class="s1">_uname</span><span class="s3">.</span><span class="s1">machine </span><span class="s3">== </span><span class="s5">'arm64'</span>
<span class="s1">skip_m1_fenv_errors </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">IS_OSX_ARM64</span><span class="s3">,</span>
    <span class="s5">&quot;fenv.h-like functionality unreliable on OSX arm64&quot;</span><span class="s3">)</span>

<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cython_lapack</span>
    <span class="s1">has_lapack </span><span class="s3">= </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">has_lapack </span><span class="s3">= </span><span class="s2">False</span>

<span class="s1">needs_lapack </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span><span class="s1">has_lapack</span><span class="s3">,</span>
                                   <span class="s5">&quot;LAPACK needs SciPy 1.0+&quot;</span><span class="s3">)</span>

<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cython_blas</span>
    <span class="s1">has_blas </span><span class="s3">= </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">has_blas </span><span class="s3">= </span><span class="s2">False</span>

<span class="s1">needs_blas </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span><span class="s1">has_blas</span><span class="s3">, </span><span class="s5">&quot;BLAS needs SciPy 1.0+&quot;</span><span class="s3">)</span>

<span class="s4"># Decorate a test with @needs_subprocess to ensure it doesn't run unless the</span>
<span class="s4"># `SUBPROC_TEST` environment variable is set. Use this in conjunction with:</span>
<span class="s4"># TestCase::subprocess_test_runner which will execute a given test in subprocess</span>
<span class="s4"># with this environment variable set.</span>
<span class="s1">_exec_cond </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'SUBPROC_TEST'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) == </span><span class="s5">'1'</span>
<span class="s1">needs_subprocess </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span><span class="s1">_exec_cond</span><span class="s3">, </span><span class="s5">&quot;needs subprocess harness&quot;</span><span class="s3">)</span>


<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">setuptools</span>
    <span class="s1">has_setuptools </span><span class="s3">= </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">has_setuptools </span><span class="s3">= </span><span class="s2">False</span>


<span class="s4"># decorator for a test that need setuptools</span>
<span class="s1">needs_setuptools </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipUnless</span><span class="s3">(</span><span class="s1">has_setuptools</span><span class="s3">, </span><span class="s5">'Test needs setuptools'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ignore_internal_warnings</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Use in testing within a ` warnings.catch_warnings` block to filter out 
    warnings that are unrelated/internally generated by Numba. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Filter out warnings from typeguard</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s5">'ignore'</span><span class="s3">, </span><span class="s1">module</span><span class="s3">=</span><span class="s5">&quot;typeguard&quot;</span><span class="s3">)</span>
    <span class="s4"># Filter out warnings about TBB interface mismatch</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s1">action</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">,</span>
                            <span class="s1">message</span><span class="s3">=</span><span class="s5">r&quot;.*TBB_INTERFACE_VERSION.*&quot;</span><span class="s3">,</span>
                            <span class="s1">category</span><span class="s3">=</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaWarning</span><span class="s3">,</span>
                            <span class="s1">module</span><span class="s3">=</span><span class="s5">r'numba\.np\.ufunc\.parallel.*'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestCase</span><span class="s3">(</span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">TestCase</span><span class="s3">):</span>

    <span class="s1">longMessage </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s4"># A random state yielding the same random numbers for any test case.</span>
    <span class="s4"># Use as `self.random.&lt;method name&gt;`</span>
    <span class="s3">@</span><span class="s1">cached_property</span>
    <span class="s2">def </span><span class="s1">random</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">42</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reset_module_warnings</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reset the warnings registry of a module.  This can be necessary 
        as the warnings module is buggy in that regard. 
        See http://bugs.python.org/issue4180 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">module</span><span class="s3">]</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">del </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__warningregistry__</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">pass</span>

    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">assertTypingError</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        A context manager that asserts the enclosed code block fails 
        compiling in nopython mode. 
        &quot;&quot;&quot;</span>
        <span class="s1">_accepted_errors </span><span class="s3">= (</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">LoweringError</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">,</span>
                            <span class="s1">TypeError</span><span class="s3">, </span><span class="s1">NotImplementedError</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">_accepted_errors</span><span class="s3">) </span><span class="s2">as </span><span class="s1">cm</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">cm</span>

    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">assertRefCount</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">objects</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        A context manager that asserts the given objects have the 
        same reference counts before and after executing the 
        enclosed block. 
        &quot;&quot;&quot;</span>
        <span class="s1">old_refcounts </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">objects</span><span class="s3">]</span>
        <span class="s2">yield</span>
        <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>
        <span class="s1">new_refcounts </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">objects</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">old_refcounts</span><span class="s3">, </span><span class="s1">new_refcounts</span><span class="s3">, </span><span class="s1">objects</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">old </span><span class="s3">!= </span><span class="s1">new</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s5">&quot;Refcount changed from %d to %d for object: %r&quot;</span>
                          <span class="s3">% (</span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">assertRefCountEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">objects</span><span class="s3">):</span>
        <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>
        <span class="s1">rc </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">objects</span><span class="s3">]</span>
        <span class="s1">rc_0 </span><span class="s3">= </span><span class="s1">rc</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">objects</span><span class="s3">))[</span><span class="s6">1</span><span class="s3">:]:</span>
            <span class="s1">rc_i </span><span class="s3">= </span><span class="s1">rc</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">rc_0 </span><span class="s3">!= </span><span class="s1">rc_i</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s5">f&quot;Refcount for objects does not match. &quot;</span>
                          <span class="s5">f&quot;#0(</span><span class="s2">{</span><span class="s1">rc_0</span><span class="s2">}</span><span class="s5">) != #</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">(</span><span class="s2">{</span><span class="s1">rc_i</span><span class="s2">}</span><span class="s5">) does not match.&quot;</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">assertNoNRTLeak</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        A context manager that asserts no NRT leak was created during 
        the execution of the enclosed block. 
        &quot;&quot;&quot;</span>
        <span class="s1">old </span><span class="s3">= </span><span class="s1">rtsys</span><span class="s3">.</span><span class="s1">get_allocation_stats</span><span class="s3">()</span>
        <span class="s2">yield</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">rtsys</span><span class="s3">.</span><span class="s1">get_allocation_stats</span><span class="s3">()</span>
        <span class="s1">total_alloc </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">alloc </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">alloc</span>
        <span class="s1">total_free </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">free </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">free</span>
        <span class="s1">total_mi_alloc </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">mi_alloc </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">mi_alloc</span>
        <span class="s1">total_mi_free </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">mi_free </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">mi_free</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">total_alloc</span><span class="s3">, </span><span class="s1">total_free</span><span class="s3">,</span>
                         <span class="s5">&quot;number of data allocs != number of data frees&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">total_mi_alloc</span><span class="s3">, </span><span class="s1">total_mi_free</span><span class="s3">,</span>
                         <span class="s5">&quot;number of meminfo allocs != number of meminfo frees&quot;</span><span class="s3">)</span>


    <span class="s1">_bool_types </span><span class="s3">= (</span><span class="s1">bool</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
    <span class="s1">_exact_typesets </span><span class="s3">= [</span><span class="s1">_bool_types</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">,), (</span><span class="s1">str</span><span class="s3">,), (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">,),</span>
                       <span class="s3">(</span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bytes_</span><span class="s3">)]</span>
    <span class="s1">_approx_typesets </span><span class="s3">= [(</span><span class="s1">float</span><span class="s3">,), (</span><span class="s1">complex</span><span class="s3">,), (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)]</span>
    <span class="s1">_sequence_typesets </span><span class="s3">= [(</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)]</span>
    <span class="s1">_float_types </span><span class="s3">= (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">)</span>
    <span class="s1">_complex_types </span><span class="s3">= (</span><span class="s1">complex</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_detect_family</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">numeric_object</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This function returns a string description of the type family 
        that the object in question belongs to.  Possible return values 
        are: &quot;exact&quot;, &quot;complex&quot;, &quot;approximate&quot;, &quot;sequence&quot;, and &quot;unknown&quot; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s5">&quot;ndarray&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">enum</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s5">&quot;enum&quot;</span>

        <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sequence_typesets</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s5">&quot;sequence&quot;</span>

        <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_exact_typesets</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s5">&quot;exact&quot;</span>

        <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_complex_types</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s5">&quot;complex&quot;</span>

        <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_approx_typesets</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">numeric_object</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s5">&quot;approximate&quot;</span>

        <span class="s2">return </span><span class="s5">&quot;unknown&quot;</span>

    <span class="s2">def </span><span class="s1">_fix_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fix the given *dtype* for comparison. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Under 64-bit Windows, Numpy may return either int32 or int64</span>
        <span class="s4"># arrays depending on the function.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s5">'win32' </span><span class="s2">and </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">maxsize </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">**</span><span class="s6">32 </span><span class="s2">and</span>
            <span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'int32'</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'int64'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype</span>

    <span class="s2">def </span><span class="s1">_fix_strides</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the strides of the given array, fixed for comparison. 
        Strides for 0- or 1-sized dimensions are ignored. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s6">0</span><span class="s3">] * </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s1">stride </span><span class="s3">/ </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">itemsize</span>
                    <span class="s2">for </span><span class="s3">(</span><span class="s1">stride</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">shape </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">assertStridesEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that two arrays have the same shape and strides. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s5">&quot;shapes differ&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s5">&quot;itemsizes differ&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_strides</span><span class="s3">(</span><span class="s1">first</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_strides</span><span class="s3">(</span><span class="s1">second</span><span class="s3">),</span>
                         <span class="s5">&quot;strides differ&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">prec</span><span class="s3">=</span><span class="s5">'exact'</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
                           <span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ignore_sign_on_zero</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                           <span class="s1">abs_tol</span><span class="s3">=</span><span class="s2">None</span>
                           <span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Versatile equality testing function with more built-in checks than 
        standard assertEqual(). 
 
        For arrays, test that layout, dtype, shape are identical, and 
        recursively call assertPreciseEqual() on the contents. 
 
        For other sequences, recursively call assertPreciseEqual() on 
        the contents. 
 
        For scalars, test that two scalars or have similar types and are 
        equal up to a computed precision. 
        If the scalars are instances of exact types or if *prec* is 
        'exact', they are compared exactly. 
        If the scalars are instances of inexact types (float, complex) 
        and *prec* is not 'exact', then the number of significant bits 
        is computed according to the value of *prec*: 53 bits if *prec* 
        is 'double', 24 bits if *prec* is single.  This number of bits 
        can be lowered by raising the *ulps* value. 
        ignore_sign_on_zero can be set to True if zeros are to be considered 
        equal regardless of their sign bit. 
        abs_tol if this is set to a float value its value is used in the 
        following. If, however, this is set to the string &quot;eps&quot; then machine 
        precision of the type(first) is used in the following instead. This 
        kwarg is used to check if the absolute difference in value between first 
        and second is less than the value set, if so the numbers being compared 
        are considered equal. (This is to handle small numbers typically of 
        magnitude less than machine precision). 
 
        Any value of *prec* other than 'exact', 'single' or 'double' 
        will raise an error. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_assertPreciseEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">prec</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">,</span>
                <span class="s1">ignore_sign_on_zero</span><span class="s3">, </span><span class="s1">abs_tol</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
            <span class="s1">failure_msg </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">)</span>
            <span class="s4"># Fall off of the 'except' scope to avoid Python 3 exception</span>
            <span class="s4"># chaining.</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s4"># Decorate the failure message with more information</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s5">&quot;when comparing %s and %s: %s&quot; </span><span class="s3">% (</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">failure_msg</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_assertPreciseEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">prec</span><span class="s3">=</span><span class="s5">'exact'</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
                            <span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ignore_sign_on_zero</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                            <span class="s1">abs_tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Recursive workhorse for assertPreciseEqual().&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">_assertNumberEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">delta </span><span class="s2">is None or </span><span class="s1">first </span><span class="s3">== </span><span class="s1">second </span><span class="s3">== </span><span class="s6">0.0</span>
                <span class="s2">or </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">first</span><span class="s3">) </span><span class="s2">or </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">second</span><span class="s3">)):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">)</span>
                <span class="s4"># For signed zeros</span>
                <span class="s2">if not </span><span class="s1">ignore_sign_on_zero</span><span class="s3">:</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">math</span><span class="s3">.</span><span class="s1">copysign</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">first</span><span class="s3">) != </span><span class="s1">math</span><span class="s3">.</span><span class="s1">copysign</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">second</span><span class="s3">):</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span>
                                <span class="s1">self</span><span class="s3">.</span><span class="s1">_formatMessage</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">,</span>
                                                    <span class="s5">&quot;%s != %s&quot; </span><span class="s3">%</span>
                                                    <span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">)))</span>
                    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                        <span class="s2">pass</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertAlmostEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">=</span><span class="s1">delta</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">first_family </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_detect_family</span><span class="s3">(</span><span class="s1">first</span><span class="s3">)</span>
        <span class="s1">second_family </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_detect_family</span><span class="s3">(</span><span class="s1">second</span><span class="s3">)</span>

        <span class="s1">assertion_message </span><span class="s3">= </span><span class="s5">&quot;Type Family mismatch. (%s != %s)&quot; </span><span class="s3">% (</span><span class="s1">first_family</span><span class="s3">,</span>
            <span class="s1">second_family</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">msg</span><span class="s3">:</span>
            <span class="s1">assertion_message </span><span class="s3">+= </span><span class="s5">': %s' </span><span class="s3">% (</span><span class="s1">msg</span><span class="s3">,)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first_family</span><span class="s3">, </span><span class="s1">second_family</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s1">assertion_message</span><span class="s3">)</span>

        <span class="s4"># We now know they are in the same comparison family</span>
        <span class="s1">compare_family </span><span class="s3">= </span><span class="s1">first_family</span>

        <span class="s4"># For recognized sequences, recurse</span>
        <span class="s2">if </span><span class="s1">compare_family </span><span class="s3">== </span><span class="s5">&quot;ndarray&quot;</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_dtype</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_dtype</span><span class="s3">(</span><span class="s1">second</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,</span>
                             <span class="s5">&quot;different number of dimensions&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                             <span class="s5">&quot;different shapes&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">writeable</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">writeable</span><span class="s3">,</span>
                             <span class="s5">&quot;different mutability&quot;</span><span class="s3">)</span>
            <span class="s4"># itemsize is already checked by the dtype test above</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_strides</span><span class="s3">(</span><span class="s1">first</span><span class="s3">),</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_strides</span><span class="s3">(</span><span class="s1">second</span><span class="s3">), </span><span class="s5">&quot;different strides&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">first</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s1">first </span><span class="s3">= </span><span class="s1">first</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">second</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s1">second </span><span class="s3">= </span><span class="s1">second</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_assertPreciseEqual</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">prec</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">,</span>
                                         <span class="s1">ignore_sign_on_zero</span><span class="s3">, </span><span class="s1">abs_tol</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s2">elif </span><span class="s1">compare_family </span><span class="s3">== </span><span class="s5">&quot;sequence&quot;</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">first</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">second</span><span class="s3">), </span><span class="s1">msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_assertPreciseEqual</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">prec</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">,</span>
                                         <span class="s1">ignore_sign_on_zero</span><span class="s3">, </span><span class="s1">abs_tol</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s2">elif </span><span class="s1">compare_family </span><span class="s3">== </span><span class="s5">&quot;exact&quot;</span><span class="s3">:</span>
            <span class="s1">exact_comparison </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">elif </span><span class="s1">compare_family </span><span class="s2">in </span><span class="s3">[</span><span class="s5">&quot;complex&quot;</span><span class="s3">, </span><span class="s5">&quot;approximate&quot;</span><span class="s3">]:</span>
            <span class="s1">exact_comparison </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">elif </span><span class="s1">compare_family </span><span class="s3">== </span><span class="s5">&quot;enum&quot;</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIs</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_assertPreciseEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                     <span class="s1">prec</span><span class="s3">, </span><span class="s1">ulps</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">,</span>
                                     <span class="s1">ignore_sign_on_zero</span><span class="s3">, </span><span class="s1">abs_tol</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s2">elif </span><span class="s1">compare_family </span><span class="s3">== </span><span class="s5">&quot;unknown&quot;</span><span class="s3">:</span>
            <span class="s4"># Assume these are non-numeric types: we will fall back</span>
            <span class="s4"># on regular unittest comparison.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIs</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
            <span class="s1">exact_comparison </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s6">0</span><span class="s3">, </span><span class="s5">&quot;unexpected family&quot;</span>

        <span class="s4"># If a Numpy scalar, check the dtype is exactly the same too</span>
        <span class="s4"># (required for datetime64 and timedelta64).</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">second</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s4"># Mixing bools and non-bools should always fail</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_bool_types</span><span class="s3">) !=</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">second</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_bool_types</span><span class="s3">)):</span>
            <span class="s1">assertion_message </span><span class="s3">= (</span><span class="s5">&quot;Mismatching return types (%s vs. %s)&quot;</span>
                                 <span class="s3">% (</span><span class="s1">first</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">msg</span><span class="s3">:</span>
                <span class="s1">assertion_message </span><span class="s3">+= </span><span class="s5">': %s' </span><span class="s3">% (</span><span class="s1">msg</span><span class="s3">,)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s1">assertion_message</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">cmath</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">first</span><span class="s3">) </span><span class="s2">and </span><span class="s1">cmath</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">second</span><span class="s3">):</span>
                <span class="s4"># The NaNs will compare unequal, skip regular comparison</span>
                <span class="s2">return</span>
        <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
            <span class="s4"># Not floats.</span>
            <span class="s2">pass</span>

        <span class="s4"># if absolute comparison is set, use it</span>
        <span class="s2">if </span><span class="s1">abs_tol </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">abs_tol </span><span class="s3">== </span><span class="s5">&quot;eps&quot;</span><span class="s3">:</span>
                <span class="s1">rtol </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">first</span><span class="s3">)).</span><span class="s1">eps</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">abs_tol</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
                <span class="s1">rtol </span><span class="s3">= </span><span class="s1">abs_tol</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;abs_tol is not </span><span class="s2">\&quot;</span><span class="s5">eps</span><span class="s2">\&quot; </span><span class="s5">or a float, found %s&quot;</span>
                    <span class="s3">% </span><span class="s1">abs_tol</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">first </span><span class="s3">- </span><span class="s1">second</span><span class="s3">) &lt; </span><span class="s1">rtol</span><span class="s3">:</span>
                <span class="s2">return</span>

        <span class="s1">exact_comparison </span><span class="s3">= </span><span class="s1">exact_comparison </span><span class="s2">or </span><span class="s1">prec </span><span class="s3">== </span><span class="s5">'exact'</span>

        <span class="s2">if not </span><span class="s1">exact_comparison </span><span class="s2">and </span><span class="s1">prec </span><span class="s3">!= </span><span class="s5">'exact'</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">prec </span><span class="s3">== </span><span class="s5">'single'</span><span class="s3">:</span>
                <span class="s1">bits </span><span class="s3">= </span><span class="s6">24</span>
            <span class="s2">elif </span><span class="s1">prec </span><span class="s3">== </span><span class="s5">'double'</span><span class="s3">:</span>
                <span class="s1">bits </span><span class="s3">= </span><span class="s6">53</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;unsupported precision %r&quot; </span><span class="s3">% (</span><span class="s1">prec</span><span class="s3">,))</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">** (</span><span class="s1">ulps </span><span class="s3">- </span><span class="s1">bits </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s1">delta </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* (</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">first</span><span class="s3">) + </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">second</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">delta </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_complex_types</span><span class="s3">):</span>
            <span class="s1">_assertNumberEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">)</span>
            <span class="s1">_assertNumberEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">second</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">timedelta64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">datetime64</span><span class="s3">)):</span>
            <span class="s4"># Since Np 1.16 NaT == NaT is False, so special comparison needed</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">first</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">first</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">second</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">_assertNumberEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">_assertNumberEqual</span><span class="s3">(</span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">subprocess_test_runner</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">test_module</span><span class="s3">, </span><span class="s1">test_class</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                               <span class="s1">test_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">envvars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s6">60</span><span class="s3">,</span>
                               <span class="s1">flags</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">_subproc_test_env</span><span class="s3">=</span><span class="s5">&quot;1&quot;</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Runs named unit test(s) as specified in the arguments as: 
        test_module.test_class.test_name. test_module must always be supplied 
        and if no further refinement is made with test_class and test_name then 
        all tests in the module will be run. The tests will be run in a 
        subprocess with environment variables specified in `envvars`. 
        If given, envvars must be a map of form: 
            environment variable name (str) -&gt; value (str) 
        If given, flags must be a map of form: 
            flag including the `-` (str) -&gt; value (str) 
        It is most convenient to use this method in conjunction with 
        @needs_subprocess as the decorator will cause the decorated test to be 
        skipped unless the `SUBPROC_TEST` environment variable is set to 
        the same value of ``_subproc_test_env`` 
        (this special environment variable is set by this method such that the 
        specified test(s) will not be skipped in the subprocess). 
 
 
        Following execution in the subprocess this method will check the test(s) 
        executed without error. The timeout kwarg can be used to allow more time 
        for longer running tests, it defaults to 60 seconds. 
        &quot;&quot;&quot;</span>
        <span class="s1">themod </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__module__</span>
        <span class="s1">thecls </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span>
        <span class="s1">parts </span><span class="s3">= (</span><span class="s1">test_module</span><span class="s3">, </span><span class="s1">test_class</span><span class="s3">, </span><span class="s1">test_name</span><span class="s3">)</span>
        <span class="s1">fully_qualified_test </span><span class="s3">= </span><span class="s5">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">parts </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s3">)</span>
        <span class="s1">flags_args </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">flags </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">flags</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">flags_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">flag</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>
                <span class="s1">flags_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>
        <span class="s1">cmd </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">, *</span><span class="s1">flags_args</span><span class="s3">, </span><span class="s5">'-m'</span><span class="s3">, </span><span class="s5">'numba.runtests'</span><span class="s3">,</span>
               <span class="s1">fully_qualified_test</span><span class="s3">]</span>
        <span class="s1">env_copy </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">env_copy</span><span class="s3">[</span><span class="s5">'SUBPROC_TEST'</span><span class="s3">] = </span><span class="s1">_subproc_test_env</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">env_copy</span><span class="s3">[</span><span class="s5">'COVERAGE_PROCESS_START'</span><span class="s3">] = </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s5">'COVERAGE_RCFILE'</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s2">pass   </span><span class="s4"># ignored</span>
        <span class="s1">envvars </span><span class="s3">= </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">MappingProxyType</span><span class="s3">({} </span><span class="s2">if </span><span class="s1">envvars </span><span class="s2">is None else </span><span class="s1">envvars</span><span class="s3">)</span>
        <span class="s1">env_copy</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">envvars</span><span class="s3">)</span>
        <span class="s1">status </span><span class="s3">= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">run</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">=</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">,</span>
                                <span class="s1">stderr</span><span class="s3">=</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s1">timeout</span><span class="s3">,</span>
                                <span class="s1">env</span><span class="s3">=</span><span class="s1">env_copy</span><span class="s3">, </span><span class="s1">universal_newlines</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">streams </span><span class="s3">= (</span><span class="s5">f'</span><span class="s2">\n</span><span class="s5">captured stdout: </span><span class="s2">{</span><span class="s1">status</span><span class="s3">.</span><span class="s1">stdout</span><span class="s2">}\n</span><span class="s5">'</span>
                   <span class="s5">f'captured stderr: </span><span class="s2">{</span><span class="s1">status</span><span class="s3">.</span><span class="s1">stderr</span><span class="s2">}</span><span class="s5">'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">returncode</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">streams</span><span class="s3">)</span>
        <span class="s4"># Python 3.12.1 report</span>
        <span class="s1">no_tests_ran </span><span class="s3">= </span><span class="s5">&quot;NO TESTS RAN&quot;</span>
        <span class="s2">if </span><span class="s1">no_tests_ran </span><span class="s2">in </span><span class="s1">status</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">skipTest</span><span class="s3">(</span><span class="s1">no_tests_ran</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">'OK'</span><span class="s3">, </span><span class="s1">status</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">status</span>

    <span class="s2">def </span><span class="s1">run_test_in_subprocess</span><span class="s3">(</span><span class="s1">maybefunc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s6">60</span><span class="s3">, </span><span class="s1">envvars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Runs the decorated test in a subprocess via invoking numba's test 
        runner. kwargs timeout and envvars are passed through to 
        subprocess_test_runner.&quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;SUBPROC_TEST&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) != </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">:</span>
                    <span class="s4"># Not in a subprocess test env, so stage the call to run the</span>
                    <span class="s4"># test in a subprocess which will set the env var.</span>
                    <span class="s1">class_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">subprocess_test_runner</span><span class="s3">(</span>
                        <span class="s1">test_module</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__module__</span><span class="s3">,</span>
                        <span class="s1">test_class</span><span class="s3">=</span><span class="s1">class_name</span><span class="s3">,</span>
                        <span class="s1">test_name</span><span class="s3">=</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">,</span>
                        <span class="s1">timeout</span><span class="s3">=</span><span class="s1">timeout</span><span class="s3">,</span>
                        <span class="s1">envvars</span><span class="s3">=</span><span class="s1">envvars</span><span class="s3">,</span>
                        <span class="s1">_subproc_test_env</span><span class="s3">=</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># env var is set, so we're in the subprocess, run the</span>
                    <span class="s4"># actual test.</span>
                    <span class="s1">func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">inner</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">maybefunc</span><span class="s3">, </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">maybefunc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">wrapper</span>

    <span class="s2">def </span><span class="s1">make_dummy_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Use to generate a dummy type unique to this test. Returns a python 
        Dummy class and a corresponding Numba type DummyType.&quot;&quot;&quot;</span>

        <span class="s4"># Use test_id to make sure no collision is possible.</span>
        <span class="s1">test_id </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">id</span><span class="s3">()</span>
        <span class="s1">DummyType </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s5">'DummyTypeFor{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">test_id</span><span class="s3">), (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Opaque</span><span class="s3">,), {})</span>

        <span class="s1">dummy_type </span><span class="s3">= </span><span class="s1">DummyType</span><span class="s3">(</span><span class="s5">&quot;my_dummy&quot;</span><span class="s3">)</span>
        <span class="s1">register_model</span><span class="s3">(</span><span class="s1">DummyType</span><span class="s3">)(</span><span class="s1">OpaqueModel</span><span class="s3">)</span>

        <span class="s2">class </span><span class="s1">Dummy</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s3">@</span><span class="s1">typeof_impl</span><span class="s3">.</span><span class="s1">register</span><span class="s3">(</span><span class="s1">Dummy</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">typeof_dummy</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">dummy_type</span>

        <span class="s3">@</span><span class="s1">unbox</span><span class="s3">(</span><span class="s1">DummyType</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">unbox_dummy</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NativeValue</span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">())</span>

        <span class="s2">return </span><span class="s1">Dummy</span><span class="s3">, </span><span class="s1">DummyType</span>

    <span class="s2">def </span><span class="s1">skip_if_no_external_compiler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call this to ensure the test is skipped if no suitable external compiler 
        is found. This is a method on the TestCase opposed to a stand-alone 
        decorator so as to make it &quot;lazy&quot; via runtime evaluation opposed to 
        running at test-discovery time. 
        &quot;&quot;&quot;</span>
        <span class="s4"># This is a local import to avoid deprecation warnings being generated</span>
        <span class="s4"># through the use of the numba.pycc module.</span>
        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pycc</span><span class="s3">.</span><span class="s1">platform </span><span class="s2">import </span><span class="s1">external_compiler_works</span>
        <span class="s2">if not </span><span class="s1">external_compiler_works</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">skipTest</span><span class="s3">(</span><span class="s5">&quot;No suitable external compiler was found.&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">SerialMixin</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Mixin to mark test for serial execution. 
    &quot;&quot;&quot;</span>
    <span class="s1">_numba_parallel_test_ </span><span class="s3">= </span><span class="s2">False</span>


<span class="s4"># Various helpers</span>

<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">override_config</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a context manager that temporarily sets Numba config variable 
    *name* to *value*.  *name* must be the name of an existing variable 
    in numba.config. 
    &quot;&quot;&quot;</span>
    <span class="s1">old_value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">config</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">config</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">config</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">old_value</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">override_env_config</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a context manager that temporarily sets an Numba config environment 
    *name* to *value*. 
    &quot;&quot;&quot;</span>
    <span class="s1">old </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">value</span>
    <span class="s1">config</span><span class="s3">.</span><span class="s1">reload_config</span><span class="s3">()</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">old </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s4"># If it wasn't set originally, delete the environ var</span>
            <span class="s2">del </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Otherwise, restore to the old value</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">old</span>
        <span class="s4"># Always reload config</span>
        <span class="s1">config</span><span class="s3">.</span><span class="s1">reload_config</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">compile_function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a *code* string, compile it with globals *globs* and return 
    the function named *name*. 
    &quot;&quot;&quot;</span>
    <span class="s1">co </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">code</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">(), </span><span class="s5">&quot;&lt;string&gt;&quot;</span><span class="s3">, </span><span class="s5">&quot;single&quot;</span><span class="s3">)</span>
    <span class="s1">ns </span><span class="s3">= {}</span>
    <span class="s1">eval</span><span class="s3">(</span><span class="s1">co</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">ns</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ns</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>


<span class="s1">_trashcan_dir </span><span class="s3">= </span><span class="s5">'numba-tests'</span>

<span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">'nt'</span><span class="s3">:</span>
    <span class="s4"># Under Windows, gettempdir() points to the user-local temp dir</span>
    <span class="s1">_trashcan_dir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">gettempdir</span><span class="s3">(), </span><span class="s1">_trashcan_dir</span><span class="s3">)</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s4"># Mix the UID into the directory name to allow different users to</span>
    <span class="s4"># run the test suite without permission errors (issue #1586)</span>
    <span class="s1">_trashcan_dir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">gettempdir</span><span class="s3">(),</span>
                                 <span class="s5">&quot;%s.%s&quot; </span><span class="s3">% (</span><span class="s1">_trashcan_dir</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getuid</span><span class="s3">()))</span>

<span class="s4"># Stale temporary directories are deleted after they are older than this value.</span>
<span class="s4"># The test suite probably won't ever take longer than this...</span>
<span class="s1">_trashcan_timeout </span><span class="s3">= </span><span class="s6">24 </span><span class="s3">* </span><span class="s6">3600  </span><span class="s4"># 1 day</span>

<span class="s2">def </span><span class="s1">_create_trashcan_dir</span><span class="s3">():</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">mkdir</span><span class="s3">(</span><span class="s1">_trashcan_dir</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">FileExistsError</span><span class="s3">:</span>
        <span class="s2">pass</span>

<span class="s2">def </span><span class="s1">_purge_trashcan_dir</span><span class="s3">():</span>
    <span class="s1">freshness_threshold </span><span class="s3">= </span><span class="s1">time</span><span class="s3">.</span><span class="s1">time</span><span class="s3">() - </span><span class="s1">_trashcan_timeout</span>
    <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">listdir</span><span class="s3">(</span><span class="s1">_trashcan_dir</span><span class="s3">)):</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">_trashcan_dir</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">st </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">stat</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">st</span><span class="s3">.</span><span class="s1">st_mtime </span><span class="s3">&lt; </span><span class="s1">freshness_threshold</span><span class="s3">:</span>
                <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">ignore_errors</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s4"># In parallel testing, several processes can attempt to</span>
            <span class="s4"># remove the same entry at once, ignore.</span>
            <span class="s2">pass</span>

<span class="s2">def </span><span class="s1">_create_trashcan_subdir</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">):</span>
    <span class="s1">_purge_trashcan_dir</span><span class="s3">()</span>
    <span class="s1">path </span><span class="s3">= </span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">mkdtemp</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">=</span><span class="s1">prefix </span><span class="s3">+ </span><span class="s5">'-'</span><span class="s3">, </span><span class="s1">dir</span><span class="s3">=</span><span class="s1">_trashcan_dir</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">path</span>

<span class="s2">def </span><span class="s1">temp_directory</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a temporary directory with the given *prefix* that will survive 
    at least as long as this process invocation.  The temporary directory 
    will be eventually deleted when it becomes stale enough. 
 
    This is necessary because a DLL file can't be deleted while in use 
    under Windows. 
 
    An interesting side-effect is to be able to inspect the test files 
    shortly after a test suite run. 
    &quot;&quot;&quot;</span>
    <span class="s1">_create_trashcan_dir</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">_create_trashcan_subdir</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">import_dynamic</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Import and return a module of the given name.  Care is taken to 
    avoid issues due to Python's internal directory caching. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">importlib</span>
    <span class="s1">importlib</span><span class="s3">.</span><span class="s1">invalidate_caches</span><span class="s3">()</span>
    <span class="s1">__import__</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">modname</span><span class="s3">]</span>


<span class="s4"># From CPython</span>

<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">captured_output</span><span class="s3">(</span><span class="s1">stream_name</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a context manager used by captured_stdout/stdin/stderr 
    that temporarily replaces the sys stream *stream_name* with a StringIO.&quot;&quot;&quot;</span>
    <span class="s1">orig_stdout </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">)</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">, </span><span class="s1">io</span><span class="s3">.</span><span class="s1">StringIO</span><span class="s3">())</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">yield </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">, </span><span class="s1">orig_stdout</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">captured_stdout</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Capture the output of sys.stdout: 
 
       with captured_stdout() as stdout: 
           print(&quot;hello&quot;) 
       self.assertEqual(stdout.getvalue(), &quot;hello\n&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">captured_output</span><span class="s3">(</span><span class="s5">&quot;stdout&quot;</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">captured_stderr</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Capture the output of sys.stderr: 
 
       with captured_stderr() as stderr: 
           print(&quot;hello&quot;, file=sys.stderr) 
       self.assertEqual(stderr.getvalue(), &quot;hello\n&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">captured_output</span><span class="s3">(</span><span class="s5">&quot;stderr&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">capture_cache_log</span><span class="s3">():</span>
    <span class="s2">with </span><span class="s1">captured_stdout</span><span class="s3">() </span><span class="s2">as </span><span class="s1">out</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">override_config</span><span class="s3">(</span><span class="s5">'DEBUG_CACHE'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">EnableNRTStatsMixin</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Mixin to enable the NRT statistics counters.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">setUp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">_nrt</span><span class="s3">.</span><span class="s1">memsys_enable_stats</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">tearDown</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">_nrt</span><span class="s3">.</span><span class="s1">memsys_disable_stats</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">MemoryLeak</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s1">__enable_leak_check </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">memory_leak_setup</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4"># Clean up any NRT-backed objects hanging in a dead reference cycle</span>
        <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__init_stats </span><span class="s3">= </span><span class="s1">rtsys</span><span class="s3">.</span><span class="s1">get_allocation_stats</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">memory_leak_teardown</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__enable_leak_check</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_no_memory_leak</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">assert_no_memory_leak</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">old </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__init_stats</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">rtsys</span><span class="s3">.</span><span class="s1">get_allocation_stats</span><span class="s3">()</span>
        <span class="s1">total_alloc </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">alloc </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">alloc</span>
        <span class="s1">total_free </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">free </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">free</span>
        <span class="s1">total_mi_alloc </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">mi_alloc </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">mi_alloc</span>
        <span class="s1">total_mi_free </span><span class="s3">= </span><span class="s1">new</span><span class="s3">.</span><span class="s1">mi_free </span><span class="s3">- </span><span class="s1">old</span><span class="s3">.</span><span class="s1">mi_free</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">total_alloc</span><span class="s3">, </span><span class="s1">total_free</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">total_mi_alloc</span><span class="s3">, </span><span class="s1">total_mi_free</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">disable_leak_check</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4"># For per-test use when MemoryLeakMixin is injected into a TestCase</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__enable_leak_check </span><span class="s3">= </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">MemoryLeakMixin</span><span class="s3">(</span><span class="s1">EnableNRTStatsMixin</span><span class="s3">, </span><span class="s1">MemoryLeak</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">setUp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">MemoryLeakMixin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">setUp</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">memory_leak_setup</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">tearDown</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">memory_leak_teardown</span><span class="s3">()</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">MemoryLeakMixin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">tearDown</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">forbid_codegen</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Forbid LLVM code generation during the execution of the context 
    manager's enclosed block. 
 
    If code generation is invoked, a RuntimeError is raised. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">codegen</span>
    <span class="s1">patchpoints </span><span class="s3">= [</span><span class="s5">'CPUCodeLibrary._finalize_final_module'</span><span class="s3">]</span>

    <span class="s1">old </span><span class="s3">= {}</span>
    <span class="s2">def </span><span class="s1">fail</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;codegen forbidden by test case&quot;</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s4"># XXX use the mock library instead?</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">patchpoints</span><span class="s3">:</span>
            <span class="s1">parts </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">codegen</span>
            <span class="s2">for </span><span class="s1">attrname </span><span class="s2">in </span><span class="s1">parts</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]:</span>
                <span class="s1">obj </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">)</span>
            <span class="s1">attrname </span><span class="s3">= </span><span class="s1">parts</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">value</span><span class="s3">), (</span><span class="s5">&quot;%r should be callable&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">old</span><span class="s3">[</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">] = </span><span class="s1">value</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">, </span><span class="s1">fail</span><span class="s3">)</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">), </span><span class="s1">value </span><span class="s2">in </span><span class="s1">old</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s4"># For details about redirection of file-descriptor, read</span>
<span class="s4"># https://eli.thegreenplace.net/2015/redirecting-all-kinds-of-stdout-in-python/</span>

<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">redirect_fd</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Temporarily redirect *fd* to a pipe's write end and return a file object 
    wrapping the pipe's read end. 
    &quot;&quot;&quot;</span>

    <span class="s2">from </span><span class="s1">numba </span><span class="s2">import </span><span class="s1">_helperlib</span>
    <span class="s1">libnumba </span><span class="s3">= </span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">CDLL</span><span class="s3">(</span><span class="s1">_helperlib</span><span class="s3">.</span><span class="s1">__file__</span><span class="s3">)</span>

    <span class="s1">libnumba</span><span class="s3">.</span><span class="s1">_numba_flush_stdout</span><span class="s3">()</span>
    <span class="s1">save </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">dup</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">)</span>
    <span class="s1">r</span><span class="s3">, </span><span class="s1">w </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">pipe</span><span class="s3">()</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">dup2</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">fd</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">io</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s5">&quot;r&quot;</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">libnumba</span><span class="s3">.</span><span class="s1">_numba_flush_stdout</span><span class="s3">()</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">close</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">dup2</span><span class="s3">(</span><span class="s1">save</span><span class="s3">, </span><span class="s1">fd</span><span class="s3">)</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">close</span><span class="s3">(</span><span class="s1">save</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">redirect_c_stdout</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Redirect C stdout 
    &quot;&quot;&quot;</span>
    <span class="s1">fd </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">__stdout__</span><span class="s3">.</span><span class="s1">fileno</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">redirect_fd</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">run_in_new_process_caching</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">cache_dir_prefix</span><span class="s3">=</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Spawn a new process to run `func` with a temporary cache directory. 
 
    The childprocess's stdout and stderr will be captured and redirected to 
    the current process's stdout and stderr. 
 
    Returns 
    ------- 
    ret : dict 
        exitcode: 0 for success. 1 for exception-raised. 
        stdout: str 
        stderr: str 
    &quot;&quot;&quot;</span>
    <span class="s1">cache_dir </span><span class="s3">= </span><span class="s1">temp_directory</span><span class="s3">(</span><span class="s1">cache_dir_prefix</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">run_in_new_process_in_cache_dir</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">cache_dir</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">=</span><span class="s1">verbose</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">run_in_new_process_in_cache_dir</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">cache_dir</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Spawn a new process to run `func` with a temporary cache directory. 
 
    The childprocess's stdout and stderr will be captured and redirected to 
    the current process's stdout and stderr. 
 
    Similar to ``run_in_new_process_caching()`` but the ``cache_dir`` is a 
    directory path instead of a name prefix for the directory path. 
 
    Returns 
    ------- 
    ret : dict 
        exitcode: 0 for success. 1 for exception-raised. 
        stdout: str 
        stderr: str 
    &quot;&quot;&quot;</span>
    <span class="s1">ctx </span><span class="s3">= </span><span class="s1">mp</span><span class="s3">.</span><span class="s1">get_context</span><span class="s3">(</span><span class="s5">'spawn'</span><span class="s3">)</span>
    <span class="s1">qout </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">Queue</span><span class="s3">()</span>
    <span class="s2">with </span><span class="s1">override_env_config</span><span class="s3">(</span><span class="s5">'NUMBA_CACHE_DIR'</span><span class="s3">, </span><span class="s1">cache_dir</span><span class="s3">):</span>
        <span class="s1">proc </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">Process</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">_remote_runner</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=[</span><span class="s1">func</span><span class="s3">, </span><span class="s1">qout</span><span class="s3">])</span>
        <span class="s1">proc</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>
        <span class="s1">proc</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
        <span class="s1">stdout </span><span class="s3">= </span><span class="s1">qout</span><span class="s3">.</span><span class="s1">get_nowait</span><span class="s3">()</span>
        <span class="s1">stderr </span><span class="s3">= </span><span class="s1">qout</span><span class="s3">.</span><span class="s1">get_nowait</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">verbose </span><span class="s2">and </span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">():</span>
            <span class="s1">print</span><span class="s3">()</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">'STDOUT'</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">'-'</span><span class="s3">))</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">verbose </span><span class="s2">and </span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">():</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s1">file</span><span class="s3">=</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">'STDERR'</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">'-'</span><span class="s3">), </span><span class="s1">file</span><span class="s3">=</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">file</span><span class="s3">=</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">{</span>
        <span class="s5">'exitcode'</span><span class="s3">: </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">exitcode</span><span class="s3">,</span>
        <span class="s5">'stdout'</span><span class="s3">: </span><span class="s1">stdout</span><span class="s3">,</span>
        <span class="s5">'stderr'</span><span class="s3">: </span><span class="s1">stderr</span><span class="s3">,</span>
    <span class="s3">}</span>


<span class="s2">def </span><span class="s1">_remote_runner</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">qout</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Used by `run_in_new_process_caching()` 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">captured_stderr</span><span class="s3">() </span><span class="s2">as </span><span class="s1">stderr</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">captured_stdout</span><span class="s3">() </span><span class="s2">as </span><span class="s1">stdout</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">fn</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
                <span class="s1">traceback</span><span class="s3">.</span><span class="s1">print_exc</span><span class="s3">()</span>
                <span class="s1">exitcode </span><span class="s3">= </span><span class="s6">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">exitcode </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">qout</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>
    <span class="s1">qout</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>
    <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s1">exitcode</span><span class="s3">)</span>

<span class="s2">class </span><span class="s1">CheckWarningsMixin</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">check_warnings</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">messages</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s1">RuntimeWarning</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">catch</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s5">&quot;always&quot;</span><span class="s3">)</span>
            <span class="s2">yield</span>
        <span class="s1">found </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">catch</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">messages</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">w</span><span class="s3">.</span><span class="s1">message</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">w</span><span class="s3">.</span><span class="s1">category</span><span class="s3">, </span><span class="s1">category</span><span class="s3">)</span>
                    <span class="s1">found </span><span class="s3">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">found</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">messages</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_format_jit_options</span><span class="s3">(**</span><span class="s1">jit_options</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">jit_options</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">''</span>
    <span class="s1">out </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">jit_options</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s5">'&quot;{}&quot;'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">'{}={}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">create_temp_module</span><span class="s3">(</span><span class="s1">source_lines</span><span class="s3">, **</span><span class="s1">jit_options</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A context manager that creates and imports a temporary module 
    from sources provided in ``source_lines``. 
 
    Optionally it is possible to provide jit options for ``jit_module`` if it 
    is explicitly used in ``source_lines`` like ``jit_module({jit_options})``. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Use try/finally so cleanup happens even when an exception is raised</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">tempdir </span><span class="s3">= </span><span class="s1">temp_directory</span><span class="s3">(</span><span class="s5">'test_temp_module'</span><span class="s3">)</span>
        <span class="s4"># Generate random module name</span>
        <span class="s1">temp_module_name </span><span class="s3">= </span><span class="s5">'test_temp_module_{}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">str</span><span class="s3">(</span><span class="s1">uuid</span><span class="s3">.</span><span class="s1">uuid4</span><span class="s3">()).</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'-'</span><span class="s3">, </span><span class="s5">'_'</span><span class="s3">))</span>
        <span class="s1">temp_module_path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tempdir</span><span class="s3">, </span><span class="s1">temp_module_name </span><span class="s3">+ </span><span class="s5">'.py'</span><span class="s3">)</span>

        <span class="s1">jit_options </span><span class="s3">= </span><span class="s1">_format_jit_options</span><span class="s3">(**</span><span class="s1">jit_options</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">temp_module_path</span><span class="s3">, </span><span class="s5">'w'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s1">lines </span><span class="s3">= </span><span class="s1">source_lines</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">jit_options</span><span class="s3">=</span><span class="s1">jit_options</span><span class="s3">)</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">)</span>
        <span class="s4"># Add test_module to sys.path so it can be imported</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">tempdir</span><span class="s3">)</span>
        <span class="s1">test_module </span><span class="s3">= </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">import_module</span><span class="s3">(</span><span class="s1">temp_module_name</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">test_module</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">temp_module_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">tempdir</span><span class="s3">)</span>
        <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">tempdir</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">run_in_subprocess</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">env</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s6">30</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Run a snippet of Python code in a subprocess with flags, if any are 
    given. 'env' is passed to subprocess.Popen(). 'timeout' is passed to 
    popen.communicate(). 
 
    Returns the stdout and stderr of the subprocess after its termination. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">flags </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">flags </span><span class="s3">= []</span>
    <span class="s1">cmd </span><span class="s3">= [</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">,] + </span><span class="s1">flags </span><span class="s3">+ [</span><span class="s5">&quot;-c&quot;</span><span class="s3">, </span><span class="s1">code</span><span class="s3">]</span>
    <span class="s1">popen </span><span class="s3">= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">Popen</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">=</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">,</span>
                             <span class="s1">stderr</span><span class="s3">=</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">, </span><span class="s1">env</span><span class="s3">=</span><span class="s1">env</span><span class="s3">)</span>
    <span class="s1">out</span><span class="s3">, </span><span class="s1">err </span><span class="s3">= </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">communicate</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">=</span><span class="s1">timeout</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">returncode </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;process failed with code %s: stderr follows</span><span class="s2">\n</span><span class="s5">%s</span><span class="s2">\n</span><span class="s5">&quot;</span>
        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">popen</span><span class="s3">.</span><span class="s1">returncode</span><span class="s3">, </span><span class="s1">err</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">()))</span>
    <span class="s2">return </span><span class="s1">out</span><span class="s3">, </span><span class="s1">err</span>


<span class="s2">def </span><span class="s1">strace</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">syscalls</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s6">10</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Runs strace whilst executing the function work() in the current process, 
    captures the listed syscalls (list of strings). Takes an optional timeout in 
    seconds, default is 10, if this is exceeded the process will be sent a 
    SIGKILL. Returns a list of lines that are output by strace. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Open a tmpfile for strace to write into.</span>
    <span class="s2">with </span><span class="s1">tempfile</span><span class="s3">.</span><span class="s1">NamedTemporaryFile</span><span class="s3">(</span><span class="s5">'w+t'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">ntf</span><span class="s3">:</span>

        <span class="s1">parent_pid </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getpid</span><span class="s3">()</span>
        <span class="s1">strace_binary </span><span class="s3">= </span><span class="s1">shutil</span><span class="s3">.</span><span class="s1">which</span><span class="s3">(</span><span class="s5">'strace'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">strace_binary </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;No valid 'strace' binary could be found&quot;</span><span class="s3">)</span>
        <span class="s1">cmd </span><span class="s3">= [</span><span class="s1">strace_binary</span><span class="s3">, </span><span class="s4"># strace</span>
               <span class="s5">'-q'</span><span class="s3">, </span><span class="s4"># quietly (no attach/detach print out)</span>
               <span class="s5">'-p'</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">parent_pid</span><span class="s3">), </span><span class="s4"># this PID</span>
               <span class="s5">'-e'</span><span class="s3">, </span><span class="s5">','</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">syscalls</span><span class="s3">), </span><span class="s4"># these syscalls</span>
               <span class="s5">'-o'</span><span class="s3">, </span><span class="s1">ntf</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] </span><span class="s4"># put output into this file</span>

        <span class="s4"># redirect stdout, stderr is handled by the `-o` flag to strace.</span>
        <span class="s1">popen </span><span class="s3">= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">Popen</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">stdout</span><span class="s3">=</span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">PIPE</span><span class="s3">,)</span>
        <span class="s1">strace_pid </span><span class="s3">= </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">pid</span>
        <span class="s1">thread_timeout </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Timer</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">kill</span><span class="s3">)</span>
        <span class="s1">thread_timeout</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">check_return</span><span class="s3">(</span><span class="s1">problem</span><span class="s3">=</span><span class="s5">''</span><span class="s3">):</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">returncode</span>
            <span class="s2">if </span><span class="s1">ret </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;strace exited non-zero, process return code was:&quot;</span>
                       <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">ret</span><span class="s2">}</span><span class="s5">. </span><span class="s2">{</span><span class="s1">problem</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s4"># push the communication onto a thread so it doesn't block.</span>
            <span class="s4"># start comms thread</span>
            <span class="s1">thread_comms </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Thread</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">popen</span><span class="s3">.</span><span class="s1">communicate</span><span class="s3">)</span>
            <span class="s1">thread_comms</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>

            <span class="s4"># do work</span>
            <span class="s1">work</span><span class="s3">()</span>
            <span class="s4"># Flush the output buffer file</span>
            <span class="s1">ntf</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">()</span>
            <span class="s4"># interrupt the strace process to stop it if it's still running</span>
            <span class="s2">if </span><span class="s1">popen</span><span class="s3">.</span><span class="s1">poll</span><span class="s3">() </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">kill</span><span class="s3">(</span><span class="s1">strace_pid</span><span class="s3">, </span><span class="s1">signal</span><span class="s3">.</span><span class="s1">SIGINT</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># it's not running, probably an issue, raise</span>
                <span class="s1">problem</span><span class="s3">=</span><span class="s5">&quot;If this is SIGKILL, increase the timeout?&quot;</span>
                <span class="s1">check_return</span><span class="s3">(</span><span class="s1">problem</span><span class="s3">)</span>
            <span class="s4"># Make sure the return code is 0, SIGINT to detach is considered</span>
            <span class="s4"># a successful exit.</span>
            <span class="s1">popen</span><span class="s3">.</span><span class="s1">wait</span><span class="s3">()</span>
            <span class="s1">check_return</span><span class="s3">()</span>
            <span class="s4"># collect the data</span>
            <span class="s1">strace_data </span><span class="s3">= </span><span class="s1">ntf</span><span class="s3">.</span><span class="s1">readlines</span><span class="s3">()</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s4"># join communication, should be stopped now as process has</span>
            <span class="s4"># exited</span>
            <span class="s1">thread_comms</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
            <span class="s4"># should be stopped already</span>
            <span class="s1">thread_timeout</span><span class="s3">.</span><span class="s1">cancel</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">strace_data</span>


<span class="s2">def </span><span class="s1">strace_supported</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Checks if strace is supported and working&quot;&quot;&quot;</span>

    <span class="s4"># Only support this on linux where the `strace` binary is likely to be the</span>
    <span class="s4"># strace needed.</span>
    <span class="s2">if not </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'linux'</span><span class="s3">):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">force_clone</span><span class="s3">(): </span><span class="s4"># subprocess triggers a clone</span>
        <span class="s1">subprocess</span><span class="s3">.</span><span class="s1">run</span><span class="s3">([</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">, </span><span class="s5">'-c'</span><span class="s3">, </span><span class="s5">'exit()'</span><span class="s3">])</span>

    <span class="s1">syscall </span><span class="s3">= </span><span class="s5">'clone'</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">trace </span><span class="s3">= </span><span class="s1">strace</span><span class="s3">(</span><span class="s1">force_clone</span><span class="s3">, [</span><span class="s1">syscall</span><span class="s3">,])</span>
    <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">syscall </span><span class="s2">in </span><span class="s5">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">trace</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">IRPreservingTestPipeline</span><span class="s3">(</span><span class="s1">CompilerBase</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; Same as the standard pipeline, but preserves the func_ir into the 
    metadata store after legalisation, useful for testing IR changes&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">define_pipelines</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">pipeline </span><span class="s3">= </span><span class="s1">DefaultPassBuilder</span><span class="s3">.</span><span class="s1">define_nopython_pipeline</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">, </span><span class="s5">&quot;ir_preserving_custom_pipe&quot;</span><span class="s3">)</span>
        <span class="s4"># mangle the default pipeline and inject DCE and IR preservation ahead</span>
        <span class="s4"># of legalisation</span>

        <span class="s4"># TODO: add a way to not do this! un-finalizing is not a good idea</span>
        <span class="s1">pipeline</span><span class="s3">.</span><span class="s1">_finalized </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">pipeline</span><span class="s3">.</span><span class="s1">add_pass_after</span><span class="s3">(</span><span class="s1">PreserveIR</span><span class="s3">, </span><span class="s1">IRLegalization</span><span class="s3">)</span>

        <span class="s1">pipeline</span><span class="s3">.</span><span class="s1">finalize</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">pipeline</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">print_azure_matrix</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;This is a utility function that prints out the map of NumPy to Python 
    versions and how many of that combination are being tested across all the 
    declared config for azure-pipelines. It is useful to run when updating the 
    azure-pipelines config to be able to quickly see what the coverage is.&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">yaml</span>
    <span class="s2">from </span><span class="s1">yaml </span><span class="s2">import </span><span class="s1">Loader</span>
    <span class="s1">base_path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">abspath</span><span class="s3">(</span><span class="s1">__file__</span><span class="s3">))</span>
    <span class="s1">azure_pipe </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">base_path</span><span class="s3">, </span><span class="s5">'..'</span><span class="s3">, </span><span class="s5">'..'</span><span class="s3">, </span><span class="s5">'azure-pipelines.yml'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">azure_pipe</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;'azure-pipelines.yml' is not available&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">abspath</span><span class="s3">(</span><span class="s1">azure_pipe</span><span class="s3">), </span><span class="s5">'rt'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
    <span class="s1">pipe_yml </span><span class="s3">= </span><span class="s1">yaml</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">Loader</span><span class="s3">=</span><span class="s1">Loader</span><span class="s3">)</span>

    <span class="s1">templates </span><span class="s3">= </span><span class="s1">pipe_yml</span><span class="s3">[</span><span class="s5">'jobs'</span><span class="s3">]</span>
    <span class="s4"># first look at the items in the first two templates, this is osx/linux</span>
    <span class="s1">py2np_map </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">int</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">tmplt </span><span class="s2">in </span><span class="s1">templates</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">]:</span>
        <span class="s1">matrix </span><span class="s3">= </span><span class="s1">tmplt</span><span class="s3">[</span><span class="s5">'parameters'</span><span class="s3">][</span><span class="s5">'matrix'</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">setup </span><span class="s2">in </span><span class="s1">matrix</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">py2np_map</span><span class="s3">[</span><span class="s1">setup</span><span class="s3">[</span><span class="s5">'NUMPY'</span><span class="s3">]][</span><span class="s1">setup</span><span class="s3">[</span><span class="s5">'PYTHON'</span><span class="s3">]]+=</span><span class="s6">1</span>

    <span class="s4"># next look at the items in the windows only template</span>
    <span class="s1">winpath </span><span class="s3">= [</span><span class="s5">'..'</span><span class="s3">, </span><span class="s5">'..'</span><span class="s3">, </span><span class="s5">'buildscripts'</span><span class="s3">, </span><span class="s5">'azure'</span><span class="s3">, </span><span class="s5">'azure-windows.yml'</span><span class="s3">]</span>
    <span class="s1">azure_windows </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">base_path</span><span class="s3">, *</span><span class="s1">winpath</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">azure_windows</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;'azure-windows.yml' is not available&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">abspath</span><span class="s3">(</span><span class="s1">azure_windows</span><span class="s3">), </span><span class="s5">'rt'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
    <span class="s1">windows_yml </span><span class="s3">= </span><span class="s1">yaml</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">Loader</span><span class="s3">=</span><span class="s1">Loader</span><span class="s3">)</span>

    <span class="s4"># There's only one template in windows and its keyed differently to the</span>
    <span class="s4"># above, get its matrix.</span>
    <span class="s1">matrix </span><span class="s3">= </span><span class="s1">windows_yml</span><span class="s3">[</span><span class="s5">'jobs'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">][</span><span class="s5">'strategy'</span><span class="s3">][</span><span class="s5">'matrix'</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">setup </span><span class="s2">in </span><span class="s1">matrix</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">py2np_map</span><span class="s3">[</span><span class="s1">setup</span><span class="s3">[</span><span class="s5">'NUMPY'</span><span class="s3">]][</span><span class="s1">setup</span><span class="s3">[</span><span class="s5">'PYTHON'</span><span class="s3">]]+=</span><span class="s6">1</span>

    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;NumPy | Python | Count&quot;</span><span class="s3">)</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;-----------------------&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">npver</span><span class="s3">, </span><span class="s1">pys </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">py2np_map</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
        <span class="s2">for </span><span class="s1">pyver</span><span class="s3">, </span><span class="s1">count </span><span class="s2">in </span><span class="s1">pys</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">f&quot; </span><span class="s2">{</span><span class="s1">npver</span><span class="s2">} </span><span class="s5">|  </span><span class="s2">{</span><span class="s1">pyver</span><span class="s2">:</span><span class="s5">&lt;4</span><span class="s2">}  </span><span class="s5">|   </span><span class="s2">{</span><span class="s1">count</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>

    <span class="s4"># print the &quot;reverse&quot; map</span>
    <span class="s1">rev_map </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">int</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">npver</span><span class="s3">, </span><span class="s1">pys </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">py2np_map</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
        <span class="s2">for </span><span class="s1">pyver</span><span class="s3">, </span><span class="s1">count </span><span class="s2">in </span><span class="s1">pys</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">rev_map</span><span class="s3">[</span><span class="s1">pyver</span><span class="s3">][</span><span class="s1">npver</span><span class="s3">] = </span><span class="s1">count</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Python | NumPy | Count&quot;</span><span class="s3">)</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;-----------------------&quot;</span><span class="s3">)</span>
    <span class="s1">sorter </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)[</span><span class="s6">1</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">pyver</span><span class="s3">, </span><span class="s1">nps </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">rev_map</span><span class="s3">.</span><span class="s1">items</span><span class="s3">(), </span><span class="s1">key</span><span class="s3">=</span><span class="s1">sorter</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">npver</span><span class="s3">, </span><span class="s1">count </span><span class="s2">in </span><span class="s1">nps</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">f&quot; </span><span class="s2">{</span><span class="s1">pyver</span><span class="s2">:</span><span class="s5">&lt;4</span><span class="s2">} </span><span class="s5">|  </span><span class="s2">{</span><span class="s1">npver</span><span class="s2">}  </span><span class="s5">|   </span><span class="s2">{</span><span class="s1">count</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
</pre>
</body>
</html>