<html>
<head>
<title>log.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
log.py</font>
</center></td></tr></table>
<pre><span class="s0"># This module is part of GitPython and is released under the</span>
<span class="s0"># 3-Clause BSD License: https://opensource.org/license/bsd-3-clause/</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">&quot;RefLog&quot;</span><span class="s2">, </span><span class="s3">&quot;RefLogEntry&quot;</span><span class="s2">]</span>

<span class="s4">from </span><span class="s1">mmap </span><span class="s4">import </span><span class="s1">mmap</span>
<span class="s4">import </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path </span><span class="s4">as </span><span class="s1">osp</span>
<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">time </span><span class="s4">as </span><span class="s1">_time</span>

<span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">compat </span><span class="s4">import </span><span class="s1">defenc</span>
<span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">objects</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s2">(</span>
    <span class="s1">Serializable</span><span class="s2">,</span>
    <span class="s1">altz_to_utctz_str</span><span class="s2">,</span>
    <span class="s1">parse_date</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s2">(</span>
    <span class="s1">Actor</span><span class="s2">,</span>
    <span class="s1">LockedFD</span><span class="s2">,</span>
    <span class="s1">LockFile</span><span class="s2">,</span>
    <span class="s1">assure_directory_exists</span><span class="s2">,</span>
    <span class="s1">bin_to_hex</span><span class="s2">,</span>
    <span class="s1">file_contents_ro_filepath</span><span class="s2">,</span>
    <span class="s1">to_native_path</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0"># typing ------------------------------------------------------------------</span>

<span class="s4">from </span><span class="s1">typing </span><span class="s4">import </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">types </span><span class="s4">import </span><span class="s1">PathLike</span>

<span class="s4">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>

    <span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">config </span><span class="s4">import </span><span class="s1">GitConfigParser</span><span class="s2">, </span><span class="s1">SectionConstraint</span>
    <span class="s4">from </span><span class="s1">git</span><span class="s2">.</span><span class="s1">refs </span><span class="s4">import </span><span class="s1">SymbolicReference</span>

<span class="s0"># ------------------------------------------------------------------------------</span>


<span class="s4">class </span><span class="s1">RefLogEntry</span><span class="s2">(</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">], </span><span class="s1">str</span><span class="s2">]):</span>
    <span class="s5">&quot;&quot;&quot;Named tuple allowing easy access to the revlog data fields.&quot;&quot;&quot;</span>

    <span class="s1">_re_hexsha_only </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s3">r&quot;^[0-9A-Fa-f]{40}$&quot;</span><span class="s2">)</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Representation of ourselves in git reflog format.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;:return: A string suitable to be placed in a reflog file.&quot;&quot;&quot;</span>
        <span class="s1">act </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">actor</span>
        <span class="s1">time </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span>
        <span class="s4">return </span><span class="s3">&quot;{} {} {} &lt;{}&gt; {!s} {}</span><span class="s4">\t</span><span class="s3">{}</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">oldhexsha</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">newhexsha</span><span class="s2">,</span>
            <span class="s1">act</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">act</span><span class="s2">.</span><span class="s1">email</span><span class="s2">,</span>
            <span class="s1">time</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
            <span class="s1">altz_to_utctz_str</span><span class="s2">(</span><span class="s1">time</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">message</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">oldhexsha</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;The hexsha to the commit the ref pointed to before the change.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">newhexsha</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;The hexsha to the commit the ref now points to, after the change.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">actor</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Actor</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Actor instance, providing access.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">[</span><span class="s6">2</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Time as tuple: 
 
        * [0] = ``int(time)`` 
        * [1] = ``int(timezone_offset)`` in :attr:`time.altzone` format 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">[</span><span class="s6">3</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">message</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Message describing the operation that acted on the reference.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">[</span><span class="s6">4</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">new</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">oldhexsha</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">newhexsha</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">actor</span><span class="s2">: </span><span class="s1">Actor</span><span class="s2">,</span>
        <span class="s1">time</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">tz_offset</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLogEntry&quot;</span><span class="s2">:  </span><span class="s0"># skipcq: PYL-W0621</span>
        <span class="s5">&quot;&quot;&quot;:return: New instance of a :class:`RefLogEntry`&quot;&quot;&quot;</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">actor</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Need actor instance, got %s&quot; </span><span class="s2">% </span><span class="s1">actor</span><span class="s2">)</span>
        <span class="s0"># END check types</span>
        <span class="s4">return </span><span class="s1">RefLogEntry</span><span class="s2">((</span><span class="s1">oldhexsha</span><span class="s2">, </span><span class="s1">newhexsha</span><span class="s2">, </span><span class="s1">actor</span><span class="s2">, (</span><span class="s1">time</span><span class="s2">, </span><span class="s1">tz_offset</span><span class="s2">), </span><span class="s1">message</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">from_line</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">line</span><span class="s2">: </span><span class="s1">bytes</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLogEntry&quot;</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;:return: New :class:`RefLogEntry` instance from the given revlog line. 
 
        :param line: 
            Line bytes without trailing newline 
 
        :raise ValueError: 
            If `line` could not be parsed. 
        &quot;&quot;&quot;</span>
        <span class="s1">line_str </span><span class="s2">= </span><span class="s1">line</span><span class="s2">.</span><span class="s1">decode</span><span class="s2">(</span><span class="s1">defenc</span><span class="s2">)</span>
        <span class="s1">fields </span><span class="s2">= </span><span class="s1">line_str</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">info</span><span class="s2">, </span><span class="s1">msg </span><span class="s2">= </span><span class="s1">fields</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s4">None</span>
        <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">info</span><span class="s2">, </span><span class="s1">msg </span><span class="s2">= </span><span class="s1">fields</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Line must have up to two TAB-separated fields.&quot; &quot; Got %s&quot; </span><span class="s2">% </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">line_str</span><span class="s2">))</span>
        <span class="s0"># END handle first split</span>

        <span class="s1">oldhexsha </span><span class="s2">= </span><span class="s1">info</span><span class="s2">[:</span><span class="s6">40</span><span class="s2">]</span>
        <span class="s1">newhexsha </span><span class="s2">= </span><span class="s1">info</span><span class="s2">[</span><span class="s6">41</span><span class="s2">:</span><span class="s6">81</span><span class="s2">]</span>
        <span class="s4">for </span><span class="s1">hexsha </span><span class="s4">in </span><span class="s2">(</span><span class="s1">oldhexsha</span><span class="s2">, </span><span class="s1">newhexsha</span><span class="s2">):</span>
            <span class="s4">if not </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_re_hexsha_only</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s1">hexsha</span><span class="s2">):</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Invalid hexsha: %r&quot; </span><span class="s2">% (</span><span class="s1">hexsha</span><span class="s2">,))</span>
            <span class="s0"># END if hexsha re doesn't match</span>
        <span class="s0"># END for each hexsha</span>

        <span class="s1">email_end </span><span class="s2">= </span><span class="s1">info</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s6">82</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">email_end </span><span class="s2">== -</span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Missing token: &gt;&quot;</span><span class="s2">)</span>
        <span class="s0"># END handle missing end brace</span>

        <span class="s1">actor </span><span class="s2">= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">_from_string</span><span class="s2">(</span><span class="s1">info</span><span class="s2">[</span><span class="s6">82 </span><span class="s2">: </span><span class="s1">email_end </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">])</span>
        <span class="s1">time</span><span class="s2">, </span><span class="s1">tz_offset </span><span class="s2">= </span><span class="s1">parse_date</span><span class="s2">(</span><span class="s1">info</span><span class="s2">[</span><span class="s1">email_end </span><span class="s2">+ </span><span class="s6">2 </span><span class="s2">:])  </span><span class="s0"># skipcq: PYL-W0621</span>

        <span class="s4">return </span><span class="s1">RefLogEntry</span><span class="s2">((</span><span class="s1">oldhexsha</span><span class="s2">, </span><span class="s1">newhexsha</span><span class="s2">, </span><span class="s1">actor</span><span class="s2">, (</span><span class="s1">time</span><span class="s2">, </span><span class="s1">tz_offset</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">))</span>


<span class="s4">class </span><span class="s1">RefLog</span><span class="s2">(</span><span class="s1">List</span><span class="s2">[</span><span class="s1">RefLogEntry</span><span class="s2">], </span><span class="s1">Serializable</span><span class="s2">):</span>
    <span class="s5">R&quot;&quot;&quot;A reflog contains :class:`RefLogEntry`\s, each of which defines a certain state 
    of the head in question. Custom query methods allow to retrieve log entries by date 
    or by other criteria. 
 
    Reflog entries are ordered. The first added entry is first in the list. The last 
    entry, i.e. the last change of the head or reference, is last in the list. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s3">&quot;_path&quot;</span><span class="s2">,)</span>

    <span class="s4">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">PathLike</span><span class="s2">, </span><span class="s4">None</span><span class="s2">] = </span><span class="s4">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLog&quot;</span><span class="s2">:</span>
        <span class="s1">inst </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">inst</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">PathLike</span><span class="s2">, </span><span class="s4">None</span><span class="s2">] = </span><span class="s4">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s4">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize this instance with an optional filepath, from which we will 
        initialize our data. The path is also used to write changes back using the 
        :meth:`write` method.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_path </span><span class="s2">= </span><span class="s1">filepath</span>
        <span class="s4">if </span><span class="s1">filepath </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_read_from_file</span><span class="s2">()</span>
        <span class="s0"># END handle filepath</span>

    <span class="s4">def </span><span class="s1">_read_from_file</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s4">None</span><span class="s2">:</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">fmap </span><span class="s2">= </span><span class="s1">file_contents_ro_filepath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_path</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">allow_mmap</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">OSError</span><span class="s2">:</span>
            <span class="s0"># It is possible and allowed that the file doesn't exist!</span>
            <span class="s4">return</span>
        <span class="s0"># END handle invalid log</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_deserialize</span><span class="s2">(</span><span class="s1">fmap</span><span class="s2">)</span>
        <span class="s4">finally</span><span class="s2">:</span>
            <span class="s1">fmap</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s0"># END handle closing of handle</span>

    <span class="s0"># { Interface</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">from_file</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">: </span><span class="s1">PathLike</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLog&quot;</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: 
            A new :class:`RefLog` instance containing all entries from the reflog at the 
            given `filepath`. 
 
        :param filepath: 
            Path to reflog. 
 
        :raise ValueError: 
            If the file could not be read or was corrupted in some way. 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">path</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">: </span><span class="s3">&quot;SymbolicReference&quot;</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: 
            String to absolute path at which the reflog of the given ref instance would 
            be found. The path is not guaranteed to point to a valid file though. 
 
        :param ref: 
            :class:`~git.refs.symbolic.SymbolicReference` instance 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">osp</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">.</span><span class="s1">repo</span><span class="s2">.</span><span class="s1">git_dir</span><span class="s2">, </span><span class="s3">&quot;logs&quot;</span><span class="s2">, </span><span class="s1">to_native_path</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">.</span><span class="s1">path</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">iter_entries</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s3">&quot;BytesIO&quot;</span><span class="s2">, </span><span class="s1">mmap</span><span class="s2">]) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">RefLogEntry</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: 
            Iterator yielding :class:`RefLogEntry` instances, one for each line read 
            from the given stream. 
 
        :param stream: 
            File-like object containing the revlog in its native format or string 
            instance pointing to a file to read. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_entry </span><span class="s2">= </span><span class="s1">RefLogEntry</span><span class="s2">.</span><span class="s1">from_line</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0"># Default args return mmap since Python 3.</span>
            <span class="s1">_stream </span><span class="s2">= </span><span class="s1">file_contents_ro_filepath</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">)</span>
            <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">_stream</span><span class="s2">, </span><span class="s1">mmap</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">_stream </span><span class="s2">= </span><span class="s1">stream</span>
        <span class="s0"># END handle stream type</span>
        <span class="s4">while True</span><span class="s2">:</span>
            <span class="s1">line </span><span class="s2">= </span><span class="s1">_stream</span><span class="s2">.</span><span class="s1">readline</span><span class="s2">()</span>
            <span class="s4">if not </span><span class="s1">line</span><span class="s2">:</span>
                <span class="s4">return</span>
            <span class="s4">yield </span><span class="s1">new_entry</span><span class="s2">(</span><span class="s1">line</span><span class="s2">.</span><span class="s1">strip</span><span class="s2">())</span>
        <span class="s0"># END endless loop</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">entry_at</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">: </span><span class="s1">PathLike</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLogEntry&quot;</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: 
            :class:`RefLogEntry` at the given index. 
 
        :param filepath: 
            Full path to the index file from which to read the entry. 
 
        :param index: 
            Python list compatible index, i.e. it may be negative to specify an entry 
            counted from the end of the list. 
 
        :raise IndexError: 
            If the entry didn't exist. 
 
        :note: 
            This method is faster as it only parses the entry at index, skipping all 
            other lines. Nonetheless, the whole file has to be read if the index is 
            negative. 
        &quot;&quot;&quot;</span>
        <span class="s4">with </span><span class="s1">open</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s2">) </span><span class="s4">as </span><span class="s1">fp</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">index </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">RefLogEntry</span><span class="s2">.</span><span class="s1">from_line</span><span class="s2">(</span><span class="s1">fp</span><span class="s2">.</span><span class="s1">readlines</span><span class="s2">()[</span><span class="s1">index</span><span class="s2">].</span><span class="s1">strip</span><span class="s2">())</span>
            <span class="s0"># Read until index is reached.</span>

            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">index </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">):</span>
                <span class="s1">line </span><span class="s2">= </span><span class="s1">fp</span><span class="s2">.</span><span class="s1">readline</span><span class="s2">()</span>
                <span class="s4">if not </span><span class="s1">line</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">f&quot;Index file ended at line </span><span class="s4">{</span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s4">}</span><span class="s3">, before given index was reached&quot;</span><span class="s2">)</span>
                <span class="s0"># END abort on eof</span>
            <span class="s0"># END handle runup</span>

            <span class="s4">return </span><span class="s1">RefLogEntry</span><span class="s2">.</span><span class="s1">from_line</span><span class="s2">(</span><span class="s1">line</span><span class="s2">.</span><span class="s1">strip</span><span class="s2">())</span>
        <span class="s0"># END handle index</span>

    <span class="s4">def </span><span class="s1">to_file</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filepath</span><span class="s2">: </span><span class="s1">PathLike</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s4">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Write the contents of the reflog instance to a file at the given filepath. 
 
        :param filepath: 
            Path to file. Parent directories are assumed to exist. 
        &quot;&quot;&quot;</span>
        <span class="s1">lfd </span><span class="s2">= </span><span class="s1">LockedFD</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>
        <span class="s1">assure_directory_exists</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">is_file</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

        <span class="s1">fp </span><span class="s2">= </span><span class="s1">lfd</span><span class="s2">.</span><span class="s1">open</span><span class="s2">(</span><span class="s1">write</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_serialize</span><span class="s2">(</span><span class="s1">fp</span><span class="s2">)</span>
            <span class="s1">lfd</span><span class="s2">.</span><span class="s1">commit</span><span class="s2">()</span>
        <span class="s4">except </span><span class="s1">BaseException</span><span class="s2">:</span>
            <span class="s1">lfd</span><span class="s2">.</span><span class="s1">rollback</span><span class="s2">()</span>
            <span class="s4">raise</span>
        <span class="s0"># END handle change</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">append_entry</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">config_reader</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Actor</span><span class="s2">, </span><span class="s3">&quot;GitConfigParser&quot;</span><span class="s2">, </span><span class="s3">&quot;SectionConstraint&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">],</span>
        <span class="s1">filepath</span><span class="s2">: </span><span class="s1">PathLike</span><span class="s2">,</span>
        <span class="s1">oldbinsha</span><span class="s2">: </span><span class="s1">bytes</span><span class="s2">,</span>
        <span class="s1">newbinsha</span><span class="s2">: </span><span class="s1">bytes</span><span class="s2">,</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">write</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s4">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLogEntry&quot;</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Append a new log entry to the revlog at filepath. 
 
        :param config_reader: 
            Configuration reader of the repository - used to obtain user information. 
            May also be an :class:`~git.util.Actor` instance identifying the committer 
            directly or ``None``. 
 
        :param filepath: 
            Full path to the log file. 
 
        :param oldbinsha: 
            Binary sha of the previous commit. 
 
        :param newbinsha: 
            Binary sha of the current commit. 
 
        :param message: 
            Message describing the change to the reference. 
 
        :param write: 
            If ``True``, the changes will be written right away. 
            Otherwise the change will not be written. 
 
        :return: 
            :class:`RefLogEntry` objects which was appended to the log. 
 
        :note: 
            As we are append-only, concurrent access is not a problem as we do not 
            interfere with readers. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">oldbinsha</span><span class="s2">) != </span><span class="s6">20 </span><span class="s4">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">newbinsha</span><span class="s2">) != </span><span class="s6">20</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Shas need to be given in binary format&quot;</span><span class="s2">)</span>
        <span class="s0"># END handle sha type</span>
        <span class="s1">assure_directory_exists</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s1">is_file</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s1">first_line </span><span class="s2">= </span><span class="s1">message</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">config_reader</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">):</span>
            <span class="s1">committer </span><span class="s2">= </span><span class="s1">config_reader  </span><span class="s0"># mypy thinks this is Actor | Gitconfigparser, but why?</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">committer </span><span class="s2">= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">committer</span><span class="s2">(</span><span class="s1">config_reader</span><span class="s2">)</span>
        <span class="s1">entry </span><span class="s2">= </span><span class="s1">RefLogEntry</span><span class="s2">(</span>
            <span class="s2">(</span>
                <span class="s1">bin_to_hex</span><span class="s2">(</span><span class="s1">oldbinsha</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">&quot;ascii&quot;</span><span class="s2">),</span>
                <span class="s1">bin_to_hex</span><span class="s2">(</span><span class="s1">newbinsha</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">&quot;ascii&quot;</span><span class="s2">),</span>
                <span class="s1">committer</span><span class="s2">,</span>
                <span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s1">_time</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()), </span><span class="s1">_time</span><span class="s2">.</span><span class="s1">altzone</span><span class="s2">),</span>
                <span class="s1">first_line</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s4">if </span><span class="s1">write</span><span class="s2">:</span>
            <span class="s1">lf </span><span class="s2">= </span><span class="s1">LockFile</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">)</span>
            <span class="s1">lf</span><span class="s2">.</span><span class="s1">_obtain_lock_or_raise</span><span class="s2">()</span>
            <span class="s1">fd </span><span class="s2">= </span><span class="s1">open</span><span class="s2">(</span><span class="s1">filepath</span><span class="s2">, </span><span class="s3">&quot;ab&quot;</span><span class="s2">)</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">fd</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s1">entry</span><span class="s2">.</span><span class="s1">format</span><span class="s2">().</span><span class="s1">encode</span><span class="s2">(</span><span class="s1">defenc</span><span class="s2">))</span>
            <span class="s4">finally</span><span class="s2">:</span>
                <span class="s1">fd</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
                <span class="s1">lf</span><span class="s2">.</span><span class="s1">_release_lock</span><span class="s2">()</span>
            <span class="s0"># END handle write operation</span>
        <span class="s4">return </span><span class="s1">entry</span>

    <span class="s4">def </span><span class="s1">write</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLog&quot;</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Write this instance's data to the file we are originating from. 
 
        :return: 
            self 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_path </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Instance was not initialized with a path, use to_file(...) instead&quot;</span><span class="s2">)</span>
        <span class="s0"># END assert path</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">to_file</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_path</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s0"># } END interface</span>

    <span class="s0"># { Serializable Interface</span>

    <span class="s4">def </span><span class="s1">_serialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">: </span><span class="s3">&quot;BytesIO&quot;</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLog&quot;</span><span class="s2">:</span>
        <span class="s1">write </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">write</span>

        <span class="s0"># Write all entries.</span>
        <span class="s4">for </span><span class="s1">e </span><span class="s4">in </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">write</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">format</span><span class="s2">().</span><span class="s1">encode</span><span class="s2">(</span><span class="s1">defenc</span><span class="s2">))</span>
        <span class="s0"># END for each entry</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">_deserialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">: </span><span class="s3">&quot;BytesIO&quot;</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s3">&quot;RefLog&quot;</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">iter_entries</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s0"># } END serializable interface</span>
</pre>
</body>
</html>