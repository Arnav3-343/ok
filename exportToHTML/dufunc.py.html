<html>
<head>
<title>dufunc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dufunc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">jit</span><span class="s2">, </span><span class="s1">typeof</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">cgutils</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">serialize</span><span class="s2">, </span><span class="s1">sigutils</span><span class="s2">, </span><span class="s1">errors</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">extending </span><span class="s0">import </span><span class="s2">(</span><span class="s1">is_jitted</span><span class="s2">, </span><span class="s1">overload_attribute</span><span class="s2">,</span>
                                  <span class="s1">overload_method</span><span class="s2">, </span><span class="s1">register_jitable</span><span class="s2">,</span>
                                  <span class="s1">intrinsic</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s1">npydecl</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">templates </span><span class="s0">import </span><span class="s1">AbstractTemplate</span><span class="s2">, </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython</span><span class="s2">.</span><span class="s1">unsafe</span><span class="s2">.</span><span class="s1">tuple </span><span class="s0">import </span><span class="s1">tuple_setitem</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc </span><span class="s0">import </span><span class="s1">_internal</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">ufunc_base </span><span class="s0">import </span><span class="s1">UfuncBase</span><span class="s2">, </span><span class="s1">UfuncLowererBase</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors </span><span class="s0">import </span><span class="s1">array_analysis</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc </span><span class="s0">import </span><span class="s1">ufuncbuilder</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">numpy_support</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_lock </span><span class="s0">import </span><span class="s1">global_compiler_lock</span>


<span class="s0">class </span><span class="s1">UfuncAtIterator</span><span class="s2">:</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_ty</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indices_ty</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">b_ty</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc </span><span class="s2">= </span><span class="s1">ufunc</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">a </span><span class="s2">= </span><span class="s1">a</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">a_ty </span><span class="s2">= </span><span class="s1">a_ty</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">indices</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indices_ty </span><span class="s2">= </span><span class="s1">indices_ty</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s2">= </span><span class="s1">b</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">b_ty </span><span class="s2">= </span><span class="s1">b_ty</span>

    <span class="s0">def </span><span class="s1">run</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_prepare</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">)</span>
        <span class="s1">loop_indices</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">begin_loops</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_call_ufunc</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">loop_indices</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">end_loops</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">need_advanced_indexing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices_ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_prepare</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arrayobj </span><span class="s0">import </span><span class="s1">normalize_indices</span><span class="s2">, </span><span class="s1">FancyIndexer</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span>
        <span class="s1">a_ty</span><span class="s2">, </span><span class="s1">indices_ty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">a_ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices_ty</span>

        <span class="s1">zero </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)(</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">b_indice </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once_value</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">need_advanced_indexing</span><span class="s2">():</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">unpack_tuple</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">,</span>
                                           <span class="s1">count</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices_ty</span><span class="s2">))</span>
            <span class="s1">index_types </span><span class="s2">= </span><span class="s1">indices_ty</span><span class="s2">.</span><span class="s1">types</span>
            <span class="s1">index_types</span><span class="s2">, </span><span class="s1">indices </span><span class="s2">= </span><span class="s1">normalize_indices</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">,</span>
                                                     <span class="s1">index_types</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= (</span><span class="s1">indices</span><span class="s2">,)</span>
            <span class="s1">index_types </span><span class="s2">= (</span><span class="s1">indices_ty</span><span class="s2">,)</span>
            <span class="s1">index_types</span><span class="s2">, </span><span class="s1">indices </span><span class="s2">= </span><span class="s1">normalize_indices</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">,</span>
                                                     <span class="s1">index_types</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">indexer </span><span class="s2">= </span><span class="s1">FancyIndexer</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">a_ty</span><span class="s2">, </span><span class="s1">a</span><span class="s2">,</span>
                                    <span class="s1">index_types</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">prepare</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_ufunc</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_load_val</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">loop_indices</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">array_ty</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arrayobj </span><span class="s0">import </span><span class="s1">load_item</span>
        <span class="s1">shapes </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">unpack_tuple</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">strides </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">unpack_tuple</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">array</span><span class="s2">.</span><span class="s1">strides</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s1">ptr </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_item_pointer2</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">strides</span><span class="s2">,</span>
                                        <span class="s1">array_ty</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">, </span><span class="s1">loop_indices</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">load_item</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">array_ty</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_load_flat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">array_ty</span><span class="s2">):</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">array_ty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">array_ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
        <span class="s1">impl </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">getitem</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, (</span><span class="s1">array</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">))</span>

        <span class="s4"># increment indices</span>
        <span class="s1">one </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)(</span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">one</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>

        <span class="s0">return None</span><span class="s2">, </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_store_val</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">array_ty</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arrayobj </span><span class="s0">import </span><span class="s1">store_item</span>
        <span class="s1">fromty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cres</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">.</span><span class="s1">return_type</span>
        <span class="s1">toty </span><span class="s2">= </span><span class="s1">array_ty</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">)</span>
        <span class="s1">store_item</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">array_ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_compile_ufunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">key</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">a_ty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">,)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">a_ty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b_ty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">cres </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s1">context</span><span class="s2">.</span><span class="s1">add_linking_libs</span><span class="s2">((</span><span class="s1">cres</span><span class="s2">.</span><span class="s1">library</span><span class="s2">,))</span>
        <span class="s0">return </span><span class="s1">cres</span>

    <span class="s0">def </span><span class="s1">_call_ufunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">loop_indices</span><span class="s2">):</span>
        <span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cres</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">a_ty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">a_ty</span>

        <span class="s1">ptr</span><span class="s2">, </span><span class="s1">val </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_load_val</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">loop_indices</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_ty</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">args </span><span class="s2">= (</span><span class="s1">val</span><span class="s2">,)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">b</span><span class="s2">, </span><span class="s1">b_ty</span><span class="s2">, </span><span class="s1">b_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b_ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b_indice</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">val_b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_load_flat</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">b_idx</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b_ty</span><span class="s2">)</span>
            <span class="s1">args </span><span class="s2">= (</span><span class="s1">val</span><span class="s2">, </span><span class="s1">val_b</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">call_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">,</span>
                                    <span class="s1">args</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_store_val</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_ty</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">make_dufunc_kernel</span><span class="s2">(</span><span class="s1">_dufunc</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">npyimpl</span>

    <span class="s0">class </span><span class="s1">DUFuncKernel</span><span class="s2">(</span><span class="s1">npyimpl</span><span class="s2">.</span><span class="s1">_Kernel</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        npyimpl._Kernel subclass responsible for lowering a DUFunc kernel 
        (element-wise function) inside a broadcast loop (which is 
        generated by npyimpl.numpy_ufunc_kernel()). 
        &quot;&quot;&quot;</span>
        <span class="s1">dufunc </span><span class="s2">= </span><span class="s1">_dufunc</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">outer_sig</span><span class="s2">):</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">outer_sig</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">inner_sig</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dufunc</span><span class="s2">.</span><span class="s1">find_ewise_function</span><span class="s2">(</span>
                <span class="s1">outer_sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s1">DUFuncKernel</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">+= </span><span class="s1">_dufunc</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span>
    <span class="s0">return </span><span class="s1">DUFuncKernel</span>


<span class="s0">class </span><span class="s1">DUFuncLowerer</span><span class="s2">(</span><span class="s1">UfuncLowererBase</span><span class="s2">):</span>
    <span class="s5">'''Callable class responsible for lowering calls to a specific DUFunc. 
    '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dufunc</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">npyimpl</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dufunc</span><span class="s2">,</span>
                         <span class="s1">make_dufunc_kernel</span><span class="s2">,</span>
                         <span class="s1">npyimpl</span><span class="s2">.</span><span class="s1">numpy_ufunc_kernel</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">DUFunc</span><span class="s2">(</span><span class="s1">serialize</span><span class="s2">.</span><span class="s1">ReduceMixin</span><span class="s2">, </span><span class="s1">_internal</span><span class="s2">.</span><span class="s1">_DUFunc</span><span class="s2">, </span><span class="s1">UfuncBase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dynamic universal function (DUFunc) intended to act like a normal 
    Numpy ufunc, but capable of call-time (just-in-time) compilation 
    of fast loops specialized to inputs. 
    &quot;&quot;&quot;</span>
    <span class="s4"># NOTE: __base_kwargs must be kept in synch with the kwlist in</span>
    <span class="s4"># _internal.c:dufunc_init()</span>
    <span class="s1">__base_kwargs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">((</span><span class="s6">'identity'</span><span class="s2">, </span><span class="s6">'_keepalive'</span><span class="s2">, </span><span class="s6">'nin'</span><span class="s2">, </span><span class="s6">'nout'</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">py_func</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">targetoptions</span><span class="s2">={}):</span>
        <span class="s0">if </span><span class="s1">is_jitted</span><span class="s2">(</span><span class="s1">py_func</span><span class="s2">):</span>
            <span class="s1">py_func </span><span class="s2">= </span><span class="s1">py_func</span><span class="s2">.</span><span class="s1">py_func</span>
        <span class="s0">with </span><span class="s1">ufuncbuilder</span><span class="s2">.</span><span class="s1">_suppress_deprecation_warning_nopython_not_supplied</span><span class="s2">():</span>
            <span class="s1">dispatcher </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">_target</span><span class="s2">=</span><span class="s6">'npyufunc'</span><span class="s2">,</span>
                             <span class="s1">cache</span><span class="s2">=</span><span class="s1">cache</span><span class="s2">,</span>
                             <span class="s2">**</span><span class="s1">targetoptions</span><span class="s2">)(</span><span class="s1">py_func</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_initialize</span><span class="s2">(</span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">)</span>
        <span class="s1">functools</span><span class="s2">.</span><span class="s1">update_wrapper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">py_func</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_initialize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">):</span>
        <span class="s1">identity </span><span class="s2">= </span><span class="s1">ufuncbuilder</span><span class="s2">.</span><span class="s1">parse_identity</span><span class="s2">(</span><span class="s1">identity</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">DUFunc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">=</span><span class="s1">identity</span><span class="s2">)</span>
        <span class="s4"># Loop over a copy of the keys instead of the keys themselves,</span>
        <span class="s4"># since we're changing the dictionary while looping.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">dispatcher</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">dispatcher</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lower_me </span><span class="s2">= </span><span class="s1">DUFuncLowerer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_cg</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_reduce_states</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        NOTE: part of ReduceMixin protocol 
        &quot;&quot;&quot;</span>
        <span class="s1">siglist </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s0">return </span><span class="s1">dict</span><span class="s2">(</span>
            <span class="s1">dispatcher</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">,</span>
            <span class="s1">identity</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">identity</span><span class="s2">,</span>
            <span class="s1">frozen</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen</span><span class="s2">,</span>
            <span class="s1">siglist</span><span class="s2">=</span><span class="s1">siglist</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_rebuild</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">, </span><span class="s1">frozen</span><span class="s2">, </span><span class="s1">siglist</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        NOTE: part of ReduceMixin protocol 
        &quot;&quot;&quot;</span>
        <span class="s1">self </span><span class="s2">= </span><span class="s1">_internal</span><span class="s2">.</span><span class="s1">_DUFunc</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_initialize</span><span class="s2">(</span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">)</span>
        <span class="s4"># Re-add signatures</span>
        <span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">siglist</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">frozen</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">disable_compile</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">build_ufunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        For compatibility with the various *UFuncBuilder classes. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">targetoptions</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">targetoptions</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nout</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nargs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nargs</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ntypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">ntypes</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">types</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">types</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">identity</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">identity</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">signature</span>

    <span class="s0">def </span><span class="s1">disable_compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Disable the compilation of new signatures at call time. 
        &quot;&quot;&quot;</span>
        <span class="s4"># If disabling compilation then there must be at least one signature</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">overloads</span><span class="s2">) &gt; </span><span class="s3">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">add</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Compile the DUFunc for the given signature. 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">return_type </span><span class="s2">= </span><span class="s1">sigutils</span><span class="s2">.</span><span class="s1">normalize_signature</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_for_argtys</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Allow any argument that has overridden __array_ufunc__ (NEP-18) 
        to take control of DUFunc.__call__. 
        &quot;&quot;&quot;</span>
        <span class="s1">default </span><span class="s2">= </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">.</span><span class="s1">__array_ufunc__</span>

        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args </span><span class="s2">+ </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">kws</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()):</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">), </span><span class="s6">&quot;__array_ufunc__&quot;</span><span class="s2">, </span><span class="s1">default</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">default</span><span class="s2">:</span>
                <span class="s1">output </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__array_ufunc__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;__call__&quot;</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">output </span><span class="s0">is not </span><span class="s1">NotImplemented</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">output</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__call__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_compile_for_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">nin </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span>
        <span class="s0">if </span><span class="s1">kws</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s6">'out' </span><span class="s0">in </span><span class="s1">kws</span><span class="s2">:</span>
                <span class="s1">out </span><span class="s2">= </span><span class="s1">kws</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s6">'out'</span><span class="s2">)</span>
                <span class="s1">args </span><span class="s2">+= (</span><span class="s1">out</span><span class="s2">,)</span>
            <span class="s0">if </span><span class="s1">kws</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s6">&quot;unexpected keyword arguments to ufunc: %s&quot;</span>
                                <span class="s2">% </span><span class="s6">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">k</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">kws</span><span class="s2">)))</span>

        <span class="s1">args_len </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span><span class="s1">args_len </span><span class="s2">== </span><span class="s1">nin</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">args_len </span><span class="s2">== </span><span class="s1">nin </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout</span><span class="s2">)</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s1">argtys </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">[:</span><span class="s1">nin</span><span class="s2">]:</span>
            <span class="s1">argty </span><span class="s2">= </span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">argty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
                <span class="s1">argty </span><span class="s2">= </span><span class="s1">argty</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># To avoid a mismatch in how Numba types scalar values as</span>
                <span class="s4"># opposed to Numpy, we need special logic for scalars.</span>
                <span class="s4"># For example, on 64-bit systems, numba.typeof(3) =&gt; int32, but</span>
                <span class="s4"># np.array(3).dtype =&gt; int64.</span>

                <span class="s4"># Note: this will not handle numpy &quot;duckarrays&quot; correctly,</span>
                <span class="s4"># including but not limited to those implementing `__array__`</span>
                <span class="s4"># and `__array_ufunc__`.</span>
                <span class="s1">argty </span><span class="s2">= </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">map_arrayscalar_type</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s1">argtys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">argty</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_for_argtys</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">argtys</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">global_compiler_lock</span>
    <span class="s0">def </span><span class="s1">_compile_for_argtys</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Given a tuple of argument types (these should be the array 
        dtypes, and not the array types themselves), compile the 
        element-wise function for those inputs, generate a UFunc loop 
        wrapper, and register the loop with the Numpy ufunc object for 
        this DUFunc. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s6">&quot;compilation disabled for %s&quot; </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">,))</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">return_type </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">argtys</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">return_type</span><span class="s2">(*</span><span class="s1">argtys</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">cres </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">argtys </span><span class="s2">== </span><span class="s1">k</span><span class="s2">.</span><span class="s1">args</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s6">&quot;Compilation requested for previously compiled argument&quot;</span>
                       <span class="s6">f&quot; types (</span><span class="s0">{</span><span class="s1">argtys</span><span class="s0">}</span><span class="s6">). This has no effect and perhaps &quot;</span>
                       <span class="s6">&quot;indicates a bug in the calling code (compiling a &quot;</span>
                       <span class="s6">&quot;ufunc more than once for the same signature&quot;</span><span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaWarning</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">cres</span>

        <span class="s1">cres</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">return_type </span><span class="s2">= </span><span class="s1">ufuncbuilder</span><span class="s2">.</span><span class="s1">_compile_element_wise_function</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">targetoptions</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s1">actual_sig </span><span class="s2">= </span><span class="s1">ufuncbuilder</span><span class="s2">.</span><span class="s1">_finalize_ufunc_signature</span><span class="s2">(</span>
            <span class="s1">cres</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">)</span>
        <span class="s1">dtypenums</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">env </span><span class="s2">= </span><span class="s1">ufuncbuilder</span><span class="s2">.</span><span class="s1">_build_element_wise_ufunc_wrapper</span><span class="s2">(</span>
            <span class="s1">cres</span><span class="s2">, </span><span class="s1">actual_sig</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_loop</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">), </span><span class="s1">dtypenums</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_keepalive</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">library</span><span class="s2">, </span><span class="s1">env</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lower_me</span><span class="s2">.</span><span class="s1">libs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">cres</span><span class="s2">.</span><span class="s1">library</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cres</span>

    <span class="s0">def </span><span class="s1">match_signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ewise_types</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args </span><span class="s2">== </span><span class="s1">ewise_types</span>

    <span class="s0">def </span><span class="s1">_install_ufunc_attributes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">template</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>

        <span class="s0">def </span><span class="s1">get_attr_fn</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">:</span>

            <span class="s0">def </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">):</span>
                <span class="s1">val </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">key</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">return lambda </span><span class="s1">ufunc</span><span class="s2">: </span><span class="s1">val</span>
            <span class="s0">return </span><span class="s1">impl</span>

        <span class="s4"># ntypes/types needs &quot;at&quot; to be a BoundFunction rather than a Function</span>
        <span class="s4"># But this fails as it cannot a weak reference to an ufunc due to NumPy</span>
        <span class="s4"># not setting the &quot;tp_weaklistoffset&quot; field. See:</span>
        <span class="s4"># https://github.com/numpy/numpy/blob/7fc72776b972bfbfdb909e4b15feb0308cf8adba/numpy/core/src/umath/ufunc_object.c#L6968-L6983  # noqa: E501</span>

        <span class="s1">at </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">template</span><span class="s2">)</span>
        <span class="s1">attributes </span><span class="s2">= (</span><span class="s6">'nin'</span><span class="s2">, </span><span class="s6">'nout'</span><span class="s2">, </span><span class="s6">'nargs'</span><span class="s2">, </span><span class="s4"># 'ntypes', # 'types',</span>
                      <span class="s6">'identity'</span><span class="s2">, </span><span class="s6">'signature'</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">attributes</span><span class="s2">:</span>
            <span class="s1">attr_fn </span><span class="s2">= </span><span class="s1">get_attr_fn</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s1">overload_attribute</span><span class="s2">(</span><span class="s1">at</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)(</span><span class="s1">attr_fn</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_install_ufunc_methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">template</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_ufunc_reduce</span><span class="s2">(</span><span class="s1">template</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_ufunc_at</span><span class="s2">(</span><span class="s1">template</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_install_ufunc_at</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">template</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">at </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">template</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">overload_method</span><span class="s2">(</span><span class="s1">at</span><span class="s2">, </span><span class="s6">'at'</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">ol_at</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;ufunc.at feature is experimental&quot;</span><span class="s2">,</span>
                          <span class="s1">category</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaExperimentalFeatureWarning</span><span class="s2">)</span>

            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">'The first argument &quot;a&quot; must be array-like'</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s1">indices_arr </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">)</span>
            <span class="s1">indices_list </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">List</span><span class="s2">)</span>
            <span class="s1">indices_tuple </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">)</span>
            <span class="s1">indices_slice </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">SliceType</span><span class="s2">)</span>
            <span class="s1">indices_scalar </span><span class="s2">= </span><span class="s0">not </span><span class="s2">(</span><span class="s1">indices_arr </span><span class="s0">or </span><span class="s1">indices_slice </span><span class="s0">or </span><span class="s1">indices_tuple</span><span class="s2">)</span>
            <span class="s1">indices_empty_tuple </span><span class="s2">= </span><span class="s1">indices_tuple </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">) == </span><span class="s3">0</span>
            <span class="s1">b_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">List</span><span class="s2">,</span>
                                     <span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">))</span>
            <span class="s1">b_none </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">b_scalar </span><span class="s2">= </span><span class="s0">not </span><span class="s2">(</span><span class="s1">b_array </span><span class="s0">or </span><span class="s1">b_none</span><span class="s2">)</span>
            <span class="s1">need_cast </span><span class="s2">= </span><span class="s1">any</span><span class="s2">([</span><span class="s1">indices_list</span><span class="s2">])</span>

            <span class="s1">nin </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span>

            <span class="s4"># missing second argument?</span>
            <span class="s0">if </span><span class="s1">nin </span><span class="s2">== </span><span class="s3">2 </span><span class="s0">and </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s6">'second operand needed for ufunc'</span><span class="s2">)</span>

            <span class="s4"># extra second argument</span>
            <span class="s0">if </span><span class="s1">nin </span><span class="s2">== </span><span class="s3">1 </span><span class="s0">and not </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">'second operand provided when ufunc is unary'</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">add</span><span class="s2">((</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">,))</span>
            <span class="s0">elif </span><span class="s1">b_scalar</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">add</span><span class="s2">((</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">add</span><span class="s2">((</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

            <span class="s0">def </span><span class="s1">apply_ufunc_codegen</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arrayobj </span><span class="s0">import </span><span class="s1">make_array</span>

                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s3">4</span><span class="s2">:</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">aty</span><span class="s2">, </span><span class="s1">idxty</span><span class="s2">, </span><span class="s1">bty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">args</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">aty</span><span class="s2">, </span><span class="s1">idxty</span><span class="s2">, </span><span class="s1">bty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args </span><span class="s2">+ (</span><span class="s0">None</span><span class="s2">,)</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">args </span><span class="s2">+ (</span><span class="s0">None</span><span class="s2">,)</span>

                <span class="s1">a </span><span class="s2">= </span><span class="s1">make_array</span><span class="s2">(</span><span class="s1">aty</span><span class="s2">)(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
                <span class="s1">at_iter </span><span class="s2">= </span><span class="s1">UfuncAtIterator</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">aty</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">idxty</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">bty</span><span class="s2">)</span>
                <span class="s1">at_iter</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">)</span>

            <span class="s2">@</span><span class="s1">intrinsic</span>
            <span class="s0">def </span><span class="s1">apply_a_b_ufunc</span><span class="s2">(</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
                <span class="s1">sig </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">apply_ufunc_codegen</span>

            <span class="s2">@</span><span class="s1">intrinsic</span>
            <span class="s0">def </span><span class="s1">apply_a_ufunc</span><span class="s2">(</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">):</span>
                <span class="s1">sig </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">apply_ufunc_codegen</span>

            <span class="s0">def </span><span class="s1">impl_cast</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">b_none</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">at</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">at</span><span class="s2">(</span><span class="s1">a</span><span class="s2">,</span>
                                    <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">),</span>
                                    <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>

            <span class="s0">def </span><span class="s1">impl_generic</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">b_none</span><span class="s2">:</span>
                    <span class="s1">apply_a_ufunc</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">,)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">b_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
                    <span class="s1">a_ </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">]</span>
                    <span class="s1">b_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">b_</span><span class="s2">, </span><span class="s1">a_</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                    <span class="s1">apply_a_b_ufunc</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b_</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">impl_indices_empty_b_scalar</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s1">a</span><span class="s2">[()] = </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[()], </span><span class="s1">b</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">impl_scalar_scalar</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">b_none</span><span class="s2">:</span>
                    <span class="s1">a</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">] = </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">])</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">a</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">] = </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">], </span><span class="s1">b</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">need_cast</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">impl_cast</span>
            <span class="s0">elif </span><span class="s1">indices_empty_tuple </span><span class="s0">and </span><span class="s1">b_scalar</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">impl_indices_empty_b_scalar</span>
            <span class="s0">elif </span><span class="s1">indices_scalar </span><span class="s0">and </span><span class="s1">b_scalar</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">impl_scalar_scalar</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">impl_generic</span>

    <span class="s0">def </span><span class="s1">_install_ufunc_reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">template</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">at </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">template</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">overload_method</span><span class="s2">(</span><span class="s1">at</span><span class="s2">, </span><span class="s6">'reduce'</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">ol_reduce</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>

            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;ufunc.reduce feature is experimental&quot;</span><span class="s2">,</span>
                          <span class="s1">category</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaExperimentalFeatureWarning</span><span class="s2">)</span>

            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">'The first argument &quot;array&quot; must be array-like'</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s1">axis_int </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)</span>
            <span class="s1">axis_int_tuple </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">\</span>
                <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)</span>
            <span class="s1">axis_empty_tuple </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) == </span><span class="s3">0</span>
            <span class="s1">axis_none </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s1">axis_tuple_size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) </span><span class="s0">if </span><span class="s1">axis_int_tuple </span><span class="s0">else </span><span class="s3">0</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">identity </span><span class="s0">is None and not </span><span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">axis_int_tuple </span><span class="s0">and </span><span class="s1">axis_tuple_size </span><span class="s2">== </span><span class="s3">1</span><span class="s2">) </span><span class="s0">or</span>
                    <span class="s1">axis_empty_tuple </span><span class="s0">or </span><span class="s1">axis_int </span><span class="s0">or </span><span class="s1">axis_none</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s6">f&quot;reduction operation '</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s6">' is not &quot;</span>
                       <span class="s6">&quot;reorderable, so at most one axis may be specified&quot;</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s1">tup_init </span><span class="s2">= (</span><span class="s3">0</span><span class="s2">,) * (</span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
            <span class="s1">tup_init_m1 </span><span class="s2">= (</span><span class="s3">0</span><span class="s2">,) * (</span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">nb_dtype </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">if </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">else </span><span class="s1">dtype</span>
            <span class="s1">identity </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">identity</span>

            <span class="s1">id_none </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">identity</span><span class="s2">)</span>
            <span class="s1">init_none </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">initial</span><span class="s2">)</span>

            <span class="s2">@</span><span class="s1">register_jitable</span>
            <span class="s0">def </span><span class="s1">tuple_slice</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">):</span>
                <span class="s4"># Same as</span>
                <span class="s4"># tup = tup[0 : pos] + tup[pos + 1:]</span>
                <span class="s1">s </span><span class="s2">= </span><span class="s1">tup_init_m1</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s3">0</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">j </span><span class="s2">== </span><span class="s1">pos</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">s </span><span class="s2">= </span><span class="s1">tuple_setitem</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">e</span><span class="s2">)</span>
                    <span class="s1">i </span><span class="s2">+= </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">s</span>

            <span class="s2">@</span><span class="s1">register_jitable</span>
            <span class="s0">def </span><span class="s1">tuple_slice_append</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
                <span class="s4"># Same as</span>
                <span class="s4"># tup = tup[0 : pos] + val + tup[pos + 1:]</span>
                <span class="s1">s </span><span class="s2">= </span><span class="s1">tup_init</span>
                <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">sz </span><span class="s2">= </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>
                <span class="s0">while </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">sz</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">j </span><span class="s2">== </span><span class="s1">pos</span><span class="s2">:</span>
                        <span class="s1">s </span><span class="s2">= </span><span class="s1">tuple_setitem</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">e </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                        <span class="s1">s </span><span class="s2">= </span><span class="s1">tuple_setitem</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">e</span><span class="s2">)</span>
                        <span class="s1">i </span><span class="s2">+= </span><span class="s3">1</span>
                    <span class="s1">j </span><span class="s2">+= </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">s</span>

            <span class="s2">@</span><span class="s1">intrinsic</span>
            <span class="s0">def </span><span class="s1">compute_flat_idx</span><span class="s2">(</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">strides</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
                <span class="s1">sig </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
                <span class="s1">len_idx </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)</span>

                <span class="s0">def </span><span class="s1">gen_block</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">block_pos</span><span class="s2">, </span><span class="s1">block_name</span><span class="s2">, </span><span class="s1">bb_end</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                    <span class="s1">strides</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">args</span>
                    <span class="s1">bb </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">block_name</span><span class="s2">)</span>

                    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb</span><span class="s2">):</span>
                        <span class="s1">zero </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s3">64</span><span class="s2">)(</span><span class="s3">0</span><span class="s2">)</span>
                        <span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">zero</span>

                        <span class="s0">if </span><span class="s1">block_pos </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">len_idx</span><span class="s2">):</span>
                                <span class="s1">stride </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">)</span>
                                <span class="s1">idx_i </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">m </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">, </span><span class="s1">idx_i</span><span class="s2">)</span>
                                <span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">flat_idx</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
                        <span class="s0">elif </span><span class="s3">0 </span><span class="s2">&lt; </span><span class="s1">block_pos </span><span class="s2">&lt; </span><span class="s1">len_idx </span><span class="s2">- </span><span class="s3">1</span><span class="s2">:</span>
                            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">block_pos</span><span class="s2">):</span>
                                <span class="s1">stride </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">idx_i </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">m </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">, </span><span class="s1">idx_i</span><span class="s2">)</span>
                                <span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">flat_idx</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>

                            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">block_pos </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">len_idx</span><span class="s2">):</span>
                                <span class="s1">stride </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">)</span>
                                <span class="s1">idx_i </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">m </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">, </span><span class="s1">idx_i</span><span class="s2">)</span>
                                <span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">flat_idx</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len_idx </span><span class="s2">- </span><span class="s3">1</span><span class="s2">):</span>
                                <span class="s1">stride </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">idx_i </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">extract_value</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                                <span class="s1">m </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">, </span><span class="s1">idx_i</span><span class="s2">)</span>
                                <span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">flat_idx</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>

                        <span class="s1">builder</span><span class="s2">.</span><span class="s1">branch</span><span class="s2">(</span><span class="s1">bb_end</span><span class="s2">)</span>

                    <span class="s0">return </span><span class="s1">bb</span><span class="s2">, </span><span class="s1">flat_idx</span>

                <span class="s0">def </span><span class="s1">codegen</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                    <span class="s1">strides</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">= </span><span class="s1">args</span>

                    <span class="s1">bb </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">basic_block</span>
                    <span class="s1">switch_end </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s6">'axis_end'</span><span class="s2">)</span>
                    <span class="s1">l </span><span class="s2">= []</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len_idx</span><span class="s2">):</span>
                        <span class="s1">block</span><span class="s2">, </span><span class="s1">flat_idx </span><span class="s2">= </span><span class="s1">gen_block</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s6">f&quot;axis_</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s6">&quot;</span><span class="s2">,</span>
                                                    <span class="s1">switch_end</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
                        <span class="s1">l</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">block</span><span class="s2">, </span><span class="s1">flat_idx</span><span class="s2">))</span>

                    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb</span><span class="s2">):</span>
                        <span class="s1">switch </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">switch</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">l</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">][</span><span class="s3">0</span><span class="s2">])</span>
                        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len_idx</span><span class="s2">):</span>
                            <span class="s1">switch</span><span class="s2">.</span><span class="s1">add_case</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">l</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s3">0</span><span class="s2">])</span>

                    <span class="s1">builder</span><span class="s2">.</span><span class="s1">position_at_end</span><span class="s2">(</span><span class="s1">switch_end</span><span class="s2">)</span>
                    <span class="s1">phi </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">phi</span><span class="s2">(</span><span class="s1">l</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s3">1</span><span class="s2">].</span><span class="s1">type</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">block</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">l</span><span class="s2">:</span>
                        <span class="s1">phi</span><span class="s2">.</span><span class="s1">add_incoming</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">block</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sdiv</span><span class="s2">(</span><span class="s1">phi</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">)</span>

                <span class="s0">return </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">codegen</span>

            <span class="s2">@</span><span class="s1">register_jitable</span>
            <span class="s0">def </span><span class="s1">fixup_axis</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">):</span>
                <span class="s1">ax </span><span class="s2">= </span><span class="s1">axis</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)):</span>
                    <span class="s1">val </span><span class="s2">= </span><span class="s1">axis</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s1">ndim </span><span class="s0">if </span><span class="s1">axis</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &lt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">axis</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                    <span class="s1">ax </span><span class="s2">= </span><span class="s1">tuple_setitem</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">ax</span>

            <span class="s2">@</span><span class="s1">register_jitable</span>
            <span class="s0">def </span><span class="s1">find_min</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
                <span class="s1">idx</span><span class="s2">, </span><span class="s1">e </span><span class="s2">= </span><span class="s3">0</span><span class="s2">, </span><span class="s1">tup</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">)):</span>
                    <span class="s0">if </span><span class="s1">tup</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &lt; </span><span class="s1">e</span><span class="s2">:</span>
                        <span class="s1">idx</span><span class="s2">, </span><span class="s1">e </span><span class="s2">= </span><span class="s1">i</span><span class="s2">, </span><span class="s1">tup</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s0">return </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">e</span>

            <span class="s0">def </span><span class="s1">impl_1d</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s1">start </span><span class="s2">= </span><span class="s3">0</span>
                <span class="s0">if </span><span class="s1">init_none </span><span class="s0">and </span><span class="s1">id_none</span><span class="s2">:</span>
                    <span class="s1">start </span><span class="s2">= </span><span class="s3">1</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">array</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
                <span class="s0">elif </span><span class="s1">init_none</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">identity</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">initial</span>

                <span class="s1">sz </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">sz</span><span class="s2">):</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">array</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
                <span class="s0">return </span><span class="s1">r</span>

            <span class="s0">def </span><span class="s1">impl_nd_axis_int</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">,</span>
                                 <span class="s1">array</span><span class="s2">,</span>
                                 <span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">,</span>
                                 <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                                 <span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;'axis' must be specified&quot;</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s1">axis </span><span class="s2">+= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span>

                <span class="s0">if </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">axis </span><span class="s2">&gt;= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Invalid axis&quot;</span><span class="s2">)</span>

                <span class="s4"># create result array</span>
                <span class="s1">shape </span><span class="s2">= </span><span class="s1">tuple_slice</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">initial </span><span class="s0">is None and </span><span class="s1">identity </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">nb_dtype</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndenumerate</span><span class="s2">(</span><span class="s1">r</span><span class="s2">):</span>
                        <span class="s4"># shape[0:axis] + 0 + shape[axis:]</span>
                        <span class="s1">result_idx </span><span class="s2">= </span><span class="s1">tuple_slice_append</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)</span>
                        <span class="s1">r</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">array</span><span class="s2">[</span><span class="s1">result_idx</span><span class="s2">]</span>
                <span class="s0">elif </span><span class="s1">initial </span><span class="s0">is None and </span><span class="s1">identity </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s4"># Checking if identity is not none is redundant but required</span>
                    <span class="s4"># compile this block</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">identity</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">nb_dtype</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">initial</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">nb_dtype</span><span class="s2">)</span>

                <span class="s4"># One approach to implement reduce is to remove the axis index</span>
                <span class="s4"># from the indexing tuple returned by &quot;np.ndenumerate&quot;. For</span>
                <span class="s4"># instance, if idx = (X, Y, Z) and axis=1, the result index</span>
                <span class="s4"># is (X, Y).</span>
                <span class="s4"># Another way is to compute the result index using strides,</span>
                <span class="s4"># which is faster than manipulating tuples.</span>
                <span class="s1">view </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">initial </span><span class="s0">is None and </span><span class="s1">identity </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndenumerate</span><span class="s2">(</span><span class="s1">array</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">idx</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] == </span><span class="s3">0</span><span class="s2">:</span>
                            <span class="s0">continue</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">flat_pos </span><span class="s2">= </span><span class="s1">compute_flat_idx</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">,</span>
                                                        <span class="s1">idx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
                            <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">view</span><span class="s2">[</span><span class="s1">flat_pos</span><span class="s2">], </span><span class="s1">val</span>
                            <span class="s1">view</span><span class="s2">[</span><span class="s1">flat_pos</span><span class="s2">] = </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndenumerate</span><span class="s2">(</span><span class="s1">array</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">initial </span><span class="s0">is None and </span><span class="s1">identity </span><span class="s0">is None and </span><span class="s1">\</span>
                                <span class="s1">idx</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] == </span><span class="s3">0</span><span class="s2">:</span>
                            <span class="s0">continue</span>
                        <span class="s1">flat_pos </span><span class="s2">= </span><span class="s1">compute_flat_idx</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">strides</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">,</span>
                                                    <span class="s1">idx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
                        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">view</span><span class="s2">[</span><span class="s1">flat_pos</span><span class="s2">], </span><span class="s1">val</span>
                        <span class="s1">view</span><span class="s2">[</span><span class="s1">flat_pos</span><span class="s2">] = </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">r</span>

            <span class="s0">def </span><span class="s1">impl_nd_axis_tuple</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">,</span>
                                   <span class="s1">array</span><span class="s2">,</span>
                                   <span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">,</span>
                                   <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                                   <span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s1">axis_ </span><span class="s2">= </span><span class="s1">fixup_axis</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis_</span><span class="s2">)):</span>
                    <span class="s0">if </span><span class="s1">axis_</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">axis_</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &gt;= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Invalid axis&quot;</span><span class="s2">)</span>

                    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis_</span><span class="s2">)):</span>
                        <span class="s0">if </span><span class="s1">axis_</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] == </span><span class="s1">axis_</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]:</span>
                            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;duplicate value in 'axis'&quot;</span><span class="s2">)</span>

                <span class="s1">min_idx</span><span class="s2">, </span><span class="s1">min_elem </span><span class="s2">= </span><span class="s1">find_min</span><span class="s2">(</span><span class="s1">axis_</span><span class="s2">)</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">array</span><span class="s2">,</span>
                                 <span class="s1">axis</span><span class="s2">=</span><span class="s1">min_elem</span><span class="s2">,</span>
                                 <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
                                 <span class="s1">initial</span><span class="s2">=</span><span class="s1">initial</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) == </span><span class="s3">1</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">r</span>
                <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) == </span><span class="s3">2</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis_</span><span class="s2">[(</span><span class="s1">min_idx </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">) % </span><span class="s3">2</span><span class="s2">] - </span><span class="s3">1</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">ax </span><span class="s2">= </span><span class="s1">axis_tup</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">)):</span>
                        <span class="s0">if </span><span class="s1">i </span><span class="s2">!= </span><span class="s1">min_idx</span><span class="s2">:</span>
                            <span class="s1">ax </span><span class="s2">= </span><span class="s1">tuple_setitem</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">axis_</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
                    <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">impl_axis_empty_tuple</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">,</span>
                                      <span class="s1">array</span><span class="s2">,</span>
                                      <span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">,</span>
                                      <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                                      <span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">array</span>

            <span class="s0">def </span><span class="s1">impl_axis_none</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">,</span>
                               <span class="s1">array</span><span class="s2">,</span>
                               <span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">,</span>
                               <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                               <span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">axis_tup</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s3">1 </span><span class="s0">and not </span><span class="s1">axis_empty_tuple</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">impl_1d</span>
            <span class="s0">elif </span><span class="s1">axis_empty_tuple</span><span class="s2">:</span>
                <span class="s4"># ufunc(array, axis=())</span>
                <span class="s0">return </span><span class="s1">impl_axis_empty_tuple</span>
            <span class="s0">elif </span><span class="s1">axis_none</span><span class="s2">:</span>
                <span class="s4"># ufunc(array, axis=None)</span>
                <span class="s1">axis_tup </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">))</span>
                <span class="s0">return </span><span class="s1">impl_axis_none</span>
            <span class="s0">elif </span><span class="s1">axis_int_tuple</span><span class="s2">:</span>
                <span class="s4"># axis is tuple of integers</span>
                <span class="s4"># ufunc(array, axis=(1, 2, ...))</span>
                <span class="s1">axis_tup </span><span class="s2">= (</span><span class="s3">0</span><span class="s2">,) * (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) - </span><span class="s3">1</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">impl_nd_axis_tuple</span>
            <span class="s0">elif </span><span class="s1">axis </span><span class="s2">== </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">,</span>
                                                <span class="s1">types</span><span class="s2">.</span><span class="s1">Omitted</span><span class="s2">,</span>
                                                <span class="s1">types</span><span class="s2">.</span><span class="s1">IntegerLiteral</span><span class="s2">)):</span>
                <span class="s4"># axis is default value (0) or an integer</span>
                <span class="s4"># ufunc(array, axis=0)</span>
                <span class="s0">return </span><span class="s1">impl_nd_axis_int</span>
            <span class="s4"># elif array.ndim == 1:</span>
            <span class="s4">#     return impl_1d</span>

    <span class="s0">def </span><span class="s1">at</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4"># dynamic compile ufunc.at</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">a</span><span class="s2">,) </span><span class="s0">if </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s0">else </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s1">argtys </span><span class="s2">= (</span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">ewise_types </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">) </span><span class="s0">else </span><span class="s1">arg</span>
                            <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">argtys</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find_ewise_function</span><span class="s2">(</span><span class="s1">ewise_types</span><span class="s2">) == (</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">):</span>
            <span class="s4"># cannot find a matching function and compilation is disabled</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;compilation disabled for %s.at(...)&quot; </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">,)</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_for_args</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s4"># all good, just dispatch to the function</span>
        <span class="s0">if </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_nonelike</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">at</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">at</span><span class="s2">(*(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_install_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Constructs and installs a typing class for a DUFunc object in the 
        input typing context.  If no typing context is given, then 
        _install_type() installs into the typing context of the 
        dispatcher object (should be same default context used by 
        jit() and njit()). 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">typingctx </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">typingctx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">targetdescr</span><span class="s2">.</span><span class="s1">typing_context</span>
        <span class="s1">_ty_cls </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s6">'DUFuncTyping_' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
                       <span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">,),</span>
                       <span class="s1">dict</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">, </span><span class="s1">generic</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_type_me</span><span class="s2">))</span>
        <span class="s1">typingctx</span><span class="s2">.</span><span class="s1">insert_user_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">_ty_cls</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_ufunc_attributes</span><span class="s2">(</span><span class="s1">_ty_cls</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_install_ufunc_methods</span><span class="s2">(</span><span class="s1">_ty_cls</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">find_ewise_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ewise_types</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Given a tuple of element-wise argument types, find a matching 
        signature in the dispatcher. 
 
        Return a 2-tuple containing the matching signature, and 
        compilation result.  Will return two None's if no matching 
        signature was found. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen</span><span class="s2">:</span>
            <span class="s4"># If we cannot compile, coerce to the best matching loop</span>
            <span class="s1">loop </span><span class="s2">= </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">ufunc_find_matching_loop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ewise_types</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">loop </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return None</span><span class="s2">, </span><span class="s0">None</span>
            <span class="s1">ewise_types </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">inputs </span><span class="s2">+ </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">outputs</span><span class="s2">)[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">ewise_types</span><span class="s2">)]</span>
        <span class="s0">for </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">cres </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dispatcher</span><span class="s2">.</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args </span><span class="s2">== </span><span class="s1">ewise_types</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">cres</span>
        <span class="s0">return None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_type_me</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">kwtys</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Implement AbstractTemplate.generic() for the typing class 
        built by DUFunc._install_type(). 
 
        Return the call-site signature after either validating the 
        element-wise signature or compiling for it. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert not </span><span class="s1">kwtys</span>
        <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span>
        <span class="s1">_handle_inputs_result </span><span class="s2">= </span><span class="s1">npydecl</span><span class="s2">.</span><span class="s1">Numpy_rules_ufunc</span><span class="s2">.</span><span class="s1">_handle_inputs</span><span class="s2">(</span>
            <span class="s1">ufunc</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">kwtys</span><span class="s2">)</span>
        <span class="s1">base_types</span><span class="s2">, </span><span class="s1">explicit_outputs</span><span class="s2">, </span><span class="s1">ndims</span><span class="s2">, </span><span class="s1">layout </span><span class="s2">= </span><span class="s1">_handle_inputs_result</span>
        <span class="s1">explicit_output_count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">explicit_output_count </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s1">ewise_types </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">base_types</span><span class="s2">[:-</span><span class="s1">len</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">)])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ewise_types </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">base_types</span><span class="s2">)</span>
        <span class="s1">sig</span><span class="s2">, </span><span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find_ewise_function</span><span class="s2">(</span><span class="s1">ewise_types</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sig </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s4"># Matching element-wise signature was not found; must</span>
            <span class="s4"># compile.</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frozen</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s6">&quot;cannot call %s with types %s&quot;</span>
                                <span class="s2">% (</span><span class="s1">self</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_for_argtys</span><span class="s2">(</span><span class="s1">ewise_types</span><span class="s2">)</span>
            <span class="s1">sig</span><span class="s2">, </span><span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find_ewise_function</span><span class="s2">(</span><span class="s1">ewise_types</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">sig </span><span class="s0">is not None</span>
        <span class="s0">if </span><span class="s1">explicit_output_count </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s1">outtys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">ndims </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">outtys </span><span class="s2">= [</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">ndims</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">)]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">outtys </span><span class="s2">= [</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;typing gufuncs (nout &gt; 1)&quot;</span><span class="s2">)</span>
        <span class="s1">outtys</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">argtys</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(*</span><span class="s1">outtys</span><span class="s2">)</span>


<span class="s1">array_analysis</span><span class="s2">.</span><span class="s1">MAP_TYPES</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DUFunc</span><span class="s2">)</span>
</pre>
</body>
</html>