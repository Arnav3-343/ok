<html>
<head>
<title>knspace.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
knspace.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Kivy Namespaces 
=============== 
 
.. versionadded:: 1.9.1 
 
.. warning:: 
    This code is still experimental, and its API is subject to change in a 
    future version. 
 
The :class:`KNSpaceBehavior` `mixin &lt;https://en.wikipedia.org/wiki/Mixin&gt;`_ 
class provides namespace functionality for Kivy objects. It allows kivy objects 
to be named and then accessed using namespaces. 
 
:class:`KNSpace` instances are the namespaces that store the named objects 
in Kivy :class:`~kivy.properties.ObjectProperty` instances. 
In addition, when inheriting from :class:`KNSpaceBehavior`, if the derived 
object is named, the name will automatically be added to the associated 
namespace and will point to a :attr:`~kivy.uix.widget.proxy_ref` of the 
derived object. 
 
Basic examples 
-------------- 
 
By default, there's only a single namespace: the :attr:`knspace` namespace. The 
simplest example is adding a widget to the namespace: 
 
.. code-block:: python 
 
    from kivy.uix.behaviors.knspace import knspace 
    widget = Widget() 
    knspace.my_widget = widget 
 
This adds a kivy :class:`~kivy.properties.ObjectProperty` with `rebind=True` 
and `allownone=True` to the :attr:`knspace` namespace with a property name 
`my_widget`. And the property now also points to this widget. 
 
This can be done automatically with: 
 
.. code-block:: python 
 
    class MyWidget(KNSpaceBehavior, Widget): 
        pass 
 
    widget = MyWidget(knsname='my_widget') 
 
Or in kv: 
 
.. code-block:: kv 
 
    &lt;MyWidget@KNSpaceBehavior+Widget&gt; 
 
    MyWidget: 
        knsname: 'my_widget' 
 
Now, `knspace.my_widget` will point to that widget. 
 
When one creates a second widget with the same name, the namespace will 
also change to point to the new widget. E.g.: 
 
.. code-block:: python 
 
    widget = MyWidget(knsname='my_widget') 
    # knspace.my_widget now points to widget 
    widget2 = MyWidget(knsname='my_widget') 
    # knspace.my_widget now points to widget2 
 
Setting the namespace 
--------------------- 
 
One can also create ones own namespace rather than using the default 
:attr:`knspace` by directly setting :attr:`KNSpaceBehavior.knspace`: 
 
.. code-block:: python 
 
    class MyWidget(KNSpaceBehavior, Widget): 
        pass 
 
    widget = MyWidget(knsname='my_widget') 
    my_new_namespace = KNSpace() 
    widget.knspace = my_new_namespace 
 
Initially, `my_widget` is added to the default namespace, but when the widget's 
namespace is changed to `my_new_namespace`, the reference to `my_widget` is 
moved to that namespace. We could have also of course first set the namespace 
to `my_new_namespace` and then have named the widget `my_widget`, thereby 
avoiding the initial assignment to the default namespace. 
 
Similarly, in kv: 
 
.. code-block:: kv 
 
    &lt;MyWidget@KNSpaceBehavior+Widget&gt; 
 
    MyWidget: 
        knspace: KNSpace() 
        knsname: 'my_widget' 
 
Inheriting the namespace 
------------------------ 
 
In the previous example, we directly set the namespace we wished to use. 
In the following example, we inherit it from the parent, so we only have to set 
it once: 
 
.. code-block:: kv 
 
    &lt;MyWidget@KNSpaceBehavior+Widget&gt; 
    &lt;MyLabel@KNSpaceBehavior+Label&gt; 
 
    &lt;MyComplexWidget@MyWidget&gt;: 
        knsname: 'my_complex' 
        MyLabel: 
            knsname: 'label1' 
        MyLabel: 
            knsname: 'label2' 
 
Then, we do: 
 
.. code-block:: python 
 
    widget = MyComplexWidget() 
    new_knspace = KNSpace() 
    widget.knspace = new_knspace 
 
The rule is that if no knspace has been assigned to a widget, it looks for a 
namespace in its parent and parent's parent and so on until it find one to 
use. If none are found, it uses the default :attr:`knspace`. 
 
When `MyComplexWidget` is created, it still used the default namespace. 
However, when we assigned the root widget its new namespace, all its 
children switched to using that new namespace as well. So `new_knspace` now 
contains `label1` and `label2` as well as `my_complex`. 
 
If we had first done: 
 
.. code-block:: python 
 
    widget = MyComplexWidget() 
    new_knspace = KNSpace() 
    knspace.label1.knspace = knspace 
    widget.knspace = new_knspace 
 
Then `label1` would remain stored in the default :attr:`knspace` since it was 
directly set, but `label2` and `my_complex` would still be added to the new 
namespace. 
 
One can customize the attribute used to search the parent tree by changing 
:attr:`KNSpaceBehavior.knspace_key`. If the desired knspace is not reachable 
through a widgets parent tree, e.g. in a popup that is not a widget's child, 
:attr:`KNSpaceBehavior.knspace_key` can be used to establish a different 
search order. 
 
Accessing the namespace 
----------------------- 
 
As seen in the previous example, if not directly assigned, the namespace is 
found by searching the parent tree. Consequently, if a namespace was assigned 
further up the parent tree, all its children and below could access that 
namespace through their :attr:`KNSpaceBehavior.knspace` property. 
 
This allows the creation of multiple widgets with identically given names 
if each root widget instance is assigned a new namespace. For example: 
 
.. code-block:: kv 
 
    &lt;MyComplexWidget@KNSpaceBehavior+Widget&gt;: 
        Label: 
            text: root.knspace.pretty.text if root.knspace.pretty else '' 
 
    &lt;MyPrettyWidget@KNSpaceBehavior+TextInput&gt;: 
        knsname: 'pretty' 
        text: 'Hello' 
 
    &lt;MyCompositeWidget@KNSpaceBehavior+BoxLayout&gt;: 
        MyComplexWidget 
        MyPrettyWidget 
 
Now, when we do: 
 
.. code-block:: python 
 
    knspace1, knspace2 = KNSpace(), KNSpace() 
    composite1 = MyCompositeWidget() 
    composite1.knspace = knspace1 
 
    composite2 = MyCompositeWidget() 
    composite2.knspace = knspace2 
 
    knspace1.pretty = &quot;Here's the ladder, now fix the roof!&quot; 
    knspace2.pretty = &quot;Get that raccoon off me!&quot; 
 
Because each of the `MyCompositeWidget` instances have a different namespace 
their children also use different namespaces. Consequently, the 
pretty and complex widgets of each instance will have different text. 
 
Further, because both the namespace :class:`~kivy.properties.ObjectProperty` 
references, and :attr:`KNSpaceBehavior.knspace` have `rebind=True`, the 
text of the `MyComplexWidget` label is rebound to match the text of 
`MyPrettyWidget` when either the root's namespace changes or when the 
`root.knspace.pretty` property changes, as expected. 
 
Forking a namespace 
------------------- 
 
Forking a namespace provides the opportunity to create a new namespace 
from a parent namespace so that the forked namespace will contain everything 
in the origin namespace, but the origin namespace will not have access to 
anything added to the forked namespace. 
 
For example: 
 
.. code-block:: python 
 
    child = knspace.fork() 
    grandchild = child.fork() 
 
    child.label = Label() 
    grandchild.button = Button() 
 
Now label is accessible by both child and grandchild, but not by knspace. And 
button is only accessible by the grandchild but not by the child or by knspace. 
Finally, doing `grandchild.label = Label()` will leave `grandchild.label` 
and `child.label` pointing to different labels. 
 
A motivating example is the example from above: 
 
.. code-block:: kv 
 
    &lt;MyComplexWidget@KNSpaceBehavior+Widget&gt;: 
        Label: 
            text: root.knspace.pretty.text if root.knspace.pretty else '' 
 
    &lt;MyPrettyWidget@KNSpaceBehavior+TextInput&gt;: 
        knsname: 'pretty' 
        text: 'Hello' 
 
    &lt;MyCompositeWidget@KNSpaceBehavior+BoxLayout&gt;: 
        knspace: 'fork' 
        MyComplexWidget 
        MyPrettyWidget 
 
Notice the addition of `knspace: 'fork'`. This is identical to doing 
`knspace: self.knspace.fork()`. However, doing that would lead to infinite 
recursion as that kv rule would be executed recursively because `self.knspace` 
will keep on changing. However, allowing `knspace: 'fork'` cirumvents that. 
See :attr:`KNSpaceBehavior.knspace`. 
 
Now, having forked, we just need to do: 
 
.. code-block:: python 
 
    composite1 = MyCompositeWidget() 
    composite2 = MyCompositeWidget() 
 
    composite1.knspace.pretty = &quot;Here's the ladder, now fix the roof!&quot; 
    composite2.knspace.pretty = &quot;Get that raccoon off me!&quot; 
 
Since by forking we automatically created a unique namespace for each 
`MyCompositeWidget` instance. 
'''</span>

<span class="s1">__all__ </span><span class="s2">= (</span><span class="s3">'KNSpace'</span><span class="s2">, </span><span class="s3">'KNSpaceBehavior'</span><span class="s2">, </span><span class="s3">'knspace'</span><span class="s2">)</span>

<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">event </span><span class="s4">import </span><span class="s1">EventDispatcher</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">properties </span><span class="s4">import </span><span class="s1">StringProperty</span><span class="s2">, </span><span class="s1">ObjectProperty</span><span class="s2">, </span><span class="s1">AliasProperty</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">context </span><span class="s4">import </span><span class="s1">register_context</span>


<span class="s4">class </span><span class="s1">KNSpace</span><span class="s2">(</span><span class="s1">EventDispatcher</span><span class="s2">):</span>
    <span class="s0">'''Each :class:`KNSpace` instance is a namespace that stores the named Kivy 
    objects associated with this namespace. Each named object is 
    stored as the value of a Kivy :class:`~kivy.properties.ObjectProperty` of 
    this instance whose property name is the object's given name. Both `rebind` 
    and `allownone` are set to `True` for the property. 
 
    See :attr:`KNSpaceBehavior.knspace` for details on how a namespace is 
    associated with a named object. 
 
    When storing an object in the namespace, the object's `proxy_ref` is 
    stored if the object has such an attribute. 
 
    :Parameters: 
 
        `parent`: (internal) A :class:`KNSpace` instance or None. 
            If specified, it's a parent namespace, in which case, the current 
            namespace will have in its namespace all its named objects 
            as well as the named objects of its parent and parent's parent 
            etc. See :meth:`fork` for more details. 
    '''</span>

    <span class="s1">parent </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s3">'''(internal) The parent namespace instance, :class:`KNSpace`, or None. See 
    :meth:`fork`. 
    '''</span>
    <span class="s1">__has_applied </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s1">keep_ref </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s3">'''Whether a direct reference should be kept to the stored objects. 
    If ``True``, we use the direct object, otherwise we use 
    :attr:`~kivy.uix.widget.proxy_ref` when present. 
 
    Defaults to False. 
    '''</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">keep_ref</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">keep_ref </span><span class="s2">= </span><span class="s1">keep_ref</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">parent </span><span class="s2">= </span><span class="s1">parent</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__has_applied </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">properties</span><span class="s2">().</span><span class="s1">keys</span><span class="s2">())</span>

    <span class="s4">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">prop </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">property</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">quiet</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s1">has_applied </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__has_applied</span>
        <span class="s4">if </span><span class="s1">prop </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
                <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">apply_property</span><span class="s2">(</span>
                    <span class="s2">**{</span><span class="s1">name</span><span class="s2">:</span>
                       <span class="s1">ObjectProperty</span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s1">rebind</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">allownone</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)}</span>
                <span class="s2">)</span>
                <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">keep_ref</span><span class="s2">:</span>
                    <span class="s1">value </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s3">'proxy_ref'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
                <span class="s1">has_applied</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">name </span><span class="s4">not in </span><span class="s1">has_applied</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">apply_property</span><span class="s2">(**{</span><span class="s1">name</span><span class="s2">: </span><span class="s1">prop</span><span class="s2">})</span>
            <span class="s1">has_applied</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">keep_ref</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s3">'proxy_ref'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">keep_ref</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s3">'proxy_ref'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">name </span><span class="s4">in </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s3">'__dict__'</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s1">parent </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s3">'parent'</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">parent </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">value </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">value</span>

        <span class="s1">parent </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s3">'parent'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">parent </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return None</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)  </span><span class="s5"># if parent doesn't have it</span>
        <span class="s4">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">property</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">quiet</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s5"># needs to overwrite EventDispatcher.property so kv lang will work</span>
        <span class="s1">prop </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">property</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">quiet</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">prop </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">prop</span>

        <span class="s1">prop </span><span class="s2">= </span><span class="s1">ObjectProperty</span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s1">rebind</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">allownone</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">apply_property</span><span class="s2">(**{</span><span class="s1">name</span><span class="s2">: </span><span class="s1">prop</span><span class="s2">})</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__has_applied</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">prop</span>

    <span class="s4">def </span><span class="s1">fork</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Returns a new :class:`KNSpace` instance which will have access to 
        all the named objects in the current namespace but will also have a 
        namespace of its own that is unique to it. 
 
        For example: 
 
        .. code-block:: python 
 
            forked_knspace1 = knspace.fork() 
            forked_knspace2 = knspace.fork() 
 
        Now, any names added to `knspace` will be accessible by the 
        `forked_knspace1` and `forked_knspace2` namespaces by the normal means. 
        However, any names added to `forked_knspace1` will not be accessible 
        from `knspace` or `forked_knspace2`. Similar for `forked_knspace2`. 
        '''</span>
        <span class="s4">return </span><span class="s1">KNSpace</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">=</span><span class="s1">self</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">KNSpaceBehavior</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">'''Inheriting from this class allows naming of the inherited objects, which 
    are then added to the associated namespace :attr:`knspace` and accessible 
    through it. 
 
    Please see the :mod:`knspace behaviors module &lt;kivy.uix.behaviors.knspace&gt;` 
    documentation for more information. 
    '''</span>

    <span class="s1">_knspace </span><span class="s2">= </span><span class="s1">ObjectProperty</span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s1">allownone</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">_knsname </span><span class="s2">= </span><span class="s1">StringProperty</span><span class="s2">(</span><span class="s3">''</span><span class="s2">)</span>
    <span class="s1">__last_knspace </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">__callbacks </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">knspace</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">knspace </span><span class="s2">= </span><span class="s1">knspace</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">KNSpaceBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__knspace_clear_callbacks</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">largs</span><span class="s2">):</span>
        <span class="s4">for </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">uid </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks</span><span class="s2">:</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">unbind_uid</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">)</span>
        <span class="s1">last </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace </span><span class="s4">is None</span>
        <span class="s4">assert </span><span class="s1">last</span>

        <span class="s1">new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__set_parent_knspace</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">new </span><span class="s4">is </span><span class="s1">last</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">property</span><span class="s2">(</span><span class="s3">'_knspace'</span><span class="s2">).</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knsname</span>
        <span class="s4">if not </span><span class="s1">name</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s4">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">last</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">last</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">new</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Object has name &quot;{}&quot;, but no namespace'</span><span class="s2">.</span>
                             <span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__set_parent_knspace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">callbacks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks </span><span class="s2">= []</span>
        <span class="s1">fbind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fbind</span>
        <span class="s1">append </span><span class="s2">= </span><span class="s1">callbacks</span><span class="s2">.</span><span class="s1">append</span>
        <span class="s1">parent_key </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knspace_key</span>
        <span class="s1">clear </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__knspace_clear_callbacks</span>

        <span class="s1">append</span><span class="s2">((</span><span class="s1">self</span><span class="s2">, </span><span class="s3">'knspace_key'</span><span class="s2">, </span><span class="s1">fbind</span><span class="s2">(</span><span class="s3">'knspace_key'</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">)))</span>
        <span class="s4">if not </span><span class="s1">parent_key</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace </span><span class="s2">= </span><span class="s1">knspace</span>
            <span class="s4">return </span><span class="s1">knspace</span>

        <span class="s1">append</span><span class="s2">((</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parent_key</span><span class="s2">, </span><span class="s1">fbind</span><span class="s2">(</span><span class="s1">parent_key</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">)))</span>
        <span class="s1">parent </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parent_key</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
        <span class="s4">while </span><span class="s1">parent </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">fbind </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">fbind</span>

            <span class="s1">parent_knspace </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s3">'knspace'</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">parent_knspace </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">append</span><span class="s2">((</span><span class="s1">parent</span><span class="s2">, </span><span class="s3">'knspace'</span><span class="s2">, </span><span class="s1">fbind</span><span class="s2">(</span><span class="s3">'knspace'</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">)))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace </span><span class="s2">= </span><span class="s1">parent_knspace</span>
                <span class="s4">return </span><span class="s1">parent_knspace</span>

            <span class="s1">append</span><span class="s2">((</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parent_key</span><span class="s2">, </span><span class="s1">fbind</span><span class="s2">(</span><span class="s1">parent_key</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">)))</span>
            <span class="s1">new_parent </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parent_key</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">new_parent </span><span class="s4">is </span><span class="s1">parent</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s1">parent </span><span class="s2">= </span><span class="s1">new_parent</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace </span><span class="s2">= </span><span class="s1">knspace</span>
        <span class="s4">return </span><span class="s1">knspace</span>

    <span class="s4">def </span><span class="s1">_get_knspace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">_knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace</span>
        <span class="s4">if </span><span class="s1">_knspace </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">_knspace</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace</span>

        <span class="s5"># we only get here if we never accessed our knspace</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__set_parent_knspace</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">_set_knspace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">value </span><span class="s4">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s1">knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace </span><span class="s4">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knsname</span>
        <span class="s4">if </span><span class="s1">name </span><span class="s4">and </span><span class="s1">knspace </span><span class="s4">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)  </span><span class="s5"># reset old namespace</span>

        <span class="s4">if </span><span class="s1">value </span><span class="s2">== </span><span class="s3">'fork'</span><span class="s2">:</span>
            <span class="s4">if not </span><span class="s1">knspace</span><span class="s2">:</span>
                <span class="s1">knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knspace  </span><span class="s5"># get parents in case we haven't before</span>
            <span class="s4">if </span><span class="s1">knspace</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">knspace</span><span class="s2">.</span><span class="s1">fork</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Cannot fork with no namespace'</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">prop_name</span><span class="s2">, </span><span class="s1">uid </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks </span><span class="s4">or </span><span class="s2">[]:</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">unbind_uid</span><span class="s2">(</span><span class="s1">prop_name</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__last_knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__callbacks </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">name</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">value </span><span class="s4">is None</span><span class="s2">:  </span><span class="s5"># if None, first update the recursive knspace</span>
                <span class="s1">knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__set_parent_knspace</span><span class="s2">()</span>
                <span class="s4">if </span><span class="s1">knspace</span><span class="s2">:</span>
                    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace </span><span class="s2">= </span><span class="s4">None  </span><span class="s5"># cause a kv trigger</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>
                <span class="s1">knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace </span><span class="s2">= </span><span class="s1">value</span>

            <span class="s4">if not </span><span class="s1">knspace</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Object has name &quot;{}&quot;, but no namespace'</span><span class="s2">.</span>
                                 <span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">value </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__set_parent_knspace</span><span class="s2">()  </span><span class="s5"># update before trigger below</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_knspace </span><span class="s2">= </span><span class="s1">value</span>

    <span class="s1">knspace </span><span class="s2">= </span><span class="s1">AliasProperty</span><span class="s2">(</span>
        <span class="s1">_get_knspace</span><span class="s2">, </span><span class="s1">_set_knspace</span><span class="s2">, </span><span class="s1">bind</span><span class="s2">=(</span><span class="s3">'_knspace'</span><span class="s2">, ), </span><span class="s1">cache</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
        <span class="s1">rebind</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">allownone</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s3">'''The namespace instance, :class:`KNSpace`, associated with this widget. 
    The :attr:`knspace` namespace stores this widget when naming this widget 
    with :attr:`knsname`. 
 
    If the namespace has been set with a :class:`KNSpace` instance, e.g. with 
    `self.knspace = KNSpace()`, then that instance is returned (setting with 
    `None` doesn't count). Otherwise, if :attr:`knspace_key` is not None, we 
    look for a namespace to use in the object that is stored in the property 
    named :attr:`knspace_key`, of this instance. I.e. 
    `object = getattr(self, self.knspace_key)`. 
 
    If that object has a knspace property, then we return its value. Otherwise, 
    we go further up, e.g. with `getattr(object, self.knspace_key)` and look 
    for its `knspace` property. 
 
    Finally, if we reach a value of `None`, or :attr:`knspace_key` was `None`, 
    the default :attr:`~kivy.uix.behaviors.knspace.knspace` namespace is 
    returned. 
 
    If :attr:`knspace` is set to the string `'fork'`, the current namespace 
    in :attr:`knspace` will be forked with :meth:`KNSpace.fork` and the 
    resulting namespace will be assigned to this instance's :attr:`knspace`. 
    See the module examples for a motivating example. 
 
    Both `rebind` and `allownone` are `True`. 
    '''</span>

    <span class="s1">knspace_key </span><span class="s2">= </span><span class="s1">StringProperty</span><span class="s2">(</span><span class="s3">'parent'</span><span class="s2">, </span><span class="s1">allownone</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s3">'''The name of the property of this instance, to use to search upwards for 
    a namespace to use by this instance. Defaults to `'parent'` so that we'll 
    search the parent tree. See :attr:`knspace`. 
 
    When `None`, we won't search the parent tree for the namespace. 
    `allownone` is `True`. 
    '''</span>

    <span class="s4">def </span><span class="s1">_get_knsname</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knsname</span>

    <span class="s4">def </span><span class="s1">_set_knsname</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">old_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_knsname</span>
        <span class="s1">knspace </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knspace</span>
        <span class="s4">if </span><span class="s1">old_name </span><span class="s4">and </span><span class="s1">knspace </span><span class="s4">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">old_name</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">old_name</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_knsname </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s4">if </span><span class="s1">value</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">knspace</span><span class="s2">:</span>
                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">knspace</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Object has name &quot;{}&quot;, but no namespace'</span><span class="s2">.</span>
                                 <span class="s1">format</span><span class="s2">(</span><span class="s1">value</span><span class="s2">))</span>

    <span class="s1">knsname </span><span class="s2">= </span><span class="s1">AliasProperty</span><span class="s2">(</span>
        <span class="s1">_get_knsname</span><span class="s2">, </span><span class="s1">_set_knsname</span><span class="s2">, </span><span class="s1">bind</span><span class="s2">=(</span><span class="s3">'_knsname'</span><span class="s2">, ), </span><span class="s1">cache</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s3">'''The name given to this instance. If named, the name will be added to the 
    associated :attr:`knspace` namespace, which will then point to the 
    `proxy_ref` of this instance. 
 
    When named, one can access this object by e.g. self.knspace.name, where 
    `name` is the given name of this instance. See :attr:`knspace` and the 
    module description for more details. 
    '''</span>


<span class="s1">knspace </span><span class="s2">= </span><span class="s1">register_context</span><span class="s2">(</span><span class="s3">'knspace'</span><span class="s2">, </span><span class="s1">KNSpace</span><span class="s2">)</span>
<span class="s3">'''The default :class:`KNSpace` namespace. See :attr:`KNSpaceBehavior.knspace` 
for more details. 
'''</span>
</pre>
</body>
</html>