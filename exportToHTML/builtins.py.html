<html>
<head>
<title>builtins.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
builtins.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">itertools</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span><span class="s2">, </span><span class="s1">errors</span>
<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">prange</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">internal_prange</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">templates </span><span class="s0">import </span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">, </span><span class="s1">ConcreteTemplate</span><span class="s2">,</span>
                                         <span class="s1">AbstractTemplate</span><span class="s2">, </span><span class="s1">infer_global</span><span class="s2">, </span><span class="s1">infer</span><span class="s2">,</span>
                                         <span class="s1">infer_getattr</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">,</span>
                                         <span class="s1">bound_function</span><span class="s2">, </span><span class="s1">make_callable_template</span><span class="s2">)</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython</span><span class="s2">.</span><span class="s1">builtins </span><span class="s0">import </span><span class="s1">get_type_min_value</span><span class="s2">, </span><span class="s1">get_type_max_value</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">extending </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">typeof_impl</span><span class="s2">, </span><span class="s1">type_callable</span><span class="s2">, </span><span class="s1">models</span><span class="s2">, </span><span class="s1">register_model</span><span class="s2">, </span><span class="s1">make_attribute_wrapper</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">print</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Print</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s3">&quot;print_item&quot;</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">,), {})</span>
            <span class="s0">if </span><span class="s1">sig </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Type %s is not printable.&quot; </span><span class="s2">% </span><span class="s1">a</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type </span><span class="s0">is </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>

<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">PrintItem</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;print_item&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">arg</span><span class="s2">, = </span><span class="s1">args</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Abs</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">int_cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)]</span>
    <span class="s1">uint_cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)]</span>
    <span class="s1">real_cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">complex_cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">.</span><span class="s1">underlying_float</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
                     <span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">int_cases </span><span class="s2">+ </span><span class="s1">uint_cases </span><span class="s2">+  </span><span class="s1">real_cases </span><span class="s2">+ </span><span class="s1">complex_cases</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Slice</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice2_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">slice3_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">),</span>
    <span class="s2">]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">range</span><span class="s2">, </span><span class="s1">typing_key</span><span class="s2">=</span><span class="s1">range</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">prange</span><span class="s2">, </span><span class="s1">typing_key</span><span class="s2">=</span><span class="s1">prange</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">internal_prange</span><span class="s2">, </span><span class="s1">typing_key</span><span class="s2">=</span><span class="s1">internal_prange</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Range</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state32_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state32_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state32_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">,</span>
                  <span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">,</span>
                  <span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_range_state64_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">,</span>
                  <span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">),</span>
    <span class="s2">]</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">GetIter</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;getiter&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">[</span><span class="s1">obj</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IterableType</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">iterator_type</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">IterNext</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;iternext&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">[</span><span class="s1">it</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">it</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IteratorType</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Pair</span><span class="s2">(</span><span class="s1">it</span><span class="s2">.</span><span class="s1">yield_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">), </span><span class="s1">it</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">PairFirst</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Given a heterogeneous pair, return the first element. 
    &quot;&quot;&quot;</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;pair_first&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">[</span><span class="s1">pair</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Pair</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">.</span><span class="s1">first_type</span><span class="s2">, </span><span class="s1">pair</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">PairSecond</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Given a heterogeneous pair, return the second element. 
    &quot;&quot;&quot;</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;pair_second&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">[</span><span class="s1">pair</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Pair</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">.</span><span class="s1">second_type</span><span class="s2">, </span><span class="s1">pair</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">choose_result_bitwidth</span><span class="s2">(*</span><span class="s1">inputs</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">max</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">.</span><span class="s1">bitwidth</span><span class="s2">, *(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">inputs</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">choose_result_int</span><span class="s2">(*</span><span class="s1">inputs</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Choose the integer result type for an operation on integer inputs, 
    according to the integer typing NBEP. 
    &quot;&quot;&quot;</span>
    <span class="s1">bitwidth </span><span class="s2">= </span><span class="s1">choose_result_bitwidth</span><span class="s2">(*</span><span class="s1">inputs</span><span class="s2">)</span>
    <span class="s1">signed </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">signed </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">inputs</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">.</span><span class="s1">from_bitwidth</span><span class="s2">(</span><span class="s1">bitwidth</span><span class="s2">, </span><span class="s1">signed</span><span class="s2">)</span>


<span class="s5"># The &quot;machine&quot; integer types to take into consideration for operator typing</span>
<span class="s5"># (according to the integer typing NBEP)</span>
<span class="s1">machine_ints </span><span class="s2">= (</span>
    <span class="s1">sorted</span><span class="s2">(</span><span class="s1">set</span><span class="s2">((</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">))) +</span>
    <span class="s1">sorted</span><span class="s2">(</span><span class="s1">set</span><span class="s2">((</span><span class="s1">types</span><span class="s2">.</span><span class="s1">uintp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)))</span>
    <span class="s2">)</span>

<span class="s5"># Explicit integer rules for binary operators; smaller ints will be</span>
<span class="s5"># automatically upcast.</span>
<span class="s1">integer_binop_cases </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
    <span class="s1">signature</span><span class="s2">(</span><span class="s1">choose_result_int</span><span class="s2">(</span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">), </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2 </span><span class="s0">in </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">product</span><span class="s2">(</span><span class="s1">machine_ints</span><span class="s2">, </span><span class="s1">machine_ints</span><span class="s2">)</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">BinOp</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">add</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpAdd</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">iadd</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpAdd</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpSub</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">isub</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpSub</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpMul</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">imul</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpMul</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">mod</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpMod</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">imod</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpMod</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">truediv</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpTrueDiv</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">)</span>
             <span class="s0">for </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2 </span><span class="s0">in </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">product</span><span class="s2">(</span><span class="s1">machine_ints</span><span class="s2">, </span><span class="s1">machine_ints</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">itruediv</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpTrueDiv</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">)</span>
             <span class="s0">for </span><span class="s1">op1</span><span class="s2">, </span><span class="s1">op2 </span><span class="s0">in </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">product</span><span class="s2">(</span><span class="s1">machine_ints</span><span class="s2">, </span><span class="s1">machine_ints</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">floordiv</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpFloorDiv</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ifloordiv</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpFloorDiv</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">divmod</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">DivMod</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">_tys </span><span class="s2">= </span><span class="s1">machine_ints </span><span class="s2">+ </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s6">2</span><span class="s2">), </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">_tys</span><span class="s2">]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">pow</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpPower</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s5"># Ensure that float32 ** int doesn't go through DP computations</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ipow</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BinOpPower</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s5"># Ensure that float32 ** int doesn't go through DP computations</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">pow</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PowerBuiltin</span><span class="s2">(</span><span class="s1">BinOpPower</span><span class="s2">):</span>
    <span class="s5"># TODO add 3 operand version</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">BitwiseShiftOperation</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s5"># For bitshifts, only the first operand's signedness matters</span>
    <span class="s5"># to choose the operation's signedness (the second operand</span>
    <span class="s5"># should always be positive but will generally be considered</span>
    <span class="s5"># signed anyway, since it's often a constant integer).</span>
    <span class="s5"># (also, see issue #1995 for right-shifts)</span>

    <span class="s5"># The RHS type is fixed to 64-bit signed/unsigned ints.</span>
    <span class="s5"># The implementation will always cast the operands to the width of the</span>
    <span class="s5"># result type, which is the widest between the LHS type and (u)intp.</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">), </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">)</span>
             <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)</span>
             <span class="s0">for </span><span class="s1">op2 </span><span class="s0">in </span><span class="s2">[</span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">]]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uintp</span><span class="s2">), </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op2</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)</span>
              <span class="s0">for </span><span class="s1">op2 </span><span class="s0">in </span><span class="s2">[</span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">]]</span>
    <span class="s1">unsafe_casting </span><span class="s2">= </span><span class="s0">False</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lshift</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseLeftShift</span><span class="s2">(</span><span class="s1">BitwiseShiftOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ilshift</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseLeftShift</span><span class="s2">(</span><span class="s1">BitwiseShiftOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">rshift</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseRightShift</span><span class="s2">(</span><span class="s1">BitwiseShiftOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">irshift</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseRightShift</span><span class="s2">(</span><span class="s1">BitwiseShiftOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">BitwiseLogicOperation</span><span class="s2">(</span><span class="s1">BinOp</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">integer_binop_cases</span><span class="s2">)</span>
    <span class="s1">unsafe_casting </span><span class="s2">= </span><span class="s0">False</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseAnd</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">iand</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseAnd</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseOr</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ior</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseOr</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">xor</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseXor</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ixor</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseXor</span><span class="s2">(</span><span class="s1">BitwiseLogicOperation</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s5"># Bitwise invert and negate are special: we must not upcast the operand</span>
<span class="s5"># for unsigned numbers, as that would change the result.</span>
<span class="s5"># (i.e. ~np.int8(0) == 255 but ~np.int32(0) == 4294967295).</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">invert</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">BitwiseInvert</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s5"># Note Numba follows the Numpy semantics of returning a bool,</span>
    <span class="s5"># while Python returns an int.  This makes it consistent with</span>
    <span class="s5"># np.invert() and makes array expressions correct.</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">choose_result_int</span><span class="s2">(</span><span class="s1">op</span><span class="s2">), </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">choose_result_int</span><span class="s2">(</span><span class="s1">op</span><span class="s2">), </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)]</span>

    <span class="s1">unsafe_casting </span><span class="s2">= </span><span class="s0">False</span>


<span class="s0">class </span><span class="s1">UnaryOp</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">choose_result_int</span><span class="s2">(</span><span class="s1">op</span><span class="s2">), </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">choose_result_int</span><span class="s2">(</span><span class="s1">op</span><span class="s2">), </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">neg</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">UnaryNegate</span><span class="s2">(</span><span class="s1">UnaryOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">UnaryPositive</span><span class="s2">(</span><span class="s1">UnaryOp</span><span class="s2">):</span>
   <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">not_</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">UnaryNot</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s0">class </span><span class="s1">OrderedCmpOp</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">signed_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">unsigned_domain</span><span class="s2">)]</span>
    <span class="s1">cases </span><span class="s2">+= [</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">)]</span>


<span class="s0">class </span><span class="s1">UnorderedCmpOp</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= </span><span class="s1">OrderedCmpOp</span><span class="s2">.</span><span class="s1">cases </span><span class="s2">+ [</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">)]</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpLt</span><span class="s2">(</span><span class="s1">OrderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpLe</span><span class="s2">(</span><span class="s1">OrderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">gt</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpGt</span><span class="s2">(</span><span class="s1">OrderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ge</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpGe</span><span class="s2">(</span><span class="s1">OrderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s5"># more specific overloads should be registered first</span>
<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ConstOpEq</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">arg2</span><span class="s2">) = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg2</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">arg2</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ConstOpNotEq</span><span class="s2">(</span><span class="s1">ConstOpEq</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpEq</span><span class="s2">(</span><span class="s1">UnorderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpNe</span><span class="s2">(</span><span class="s1">UnorderedCmpOp</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TupleCompare</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s2">[</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">):</span>
                <span class="s5"># Check element-wise comparability</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span><span class="s2">, (</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">), {})</span>
                <span class="s0">if </span><span class="s1">res </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleEq</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleNe</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ge</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleGe</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">gt</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleGt</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleLe</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleLt</span><span class="s2">(</span><span class="s1">TupleCompare</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">add</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleAdd</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">args</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">)</span>
                <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseNamedTuple</span><span class="s2">)</span>
                <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseNamedTuple</span><span class="s2">)):</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">.</span><span class="s1">from_types</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) + </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">CmpOpIdentity</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s2">[</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">is_</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpIs</span><span class="s2">(</span><span class="s1">CmpOpIdentity</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">is_not</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CmpOpIsNot</span><span class="s2">(</span><span class="s1">CmpOpIdentity</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">normalize_1d_index</span><span class="s2">(</span><span class="s1">index</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Normalize the *index* type (an integer or slice) for indexing a 1D 
    sequence. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">SliceType</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">index</span>

    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp </span><span class="s0">if </span><span class="s1">index</span><span class="s2">.</span><span class="s1">signed </span><span class="s0">else </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uintp</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">getitem</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">GetItemCPointer</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s1">ptr</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">CPointer</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">normalize_1d_index</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SetItemCPointer</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s1">ptr</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">CPointer</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">none</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">normalize_1d_index</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">), </span><span class="s1">ptr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">len</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Len</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">(</span><span class="s1">val</span><span class="s2">,) = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Buffer</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">RangeType</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleConstructor</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s5"># empty tuple case</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">(()))</span>
        <span class="s2">(</span><span class="s1">val</span><span class="s2">,) = </span><span class="s1">args</span>
        <span class="s5"># tuple as input</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">contains</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Contains</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">(</span><span class="s1">seq</span><span class="s2">, </span><span class="s1">val</span><span class="s2">) = </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">seq</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">seq</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">truth</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TupleBool</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">(</span><span class="s1">val</span><span class="s2">,) = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">StaticGetItemTuple</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;static_getitem&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">tup</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">ret </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">types</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">IndexError</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaIndexError</span><span class="s2">(</span><span class="s3">&quot;tuple index out of range&quot;</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">.</span><span class="s1">from_types</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">.</span><span class="s1">types</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">])</span>
        <span class="s0">if </span><span class="s1">ret </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">sig</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">StaticGetItemLiteralList</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;static_getitem&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">tup</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">LiteralList</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">types</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">ret </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">sig</span>


<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">StaticGetItemLiteralStrKeyDict</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;static_getitem&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">tup</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">LiteralStrKeyDict</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">:</span>
                <span class="s1">lookup </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaKeyError</span><span class="s2">(</span><span class="s3">f&quot;Key '</span><span class="s0">{</span><span class="s1">idx</span><span class="s0">}</span><span class="s3">' is not in dict.&quot;</span><span class="s2">)</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">types</span><span class="s2">[</span><span class="s1">lookup</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">ret </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">sig</span>

<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">StaticGetItemClass</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;This handles the &quot;static_getitem&quot; when a Numba type is subscripted e.g: 
    var = typed.List.empty_list(float64[::1, :]) 
    It only allows this on simple numerical types. Compound types, like 
    records, are not supported. 
    &quot;&quot;&quot;</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;static_getitem&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">clazz</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">clazz</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">clazz</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">sig</span>


<span class="s5"># Generic implementation for &quot;not in&quot;</span>

<span class="s2">@</span><span class="s1">infer</span>
<span class="s0">class </span><span class="s1">GenericNotIn</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s3">&quot;not in&quot;</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[::-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">contains</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, *</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[::-</span><span class="s6">1</span><span class="s2">])</span>


<span class="s5">#-------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">MemoryViewAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">MemoryView</span>

    <span class="s0">def </span><span class="s1">resolve_contiguous</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span>

    <span class="s0">def </span><span class="s1">resolve_c_contiguous</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span>

    <span class="s0">def </span><span class="s1">resolve_f_contiguous</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span>

    <span class="s0">def </span><span class="s1">resolve_itemsize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>

    <span class="s0">def </span><span class="s1">resolve_nbytes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>

    <span class="s0">def </span><span class="s1">resolve_readonly</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span>

    <span class="s0">def </span><span class="s1">resolve_shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">resolve_strides</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">resolve_ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>


<span class="s5">#-------------------------------------------------------------------------------</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">BooleanAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span>

    <span class="s0">def </span><span class="s1">resolve___class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">bound_function</span><span class="s2">(</span><span class="s3">&quot;number.item&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">resolve_item</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">NumberAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span>

    <span class="s0">def </span><span class="s1">resolve___class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">resolve_real</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s3">&quot;underlying_float&quot;</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">resolve_imag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s3">&quot;underlying_float&quot;</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">bound_function</span><span class="s2">(</span><span class="s3">&quot;complex.conjugate&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">resolve_conjugate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">args</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">bound_function</span><span class="s2">(</span><span class="s3">&quot;number.item&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">resolve_item</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">NPTimedeltaAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span>

    <span class="s0">def </span><span class="s1">resolve___class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">NPDatetimeAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span>

    <span class="s0">def </span><span class="s1">resolve___class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">SliceAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">SliceType</span>

    <span class="s0">def </span><span class="s1">resolve_start</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>

    <span class="s0">def </span><span class="s1">resolve_stop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>

    <span class="s0">def </span><span class="s1">resolve_step</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span>

    <span class="s2">@</span><span class="s1">bound_function</span><span class="s2">(</span><span class="s3">&quot;slice.indices&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">resolve_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span>
                <span class="s3">&quot;indices() takes exactly one argument (%d given)&quot; </span><span class="s2">% </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s1">typ</span><span class="s2">, = </span><span class="s1">args</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span>
                <span class="s3">&quot;'%s' object cannot be interpreted as an integer&quot; </span><span class="s2">% </span><span class="s1">typ</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s6">3</span><span class="s2">), </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>


<span class="s5">#-------------------------------------------------------------------------------</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">NumberClassAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span>

    <span class="s0">def </span><span class="s1">resolve___call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">classty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Resolve a NumPy number class's constructor (e.g. calling numpy.int32(...)) 
        &quot;&quot;&quot;</span>
        <span class="s1">ty </span><span class="s2">= </span><span class="s1">classty</span><span class="s2">.</span><span class="s1">instance_type</span>

        <span class="s0">def </span><span class="s1">typer</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">)):</span>
                <span class="s5"># Array constructor, e.g. np.int32([1, 2])</span>
                <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_value_type</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">)</span>
                <span class="s1">sig </span><span class="s2">= </span><span class="s1">fnty</span><span class="s2">.</span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">, (</span><span class="s1">val</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">DType</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)),</span>
                                         <span class="s2">{})</span>
                <span class="s0">return </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IntEnumMember</span><span class="s2">)):</span>
                 <span class="s5"># Scalar constructor, e.g. np.int32(42)</span>
                 <span class="s0">return </span><span class="s1">ty</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">)):</span>
                <span class="s5"># Constructor cast from datetime-like, e.g.</span>
                <span class="s5"># &gt; np.int64(np.datetime64(&quot;2000-01-01&quot;))</span>
                <span class="s0">if </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">== </span><span class="s6">64</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">ty</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= (</span><span class="s3">f&quot;Cannot cast </span><span class="s0">{</span><span class="s1">val</span><span class="s0">} </span><span class="s3">to </span><span class="s0">{</span><span class="s1">ty</span><span class="s0">} </span><span class="s3">as </span><span class="s0">{</span><span class="s1">ty</span><span class="s0">} </span><span class="s3">is not 64 bits &quot;</span>
                           <span class="s3">&quot;wide.&quot;</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">) </span><span class="s0">and </span><span class="s1">val</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">0 </span><span class="s0">and</span>
                    <span class="s1">val</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">ty</span><span class="s2">):</span>
                    <span class="s5"># This is 0d array -&gt; scalar degrading</span>
                    <span class="s0">return </span><span class="s1">ty</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s5"># unsupported</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s3">f&quot;Casting </span><span class="s0">{</span><span class="s1">val</span><span class="s0">} </span><span class="s3">to </span><span class="s0">{</span><span class="s1">ty</span><span class="s0">} </span><span class="s3">directly is unsupported.&quot;</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
                        <span class="s5"># array casts are supported a different way.</span>
                        <span class="s1">msg </span><span class="s2">+= </span><span class="s3">f&quot; Try doing '&lt;array&gt;.astype(np.</span><span class="s0">{</span><span class="s1">ty</span><span class="s0">}</span><span class="s3">)' instead&quot;</span>
                    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">make_callable_template</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">typer</span><span class="s2">=</span><span class="s1">typer</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">TypeRefAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">TypeRef</span>

    <span class="s0">def </span><span class="s1">resolve___call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">classty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Resolve a core number's constructor (e.g. calling int(...)) 
 
        Note: 
 
        This is needed because of the limitation of the current type-system 
        implementation.  Specifically, the lack of a higher-order type 
        (i.e. passing the ``DictType`` vs ``DictType(key_type, value_type)``) 
        &quot;&quot;&quot;</span>
        <span class="s1">ty </span><span class="s2">= </span><span class="s1">classty</span><span class="s2">.</span><span class="s1">instance_type</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">):</span>
            <span class="s5"># Redirect the typing to a:</span>
            <span class="s5">#   @type_callable(ty)</span>
            <span class="s5">#   def typeddict_call(context):</span>
            <span class="s5">#        ...</span>
            <span class="s5"># For example, see numba/typed/typeddict.py</span>
            <span class="s5">#   @type_callable(DictType)</span>
            <span class="s5">#   def typeddict_call(context):</span>
            <span class="s0">class </span><span class="s1">Redirect</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>

                <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">context </span><span class="s2">=  </span><span class="s1">context</span>

                <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s3">&quot;pysig&quot;</span><span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">pysig </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">pysig</span>
                    <span class="s0">return </span><span class="s1">result</span>

            <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">make_callable_template</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">,</span>
                                                         <span class="s1">typer</span><span class="s2">=</span><span class="s1">Redirect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">)))</span>


<span class="s5">#------------------------------------------------------------------------------</span>


<span class="s0">class </span><span class="s1">MinMaxBase</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">_unify_minmax</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tys</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">tys</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">)):</span>
                <span class="s0">return</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">unify_types</span><span class="s2">(*</span><span class="s1">tys</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Resolve a min() or max() call. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert not </span><span class="s1">kws</span>

        <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s5"># max(arg) only supported if arg is an iterable</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
                <span class="s1">tys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
                <span class="s0">if not </span><span class="s1">tys</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;%s() argument is an empty tuple&quot;</span>
                                    <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># max(*args)</span>
            <span class="s1">tys </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">retty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_unify_minmax</span><span class="s2">(</span><span class="s1">tys</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">retty </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">retty</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">max</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Max</span><span class="s2">(</span><span class="s1">MinMaxBase</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">min</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Min</span><span class="s2">(</span><span class="s1">MinMaxBase</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">round</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Round</span><span class="s2">(</span><span class="s1">ConcreteTemplate</span><span class="s2">):</span>
    <span class="s1">cases </span><span class="s2">= [</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
    <span class="s2">]</span>


<span class="s5">#------------------------------------------------------------------------------</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Bool</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s2">[</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s5"># XXX typing for bool cannot be polymorphic because of the</span>
        <span class="s5"># types.Function thing, so we redirect to the operator.truth</span>
        <span class="s5"># intrinsic.</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">truth</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">int</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Int</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">kws</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaAssertionError</span><span class="s2">(</span><span class="s3">'kws not supported'</span><span class="s2">)</span>

        <span class="s2">[</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Float</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s3">'ns'</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">f&quot;Only datetime64[ns] can be converted, but got datetime64[</span><span class="s0">{</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">unit</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Float</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>

        <span class="s2">[</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UnicodeType</span><span class="s2">):</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">'argument must be a string literal'</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">RequireLiteralValue</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">StringLiteral</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">arg </span><span class="s0">not in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">number_domain</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">&quot;float() only support for numbers&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex_domain</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">&quot;float() does not support complex&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">integer_domain</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">real_domain</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">complex</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Complex</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s2">[</span><span class="s1">arg</span><span class="s2">] = </span><span class="s1">args</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">not in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">number_domain</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">&quot;complex() only support for numbers&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s2">[</span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">] = </span><span class="s1">args</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">real </span><span class="s0">not in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">number_domain </span><span class="s0">or</span>
                <span class="s1">imag </span><span class="s0">not in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">number_domain</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">&quot;complex() only support for numbers&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">real </span><span class="s2">== </span><span class="s1">imag </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">)</span>


<span class="s5">#------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">enumerate</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Enumerate</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s1">it </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) &gt; </span><span class="s6">1 </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s3">&quot;Only integers supported as start &quot;</span>
                                        <span class="s3">&quot;value in enumerate&quot;</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) &gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s5">#let python raise its own error</span>
            <span class="s1">enumerate</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">it</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IterableType</span><span class="s2">):</span>
            <span class="s1">enumerate_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">EnumerateType</span><span class="s2">(</span><span class="s1">it</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">enumerate_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Zip</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">it</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IterableType</span><span class="s2">) </span><span class="s0">for </span><span class="s1">it </span><span class="s0">in </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s1">zip_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ZipType</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">zip_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Iter</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">it </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">it</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IterableType</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">it</span><span class="s2">.</span><span class="s1">iterator_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">next</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Next</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">it </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">it</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IteratorType</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">it</span><span class="s2">.</span><span class="s1">yield_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s5">#------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">type</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TypeBuiltin</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s5"># One-argument type() -&gt; return the __class__</span>
            <span class="s5"># Avoid literal types</span>
            <span class="s1">arg </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">unliteral</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s1">classty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_getattr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s3">&quot;__class__&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">classty </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">classty</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s5">#------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">OptionalAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Optional</span>

    <span class="s0">def </span><span class="s1">generic_resolve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">optional</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_getattr</span><span class="s2">(</span><span class="s1">optional</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>

<span class="s5">#------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_getattr</span>
<span class="s0">class </span><span class="s1">DeferredAttribute</span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">):</span>
    <span class="s1">key </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">DeferredType</span>

    <span class="s0">def </span><span class="s1">generic_resolve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deferred</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_getattr</span><span class="s2">(</span><span class="s1">deferred</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(), </span><span class="s1">attr</span><span class="s2">)</span>

<span class="s5">#------------------------------------------------------------------------------</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">get_type_min_value</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">get_type_max_value</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MinValInfer</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">DType</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s5">#------------------------------------------------------------------------------</span>


<span class="s0">class </span><span class="s1">IndexValue</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Index and value 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">ind</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s3">'IndexValue(%f, %f)' </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">IndexValueType</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val_typ</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">val_typ </span><span class="s2">= </span><span class="s1">val_typ</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">IndexValueType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span>
                                    <span class="s1">name</span><span class="s2">=</span><span class="s3">'IndexValueType({})'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">val_typ</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">typeof_impl</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">IndexValue</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">typeof_index</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">c</span><span class="s2">):</span>
    <span class="s1">val_typ </span><span class="s2">= </span><span class="s1">typeof_impl</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">c</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">IndexValueType</span><span class="s2">(</span><span class="s1">val_typ</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">type_callable</span><span class="s2">(</span><span class="s1">IndexValue</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">type_index_value</span><span class="s2">(</span><span class="s1">context</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">typer</span><span class="s2">(</span><span class="s1">ind</span><span class="s2">, </span><span class="s1">mval</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">ind </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp </span><span class="s0">or </span><span class="s1">ind </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uintp</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">IndexValueType</span><span class="s2">(</span><span class="s1">mval</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">typer</span>


<span class="s2">@</span><span class="s1">register_model</span><span class="s2">(</span><span class="s1">IndexValueType</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">IndexValueModel</span><span class="s2">(</span><span class="s1">models</span><span class="s2">.</span><span class="s1">StructModel</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dmm</span><span class="s2">, </span><span class="s1">fe_type</span><span class="s2">):</span>
        <span class="s1">members </span><span class="s2">= [</span>
            <span class="s2">(</span><span class="s3">'index'</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'value'</span><span class="s2">, </span><span class="s1">fe_type</span><span class="s2">.</span><span class="s1">val_typ</span><span class="s2">),</span>
            <span class="s2">]</span>
        <span class="s1">models</span><span class="s2">.</span><span class="s1">StructModel</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dmm</span><span class="s2">, </span><span class="s1">fe_type</span><span class="s2">, </span><span class="s1">members</span><span class="s2">)</span>


<span class="s1">make_attribute_wrapper</span><span class="s2">(</span><span class="s1">IndexValueType</span><span class="s2">, </span><span class="s3">'index'</span><span class="s2">, </span><span class="s3">'index'</span><span class="s2">)</span>
<span class="s1">make_attribute_wrapper</span><span class="s2">(</span><span class="s1">IndexValueType</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">)</span>
</pre>
</body>
</html>