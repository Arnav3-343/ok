<html>
<head>
<title>views.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
views.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
RecycleView Views 
================= 
 
.. versionadded:: 1.10.0 
 
The adapter part of the RecycleView which together with the layout is the 
view part of the model-view-controller pattern. 
 
The view module handles converting the data to a view using the adapter class 
which is then displayed by the layout. A view can be any Widget based class. 
However, inheriting from RecycleDataViewBehavior adds methods for converting 
the data to a view. 
 
TODO: 
    * Make view caches specific to each view class type. 
 
'''</span>

<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">properties </span><span class="s2">import </span><span class="s1">ObjectProperty</span>
<span class="s2">from </span><span class="s1">kivy</span><span class="s3">.</span><span class="s1">event </span><span class="s2">import </span><span class="s1">EventDispatcher</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>

<span class="s1">__all__ </span><span class="s3">= (</span>
    <span class="s4">'RecycleDataViewBehavior'</span><span class="s3">, </span><span class="s4">'RecycleKVIDsDataViewBehavior'</span><span class="s3">,</span>
    <span class="s4">'RecycleDataAdapter'</span><span class="s3">)</span>

<span class="s1">_view_base_cache </span><span class="s3">= {}</span>
<span class="s4">'''Cache whose keys are classes and values is a boolean indicating whether the 
class inherits from :class:`RecycleDataViewBehavior`. 
'''</span>

<span class="s1">_cached_views </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>
<span class="s4">'''A size limited cache that contains old views (instances) that are not used. 
Each key is a class whose value is the list of the instances of that class. 
'''</span>
<span class="s5"># current number of unused classes in the class cache</span>
<span class="s1">_cache_count </span><span class="s3">= </span><span class="s6">0</span>
<span class="s5"># maximum number of items in the class cache</span>
<span class="s1">_max_cache_size </span><span class="s3">= </span><span class="s6">1000</span>


<span class="s2">def </span><span class="s1">_clean_cache</span><span class="s3">():</span>
    <span class="s0">'''Trims _cached_views cache to half the size of `_max_cache_size`. 
    '''</span>
    <span class="s5"># all keys will be reduced to max_size.</span>
    <span class="s1">max_size </span><span class="s3">= (</span><span class="s1">_max_cache_size </span><span class="s3">// </span><span class="s6">2</span><span class="s3">) // </span><span class="s1">len</span><span class="s3">(</span><span class="s1">_cached_views</span><span class="s3">)</span>
    <span class="s2">global </span><span class="s1">_cache_count</span>
    <span class="s2">for </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">instances </span><span class="s2">in </span><span class="s1">_cached_views</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">_cache_count </span><span class="s3">-= </span><span class="s1">max</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">instances</span><span class="s3">) - </span><span class="s1">max_size</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">instances</span><span class="s3">[</span><span class="s1">max_size</span><span class="s3">:]</span>


<span class="s2">class </span><span class="s1">RecycleDataViewBehavior</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">'''A optional base class for data views (:attr:`RecycleView`.viewclass). 
    If a view inherits from this class, the class's functions will be called 
    when the view needs to be updated due to a data change or layout update. 
    '''</span>

    <span class="s2">def </span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s0">'''Called by the :class:`RecycleAdapter` when the view is initially 
        populated with the values from the `data` dictionary for this item. 
 
        Any pos or size info should be removed because they are set 
        subsequently with :attr:`refresh_view_layout`. 
 
        :Parameters: 
 
            `rv`: :class:`RecycleView` instance 
                The :class:`RecycleView` that caused the update. 
            `data`: dict 
                The data dict used to populate this view. 
        '''</span>
        <span class="s1">sizing_attrs </span><span class="s3">= </span><span class="s1">RecycleDataAdapter</span><span class="s3">.</span><span class="s1">_sizing_attrs</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">data</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">sizing_attrs</span><span class="s3">:</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">refresh_view_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">viewport</span><span class="s3">):</span>
        <span class="s0">'''Called when the view's size is updated by the layout manager, 
        :class:`RecycleLayoutManagerBehavior`. 
 
        :Parameters: 
 
            `rv`: :class:`RecycleView` instance 
                The :class:`RecycleView` that caused the update. 
            `viewport`: 4-tuple 
                The coordinates of the bottom left and width height in layout 
                manager coordinates. This may be larger than this view item. 
 
        :raises: 
            `LayoutChangeException`: If the sizing or data changed during a 
            call to this method, raising a `LayoutChangeException` exception 
            will force a refresh. Useful when data changed and we don't want 
            to layout further since it'll be overwritten again soon. 
        '''</span>
        <span class="s1">w</span><span class="s3">, </span><span class="s1">h </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">w </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">h </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">height </span><span class="s3">= </span><span class="s1">h</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">h </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">width </span><span class="s3">= </span><span class="s1">w</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>

        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">layout</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">apply_selection</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">is_selected</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">RecycleKVIDsDataViewBehavior</span><span class="s3">(</span><span class="s1">RecycleDataViewBehavior</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Similar to :class:`RecycleDataViewBehavior`, except that the data keys 
    can signify properties of an object named with an id in the root KV rule. 
 
    E.g. given a KV rule:: 
 
        &lt;MyRule@RecycleKVIDsDataViewBehavior+BoxLayout&gt;: 
            Label: 
                id: name 
            Label: 
                id: value 
 
    Then setting the data list with 
    ``rv.data = [{'name.text': 'Kivy user', 'value.text': '12'}]`` would 
    automatically set the corresponding labels. 
 
    So, if the key doesn't have a period, the named property of the root widget 
    will be set to the corresponding value. If there is a period, the named 
    property of the widget with the id listed before the period will be set to 
    the corresponding value. 
 
    .. versionadded:: 2.0.0 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">sizing_attrs </span><span class="s3">= </span><span class="s1">RecycleDataAdapter</span><span class="s3">.</span><span class="s1">_sizing_attrs</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">data</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">sizing_attrs</span><span class="s3">:</span>
                <span class="s1">name</span><span class="s3">, *</span><span class="s1">ids </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">ids</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ids</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                            <span class="s4">f'Data key &quot;</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">&quot; has more than one period'</span><span class="s3">)</span>
                    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ids</span><span class="s3">[</span><span class="s1">name</span><span class="s3">], </span><span class="s1">ids</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">value</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">RecycleDataAdapter</span><span class="s3">(</span><span class="s1">EventDispatcher</span><span class="s3">):</span>
    <span class="s0">'''The class that converts data to a view. 
 
    --- Internal details --- 
    A view can have 3 states. 
 
        * It can be completely in sync with the data, which 
          occurs when the view is displayed. These are stored in :attr:`views`. 
        * It can be dirty, which occurs when the view is in sync with the data, 
          except for the size/pos parameters which is controlled by the layout. 
          This occurs when the view is not currently displayed but the data has 
          not changed. These views are stored in :attr:`dirty_views`. 
        * Finally the view can be dead which occurs when the data changes and 
          the view was not updated or when a view is just created. Such views 
          are typically added to the internal cache. 
 
    Typically what happens is that the layout manager lays out the data 
    and then asks for views, using :meth:`set_visible_views`, for some specific 
    data items that it displays. 
 
    These views are gotten from the current views, dirty or global cache. Then 
    depending on the view state :meth:`refresh_view_attrs` is called to bring 
    the view up to date with the data (except for sizing parameters). Finally, 
    the layout manager gets these views, updates their size and displays them. 
    '''</span>

    <span class="s1">recycleview </span><span class="s3">= </span><span class="s1">ObjectProperty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">allownone</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s4">'''The :class:`~kivy.uix.recycleview.RecycleViewBehavior` associated 
    with this instance. 
    '''</span>

    <span class="s5"># internals</span>
    <span class="s1">views </span><span class="s3">= {}  </span><span class="s5"># current displayed items</span>
    <span class="s5"># items whose attrs, except for pos/size is still accurate</span>
    <span class="s1">dirty_views </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">)</span>

    <span class="s1">_sizing_attrs </span><span class="s3">= {</span>
        <span class="s4">'size'</span><span class="s3">, </span><span class="s4">'width'</span><span class="s3">, </span><span class="s4">'height'</span><span class="s3">, </span><span class="s4">'size_hint'</span><span class="s3">, </span><span class="s4">'size_hint_x'</span><span class="s3">, </span><span class="s4">'size_hint_y'</span><span class="s3">,</span>
        <span class="s4">'pos'</span><span class="s3">, </span><span class="s4">'x'</span><span class="s3">, </span><span class="s4">'y'</span><span class="s3">, </span><span class="s4">'center'</span><span class="s3">, </span><span class="s4">'center_x'</span><span class="s3">, </span><span class="s4">'center_y'</span><span class="s3">, </span><span class="s4">'pos_hint'</span><span class="s3">,</span>
        <span class="s4">'size_hint_min'</span><span class="s3">, </span><span class="s4">'size_hint_min_x'</span><span class="s3">, </span><span class="s4">'size_hint_min_y'</span><span class="s3">, </span><span class="s4">'size_hint_max'</span><span class="s3">,</span>
        <span class="s4">'size_hint_max_x'</span><span class="s3">, </span><span class="s4">'size_hint_max_y'</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fix for issue https://github.com/kivy/kivy/issues/5913: 
        Scrolling RV A, then Scrolling RV B, content of A and B seemed 
        to be getting mixed up 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">views </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">RecycleDataAdapter</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">attach_recycleview</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">):</span>
        <span class="s0">'''Associates a :class:`~kivy.uix.recycleview.RecycleViewBehavior` 
        with this instance. It is stored in :attr:`recycleview`. 
        '''</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">recycleview </span><span class="s3">= </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">detach_recycleview</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">'''Removes the :class:`~kivy.uix.recycleview.RecycleViewBehavior` 
        associated with this instance and clears :attr:`recycleview`. 
        '''</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">recycleview </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">create_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">viewclass</span><span class="s3">):</span>
        <span class="s0">'''(internal) Creates and initializes the view for the data at `index`. 
 
        The returned view is synced with the data, except for the pos/size 
        information. 
        '''</span>
        <span class="s2">if </span><span class="s1">viewclass </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">view </span><span class="s3">= </span><span class="s1">viewclass</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">view</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">view</span>

    <span class="s2">def </span><span class="s1">get_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">viewclass</span><span class="s3">):</span>
        <span class="s0">'''(internal) Returns a view instance for the data at `index` 
 
        It looks through the various caches and finally creates a view if it 
        doesn't exist. The returned view is synced with the data, except for 
        the pos/size information. 
 
        If found in the cache it's removed from the source 
        before returning. It doesn't check the current views. 
        '''</span>
        <span class="s5"># is it in the dirtied views?</span>
        <span class="s1">dirty_views </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views</span>
        <span class="s2">if </span><span class="s1">viewclass </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">stale </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">view </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">viewclass </span><span class="s2">in </span><span class="s1">dirty_views</span><span class="s3">:  </span><span class="s5"># get it first from dirty list</span>
            <span class="s1">dirty_class </span><span class="s3">= </span><span class="s1">dirty_views</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">index </span><span class="s2">in </span><span class="s1">dirty_class</span><span class="s3">:</span>
                <span class="s5"># we found ourself in the dirty list, no need to update data!</span>
                <span class="s1">view </span><span class="s3">= </span><span class="s1">dirty_class</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">]:</span>
                <span class="s5"># global cache has this class, update data</span>
                <span class="s1">view</span><span class="s3">, </span><span class="s1">stale </span><span class="s3">= </span><span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">].</span><span class="s1">pop</span><span class="s3">(), </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">dirty_class</span><span class="s3">:</span>
                <span class="s5"># random any dirty view element - update data</span>
                <span class="s1">view</span><span class="s3">, </span><span class="s1">stale </span><span class="s3">= </span><span class="s1">dirty_class</span><span class="s3">.</span><span class="s1">popitem</span><span class="s3">()[</span><span class="s6">1</span><span class="s3">], </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">]:  </span><span class="s5"># otherwise go directly to cache</span>
            <span class="s5"># global cache has this class, update data</span>
            <span class="s1">view</span><span class="s3">, </span><span class="s1">stale </span><span class="s3">= </span><span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">].</span><span class="s1">pop</span><span class="s3">(), </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">view </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">view </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">create_view</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">viewclass</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">view </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">stale</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">view</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">view</span>

    <span class="s2">def </span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">, </span><span class="s1">view</span><span class="s3">):</span>
        <span class="s0">'''(internal) Syncs the view and brings it up to date with the data. 
 
        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs` 
        if the view inherits from :class:`RecycleDataViewBehavior`. See that 
        method for more details. 
 
        .. note:: 
            Any sizing and position info is skipped when syncing with the data. 
        '''</span>
        <span class="s1">viewclass </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span>
        <span class="s2">if </span><span class="s1">viewclass </span><span class="s2">not in </span><span class="s1">_view_base_cache</span><span class="s3">:</span>
            <span class="s1">_view_base_cache</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">] = </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">view</span><span class="s3">,</span>
                                                     <span class="s1">RecycleDataViewBehavior</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">_view_base_cache</span><span class="s3">[</span><span class="s1">viewclass</span><span class="s3">]:</span>
            <span class="s1">view</span><span class="s3">.</span><span class="s1">refresh_view_attrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">recycleview</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">data_item</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">sizing_attrs </span><span class="s3">= </span><span class="s1">RecycleDataAdapter</span><span class="s3">.</span><span class="s1">_sizing_attrs</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">data_item</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">sizing_attrs</span><span class="s3">:</span>
                    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">view</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">refresh_view_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">view</span><span class="s3">, </span><span class="s1">viewport</span><span class="s3">):</span>
        <span class="s0">'''Updates the sizing information of the view. 
 
        viewport is in coordinates of the layout manager. 
 
        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs` 
        if the view inherits from :class:`RecycleDataViewBehavior`. See that 
        method for more details. 
 
        .. note:: 
            Any sizing and position info is skipped when syncing with the data. 
        '''</span>
        <span class="s2">if </span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">not in </span><span class="s1">_view_base_cache</span><span class="s3">:</span>
            <span class="s1">_view_base_cache</span><span class="s3">[</span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">] = </span><span class="s1">isinstance</span><span class="s3">(</span>
                <span class="s1">view</span><span class="s3">, </span><span class="s1">RecycleDataViewBehavior</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">_view_base_cache</span><span class="s3">[</span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">]:</span>
            <span class="s1">view</span><span class="s3">.</span><span class="s1">refresh_view_layout</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">recycleview</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">viewport</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">w</span><span class="s3">, </span><span class="s1">h </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">w </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">h </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">view</span><span class="s3">.</span><span class="s1">height </span><span class="s3">= </span><span class="s1">h</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">h </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">view</span><span class="s3">.</span><span class="s1">width </span><span class="s3">= </span><span class="s1">w</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">view</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>

            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">layout</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">view</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">make_view_dirty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">view</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s0">'''(internal) Used to flag this view as dirty, ready to be used for 
        others. See :meth:`make_views_dirty`. 
        '''</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">views</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views</span><span class="s3">[</span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">][</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">view</span>

    <span class="s2">def </span><span class="s1">make_views_dirty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">'''Makes all the current views dirty. 
 
        Dirty views are still in sync with the corresponding data. However, the 
        size information may go out of sync. Therefore a dirty view can be 
        reused by the same index by just updating the sizing information. 
 
        Once the underlying data of this index changes, the view should be 
        removed from the dirty views and moved to the global cache with 
        :meth:`invalidate`. 
 
        This is typically called when the layout manager needs to re-layout all 
        the data. 
        '''</span>
        <span class="s1">views </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">views</span>
        <span class="s2">if not </span><span class="s1">views</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">dirty_views </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views</span>
        <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">view </span><span class="s2">in </span><span class="s1">views</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">dirty_views</span><span class="s3">[</span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">][</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">view</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">views </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">invalidate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">'''Moves all the current views into the global cache. 
 
        As opposed to making a view dirty where the view is in sync with the 
        data except for sizing information, this will completely disconnect the 
        view from the data, as it is assumed the data has gone out of sync with 
        the view. 
 
        This is typically called when the data changes. 
        '''</span>
        <span class="s2">global </span><span class="s1">_cache_count</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">views</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">view</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">view</span><span class="s3">)</span>
            <span class="s1">_cache_count </span><span class="s3">+= </span><span class="s6">1</span>

        <span class="s2">for </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">views </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">_cached_views</span><span class="s3">[</span><span class="s1">cls</span><span class="s3">].</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">views</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
            <span class="s1">_cache_count </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">views</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">_cache_count </span><span class="s3">&gt;= </span><span class="s1">_max_cache_size</span><span class="s3">:</span>
            <span class="s1">_clean_cache</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">views </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dirty_views</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">set_visible_views</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">viewclasses</span><span class="s3">):</span>
        <span class="s0">'''Gets a 3-tuple of the new, remaining, and old views for the current 
        viewport. 
 
        The new views are synced to the data except for the size/pos 
        properties. 
        The old views need to be removed from the layout, and the new views 
        added. 
 
        The new views are not necessarily *new*, but are all the currently 
        visible views. 
        '''</span>
        <span class="s1">visible_views </span><span class="s3">= {}</span>
        <span class="s1">previous_views </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">views</span>
        <span class="s1">ret_new </span><span class="s3">= []</span>
        <span class="s1">ret_remain </span><span class="s3">= []</span>
        <span class="s1">get_view </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_view</span>

        <span class="s5"># iterate though the visible view</span>
        <span class="s5"># add them into the container if not already done</span>
        <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s1">view </span><span class="s3">= </span><span class="s1">previous_views</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">view </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s5"># was current view</span>
                <span class="s1">visible_views</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">view</span>
                <span class="s1">ret_remain</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">index</span><span class="s3">, </span><span class="s1">view</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">view </span><span class="s3">= </span><span class="s1">get_view</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">index</span><span class="s3">],</span>
                                <span class="s1">viewclasses</span><span class="s3">[</span><span class="s1">index</span><span class="s3">][</span><span class="s4">'viewclass'</span><span class="s3">])</span>
                <span class="s2">if </span><span class="s1">view </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">visible_views</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">view</span>
                <span class="s1">ret_new</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">index</span><span class="s3">, </span><span class="s1">view</span><span class="s3">))</span>

        <span class="s1">old_views </span><span class="s3">= </span><span class="s1">previous_views</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">make_views_dirty</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">views </span><span class="s3">= </span><span class="s1">visible_views</span>
        <span class="s2">return </span><span class="s1">ret_new</span><span class="s3">, </span><span class="s1">ret_remain</span><span class="s3">, </span><span class="s1">old_views</span>

    <span class="s2">def </span><span class="s1">get_visible_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s0">'''Returns the currently visible view associated with ``index``. 
 
        If no view is currently displayed for ``index`` it returns ``None``. 
        '''</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">views</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
</pre>
</body>
</html>