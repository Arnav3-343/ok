<html>
<head>
<title>ir_utils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ir_utils.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Copyright (c) 2017 Intel Corporation</span>
<span class="s0"># SPDX-License-Identifier: BSD-2-Clause</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">numpy</span>
<span class="s2">import </span><span class="s1">math</span>

<span class="s2">import </span><span class="s1">types </span><span class="s2">as </span><span class="s1">pytypes</span>
<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numba</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">_Intrinsic</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">, </span><span class="s1">analysis</span><span class="s3">, </span><span class="s1">postproc</span><span class="s3">, </span><span class="s1">rewrites</span><span class="s3">, </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">templates </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">analysis </span><span class="s2">import </span><span class="s3">(</span><span class="s1">compute_live_map</span><span class="s3">, </span><span class="s1">compute_use_defs</span><span class="s3">,</span>
                            <span class="s1">compute_cfg_from_blocks</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s3">(</span><span class="s1">TypingError</span><span class="s3">, </span><span class="s1">UnsupportedError</span><span class="s3">,</span>
                               <span class="s1">NumbaPendingDeprecationWarning</span><span class="s3">,</span>
                               <span class="s1">CompilerError</span><span class="s3">)</span>

<span class="s2">import </span><span class="s1">copy</span>

<span class="s1">_unique_var_count </span><span class="s3">= </span><span class="s4">0</span>


<span class="s2">def </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">):</span>
    <span class="s2">global </span><span class="s1">_unique_var_count</span>
    <span class="s1">var </span><span class="s3">= </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s5">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">_unique_var_count</span><span class="s3">)</span>
    <span class="s1">_unique_var_count </span><span class="s3">= </span><span class="s1">_unique_var_count </span><span class="s3">+ </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">var</span>


<span class="s2">class </span><span class="s1">_MaxLabel</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">= </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">next</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">+= </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span>

    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">newval</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">newval</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">)</span>


<span class="s1">_the_max_label </span><span class="s3">= </span><span class="s1">_MaxLabel</span><span class="s3">()</span>
<span class="s2">del </span><span class="s1">_MaxLabel</span>


<span class="s2">def </span><span class="s1">get_unused_var_name</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">var_table</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Get a new var name with a given prefix and 
        make sure it is unused in the given variable table. 
    &quot;&quot;&quot;</span>
    <span class="s1">cur </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">cur</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">var </span><span class="s2">not in </span><span class="s1">var_table</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">var</span>
        <span class="s1">cur </span><span class="s3">+= </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">next_label</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">next</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">mk_alloc</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">,</span>
             <span class="s1">lhs_typ</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;generate an array allocation with np.empty() and return list of nodes. 
    size_var can be an int variable or tuple of int variables. 
    lhs_typ is the type of the array being allocated. 
    &quot;&quot;&quot;</span>
    <span class="s1">out </span><span class="s3">= []</span>
    <span class="s1">ndims </span><span class="s3">= </span><span class="s4">1</span>
    <span class="s1">size_typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s1">size_var </span><span class="s3">= </span><span class="s1">size_var</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">size_var </span><span class="s3">= </span><span class="s1">convert_size_to_var</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># tuple_var = build_tuple([size_var...])</span>
            <span class="s1">ndims </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">)</span>
            <span class="s1">tuple_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$tuple_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
                <span class="s1">typemap</span><span class="s3">[</span><span class="s1">tuple_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ndims</span><span class="s3">)</span>
            <span class="s0"># constant sizes need to be assigned to vars</span>
            <span class="s1">new_sizes </span><span class="s3">= [</span><span class="s1">convert_size_to_var</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
                         <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">size_var</span><span class="s3">]</span>
            <span class="s1">tuple_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">build_tuple</span><span class="s3">(</span><span class="s1">new_sizes</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">tuple_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">tuple_call</span><span class="s3">, </span><span class="s1">tuple_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tuple_assign</span><span class="s3">)</span>
            <span class="s1">size_var </span><span class="s3">= </span><span class="s1">tuple_var</span>
            <span class="s1">size_typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ndims</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lhs_typ</span><span class="s3">, </span><span class="s5">&quot;__allocate__&quot;</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">__allocate__</span><span class="s3">(</span>
            <span class="s1">typingctx</span><span class="s3">,</span>
            <span class="s1">typemap</span><span class="s3">,</span>
            <span class="s1">calltypes</span><span class="s3">,</span>
            <span class="s1">lhs</span><span class="s3">,</span>
            <span class="s1">size_var</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">,</span>
            <span class="s1">scope</span><span class="s3">,</span>
            <span class="s1">loc</span><span class="s3">,</span>
            <span class="s1">lhs_typ</span><span class="s3">,</span>
            <span class="s1">size_typ</span><span class="s3">,</span>
            <span class="s1">out</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s0"># g_np_var = Global(numpy)</span>
    <span class="s1">g_np_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$np_g_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_np_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">)</span>
    <span class="s1">g_np </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s5">'np'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">g_np_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">g_np</span><span class="s3">, </span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># attr call: empty_attr = getattr(g_np_var, empty)</span>
    <span class="s1">empty_attr_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s5">&quot;empty&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">attr_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$empty_attr_attr&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">attr_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">)</span>
    <span class="s1">attr_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">empty_attr_call</span><span class="s3">, </span><span class="s1">attr_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
     <span class="s0"># Assume str(dtype) returns a valid type</span>
    <span class="s1">dtype_str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s0"># alloc call: lhs = empty_attr(size_var, typ_var)</span>
    <span class="s1">typ_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$np_typ_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">typ_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">functions</span><span class="s3">.</span><span class="s1">NumberClass</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s0"># If dtype is a datetime/timedelta with a unit,</span>
    <span class="s0"># then it won't return a valid type and instead can be created</span>
    <span class="s0"># with a string. i.e. &quot;datetime64[ns]&quot;)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)) </span><span class="s2">and</span>
        <span class="s1">dtype</span><span class="s3">.</span><span class="s1">unit </span><span class="s3">!= </span><span class="s5">''</span><span class="s3">):</span>
            <span class="s1">typename_const </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">dtype_str</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">typ_var_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">typename_const</span><span class="s3">, </span><span class="s1">typ_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">dtype_str</span><span class="s3">==</span><span class="s5">'bool'</span><span class="s3">:</span>
            <span class="s0"># empty doesn't like 'bool' sometimes (e.g. kmeans example)</span>
            <span class="s1">dtype_str </span><span class="s3">= </span><span class="s5">'bool_'</span>
        <span class="s1">np_typ_getattr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">dtype_str</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">typ_var_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">np_typ_getattr</span><span class="s3">, </span><span class="s1">typ_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">alloc_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">attr_var</span><span class="s3">, [</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">typ_var</span><span class="s3">], (), </span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">calltypes</span><span class="s3">:</span>
        <span class="s1">cac </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">attr_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get_call_type</span><span class="s3">(</span>
            <span class="s1">typingctx</span><span class="s3">, [</span><span class="s1">size_typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">functions</span><span class="s3">.</span><span class="s1">NumberClass</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)], {})</span>
        <span class="s0"># By default, all calls to &quot;empty&quot; are typed as returning a standard</span>
        <span class="s0"># NumPy ndarray.  If we are allocating a ndarray subclass here then</span>
        <span class="s0"># just change the return type to be that of the subclass.</span>
        <span class="s1">cac</span><span class="s3">.</span><span class="s1">_return_type </span><span class="s3">= (</span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s5">'C'</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s5">'F'</span>
                            <span class="s2">else </span><span class="s1">lhs_typ</span><span class="s3">)</span>
        <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">alloc_call</span><span class="s3">] = </span><span class="s1">cac</span>
    <span class="s2">if </span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s5">'F'</span><span class="s3">:</span>
        <span class="s1">empty_c_typ </span><span class="s3">= </span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s5">'C'</span><span class="s3">)</span>
        <span class="s1">empty_c_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$empty_c_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">empty_c_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">lhs_typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s5">'C'</span><span class="s3">)</span>
        <span class="s1">empty_c_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">alloc_call</span><span class="s3">, </span><span class="s1">empty_c_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s0"># attr call: asfortranarray = getattr(g_np_var, asfortranarray)</span>
        <span class="s1">asfortranarray_attr_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s5">&quot;asfortranarray&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">afa_attr_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$asfortran_array_attr&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">afa_attr_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">)</span>
        <span class="s1">afa_attr_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">asfortranarray_attr_call</span><span class="s3">, </span><span class="s1">afa_attr_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s0"># call asfortranarray</span>
        <span class="s1">asfortranarray_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">afa_attr_var</span><span class="s3">, [</span><span class="s1">empty_c_var</span><span class="s3">], (), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">calltypes</span><span class="s3">:</span>
            <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">asfortranarray_call</span><span class="s3">] = </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">afa_attr_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get_call_type</span><span class="s3">(</span>
                <span class="s1">typingctx</span><span class="s3">, [</span><span class="s1">empty_c_typ</span><span class="s3">], {})</span>

        <span class="s1">asfortranarray_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">asfortranarray_call</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s1">out</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">g_np_assign</span><span class="s3">, </span><span class="s1">attr_assign</span><span class="s3">, </span><span class="s1">typ_var_assign</span><span class="s3">, </span><span class="s1">empty_c_assign</span><span class="s3">,</span>
                    <span class="s1">afa_attr_assign</span><span class="s3">, </span><span class="s1">asfortranarray_assign</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">alloc_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">alloc_call</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">g_np_assign</span><span class="s3">, </span><span class="s1">attr_assign</span><span class="s3">, </span><span class="s1">typ_var_assign</span><span class="s3">, </span><span class="s1">alloc_assign</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">convert_size_to_var</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">nodes</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">new_size </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$alloc_size&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">new_size</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
        <span class="s1">size_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">new_size</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">nodes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">size_assign</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">new_size</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">size_var</span>


<span class="s2">def </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;get type of the incoming function from builtin registry&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">in </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">npydecl</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s1">func</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">v</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">in </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">templates</span><span class="s3">.</span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s1">func</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">v</span>
    <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;type for func &quot;</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s5">&quot; not found&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">mk_range_block</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;make a block that initializes loop range and iteration variables. 
    target label in jump needs to be set. 
    &quot;&quot;&quot;</span>
    <span class="s0"># g_range_var = Global(range)</span>
    <span class="s1">g_range_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$range_g_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_range_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">get_global_func_typ</span><span class="s3">(</span><span class="s1">range</span><span class="s3">)</span>
    <span class="s1">g_range </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s5">'range'</span><span class="s3">, </span><span class="s1">range</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">g_range_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">g_range</span><span class="s3">, </span><span class="s1">g_range_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">arg_nodes</span><span class="s3">, </span><span class="s1">args </span><span class="s3">= </span><span class="s1">_mk_range_args</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># range_call_var = call g_range_var(start, stop, step)</span>
    <span class="s1">range_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">g_range_var</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, (), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">range_call</span><span class="s3">] = </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_range_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get_call_type</span><span class="s3">(</span>
        <span class="s1">typing</span><span class="s3">.</span><span class="s1">Context</span><span class="s3">(), [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">), {})</span>
    <span class="s0">#signature(types.range_state64_type, types.intp)</span>
    <span class="s1">range_call_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$range_c_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">range_call_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">iterators</span><span class="s3">.</span><span class="s1">RangeType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">range_call_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">range_call</span><span class="s3">, </span><span class="s1">range_call_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># iter_var = getiter(range_call_var)</span>
    <span class="s1">iter_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getiter</span><span class="s3">(</span><span class="s1">range_call_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">iter_call</span><span class="s3">] = </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">range_iter64_type</span><span class="s3">,</span>
                                     <span class="s1">types</span><span class="s3">.</span><span class="s1">range_state64_type</span><span class="s3">)</span>
    <span class="s1">iter_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$iter_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">iter_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">iterators</span><span class="s3">.</span><span class="s1">RangeIteratorType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">iter_call_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">iter_call</span><span class="s3">, </span><span class="s1">iter_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># $phi = iter_var</span>
    <span class="s1">phi_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$phi&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">phi_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">iterators</span><span class="s3">.</span><span class="s1">RangeIteratorType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">phi_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">iter_var</span><span class="s3">, </span><span class="s1">phi_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># jump to header</span>
    <span class="s1">jump_header </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">range_block </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">range_block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">arg_nodes </span><span class="s3">+ [</span><span class="s1">g_range_assign</span><span class="s3">, </span><span class="s1">range_call_assign</span><span class="s3">,</span>
                                    <span class="s1">iter_call_assign</span><span class="s3">, </span><span class="s1">phi_assign</span><span class="s3">, </span><span class="s1">jump_header</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">range_block</span>


<span class="s2">def </span><span class="s1">_mk_range_args</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
    <span class="s1">nodes </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
        <span class="s1">g_stop_var </span><span class="s3">= </span><span class="s1">stop</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">g_stop_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$range_stop&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_stop_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
        <span class="s1">stop_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">g_stop_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">nodes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stop_assign</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">start </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">step </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">nodes</span><span class="s3">, [</span><span class="s1">g_stop_var</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
        <span class="s1">g_start_var </span><span class="s3">= </span><span class="s1">start</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">g_start_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$range_start&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_start_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
        <span class="s1">start_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">g_start_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">nodes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">start_assign</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">step </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">nodes</span><span class="s3">, [</span><span class="s1">g_start_var</span><span class="s3">, </span><span class="s1">g_stop_var</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
        <span class="s1">g_step_var </span><span class="s3">= </span><span class="s1">step</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">g_step_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$range_step&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">typemap</span><span class="s3">:</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_step_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
        <span class="s1">step_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">g_step_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">nodes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">step_assign</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">nodes</span><span class="s3">, [</span><span class="s1">g_start_var</span><span class="s3">, </span><span class="s1">g_stop_var</span><span class="s3">, </span><span class="s1">g_step_var</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">get_global_func_typ</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;get type variable for func() from builtin registry&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">in </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">templates</span><span class="s3">.</span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s1">func</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">v</span>
    <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;func type not found {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">func</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">mk_loop_header</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">phi_var</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;make a block that is a loop header updating iteration variables. 
    target labels in branch need to be set. 
    &quot;&quot;&quot;</span>
    <span class="s0"># iternext_var = iternext(phi_var)</span>
    <span class="s1">iternext_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$iternext_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">iternext_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">Pair</span><span class="s3">(</span>
        <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">)</span>
    <span class="s1">iternext_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">iternext</span><span class="s3">(</span><span class="s1">phi_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">iternext_call</span><span class="s3">] = </span><span class="s1">signature</span><span class="s3">(</span>
        <span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">Pair</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">),</span>
        <span class="s1">types</span><span class="s3">.</span><span class="s1">range_iter64_type</span><span class="s3">)</span>
    <span class="s1">iternext_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">iternext_call</span><span class="s3">, </span><span class="s1">iternext_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># pair_first_var = pair_first(iternext_var)</span>
    <span class="s1">pair_first_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$pair_first_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">pair_first_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
    <span class="s1">pair_first_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">pair_first</span><span class="s3">(</span><span class="s1">iternext_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">pair_first_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">pair_first_call</span><span class="s3">, </span><span class="s1">pair_first_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># pair_second_var = pair_second(iternext_var)</span>
    <span class="s1">pair_second_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$pair_second_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">pair_second_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span>
    <span class="s1">pair_second_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">pair_second</span><span class="s3">(</span><span class="s1">iternext_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">pair_second_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">pair_second_call</span><span class="s3">, </span><span class="s1">pair_second_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># phi_b_var = pair_first_var</span>
    <span class="s1">phi_b_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$phi&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">phi_b_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
    <span class="s1">phi_b_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">pair_first_var</span><span class="s3">, </span><span class="s1">phi_b_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># branch pair_second_var body_block out_block</span>
    <span class="s1">branch </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span><span class="s1">pair_second_var</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">header_block </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">header_block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= [</span><span class="s1">iternext_assign</span><span class="s3">, </span><span class="s1">pair_first_assign</span><span class="s3">,</span>
                         <span class="s1">pair_second_assign</span><span class="s3">, </span><span class="s1">phi_b_assign</span><span class="s3">, </span><span class="s1">branch</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">header_block</span>


<span class="s2">def </span><span class="s1">legalize_names</span><span class="s3">(</span><span class="s1">varnames</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;returns a dictionary for conversion of variable names to legal 
    parameter names. 
    &quot;&quot;&quot;</span>
    <span class="s1">var_map </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">varnames</span><span class="s3">:</span>
        <span class="s1">new_name </span><span class="s3">= </span><span class="s1">var</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">&quot;_&quot;</span><span class="s3">, </span><span class="s5">&quot;__&quot;</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">&quot;$&quot;</span><span class="s3">, </span><span class="s5">&quot;_&quot;</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">, </span><span class="s5">&quot;_&quot;</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">new_name </span><span class="s2">not in </span><span class="s1">var_map</span>
        <span class="s1">var_map</span><span class="s3">[</span><span class="s1">var</span><span class="s3">] = </span><span class="s1">new_name</span>
    <span class="s2">return </span><span class="s1">var_map</span>


<span class="s2">def </span><span class="s1">get_name_var_table</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;create a mapping from variable names to their ir.Var objects&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">get_name_var_visit</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">namevar</span><span class="s3">):</span>
        <span class="s1">namevar</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">var</span>
        <span class="s2">return </span><span class="s1">var</span>
    <span class="s1">namevar </span><span class="s3">= {}</span>
    <span class="s1">visit_vars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">get_name_var_visit</span><span class="s3">, </span><span class="s1">namevar</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">namevar</span>


<span class="s2">def </span><span class="s1">replace_var_names</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">namedict</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;replace variables (ir.Var to ir.Var) from dictionary (name -&gt; name)&quot;&quot;&quot;</span>
    <span class="s0"># remove identity values to avoid infinite loop</span>
    <span class="s1">new_namedict </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">namedict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">l </span><span class="s3">!= </span><span class="s1">r</span><span class="s3">:</span>
            <span class="s1">new_namedict</span><span class="s3">[</span><span class="s1">l</span><span class="s3">] = </span><span class="s1">r</span>

    <span class="s2">def </span><span class="s1">replace_name</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">namedict</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)</span>
        <span class="s2">while </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">namedict</span><span class="s3">:</span>
            <span class="s1">var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">namedict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">], </span><span class="s1">var</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">var</span>
    <span class="s1">visit_vars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">replace_name</span><span class="s3">, </span><span class="s1">new_namedict</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">replace_var_callback</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)</span>
    <span class="s2">while </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">vardict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s2">assert</span><span class="s3">(</span><span class="s1">vardict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">name </span><span class="s3">!= </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">new_var </span><span class="s3">= </span><span class="s1">vardict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">new_var</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">new_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">new_var</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">var</span>


<span class="s2">def </span><span class="s1">replace_vars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;replace variables (ir.Var to ir.Var) from dictionary (name -&gt; ir.Var)&quot;&quot;&quot;</span>
    <span class="s0"># remove identity values to avoid infinite loop</span>
    <span class="s1">new_vardict </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">vardict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">l </span><span class="s3">!= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">new_vardict</span><span class="s3">[</span><span class="s1">l</span><span class="s3">] = </span><span class="s1">r</span>
    <span class="s1">visit_vars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">replace_var_callback</span><span class="s3">, </span><span class="s1">new_vardict</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">replace_vars_stmt</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">):</span>
    <span class="s1">visit_vars_stmt</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">replace_var_callback</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">replace_vars_inner</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">replace_var_callback</span><span class="s3">, </span><span class="s1">vardict</span><span class="s3">)</span>


<span class="s0"># other packages that define new nodes add calls to visit variables in them</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">visit_vars_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">visit_vars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;go over statements of block bodies and replace variable names with 
    dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s1">visit_vars_stmt</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">visit_vars_stmt</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">):</span>
    <span class="s0"># let external calls handle stmt if type matches</span>
    <span class="s2">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">visit_vars_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
            <span class="s1">f</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
            <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Raise</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">exception </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">cond </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">):</span>
        <span class="s0"># Because Del takes only a var name, we make up by</span>
        <span class="s0"># constructing a temporary variable.</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DelAttr</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetAttr</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DelItem</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">index_var </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Print</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= [</span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">args</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># TODO: raise NotImplementedError(&quot;no replacement for IR node: &quot;, stmt)</span>
        <span class="s2">pass</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">node</span><span class="s3">]</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">node</span><span class="s3">])</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
        <span class="s0"># if node.op in ['binop', 'inplace_binop']:</span>
        <span class="s0">#     lhs = node.lhs.name</span>
        <span class="s0">#     rhs = node.rhs.name</span>
        <span class="s0">#     node.lhs.name = callback, cbdata.get(lhs, lhs)</span>
        <span class="s0">#     node.rhs.name = callback, cbdata.get(rhs, rhs)</span>
        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">node</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
            <span class="s1">node</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s1">arg</span><span class="s3">] = </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s1">arg</span><span class="s3">], </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">):</span>
        <span class="s1">node</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">visit_vars_inner</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">cbdata</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">node</span>


<span class="s1">add_offset_to_labels_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">add_offset_to_labels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;add an offset to all block labels and jump/branch targets 
    &quot;&quot;&quot;</span>
    <span class="s1">new_blocks </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s0"># some parfor last blocks might be empty</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s1">term </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">add_offset_to_labels_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                        <span class="s1">f_max </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">):</span>
            <span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">term</span><span class="s3">.</span><span class="s1">target </span><span class="s3">+ </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">term</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">):</span>
            <span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span><span class="s1">term</span><span class="s3">.</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">term</span><span class="s3">.</span><span class="s1">truebr </span><span class="s3">+ </span><span class="s1">offset</span><span class="s3">,</span>
                                   <span class="s1">term</span><span class="s3">.</span><span class="s1">falsebr </span><span class="s3">+ </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">term</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">new_blocks</span><span class="s3">[</span><span class="s1">l </span><span class="s3">+ </span><span class="s1">offset</span><span class="s3">] = </span><span class="s1">b</span>
    <span class="s2">return </span><span class="s1">new_blocks</span>


<span class="s1">find_max_label_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">find_max_label</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s1">max_label </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s1">term </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">find_max_label_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                        <span class="s1">f_max </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">f_max </span><span class="s3">&gt; </span><span class="s1">max_label</span><span class="s3">:</span>
                            <span class="s1">max_label </span><span class="s3">= </span><span class="s1">f_max</span>
        <span class="s2">if </span><span class="s1">l </span><span class="s3">&gt; </span><span class="s1">max_label</span><span class="s3">:</span>
            <span class="s1">max_label </span><span class="s3">= </span><span class="s1">l</span>
    <span class="s2">return </span><span class="s1">max_label</span>


<span class="s2">def </span><span class="s1">flatten_labels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;makes the labels in range(0, len(blocks)), useful to compare CFGs 
    &quot;&quot;&quot;</span>
    <span class="s0"># first bulk move the labels out of the rewrite range</span>
    <span class="s1">blocks </span><span class="s3">= </span><span class="s1">add_offset_to_labels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">find_max_label</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s0"># order them in topo order because it's easier to read</span>
    <span class="s1">new_blocks </span><span class="s3">= {}</span>
    <span class="s1">topo_order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">l_map </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
    <span class="s1">idx </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">topo_order</span><span class="s3">:</span>
        <span class="s1">l_map</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s2">for </span><span class="s1">t_node </span><span class="s2">in </span><span class="s1">topo_order</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">t_node</span><span class="s3">]</span>
        <span class="s0"># some parfor last blocks might be empty</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s1">term </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">):</span>
            <span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">l_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">target</span><span class="s3">], </span><span class="s1">term</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">):</span>
            <span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span><span class="s1">term</span><span class="s3">.</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">l_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">truebr</span><span class="s3">],</span>
                                   <span class="s1">l_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">falsebr</span><span class="s3">], </span><span class="s1">term</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">new_blocks</span><span class="s3">[</span><span class="s1">l_map</span><span class="s3">[</span><span class="s1">t_node</span><span class="s3">]] = </span><span class="s1">b</span>
    <span class="s2">return </span><span class="s1">new_blocks</span>


<span class="s2">def </span><span class="s1">remove_dels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;remove ir.Del nodes&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">new_body </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">):</span>
                <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">new_body</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">remove_args</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;remove ir.Arg nodes&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">new_body </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
                <span class="s2">continue</span>
            <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">new_body</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">dead_code_elimination</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">arg_aliases</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Performs dead code elimination and leaves the IR in a valid state on 
    exit 
    &quot;&quot;&quot;</span>
    <span class="s1">do_post_proc </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">remove_dead</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">,</span>
                       <span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)):</span>
        <span class="s1">do_post_proc </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">do_post_proc</span><span class="s3">:</span>
        <span class="s1">post_proc </span><span class="s3">= </span><span class="s1">postproc</span><span class="s3">.</span><span class="s1">PostProcessor</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">)</span>
        <span class="s1">post_proc</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">remove_dead</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;dead code elimination using liveness and CFG info. 
    Returns True if something has been removed, or False if nothing is removed. 
    &quot;&quot;&quot;</span>
    <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">usedefs </span><span class="s3">= </span><span class="s1">compute_use_defs</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">live_map </span><span class="s3">= </span><span class="s1">compute_live_map</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">usemap</span><span class="s3">, </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">defmap</span><span class="s3">)</span>
    <span class="s1">call_table</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_call_table</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">alias_map </span><span class="s2">is None or </span><span class="s1">arg_aliases </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases </span><span class="s3">= </span><span class="s1">find_potential_aliases</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">,</span>
                                                        <span class="s1">func_ir</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;args:&quot;</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;alias map:&quot;</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;arg_aliases:&quot;</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;live_map:&quot;</span><span class="s3">, </span><span class="s1">live_map</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;usemap:&quot;</span><span class="s3">, </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">usemap</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;defmap:&quot;</span><span class="s3">, </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">defmap</span><span class="s3">)</span>
    <span class="s0"># keep set for easier search</span>
    <span class="s1">alias_set </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">alias_map</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>

    <span class="s1">removed </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s0"># find live variables at each statement to delete dead assignment</span>
        <span class="s1">lives </span><span class="s3">= {</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">terminator</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">()}</span>
        <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;remove_dead processing block&quot;</span><span class="s3">, </span><span class="s1">label</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">)</span>
        <span class="s0"># find live variables at the end of block</span>
        <span class="s2">for </span><span class="s1">out_blk</span><span class="s3">, </span><span class="s1">_data </span><span class="s2">in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">successors</span><span class="s3">(</span><span class="s1">label</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;succ live_map&quot;</span><span class="s3">, </span><span class="s1">out_blk</span><span class="s3">, </span><span class="s1">live_map</span><span class="s3">[</span><span class="s1">out_blk</span><span class="s3">])</span>
            <span class="s1">lives </span><span class="s3">|= </span><span class="s1">live_map</span><span class="s3">[</span><span class="s1">out_blk</span><span class="s3">]</span>
        <span class="s1">removed </span><span class="s3">|= </span><span class="s1">remove_dead_block</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">,</span>
                                     <span class="s1">alias_map</span><span class="s3">, </span><span class="s1">alias_set</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">removed</span>


<span class="s0"># other packages that define new nodes add calls to remove dead code in them</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">remove_dead_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">remove_dead_block</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">,</span>
                                                  <span class="s1">alias_set</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;remove dead code using liveness info. 
    Mutable arguments (e.g. arrays) that are not definitely assigned are live 
    after return of function. 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO: find mutable args that are not definitely assigned instead of</span>
    <span class="s0"># assuming all args are live after return</span>
    <span class="s1">removed </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># add statements in reverse order</span>
    <span class="s1">new_body </span><span class="s3">= [</span><span class="s1">block</span><span class="s3">.</span><span class="s1">terminator</span><span class="s3">]</span>
    <span class="s0"># for each statement in reverse order, excluding terminator</span>
    <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">]):</span>
        <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;remove_dead_block&quot;</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s0"># aliases of lives are also live</span>
        <span class="s1">alias_lives </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">init_alias_lives </span><span class="s3">= </span><span class="s1">lives </span><span class="s3">&amp; </span><span class="s1">alias_set</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">init_alias_lives</span><span class="s3">:</span>
            <span class="s1">alias_lives </span><span class="s3">|= </span><span class="s1">alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">]</span>
        <span class="s1">lives_n_aliases </span><span class="s3">= </span><span class="s1">lives </span><span class="s3">| </span><span class="s1">alias_lives </span><span class="s3">| </span><span class="s1">arg_aliases</span>

        <span class="s0"># let external calls handle stmt if type matches</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">in </span><span class="s1">remove_dead_extensions</span><span class="s3">:</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">remove_dead_extensions</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)]</span>
            <span class="s1">stmt </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">lives_n_aliases</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">,</span>
                     <span class="s1">typemap</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">stmt </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Statement was removed.&quot;</span><span class="s3">)</span>
                <span class="s1">removed </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">continue</span>

        <span class="s0"># ignore assignments that their lhs is not live or lhs==rhs</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span>
            <span class="s1">rhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s2">if </span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">lives </span><span class="s2">and </span><span class="s1">has_no_side_effect</span><span class="s3">(</span>
                    <span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives_n_aliases</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Statement was removed.&quot;</span><span class="s3">)</span>
                <span class="s1">removed </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">) </span><span class="s2">and </span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Statement was removed.&quot;</span><span class="s3">)</span>
                <span class="s1">removed </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">continue</span>
            <span class="s0"># TODO: remove other nodes like SetItem etc.</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s2">not in </span><span class="s1">lives</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Statement was removed.&quot;</span><span class="s3">)</span>
                <span class="s1">removed </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">lives_n_aliases</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Statement was removed.&quot;</span><span class="s3">)</span>
                <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">in </span><span class="s1">analysis</span><span class="s3">.</span><span class="s1">ir_extension_usedefs</span><span class="s3">:</span>
            <span class="s1">def_func </span><span class="s3">= </span><span class="s1">analysis</span><span class="s3">.</span><span class="s1">ir_extension_usedefs</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)]</span>
            <span class="s1">uses</span><span class="s3">, </span><span class="s1">defs </span><span class="s3">= </span><span class="s1">def_func</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
            <span class="s1">lives </span><span class="s3">-= </span><span class="s1">defs</span>
            <span class="s1">lives </span><span class="s3">|= </span><span class="s1">uses</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lives </span><span class="s3">|= {</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">()}</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s0"># make sure lhs is not used in rhs, e.g. a = g(a)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
                    <span class="s1">rhs_vars </span><span class="s3">= {</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">()}</span>
                    <span class="s2">if </span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">rhs_vars</span><span class="s3">:</span>
                        <span class="s1">lives</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">lives</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
    <span class="s1">new_body</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">new_body</span>
    <span class="s2">return </span><span class="s1">removed</span>

<span class="s0"># list of functions</span>
<span class="s1">remove_call_handlers </span><span class="s3">= []</span>

<span class="s2">def </span><span class="s1">remove_dead_random_call</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_list</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">call_list</span><span class="s3">) == </span><span class="s4">3 </span><span class="s2">and </span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:] == [</span><span class="s5">'random'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] </span><span class="s2">not in </span><span class="s3">{</span><span class="s5">'seed'</span><span class="s3">, </span><span class="s5">'shuffle'</span><span class="s3">}</span>
    <span class="s2">return False</span>

<span class="s1">remove_call_handlers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">remove_dead_random_call</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">has_no_side_effect</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Returns True if this expression has no side effects that 
        would prevent re-ordering. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors </span><span class="s2">import </span><span class="s1">array_analysis</span><span class="s3">, </span><span class="s1">parfor</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">prange</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
        <span class="s1">func_name </span><span class="s3">= </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">func_name </span><span class="s2">not in </span><span class="s1">call_table </span><span class="s2">or </span><span class="s1">call_table</span><span class="s3">[</span><span class="s1">func_name</span><span class="s3">] == []:</span>
            <span class="s2">return False</span>
        <span class="s1">call_list </span><span class="s3">= </span><span class="s1">call_table</span><span class="s3">[</span><span class="s1">func_name</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'empty'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">slice</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'stencil'</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'log'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'dtype'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">array_analysis</span><span class="s3">.</span><span class="s1">wrap_index</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">prange</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'prange'</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'pndindex'</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">internal_prange</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'ceil'</span><span class="s3">, </span><span class="s1">math</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">max</span><span class="s3">] </span><span class="s2">or</span>
            <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">int</span><span class="s3">]):</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">_Intrinsic</span><span class="s3">) </span><span class="s2">and</span>
              <span class="s3">(</span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">_name </span><span class="s3">== </span><span class="s5">'empty_inferred' </span><span class="s2">or</span>
               <span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">_name </span><span class="s3">== </span><span class="s5">'unsafe_empty_inferred'</span><span class="s3">)):</span>
            <span class="s2">return True</span>
        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">registry </span><span class="s2">import </span><span class="s1">CPUDispatcher</span>
        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s1">dot_3_mv_check_args</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">CPUDispatcher</span><span class="s3">):</span>
            <span class="s1">py_func </span><span class="s3">= </span><span class="s1">call_list</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">py_func</span>
            <span class="s2">if </span><span class="s1">py_func </span><span class="s3">== </span><span class="s1">dot_3_mv_check_args</span><span class="s3">:</span>
                <span class="s2">return True</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">remove_call_handlers</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">f</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_list</span><span class="s3">):</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'inplace_binop'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">lives</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'pair_first'</span><span class="s3">:</span>
        <span class="s0"># don't remove pair_first since prange looks for it</span>
        <span class="s2">return False</span>
    <span class="s2">return True</span>

<span class="s1">is_pure_extensions </span><span class="s3">= []</span>

<span class="s2">def </span><span class="s1">is_pure</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Returns True if every time this expression is evaluated it 
        returns the same result.  This is not the case for things 
        like calls to numpy.random. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
            <span class="s1">func_name </span><span class="s3">= </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s2">if </span><span class="s1">func_name </span><span class="s2">not in </span><span class="s1">call_table </span><span class="s2">or </span><span class="s1">call_table</span><span class="s3">[</span><span class="s1">func_name</span><span class="s3">] == []:</span>
                <span class="s2">return False</span>
            <span class="s1">call_list </span><span class="s3">= </span><span class="s1">call_table</span><span class="s3">[</span><span class="s1">func_name</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">call_list </span><span class="s3">== [</span><span class="s1">slice</span><span class="s3">] </span><span class="s2">or</span>
                <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'log'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">] </span><span class="s2">or</span>
                <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'empty'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">] </span><span class="s2">or</span>
                <span class="s1">call_list </span><span class="s3">== [</span><span class="s5">'ceil'</span><span class="s3">, </span><span class="s1">math</span><span class="s3">] </span><span class="s2">or</span>
                <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">max</span><span class="s3">] </span><span class="s2">or</span>
                <span class="s1">call_list </span><span class="s3">== [</span><span class="s1">int</span><span class="s3">]):</span>
                <span class="s2">return True</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">is_pure_extensions</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">f</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">lives</span><span class="s3">, </span><span class="s1">call_list</span><span class="s3">):</span>
                    <span class="s2">return True</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getiter' </span><span class="s2">or </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'iternext'</span><span class="s3">:</span>
            <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">is_const_call</span><span class="s3">(</span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">):</span>
    <span class="s0"># Returns True if there is no state in the given module changed by the given function.</span>
    <span class="s2">if </span><span class="s1">module_name </span><span class="s3">== </span><span class="s5">'numpy'</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">func_name </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'empty'</span><span class="s3">]:</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>

<span class="s1">alias_analysis_extensions </span><span class="s3">= {}</span>
<span class="s1">alias_func_extensions </span><span class="s3">= {}</span>

<span class="s2">def </span><span class="s1">get_canonical_alias</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">v </span><span class="s2">not in </span><span class="s1">alias_map</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s1">v_aliases </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">]))</span>
    <span class="s2">return </span><span class="s1">v_aliases</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

<span class="s2">def </span><span class="s1">find_potential_aliases</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                                                           <span class="s1">arg_aliases</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;find all array aliases and argument aliases to avoid remove as dead&quot;</span>
    <span class="s2">if </span><span class="s1">alias_map </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">alias_map </span><span class="s3">= {}</span>
    <span class="s2">if </span><span class="s1">arg_aliases </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">arg_aliases </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args </span><span class="s2">if not </span><span class="s1">is_immutable_type</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">))</span>

    <span class="s0"># update definitions since they are not guaranteed to be up-to-date</span>
    <span class="s0"># FIXME keep definitions up-to-date to avoid the need for rebuilding</span>
    <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">np_alias_funcs </span><span class="s3">= [</span><span class="s5">'ravel'</span><span class="s3">, </span><span class="s5">'transpose'</span><span class="s3">, </span><span class="s5">'reshape'</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">bl </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">instr </span><span class="s2">in </span><span class="s1">bl</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">) </span><span class="s2">in </span><span class="s1">alias_analysis_extensions</span><span class="s3">:</span>
                <span class="s1">f </span><span class="s3">= </span><span class="s1">alias_analysis_extensions</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">)]</span>
                <span class="s1">f</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s0"># only mutable types can alias</span>
                <span class="s2">if </span><span class="s1">is_immutable_type</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">) </span><span class="s2">and </span><span class="s1">lhs</span><span class="s3">!=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                    <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                <span class="s0"># subarrays like A = B[0] for 2D B</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'cast' </span><span class="s2">or</span>
                    <span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'getitem'</span><span class="s3">, </span><span class="s5">'static_getitem'</span><span class="s3">])):</span>
                    <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'inplace_binop'</span><span class="s3">:</span>
                    <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                <span class="s0"># array attributes like A.T</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span>
                        <span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">attr </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'T'</span><span class="s3">, </span><span class="s5">'ctypes'</span><span class="s3">, </span><span class="s5">'flat'</span><span class="s3">]):</span>
                    <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                <span class="s0"># a = b.c.  a should alias b</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span>
                        <span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">attr </span><span class="s2">not in </span><span class="s3">[</span><span class="s5">'shape'</span><span class="s3">]</span>
                        <span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">arg_aliases</span><span class="s3">):</span>
                    <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                <span class="s0"># calls that can create aliases such as B = A.ravel()</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
                    <span class="s1">fdef </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
                    <span class="s0"># TODO: sometimes gufunc backend creates duplicate code</span>
                    <span class="s0"># causing find_callname to fail. Example: test_argmax</span>
                    <span class="s0"># ignored here since those cases don't create aliases</span>
                    <span class="s0"># but should be fixed in general</span>
                    <span class="s2">if </span><span class="s1">fdef </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s2">continue</span>
                    <span class="s1">fname</span><span class="s3">, </span><span class="s1">fmod </span><span class="s3">= </span><span class="s1">fdef</span>
                    <span class="s2">if </span><span class="s1">fdef </span><span class="s2">in </span><span class="s1">alias_func_extensions</span><span class="s3">:</span>
                        <span class="s1">alias_func </span><span class="s3">= </span><span class="s1">alias_func_extensions</span><span class="s3">[</span><span class="s1">fdef</span><span class="s3">]</span>
                        <span class="s1">alias_func</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">fmod </span><span class="s3">== </span><span class="s5">'numpy' </span><span class="s2">and </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">np_alias_funcs</span><span class="s3">:</span>
                        <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fmod</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">) </span><span class="s2">and </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">np_alias_funcs</span><span class="s3">:</span>
                        <span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">fmod</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">)</span>

    <span class="s0"># copy to avoid changing size during iteration</span>
    <span class="s1">old_alias_map </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">alias_map</span><span class="s3">)</span>
    <span class="s0"># combine all aliases transitively</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">old_alias_map</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">old_alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">]:</span>
            <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">] |= </span><span class="s1">alias_map</span><span class="s3">[</span><span class="s1">w</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">old_alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">]:</span>
            <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">w</span><span class="s3">] = </span><span class="s1">alias_map</span><span class="s3">[</span><span class="s1">v</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span>

<span class="s2">def </span><span class="s1">_add_alias</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">alias_map</span><span class="s3">, </span><span class="s1">arg_aliases</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">arg_aliases</span><span class="s3">:</span>
        <span class="s1">arg_aliases</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">rhs </span><span class="s2">not in </span><span class="s1">alias_map</span><span class="s3">:</span>
            <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">lhs </span><span class="s2">not in </span><span class="s1">alias_map</span><span class="s3">:</span>
            <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
        <span class="s1">alias_map</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">)</span>
    <span class="s2">return</span>

<span class="s2">def </span><span class="s1">is_immutable_type</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s0"># Conservatively, assume mutable if type not available</span>
    <span class="s2">if </span><span class="s1">typemap </span><span class="s2">is None or </span><span class="s1">var </span><span class="s2">not in </span><span class="s1">typemap</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s1">typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">var</span><span class="s3">]</span>
    <span class="s0"># TODO: add more immutable types</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">scalars</span><span class="s3">.</span><span class="s1">_NPDatetimeBase</span><span class="s3">,</span>
                        <span class="s1">types</span><span class="s3">.</span><span class="s1">iterators</span><span class="s3">.</span><span class="s1">RangeType</span><span class="s3">)):</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">==</span><span class="s1">types</span><span class="s3">.</span><span class="s1">string</span><span class="s3">:</span>
        <span class="s2">return True</span>
    <span class="s0"># conservatively, assume mutable</span>
    <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">copy_propagate</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;compute copy propagation information for each block using fixed-point 
     iteration on data flow equations: 
     in_b = intersect(predec(B)) 
     out_b = gen_b | (in_b - kill_b) 
    &quot;&quot;&quot;</span>
    <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">entry </span><span class="s3">= </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">()</span>

    <span class="s0"># format: dict of block labels to copies as tuples</span>
    <span class="s0"># label -&gt; (l,r)</span>
    <span class="s1">c_data </span><span class="s3">= </span><span class="s1">init_copy_propagate_data</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">gen_copies</span><span class="s3">, </span><span class="s1">all_copies</span><span class="s3">, </span><span class="s1">kill_copies</span><span class="s3">, </span><span class="s1">in_copies</span><span class="s3">, </span><span class="s1">out_copies</span><span class="s3">) = </span><span class="s1">c_data</span>

    <span class="s1">old_point </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">new_point </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">out_copies</span><span class="s3">)</span>
    <span class="s0"># comparison works since dictionary of built-in types</span>
    <span class="s2">while </span><span class="s1">old_point </span><span class="s3">!= </span><span class="s1">new_point</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">label </span><span class="s3">== </span><span class="s1">entry</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s1">predecs </span><span class="s3">= [</span><span class="s1">i </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">_d </span><span class="s2">in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">predecessors</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)]</span>
            <span class="s0"># in_b =  intersect(predec(B))</span>
            <span class="s1">in_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">out_copies</span><span class="s3">[</span><span class="s1">predecs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]].</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">predecs</span><span class="s3">:</span>
                <span class="s1">in_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] &amp;= </span><span class="s1">out_copies</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s0"># out_b = gen_b | (in_b - kill_b)</span>
            <span class="s1">out_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = (</span><span class="s1">gen_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
                                 <span class="s3">| (</span><span class="s1">in_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] - </span><span class="s1">kill_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]))</span>
        <span class="s1">old_point </span><span class="s3">= </span><span class="s1">new_point</span>
        <span class="s1">new_point </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">out_copies</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;copy propagate out_copies:&quot;</span><span class="s3">, </span><span class="s1">out_copies</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">in_copies</span><span class="s3">, </span><span class="s1">out_copies</span>


<span class="s2">def </span><span class="s1">init_copy_propagate_data</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;get initial condition of copy propagation data flow for each block. 
    &quot;&quot;&quot;</span>
    <span class="s0"># gen is all definite copies, extra_kill is additional ones that may hit</span>
    <span class="s0"># for example, parfors can have control flow so they may hit extra copies</span>
    <span class="s1">gen_copies</span><span class="s3">, </span><span class="s1">extra_kill </span><span class="s3">= </span><span class="s1">get_block_copies</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
    <span class="s0"># set of all program copies</span>
    <span class="s1">all_copies </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">gen_copies</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">all_copies </span><span class="s3">|= </span><span class="s1">gen_copies</span><span class="s3">[</span><span class="s1">l</span><span class="s3">]</span>
    <span class="s1">kill_copies </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">gen_set </span><span class="s2">in </span><span class="s1">gen_copies</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">kill_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">all_copies</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] </span><span class="s2">or </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]:</span>
                <span class="s1">kill_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">((</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">))</span>
            <span class="s0"># a copy is killed if it is not in this block and lhs or rhs are</span>
            <span class="s0"># assigned in this block</span>
            <span class="s1">assigned </span><span class="s3">= {</span><span class="s1">lhs </span><span class="s2">for </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">gen_set</span><span class="s3">}</span>
            <span class="s2">if </span><span class="s3">((</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">) </span><span class="s2">not in </span><span class="s1">gen_set</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">assigned </span><span class="s2">or </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">assigned</span><span class="s3">)):</span>
                <span class="s1">kill_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">((</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">))</span>
    <span class="s0"># set initial values</span>
    <span class="s0"># all copies are in for all blocks except entry</span>
    <span class="s1">in_copies </span><span class="s3">= {</span><span class="s1">l</span><span class="s3">: </span><span class="s1">all_copies</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">() </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()}</span>
    <span class="s1">in_copies</span><span class="s3">[</span><span class="s1">entry</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">out_copies </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s0"># out_b = gen_b | (in_b - kill_b)</span>
        <span class="s1">out_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = (</span><span class="s1">gen_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
                             <span class="s3">| (</span><span class="s1">in_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] - </span><span class="s1">kill_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]))</span>
    <span class="s1">out_copies</span><span class="s3">[</span><span class="s1">entry</span><span class="s3">] = </span><span class="s1">gen_copies</span><span class="s3">[</span><span class="s1">entry</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">gen_copies</span><span class="s3">, </span><span class="s1">all_copies</span><span class="s3">, </span><span class="s1">kill_copies</span><span class="s3">, </span><span class="s1">in_copies</span><span class="s3">, </span><span class="s1">out_copies</span><span class="s3">)</span>


<span class="s0"># other packages that define new nodes add calls to get copies in them</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">copy_propagate_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">get_block_copies</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;get copies generated and killed by each block 
    &quot;&quot;&quot;</span>
    <span class="s1">block_copies </span><span class="s3">= {}</span>
    <span class="s1">extra_kill </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">assign_dict </span><span class="s3">= {}</span>
        <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s0"># assignments as dict to replace with latest value</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">copy_propagate_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                    <span class="s1">gen_set</span><span class="s3">, </span><span class="s1">kill_set </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">gen_set</span><span class="s3">:</span>
                        <span class="s1">assign_dict</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">rhs</span>
                    <span class="s0"># if a=b is in dict and b is killed, a is also killed</span>
                    <span class="s1">new_assign_dict </span><span class="s3">= {}</span>
                    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">assign_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">if </span><span class="s1">l </span><span class="s2">not in </span><span class="s1">kill_set </span><span class="s2">and </span><span class="s1">r </span><span class="s2">not in </span><span class="s1">kill_set</span><span class="s3">:</span>
                            <span class="s1">new_assign_dict</span><span class="s3">[</span><span class="s1">l</span><span class="s3">] = </span><span class="s1">r</span>
                        <span class="s2">if </span><span class="s1">r </span><span class="s2">in </span><span class="s1">kill_set</span><span class="s3">:</span>
                            <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">l</span><span class="s3">)</span>
                    <span class="s1">assign_dict </span><span class="s3">= </span><span class="s1">new_assign_dict</span>
                    <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] |= </span><span class="s1">kill_set</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                    <span class="s1">rhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s0"># copy is valid only if same type (see</span>
                    <span class="s0"># TestCFunc.test_locals)</span>
                    <span class="s0"># Some transformations can produce assignments of the</span>
                    <span class="s0"># form A = A.  We don't put these mapping in the</span>
                    <span class="s0"># copy propagation set because then you get cycles and</span>
                    <span class="s0"># infinite loops in the replacement phase.</span>
                    <span class="s2">if </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] == </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">] </span><span class="s2">and </span><span class="s1">lhs </span><span class="s3">!= </span><span class="s1">rhs</span><span class="s3">:</span>
                        <span class="s1">assign_dict</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">rhs</span>
                        <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                              <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'inplace_binop'</span><span class="s3">:</span>
                    <span class="s1">in1_var </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s1">in1_typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">in1_var</span><span class="s3">]</span>
                    <span class="s0"># inplace_binop assigns first operand if mutable</span>
                    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">in1_typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>
                            <span class="s2">or </span><span class="s1">in1_typ </span><span class="s3">== </span><span class="s1">types</span><span class="s3">.</span><span class="s1">string</span><span class="s3">):</span>
                        <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">in1_var</span><span class="s3">)</span>
                        <span class="s0"># if a=b is in dict and b is killed, a is also killed</span>
                        <span class="s1">new_assign_dict </span><span class="s3">= {}</span>
                        <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">assign_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                            <span class="s2">if </span><span class="s1">l </span><span class="s3">!= </span><span class="s1">in1_var </span><span class="s2">and </span><span class="s1">r </span><span class="s3">!= </span><span class="s1">in1_var</span><span class="s3">:</span>
                                <span class="s1">new_assign_dict</span><span class="s3">[</span><span class="s1">l</span><span class="s3">] = </span><span class="s1">r</span>
                            <span class="s2">if </span><span class="s1">r </span><span class="s3">== </span><span class="s1">in1_var</span><span class="s3">:</span>
                                <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">l</span><span class="s3">)</span>
                        <span class="s1">assign_dict </span><span class="s3">= </span><span class="s1">new_assign_dict</span>
                <span class="s1">extra_kill</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
        <span class="s1">block_cps </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">assign_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
        <span class="s1">block_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">block_cps</span>
    <span class="s2">return </span><span class="s1">block_copies</span><span class="s3">, </span><span class="s1">extra_kill</span>


<span class="s0"># other packages that define new nodes add calls to apply copy propagate in them</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">apply_copy_propagate_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">apply_copy_propagate</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">in_copies</span><span class="s3">, </span><span class="s1">name_var_table</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">,</span>
                         <span class="s1">save_copies</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;apply copy propagation to IR: replace variables when copies available&quot;&quot;&quot;</span>
    <span class="s0"># save_copies keeps an approximation of the copies that were applied, so</span>
    <span class="s0"># that the variable names of removed user variables can be recovered to some</span>
    <span class="s0"># extent.</span>
    <span class="s2">if </span><span class="s1">save_copies </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">save_copies </span><span class="s3">= []</span>

    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">var_dict </span><span class="s3">= {</span><span class="s1">l</span><span class="s3">: </span><span class="s1">name_var_table</span><span class="s3">[</span><span class="s1">r</span><span class="s3">] </span><span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">in_copies</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]}</span>
        <span class="s0"># assignments as dict to replace with latest value</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">in </span><span class="s1">apply_copy_propagate_extensions</span><span class="s3">:</span>
                <span class="s1">f </span><span class="s3">= </span><span class="s1">apply_copy_propagate_extensions</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)]</span>
                <span class="s1">f</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">, </span><span class="s1">name_var_table</span><span class="s3">,</span>
                    <span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">save_copies</span><span class="s3">)</span>
            <span class="s0"># only rhs of assignments should be replaced</span>
            <span class="s0"># e.g. if x=y is available, x in x=z shouldn't be replaced</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">replace_vars_inner</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">replace_vars_stmt</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
            <span class="s1">fix_setitem_type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">copy_propagate_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                    <span class="s1">gen_set</span><span class="s3">, </span><span class="s1">kill_set </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">gen_set</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">name_var_table</span><span class="s3">:</span>
                            <span class="s1">var_dict</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">name_var_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">]</span>
                    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">var_dict</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">if </span><span class="s1">l </span><span class="s2">in </span><span class="s1">kill_set </span><span class="s2">or </span><span class="s1">r</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">kill_set</span><span class="s3">:</span>
                            <span class="s1">var_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">l</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s0"># rhs could be replaced with lhs from previous copies</span>
                <span class="s2">if </span><span class="s1">lhs </span><span class="s3">!= </span><span class="s1">rhs</span><span class="s3">:</span>
                    <span class="s0"># copy is valid only if same type (see</span>
                    <span class="s0"># TestCFunc.test_locals)</span>
                    <span class="s2">if </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] == </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">] </span><span class="s2">and </span><span class="s1">rhs </span><span class="s2">in </span><span class="s1">name_var_table</span><span class="s3">:</span>
                        <span class="s1">var_dict</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">name_var_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">]</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">var_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s0"># a=b kills previous t=a</span>
                    <span class="s1">lhs_kill </span><span class="s3">= []</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">var_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">lhs</span><span class="s3">:</span>
                            <span class="s1">lhs_kill</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">lhs_kill</span><span class="s3">:</span>
                        <span class="s1">var_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
                                        <span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">var_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s0"># previous t=a is killed if a is killed</span>
                <span class="s1">lhs_kill </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">var_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">lhs</span><span class="s3">:</span>
                        <span class="s1">lhs_kill</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">lhs_kill</span><span class="s3">:</span>
                    <span class="s1">var_dict</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">save_copies</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">var_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>

    <span class="s2">return </span><span class="s1">save_copies</span>

<span class="s2">def </span><span class="s1">fix_setitem_type</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Copy propagation can replace setitem target variable, which can be array 
    with 'A' layout. The replaced variable can be 'C' or 'F', so we update 
    setitem call type reflect this (from matrix power test) 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">)):</span>
        <span class="s2">return</span>
    <span class="s1">t_typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
    <span class="s1">s_typ </span><span class="s3">= </span><span class="s1">calltypes</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">].</span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s0"># test_optional t_typ can be Optional with array</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">s_typ</span><span class="s3">,</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">npytypes</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">t_typ</span><span class="s3">,</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">npytypes</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">s_typ</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s5">'A' </span><span class="s2">and </span><span class="s1">t_typ</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s5">'A'</span><span class="s3">:</span>
        <span class="s1">new_s_typ </span><span class="s3">= </span><span class="s1">s_typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s1">t_typ</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
        <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">].</span><span class="s1">args </span><span class="s3">= (</span>
            <span class="s1">new_s_typ</span><span class="s3">,</span>
            <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">].</span><span class="s1">args</span><span class="s3">[</span><span class="s4">1</span><span class="s3">],</span>
            <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">].</span><span class="s1">args</span><span class="s3">[</span><span class="s4">2</span><span class="s3">])</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">dprint_func_ir</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">title</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Debug print function IR, with an optional blocks argument 
    that may differ from the IR's original blocks. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">ir_blocks </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">ir_blocks </span><span class="s2">if </span><span class="s1">blocks </span><span class="s3">== </span><span class="s2">None else </span><span class="s1">blocks</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func_qualname</span>
        <span class="s1">print</span><span class="s3">((</span><span class="s5">&quot;IR %s: %s&quot; </span><span class="s3">% (</span><span class="s1">title</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)).</span><span class="s1">center</span><span class="s3">(</span><span class="s4">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">()</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;-&quot; </span><span class="s3">* </span><span class="s4">40</span><span class="s3">)</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">ir_blocks</span>


<span class="s2">def </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">cfg </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;find topological order of blocks such that true branches are visited 
    first (e.g. for_break test in test_dataflow). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cfg </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">post_order </span><span class="s3">= []</span>
    <span class="s1">seen </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_dfs_rec</span><span class="s3">(</span><span class="s1">node</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">node </span><span class="s2">not in </span><span class="s1">seen</span><span class="s3">:</span>
            <span class="s1">seen</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">succs </span><span class="s3">= </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">_succs</span><span class="s3">[</span><span class="s1">node</span><span class="s3">]</span>
            <span class="s1">last_inst </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">node</span><span class="s3">].</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">last_inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">):</span>
                <span class="s1">succs </span><span class="s3">= [</span><span class="s1">last_inst</span><span class="s3">.</span><span class="s1">falsebr</span><span class="s3">, </span><span class="s1">last_inst</span><span class="s3">.</span><span class="s1">truebr</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">succs</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">) </span><span class="s2">not in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">_back_edges</span><span class="s3">:</span>
                    <span class="s1">_dfs_rec</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">)</span>
            <span class="s1">post_order</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

    <span class="s1">_dfs_rec</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">())</span>
    <span class="s1">post_order</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">post_order</span>


<span class="s0"># other packages that define new nodes add calls to get call table</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">call_table_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">get_call_table</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">reverse_call_table</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">topological_ordering</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;returns a dictionary of call variables and their references. 
    &quot;&quot;&quot;</span>
    <span class="s0"># call_table example: c = np.zeros becomes c:[&quot;zeroes&quot;, np]</span>
    <span class="s0"># reverse_call_table example: c = np.zeros becomes np_var:c</span>
    <span class="s2">if </span><span class="s1">call_table </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">call_table </span><span class="s3">= {}</span>
    <span class="s2">if </span><span class="s1">reverse_call_table </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">reverse_call_table </span><span class="s3">= {}</span>

    <span class="s2">if </span><span class="s1">topological_ordering</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>

    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">order</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">body</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
                    <span class="s1">call_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = []</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">call_table</span><span class="s3">:</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
                        <span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">lhs</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">reverse_call_table</span><span class="s3">:</span>
                        <span class="s1">call_var </span><span class="s3">= </span><span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">call_var</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
                        <span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">call_var</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">call_table</span><span class="s3">:</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">reverse_call_table</span><span class="s3">:</span>
                        <span class="s1">call_var </span><span class="s3">= </span><span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">call_var</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">call_table</span><span class="s3">:</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">reverse_call_table</span><span class="s3">:</span>
                        <span class="s1">call_var </span><span class="s3">= </span><span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">call_var</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">call_table</span><span class="s3">:</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                        <span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">lhs</span>
                    <span class="s2">if </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">reverse_call_table</span><span class="s3">:</span>
                        <span class="s1">call_var </span><span class="s3">= </span><span class="s1">reverse_call_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
                        <span class="s1">call_table</span><span class="s3">[</span><span class="s1">call_var</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">call_table_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                    <span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">call_table</span><span class="s3">, </span><span class="s1">reverse_call_table</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">call_table</span><span class="s3">, </span><span class="s1">reverse_call_table</span>


<span class="s0"># other packages that define new nodes add calls to get tuple table</span>
<span class="s0"># format: {type:function}</span>
<span class="s1">tuple_table_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">get_tuple_table</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">tuple_table</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;returns a dictionary of tuple variables and their values. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">tuple_table </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">tuple_table </span><span class="s3">= {}</span>

    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_tuple'</span><span class="s3">:</span>
                    <span class="s1">tuple_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">items</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                    <span class="s1">tuple_table</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">tuple_table_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                    <span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">tuple_table</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">tuple_table</span>


<span class="s2">def </span><span class="s1">get_stmt_writes</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s1">writes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">)):</span>
        <span class="s1">writes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">writes</span>


<span class="s2">def </span><span class="s1">rename_labels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;rename labels of function body blocks according to topological sort. 
    The set of labels of these blocks will remain unchanged. 
    &quot;&quot;&quot;</span>
    <span class="s1">topo_order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>

    <span class="s0"># make a block with return last if available (just for readability)</span>
    <span class="s1">return_label </span><span class="s3">= -</span><span class="s4">1</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
            <span class="s1">return_label </span><span class="s3">= </span><span class="s1">l</span>
    <span class="s0"># some cases like generators can have no return blocks</span>
    <span class="s2">if </span><span class="s1">return_label </span><span class="s3">!= -</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">topo_order</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">return_label</span><span class="s3">)</span>
        <span class="s1">topo_order</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">return_label</span><span class="s3">)</span>

    <span class="s1">label_map </span><span class="s3">= {}</span>
    <span class="s1">all_labels </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">topo_order</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">topo_order</span><span class="s3">:</span>
        <span class="s1">label_map</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">all_labels</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
    <span class="s0"># update target labels in jumps/branches</span>
    <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">terminator</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">):</span>
            <span class="s1">term</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">label_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">target</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">):</span>
            <span class="s1">term</span><span class="s3">.</span><span class="s1">truebr </span><span class="s3">= </span><span class="s1">label_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">truebr</span><span class="s3">]</span>
            <span class="s1">term</span><span class="s3">.</span><span class="s1">falsebr </span><span class="s3">= </span><span class="s1">label_map</span><span class="s3">[</span><span class="s1">term</span><span class="s3">.</span><span class="s1">falsebr</span><span class="s3">]</span>
    <span class="s0"># update blocks dictionary keys</span>
    <span class="s1">new_blocks </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">new_label </span><span class="s3">= </span><span class="s1">label_map</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s1">new_blocks</span><span class="s3">[</span><span class="s1">new_label</span><span class="s3">] = </span><span class="s1">b</span>

    <span class="s2">return </span><span class="s1">new_blocks</span>


<span class="s2">def </span><span class="s1">simplify_CFG</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;transform chains of blocks that have no loop into a single block&quot;&quot;&quot;</span>
    <span class="s0"># first, inline single-branch-block to its predecessors</span>
    <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">find_single_branch</span><span class="s3">(</span><span class="s1">label</span><span class="s3">):</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">)</span>
    <span class="s1">single_branch_blocks </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">find_single_branch</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()))</span>
    <span class="s1">marked_for_del </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">single_branch_blocks</span><span class="s3">:</span>
        <span class="s1">inst </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">].</span><span class="s1">body</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">predecessors </span><span class="s3">= </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">predecessors</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)</span>
        <span class="s1">delete_block </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">q</span><span class="s3">) </span><span class="s2">in </span><span class="s1">predecessors</span><span class="s3">:</span>
            <span class="s1">block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">):</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">delete_block </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">delete_block</span><span class="s3">:</span>
            <span class="s1">marked_for_del</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)</span>
    <span class="s0"># Delete marked labels</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">marked_for_del</span><span class="s3">:</span>
        <span class="s2">del </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
    <span class="s1">merge_adjacent_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">rename_labels</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>


<span class="s1">arr_math </span><span class="s3">= [</span><span class="s5">'min'</span><span class="s3">, </span><span class="s5">'max'</span><span class="s3">, </span><span class="s5">'sum'</span><span class="s3">, </span><span class="s5">'prod'</span><span class="s3">, </span><span class="s5">'mean'</span><span class="s3">, </span><span class="s5">'var'</span><span class="s3">, </span><span class="s5">'std'</span><span class="s3">,</span>
            <span class="s5">'cumsum'</span><span class="s3">, </span><span class="s5">'cumprod'</span><span class="s3">, </span><span class="s5">'argmax'</span><span class="s3">, </span><span class="s5">'argmin'</span><span class="s3">, </span><span class="s5">'argsort'</span><span class="s3">,</span>
            <span class="s5">'nonzero'</span><span class="s3">, </span><span class="s5">'ravel'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">canonicalize_array_math</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">):</span>
    <span class="s0"># save array arg to call</span>
    <span class="s0"># call_varname -&gt; array</span>
    <span class="s1">blocks </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span>
    <span class="s1">saved_arr_arg </span><span class="s3">= {}</span>
    <span class="s1">topo_order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">topo_order</span><span class="s3">:</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s1">new_body </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s0"># replace A.func with np.func, and save A in saved_arr_arg</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr' </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">attr </span><span class="s2">in </span><span class="s1">arr_math</span>
                        <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
                            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">npytypes</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)):</span>
                    <span class="s1">rhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
                    <span class="s1">arr </span><span class="s3">= </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span>
                    <span class="s1">saved_arr_arg</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">arr</span>
                    <span class="s1">scope </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">scope</span>
                    <span class="s1">loc </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">loc</span>
                    <span class="s0"># g_np_var = Global(numpy)</span>
                    <span class="s1">g_np_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$np_g_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_np_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">)</span>
                    <span class="s1">g_np </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s5">'np'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s1">g_np_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">g_np</span><span class="s3">, </span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s1">rhs</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">g_np_var</span>
                    <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">g_np_assign</span><span class="s3">)</span>
                    <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">g_np_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = [</span><span class="s1">g_np</span><span class="s3">]</span>
                    <span class="s0"># update func var type</span>
                    <span class="s1">func </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
                    <span class="s1">func_typ </span><span class="s3">= </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
                    <span class="s1">typemap</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
                    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">] = </span><span class="s1">func_typ</span>
                <span class="s2">if </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call' </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">saved_arr_arg</span><span class="s3">:</span>
                    <span class="s0"># add array as first arg</span>
                    <span class="s1">arr </span><span class="s3">= </span><span class="s1">saved_arr_arg</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                    <span class="s0"># update call type signature to include array arg</span>
                    <span class="s1">old_sig </span><span class="s3">= </span><span class="s1">calltypes</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">)</span>
                    <span class="s0"># argsort requires kws for typing so sig.args can't be used</span>
                    <span class="s0"># reusing sig.args since some types become Const in sig</span>
                    <span class="s1">argtyps </span><span class="s3">= </span><span class="s1">old_sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)]</span>
                    <span class="s1">kwtyps </span><span class="s3">= {</span><span class="s1">name</span><span class="s3">: </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">}</span>
                    <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">] = </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get_call_type</span><span class="s3">(</span>
                        <span class="s1">typingctx</span><span class="s3">, [</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">argtyps</span><span class="s3">), </span><span class="s1">kwtyps</span><span class="s3">)</span>
                    <span class="s1">rhs</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= [</span><span class="s1">arr</span><span class="s3">] + </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">args</span>

            <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">new_body</span>
    <span class="s2">return</span>


<span class="s0"># format: {type:function}</span>
<span class="s1">array_accesses_extensions </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">get_array_accesses</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">accesses</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;returns a set of arrays accessed and their indices. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">accesses </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">accesses </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
                <span class="s1">accesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">):</span>
                <span class="s1">accesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">lhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getitem'</span><span class="s3">:</span>
                    <span class="s1">accesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">((</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'static_getitem'</span><span class="s3">:</span>
                    <span class="s1">index </span><span class="s3">= </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">index</span>
                    <span class="s0"># slice is unhashable, so just keep the variable</span>
                    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None or </span><span class="s1">is_slice_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">):</span>
                        <span class="s1">index </span><span class="s3">= </span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s1">accesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">((</span><span class="s1">rhs</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">index</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">T</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">array_accesses_extensions</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">T</span><span class="s3">):</span>
                    <span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">accesses</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">accesses</span>

<span class="s2">def </span><span class="s1">is_slice_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;see if index is a slice index or has slice in it&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">index</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
                <span class="s2">return True</span>
    <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">merge_adjacent_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s0"># merge adjacent blocks</span>
    <span class="s1">removed </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
        <span class="s2">if </span><span class="s1">label </span><span class="s2">in </span><span class="s1">removed</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s1">succs </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">successors</span><span class="s3">(</span><span class="s1">label</span><span class="s3">))</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">succs</span><span class="s3">) != </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s2">break</span>
            <span class="s1">next_label </span><span class="s3">= </span><span class="s1">succs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">next_label </span><span class="s2">in </span><span class="s1">removed</span><span class="s3">:</span>
                <span class="s2">break</span>
            <span class="s1">preds </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">predecessors</span><span class="s3">(</span><span class="s1">next_label</span><span class="s3">))</span>
            <span class="s1">succs </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">successors</span><span class="s3">(</span><span class="s1">next_label</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">preds</span><span class="s3">) != </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">preds</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] != </span><span class="s1">label</span><span class="s3">:</span>
                <span class="s2">break</span>
            <span class="s1">next_block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">next_label</span><span class="s3">]</span>
            <span class="s0"># XXX: commented out since scope objects are not consistent</span>
            <span class="s0"># throughout the compiler. for example, pieces of code are compiled</span>
            <span class="s0"># and inlined on the fly without proper scope merge.</span>
            <span class="s0"># if block.scope != next_block.scope:</span>
            <span class="s0">#     break</span>
            <span class="s0"># merge</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()  </span><span class="s0"># remove Jump</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">+= </span><span class="s1">next_block</span><span class="s3">.</span><span class="s1">body</span>
            <span class="s2">del </span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">next_label</span><span class="s3">]</span>
            <span class="s1">removed</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">next_label</span><span class="s3">)</span>
            <span class="s1">label </span><span class="s3">= </span><span class="s1">next_label</span>


<span class="s2">def </span><span class="s1">restore_copy_var_names</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">save_copies</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    restores variable names of user variables after applying copy propagation 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">save_copies</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s1">rename_dict </span><span class="s3">= {}</span>
    <span class="s1">var_rename_map </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) </span><span class="s2">in </span><span class="s1">save_copies</span><span class="s3">:</span>
        <span class="s0"># a is string name, b is variable</span>
        <span class="s0"># if a is user variable and b is generated temporary and b is not</span>
        <span class="s0"># already renamed</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'$'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">b</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'$'</span><span class="s3">)</span>
                                                <span class="s2">and </span><span class="s1">b</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">rename_dict</span><span class="s3">):</span>
            <span class="s1">new_name </span><span class="s3">= </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">'${}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span><span class="s1">;</span>
            <span class="s1">rename_dict</span><span class="s3">[</span><span class="s1">b</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">new_name</span>
            <span class="s1">var_rename_map</span><span class="s3">[</span><span class="s1">new_name</span><span class="s3">] = </span><span class="s1">a</span>
            <span class="s1">typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">new_name</span><span class="s3">] = </span><span class="s1">typ</span>

    <span class="s1">replace_var_names</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">rename_dict</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">var_rename_map</span>


<span class="s2">def </span><span class="s1">simplify</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">):</span>
    <span class="s0"># get copies in to blocks and out from blocks</span>
    <span class="s1">in_cps</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">copy_propagate</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
    <span class="s0"># table mapping variable names to ir.Var objects to help replacement</span>
    <span class="s1">name_var_table </span><span class="s3">= </span><span class="s1">get_name_var_table</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">save_copies </span><span class="s3">= </span><span class="s1">apply_copy_propagate</span><span class="s3">(</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">,</span>
        <span class="s1">in_cps</span><span class="s3">,</span>
        <span class="s1">name_var_table</span><span class="s3">,</span>
        <span class="s1">typemap</span><span class="s3">,</span>
        <span class="s1">calltypes</span><span class="s3">)</span>
    <span class="s1">var_rename_map </span><span class="s3">= </span><span class="s1">restore_copy_var_names</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">save_copies</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s5">&quot;var_rename_map&quot; </span><span class="s2">not in </span><span class="s1">metadata</span><span class="s3">:</span>
            <span class="s1">metadata</span><span class="s3">[</span><span class="s5">&quot;var_rename_map&quot;</span><span class="s3">] = {}</span>
    <span class="s1">metadata</span><span class="s3">[</span><span class="s5">&quot;var_rename_map&quot;</span><span class="s3">].</span><span class="s1">update</span><span class="s3">(</span><span class="s1">var_rename_map</span><span class="s3">)</span>
    <span class="s0"># remove dead code to enable fusion</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">dprint_func_ir</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s5">&quot;after copy prop&quot;</span><span class="s3">)</span>
    <span class="s1">remove_dead</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
    <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">simplify_CFG</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_ARRAY_OPT </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">dprint_func_ir</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s5">&quot;after simplify&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">GuardException</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">require</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Raise GuardException if the given condition is False. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">cond</span><span class="s3">:</span>
       <span class="s2">raise </span><span class="s1">GuardException</span>

<span class="s2">def </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Run a function with given set of arguments, and guard against 
    any GuardException raised by the function by returning None, 
    or the expected return results if no such exception was raised. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">GuardException</span><span class="s3">:</span>
        <span class="s2">return None</span>

<span class="s2">def </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Same as func_ir.get_definition(name), but raise GuardException if 
    exception KeyError is caught. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">GuardException</span>

<span class="s2">def </span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Build the definitions table of the given blocks by scanning 
    through all blocks and instructions, useful when the definitions 
    table is out-of-sync. 
    Will return a new definition table if one is not passed. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">definitions </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">definitions </span><span class="s3">= </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                <span class="s1">name </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s1">definition </span><span class="s3">= </span><span class="s1">definitions</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, [])</span>
                <span class="s2">if </span><span class="s1">definition </span><span class="s3">== []:</span>
                    <span class="s1">definitions</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">definition</span>
                <span class="s1">definition</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">) </span><span class="s2">in </span><span class="s1">build_defs_extensions</span><span class="s3">:</span>
                <span class="s1">f </span><span class="s3">= </span><span class="s1">build_defs_extensions</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)]</span>
                <span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">definitions</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">definitions</span>

<span class="s1">build_defs_extensions </span><span class="s3">= {}</span>

<span class="s2">def </span><span class="s1">find_callname</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">definition_finder</span><span class="s3">=</span><span class="s1">get_definition</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Try to find a call expression's function and module names and return 
    them as strings for unbounded calls. If the call is a bounded call, return 
    the self object instead of module name. Raise GuardException if failed. 
 
    Providing typemap can make the call matching more accurate in corner cases 
    such as bounded call on an object which is inside another object. 
    &quot;&quot;&quot;</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">)</span>
    <span class="s1">callee </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">func</span>
    <span class="s1">callee_def </span><span class="s3">= </span><span class="s1">definition_finder</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">)</span>
    <span class="s1">attrs </span><span class="s3">= []</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)):</span>
            <span class="s0"># require(callee_def.value == numpy)</span>
            <span class="s0"># these checks support modules like numpy, numpy.random as well as</span>
            <span class="s0"># calls like len() and intrinsics like assertEquiv</span>
            <span class="s1">keys </span><span class="s3">= [</span><span class="s5">'name'</span><span class="s3">, </span><span class="s5">'_name'</span><span class="s3">, </span><span class="s5">'__name__'</span><span class="s3">]</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
                    <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
                    <span class="s2">break</span>
            <span class="s2">if not </span><span class="s1">value </span><span class="s2">or not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">GuardException</span>
            <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">def_val </span><span class="s3">= </span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s0"># get the underlying definition of Intrinsic object to be able to</span>
            <span class="s0"># find the module effectively.</span>
            <span class="s0"># Otherwise, it will return numba.extending</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">def_val</span><span class="s3">, </span><span class="s1">_Intrinsic</span><span class="s3">):</span>
                <span class="s1">def_val </span><span class="s3">= </span><span class="s1">def_val</span><span class="s3">.</span><span class="s1">_defn</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">def_val</span><span class="s3">, </span><span class="s5">'__module__'</span><span class="s3">):</span>
                <span class="s1">mod_name </span><span class="s3">= </span><span class="s1">def_val</span><span class="s3">.</span><span class="s1">__module__</span>
                <span class="s0"># The reason for first checking if the function is in NumPy's</span>
                <span class="s0"># top level name space by module is that some functions are</span>
                <span class="s0"># deprecated in NumPy but the functions' names are aliased with</span>
                <span class="s0"># other common names. This prevents deprecation warnings on</span>
                <span class="s0"># e.g. getattr(numpy, 'bool') were a bool the target.</span>
                <span class="s0"># For context see #6175, impacts NumPy&gt;=1.20.</span>
                <span class="s1">mod_not_none </span><span class="s3">= </span><span class="s1">mod_name </span><span class="s2">is not None</span>
                <span class="s1">numpy_toplevel </span><span class="s3">= (</span><span class="s1">mod_not_none </span><span class="s2">and</span>
                                  <span class="s3">(</span><span class="s1">mod_name </span><span class="s3">== </span><span class="s5">'numpy'</span>
                                   <span class="s2">or </span><span class="s1">mod_name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'numpy.'</span><span class="s3">)))</span>
                <span class="s0"># it might be a numpy function imported directly</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">numpy_toplevel </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
                        <span class="s2">and </span><span class="s1">def_val </span><span class="s3">== </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)):</span>
                    <span class="s1">attrs </span><span class="s3">+= [</span><span class="s5">'numpy'</span><span class="s3">]</span>
                <span class="s0"># it might be a np.random function imported directly</span>
                <span class="s2">elif </span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">random</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
                        <span class="s2">and </span><span class="s1">def_val </span><span class="s3">== </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">random</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)):</span>
                    <span class="s1">attrs </span><span class="s3">+= [</span><span class="s5">'random'</span><span class="s3">, </span><span class="s5">'numpy'</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">mod_not_none</span><span class="s3">:</span>
                    <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">mod_name</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">class_name </span><span class="s3">= </span><span class="s1">def_val</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
                <span class="s2">if </span><span class="s1">class_name </span><span class="s3">== </span><span class="s5">'builtin_function_or_method'</span><span class="s3">:</span>
                    <span class="s1">class_name </span><span class="s3">= </span><span class="s5">'builtin'</span>
                <span class="s2">if </span><span class="s1">class_name </span><span class="s3">!= </span><span class="s5">'module'</span><span class="s3">:</span>
                    <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">class_name</span><span class="s3">)</span>
            <span class="s2">break</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span><span class="s3">:</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">typemap </span><span class="s2">and </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">typemap</span><span class="s3">:</span>
                <span class="s1">typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">attrs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">obj</span>
            <span class="s1">callee_def </span><span class="s3">= </span><span class="s1">definition_finder</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># obj.func calls where obj is not np array</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s5">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">)), </span><span class="s1">obj</span>
            <span class="s2">raise </span><span class="s1">GuardException</span>
    <span class="s2">return </span><span class="s1">attrs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s5">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:]))</span>

<span class="s2">def </span><span class="s1">find_build_sequence</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Check if a variable is constructed via build_tuple or 
    build_list or build_set, and return the sequence and the 
    operator, or raise GuardException otherwise. 
    Note: only build_tuple is immutable, so use with care. 
    &quot;&quot;&quot;</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">))</span>
    <span class="s1">var_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">))</span>
    <span class="s1">build_ops </span><span class="s3">= [</span><span class="s5">'build_tuple'</span><span class="s3">, </span><span class="s5">'build_list'</span><span class="s3">, </span><span class="s5">'build_set'</span><span class="s3">]</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">var_def</span><span class="s3">.</span><span class="s1">op </span><span class="s2">in </span><span class="s1">build_ops</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">var_def</span><span class="s3">.</span><span class="s1">items</span><span class="s3">, </span><span class="s1">var_def</span><span class="s3">.</span><span class="s1">op</span>

<span class="s2">def </span><span class="s1">find_const</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Check if a variable is defined as constant, and return 
    the constant value, or raise GuardException otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">))</span>
    <span class="s1">var_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var_def</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)))</span>
    <span class="s2">return </span><span class="s1">var_def</span><span class="s3">.</span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">compile_to_numba_ir</span><span class="s3">(</span><span class="s1">mk_func</span><span class="s3">, </span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">arg_typs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compile a function or a make_function node to Numba IR. 
 
    Rename variables and 
    labels to avoid conflict if inlined somewhere else. Perform type inference 
    if typingctx and other typing inputs are available and update typemap and 
    calltypes. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">typed_passes</span>
    <span class="s0"># mk_func can be actual function or make_function node, or a njit function</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">mk_func</span><span class="s3">, </span><span class="s5">'code'</span><span class="s3">):</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">mk_func</span><span class="s3">.</span><span class="s1">code</span>
    <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">mk_func</span><span class="s3">, </span><span class="s5">'__code__'</span><span class="s3">):</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">mk_func</span><span class="s3">.</span><span class="s1">__code__</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">&quot;function type not recognized {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">mk_func</span><span class="s3">))</span>
    <span class="s1">f_ir </span><span class="s3">= </span><span class="s1">get_ir_of_code</span><span class="s3">(</span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">code</span><span class="s3">)</span>
    <span class="s1">remove_dels</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>

    <span class="s0"># relabel by adding an offset</span>
    <span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">add_offset_to_labels</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">next</span><span class="s3">())</span>
    <span class="s1">max_label </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">max_label</span><span class="s3">)</span>

    <span class="s0"># rename all variables to avoid conflict</span>
    <span class="s1">var_table </span><span class="s3">= </span><span class="s1">get_name_var_table</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">new_var_dict </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">var </span><span class="s2">in </span><span class="s1">var_table</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">new_var_dict</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">replace_var_names</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">new_var_dict</span><span class="s3">)</span>

    <span class="s0"># perform type inference if typingctx is available and update type</span>
    <span class="s0"># data structures typemap and calltypes</span>
    <span class="s2">if </span><span class="s1">typingctx</span><span class="s3">:</span>
        <span class="s1">f_typemap</span><span class="s3">, </span><span class="s1">f_return_type</span><span class="s3">, </span><span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">typed_passes</span><span class="s3">.</span><span class="s1">type_inference_stage</span><span class="s3">(</span>
                <span class="s1">typingctx</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">f_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s0"># remove argument entries like arg.a from typemap</span>
        <span class="s1">arg_names </span><span class="s3">= [</span><span class="s1">vname </span><span class="s2">for </span><span class="s1">vname </span><span class="s2">in </span><span class="s1">f_typemap </span><span class="s2">if </span><span class="s1">vname</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">&quot;arg.&quot;</span><span class="s3">)]</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arg_names</span><span class="s3">:</span>
            <span class="s1">f_typemap</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">typemap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_typemap</span><span class="s3">)</span>
        <span class="s1">calltypes</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_calltypes</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">f_ir</span>

<span class="s2">def </span><span class="s1">_create_function_from_code_obj</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">, </span><span class="s1">func_env</span><span class="s3">, </span><span class="s1">func_arg</span><span class="s3">, </span><span class="s1">func_clo</span><span class="s3">, </span><span class="s1">glbls</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Creates a function from a code object. Args: 
    * fcode - the code object 
    * func_env - string for the freevar placeholders 
    * func_arg - string for the function args (e.g. &quot;a, b, c, d=None&quot;) 
    * func_clo - string for the closure args 
    * glbls - the function globals 
    &quot;&quot;&quot;</span>
    <span class="s1">sanitized_co_name </span><span class="s3">= </span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s5">'_'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'&gt;'</span><span class="s3">, </span><span class="s5">'_'</span><span class="s3">)</span>
    <span class="s1">func_text </span><span class="s3">= (</span><span class="s5">f&quot;def closure():</span><span class="s2">\n{</span><span class="s1">func_env</span><span class="s2">}\n</span><span class="s5">&quot;</span>
                 <span class="s5">f&quot;</span><span class="s2">\t</span><span class="s5">def </span><span class="s2">{</span><span class="s1">sanitized_co_name</span><span class="s2">}</span><span class="s5">(</span><span class="s2">{</span><span class="s1">func_arg</span><span class="s2">}</span><span class="s5">):</span><span class="s2">\n</span><span class="s5">&quot;</span>
                 <span class="s5">f&quot;</span><span class="s2">\t\t</span><span class="s5">return (</span><span class="s2">{</span><span class="s1">func_clo</span><span class="s2">}</span><span class="s5">)</span><span class="s2">\n</span><span class="s5">&quot;</span>
                 <span class="s5">f&quot;</span><span class="s2">\t</span><span class="s5">return </span><span class="s2">{</span><span class="s1">sanitized_co_name</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s1">loc </span><span class="s3">= {}</span>
    <span class="s1">exec</span><span class="s3">(</span><span class="s1">func_text</span><span class="s3">, </span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s1">f </span><span class="s3">= </span><span class="s1">loc</span><span class="s3">[</span><span class="s5">'closure'</span><span class="s3">]()</span>
    <span class="s0"># replace the code body</span>
    <span class="s1">f</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s3">= </span><span class="s1">fcode</span>
    <span class="s1">f</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_name</span>
    <span class="s2">return </span><span class="s1">f</span>

<span class="s2">def </span><span class="s1">get_ir_of_code</span><span class="s3">(</span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">fcode</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compile a code object to get its IR, ir.Del nodes are emitted 
    &quot;&quot;&quot;</span>
    <span class="s1">nfree </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">)</span>
    <span class="s1">func_env </span><span class="s3">= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;</span><span class="s2">\t</span><span class="s5">c_%d = None&quot; </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nfree</span><span class="s3">)])</span>
    <span class="s1">func_clo </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;c_%d&quot; </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nfree</span><span class="s3">)])</span>
    <span class="s1">func_arg </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;x_%d&quot; </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_argcount</span><span class="s3">)])</span>

    <span class="s1">f </span><span class="s3">= </span><span class="s1">_create_function_from_code_obj</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">, </span><span class="s1">func_env</span><span class="s3">, </span><span class="s1">func_arg</span><span class="s3">, </span><span class="s1">func_clo</span><span class="s3">,</span>
                                       <span class="s1">glbls</span><span class="s3">)</span>

    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">compiler</span>
    <span class="s1">ir </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">run_frontend</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
    <span class="s0"># we need to run the before inference rewrite pass to normalize the IR</span>
    <span class="s0"># XXX: check rewrite pass flag?</span>
    <span class="s0"># for example, Raise nodes need to become StaticRaise before type inference</span>
    <span class="s2">class </span><span class="s1">DummyPipeline</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">f_ir</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">StateDict</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir </span><span class="s3">= </span><span class="s1">f_ir</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">state </span><span class="s3">= </span><span class="s1">DummyPipeline</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">).</span><span class="s1">state</span>
    <span class="s1">rewrites</span><span class="s3">.</span><span class="s1">rewrite_registry</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s5">'before-inference'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">)</span>
    <span class="s0"># call inline pass to handle cases like stencils and comprehensions</span>
    <span class="s1">swapped </span><span class="s3">= {} </span><span class="s0"># TODO: get this from diagnostics store</span>
    <span class="s2">import </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">inline_closurecall</span>
    <span class="s1">inline_pass </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">inline_closurecall</span><span class="s3">.</span><span class="s1">InlineClosureCallPass</span><span class="s3">(</span>
        <span class="s1">ir</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">cpu</span><span class="s3">.</span><span class="s1">ParallelOptions</span><span class="s3">(</span><span class="s2">False</span><span class="s3">), </span><span class="s1">swapped</span><span class="s3">)</span>
    <span class="s1">inline_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>

    <span class="s0"># TODO: DO NOT ADD MORE THINGS HERE!</span>
    <span class="s0"># If adding more things here is being contemplated, it really is time to</span>
    <span class="s0"># retire this function and work on getting the InlineWorker class from</span>
    <span class="s0"># numba.core.inline_closurecall into sufficient shape as a replacement.</span>
    <span class="s0"># The issue with `get_ir_of_code` is that it doesn't run a full compilation</span>
    <span class="s0"># pipeline and as a result various additional things keep needing to be</span>
    <span class="s0"># added to create valid IR.</span>

    <span class="s0"># rebuild IR in SSA form</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">untyped_passes </span><span class="s2">import </span><span class="s1">ReconstructSSA</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typed_passes </span><span class="s2">import </span><span class="s1">PreLowerStripPhis</span>
    <span class="s1">reconstruct_ssa </span><span class="s3">= </span><span class="s1">ReconstructSSA</span><span class="s3">()</span>
    <span class="s1">phistrip </span><span class="s3">= </span><span class="s1">PreLowerStripPhis</span><span class="s3">()</span>
    <span class="s1">reconstruct_ssa</span><span class="s3">.</span><span class="s1">run_pass</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
    <span class="s1">phistrip</span><span class="s3">.</span><span class="s1">run_pass</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>

    <span class="s1">post_proc </span><span class="s3">= </span><span class="s1">postproc</span><span class="s3">.</span><span class="s1">PostProcessor</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">)</span>
    <span class="s1">post_proc</span><span class="s3">.</span><span class="s1">run</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ir</span>

<span class="s2">def </span><span class="s1">replace_arg_nodes</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Replace ir.Arg(...) with variables 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index</span>
            <span class="s2">assert</span><span class="s3">(</span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>
            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>
    <span class="s2">return</span>


<span class="s2">def </span><span class="s1">replace_returns</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">return_label</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return return statement by assigning directly to target, and a jump. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s0"># some blocks may be empty during transformations</span>
        <span class="s2">if not </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">stmt </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">terminator</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()  </span><span class="s0"># remove return</span>
            <span class="s1">cast_stmt </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cast_stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cast_stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">cast_stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'cast'</span><span class="s3">), </span><span class="s5">&quot;invalid return cast&quot;</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">cast_stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">return_label</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">gen_np_call</span><span class="s3">(</span><span class="s1">func_as_str</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">):</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">loc</span>

    <span class="s0"># g_np_var = Global(numpy)</span>
    <span class="s1">g_np_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$np_g_var&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_np_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">)</span>
    <span class="s1">g_np </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s5">'np'</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">g_np_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">g_np</span><span class="s3">, </span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># attr call: &lt;something&gt;_attr = getattr(g_np_var, func_as_str)</span>
    <span class="s1">np_attr_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">func_as_str</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">attr_var </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">mk_unique_var</span><span class="s3">(</span><span class="s5">&quot;$np_attr_attr&quot;</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">func_var_typ </span><span class="s3">= </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
    <span class="s1">typemap</span><span class="s3">[</span><span class="s1">attr_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">func_var_typ</span>
    <span class="s1">attr_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">np_attr_call</span><span class="s3">, </span><span class="s1">attr_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0"># np call: lhs = np_attr(*args)</span>
    <span class="s1">np_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">attr_var</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, (), </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">arg_types </span><span class="s3">= [</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">x</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
    <span class="s1">func_typ </span><span class="s3">= </span><span class="s1">func_var_typ</span><span class="s3">.</span><span class="s1">get_call_type</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arg_types</span><span class="s3">, {})</span>
    <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">np_call</span><span class="s3">] = </span><span class="s1">func_typ</span>
    <span class="s1">np_assign </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">np_call</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">g_np_assign</span><span class="s3">, </span><span class="s1">attr_assign</span><span class="s3">, </span><span class="s1">np_assign</span><span class="s3">]</span>

<span class="s2">def </span><span class="s1">dump_block</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s5">&quot;:&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;    &quot;</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">dump_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">dump_block</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">block</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">is_operator_or_getitem</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;true if expr is unary or binary operator or getitem&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s5">'op'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'unary'</span><span class="s3">, </span><span class="s5">'binop'</span><span class="s3">, </span><span class="s5">'inplace_binop'</span><span class="s3">, </span><span class="s5">'getitem'</span><span class="s3">, </span><span class="s5">'static_getitem'</span><span class="s3">])</span>

<span class="s2">def </span><span class="s1">is_get_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;stmt is getitem assignment or setitem (and static cases)&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">is_getitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_getitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;true if stmt is a getitem or static_getitem assignment&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'getitem'</span><span class="s3">, </span><span class="s5">'static_getitem'</span><span class="s3">])</span>

<span class="s2">def </span><span class="s1">is_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;true if stmt is a SetItem or StaticSetItem node&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">))</span>

<span class="s2">def </span><span class="s1">index_var_of_get_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;get index variable for getitem/setitem nodes (and static cases)&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_getitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getitem'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index_var</span>

    <span class="s2">if </span><span class="s1">is_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index_var</span>

    <span class="s2">return None</span>

<span class="s2">def </span><span class="s1">set_index_var_of_get_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">new_index</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">is_getitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getitem'</span><span class="s3">:</span>
            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">new_index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index_var </span><span class="s3">= </span><span class="s1">new_index</span>
    <span class="s2">elif </span><span class="s1">is_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">new_index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">index_var </span><span class="s3">= </span><span class="s1">new_index</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;getitem or setitem node expected but received {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                     <span class="s1">stmt</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">is_namedtuple_class</span><span class="s3">(</span><span class="s1">c</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;check if c is a namedtuple class&quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s0"># should have only tuple as superclass</span>
    <span class="s1">bases </span><span class="s3">= </span><span class="s1">c</span><span class="s3">.</span><span class="s1">__bases__</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bases</span><span class="s3">) != </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">bases</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] != </span><span class="s1">tuple</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s0"># should have _make method</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s5">'_make'</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s0"># should have _fields that is all string</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s5">'_fields'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fields</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fill_block_with_call</span><span class="s3">(</span><span class="s1">newblock</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">label_next</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Fill *newblock* to call *callee* with arguments listed in *inputs*. 
    The returned values are unwrapped into variables in *outputs*. 
    The block would then jump to *label_next*. 
    &quot;&quot;&quot;</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">newblock</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s3">= </span><span class="s1">newblock</span><span class="s3">.</span><span class="s1">loc</span>

    <span class="s1">fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">fnvar </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">make_temp</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">newblock</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">fnvar</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s0"># call</span>
    <span class="s1">args </span><span class="s3">= [</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">]</span>
    <span class="s1">callexpr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">func</span><span class="s3">=</span><span class="s1">fnvar</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">=(), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">callres </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">make_temp</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">newblock</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">callres</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">callexpr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s0"># unpack return value</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">out </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">):</span>
        <span class="s1">target </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s1">getitem </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">static_getitem</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">callres</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">i</span><span class="s3">,</span>
                                         <span class="s1">index_var</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">newblock</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s0"># jump to next block</span>
    <span class="s1">newblock</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">label_next</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">newblock</span>


<span class="s2">def </span><span class="s1">fill_callee_prologue</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">label_next</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Fill a new block *block* that unwraps arguments using names in *inputs* and 
    then jumps to *label_next*. 
 
    Expected to use with *fill_block_with_call()* 
    &quot;&quot;&quot;</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">loc</span>
    <span class="s0"># load args</span>
    <span class="s1">args </span><span class="s3">= [</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">i</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">)]</span>
    <span class="s2">for </span><span class="s1">aname</span><span class="s3">, </span><span class="s1">aval </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">aname</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">aval</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s0"># jump to loop entry</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">label_next</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">block</span>


<span class="s2">def </span><span class="s1">fill_callee_epilogue</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Fill a new block *block* to prepare the return values. 
    This block is the last block of the function. 
 
    Expected to use with *fill_block_with_call()* 
    &quot;&quot;&quot;</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">loc</span>
    <span class="s0"># prepare tuples to return</span>
    <span class="s1">vals </span><span class="s3">= [</span><span class="s1">scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">outputs</span><span class="s3">]</span>
    <span class="s1">tupexpr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">build_tuple</span><span class="s3">(</span><span class="s1">items</span><span class="s3">=</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">tup </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">make_temp</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">tupexpr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s0"># return</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">block</span>


<span class="s2">def </span><span class="s1">find_outer_value</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Check if a variable is a global value, and return the value, 
    or raise GuardException otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">dfn </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dfn</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">dfn</span><span class="s3">.</span><span class="s1">value</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dfn</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dfn</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span><span class="s3">:</span>
        <span class="s1">prev_val </span><span class="s3">= </span><span class="s1">find_outer_value</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">dfn</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">prev_val</span><span class="s3">, </span><span class="s1">dfn</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">val</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GuardException</span>

    <span class="s2">raise </span><span class="s1">GuardException</span>


<span class="s2">def </span><span class="s1">raise_on_unsupported_feature</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Helper function to walk IR and raise if it finds op codes 
    that are unsupported. Could be extended to cover IR sequences 
    as well as op codes. Intended use is to call it as a pipeline 
    stage just prior to lowering to prevent LoweringErrors for known 
    unsupported features. 
    &quot;&quot;&quot;</span>
    <span class="s1">gdb_calls </span><span class="s3">= [] </span><span class="s0"># accumulate calls to gdb/gdb_init</span>

    <span class="s0"># issue 2195: check for excessively large tuples</span>
    <span class="s2">for </span><span class="s1">arg_name </span><span class="s2">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">arg_name </span><span class="s2">in </span><span class="s1">typemap </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">arg_name</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s1">typemap</span><span class="s3">[</span><span class="s1">arg_name</span><span class="s3">].</span><span class="s1">count </span><span class="s3">&gt; </span><span class="s4">1000</span><span class="s3">:</span>
            <span class="s0"># Raise an exception when len(tuple) &gt; 1000. The choice of this number (1000)</span>
            <span class="s0"># was entirely arbitrary</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Tuple '{}' length must be smaller than 1000.</span><span class="s2">\n</span><span class="s5">&quot;</span>
                   <span class="s5">&quot;Large tuples lead to the generation of a prohibitively large &quot;</span>
                   <span class="s5">&quot;LLVM IR which causes excessive memory pressure &quot;</span>
                   <span class="s5">&quot;and large compile times.</span><span class="s2">\n</span><span class="s5">&quot;</span>
                   <span class="s5">&quot;As an alternative, the use of a 'list' is recommended in &quot;</span>
                   <span class="s5">&quot;place of a 'tuple' as lists do not suffer from this problem.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">arg_name</span><span class="s3">))</span>
            <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s0"># This raises on finding `make_function`</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'make_function'</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>

                    <span class="s0"># See if the construct name can be refined</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">'code'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">code </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s0"># check if this is a closure, the co_name will</span>
                        <span class="s0"># be the captured function name which is not</span>
                        <span class="s0"># useful so be explicit</span>
                        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">'closure'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
                            <span class="s1">use </span><span class="s3">= </span><span class="s5">'&lt;creating a function from a closure&gt;'</span>
                            <span class="s1">expr </span><span class="s3">= </span><span class="s5">''</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">use </span><span class="s3">= </span><span class="s1">code</span><span class="s3">.</span><span class="s1">co_name</span>
                            <span class="s1">expr </span><span class="s3">= </span><span class="s5">'(%s) ' </span><span class="s3">% </span><span class="s1">use</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">use </span><span class="s3">= </span><span class="s5">'&lt;could not ascertain use case&gt;'</span>
                        <span class="s1">expr </span><span class="s3">= </span><span class="s5">''</span>

                    <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Numba encountered the use of a language &quot;</span>
                            <span class="s5">&quot;feature it does not support in this context: &quot;</span>
                            <span class="s5">&quot;%s (op code: make_function not supported). If &quot;</span>
                            <span class="s5">&quot;the feature is explicitly supported it is &quot;</span>
                            <span class="s5">&quot;likely that the result of the expression %s&quot;</span>
                            <span class="s5">&quot;is being used in an unsupported manner.&quot;</span><span class="s3">) % </span><span class="s1">\</span>
                            <span class="s3">(</span><span class="s1">use</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

            <span class="s0"># this checks for gdb initialization calls, only one is permitted</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)):</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">'value'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s2">continue</span>

                <span class="s0"># check global function</span>
                <span class="s1">found </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
                    <span class="s1">found </span><span class="s3">= </span><span class="s1">val </span><span class="s2">in </span><span class="s3">{</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">gdb</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">gdb_init</span><span class="s3">}</span>
                <span class="s2">if not </span><span class="s1">found</span><span class="s3">: </span><span class="s0"># freevar bind to intrinsic</span>
                    <span class="s1">found </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">'_name'</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">) == </span><span class="s5">&quot;gdb_internal&quot;</span>
                <span class="s2">if </span><span class="s1">found</span><span class="s3">:</span>
                    <span class="s1">gdb_calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">) </span><span class="s0"># report last seen location</span>

            <span class="s0"># this checks that np.&lt;type&gt; was called if view is called</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr' </span><span class="s2">and </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">== </span><span class="s5">'view'</span><span class="s3">:</span>
                    <span class="s1">var </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">var</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                        <span class="s2">continue</span>
                    <span class="s1">df </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
                    <span class="s1">cn </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">df</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">cn </span><span class="s2">and </span><span class="s1">cn</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] == </span><span class="s5">'numpy'</span><span class="s3">:</span>
                        <span class="s1">ty </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">cn</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">) </span><span class="s2">or</span>
                                <span class="s1">numpy</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">)):</span>
                            <span class="s2">continue</span>

                    <span class="s1">vardescr </span><span class="s3">= </span><span class="s5">'' </span><span class="s2">if </span><span class="s1">var</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'$'</span><span class="s3">) </span><span class="s2">else </span><span class="s5">&quot;'{}' &quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span>
                        <span class="s5">&quot;'view' can only be called on NumPy dtypes, &quot;</span>
                        <span class="s5">&quot;try wrapping the variable {}with 'np.&lt;dtype&gt;()'&quot;</span><span class="s3">.</span>
                        <span class="s1">format</span><span class="s3">(</span><span class="s1">vardescr</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

            <span class="s0"># checks for globals that are also reflected</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">):</span>
                <span class="s1">ty </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;The use of a %s type, assigned to variable '%s' in &quot;</span>
                       <span class="s5">&quot;globals, is not supported as globals are considered &quot;</span>
                       <span class="s5">&quot;compile-time constants and there is no known way to &quot;</span>
                       <span class="s5">&quot;compile a %s type as a constant.&quot;</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s5">'reflected'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) </span><span class="s2">or</span>
                    <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ListType</span><span class="s3">))):</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

            <span class="s0"># checks for generator expressions (yield in use when func_ir has</span>
            <span class="s0"># not been identified as a generator).</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">is_generator</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;The use of generator expressions is unsupported.&quot;</span>
                <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s0"># There is more than one call to function gdb/gdb_init</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">gdb_calls</span><span class="s3">) &gt; </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Calling either numba.gdb() or numba.gdb_init() more than once &quot;</span>
               <span class="s5">&quot;in a function is unsupported (strange things happen!), use &quot;</span>
               <span class="s5">&quot;numba.gdb_breakpoint() to create additional breakpoints &quot;</span>
               <span class="s5">&quot;instead.</span><span class="s2">\n\n</span><span class="s5">Relevant documentation is available here:</span><span class="s2">\n</span><span class="s5">&quot;</span>
               <span class="s5">&quot;https://numba.readthedocs.io/en/stable/user/troubleshoot.html&quot;</span>
               <span class="s5">&quot;#using-numba-s-direct-gdb-bindings-in-nopython-mode</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
               <span class="s5">&quot;Conflicting calls found at:</span><span class="s2">\n </span><span class="s5">%s&quot;</span><span class="s3">)</span>
        <span class="s1">buf </span><span class="s3">= </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">x</span><span class="s3">.</span><span class="s1">strformat</span><span class="s3">() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">gdb_calls</span><span class="s3">])</span>
        <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">buf</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">warn_deprecated</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s0"># first pass, just walk the type map</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">typemap</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s0"># the Type Metaclass has a reflected member</span>
        <span class="s2">if </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">reflected</span><span class="s3">:</span>
            <span class="s0"># if its an arg, report function call</span>
            <span class="s2">if </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'arg.'</span><span class="s3">):</span>
                <span class="s1">loc </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">loc</span>
                <span class="s1">arg </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)[</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">fname </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func_qualname</span>
                <span class="s1">tyname </span><span class="s3">= </span><span class="s5">'list' </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">) </span><span class="s2">else </span><span class="s5">'set'</span>
                <span class="s1">url </span><span class="s3">= (</span><span class="s5">&quot;https://numba.readthedocs.io/en/stable/reference/&quot;</span>
                       <span class="s5">&quot;deprecation.html#deprecation-of-reflection-for-list-and&quot;</span>
                       <span class="s5">&quot;-set-types&quot;</span><span class="s3">)</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Encountered the use of a type that is scheduled for &quot;</span>
                        <span class="s5">&quot;deprecation: type 'reflected %s' found for argument &quot;</span>
                        <span class="s5">&quot;'%s' of function '%s'.</span><span class="s2">\n\n</span><span class="s5">For more information visit &quot;</span>
                        <span class="s5">&quot;%s&quot; </span><span class="s3">% (</span><span class="s1">tyname</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">url</span><span class="s3">))</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">NumbaPendingDeprecationWarning</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">resolve_func_from_module</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">node</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    This returns the python function that is being getattr'd from a module in 
    some IR, it resolves import chains/submodules recursively. Should it not be 
    possible to find the python function being called None will be returned. 
 
    func_ir - the FunctionIR object 
    node - the IR node from which to start resolving (should be a `getattr`). 
    &quot;&quot;&quot;</span>
    <span class="s1">getattr_chain </span><span class="s3">= []</span>
    <span class="s2">def </span><span class="s1">resolve_mod</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s5">'op'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) == </span><span class="s5">'getattr'</span><span class="s3">:</span>
            <span class="s1">getattr_chain</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">mod </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">: </span><span class="s0"># multiple definitions</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">resolve_mod</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">mod</span>
        <span class="s2">return None</span>

    <span class="s1">mod </span><span class="s3">= </span><span class="s1">resolve_mod</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">mod </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">defn </span><span class="s3">= </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">getattr_chain</span><span class="s3">:</span>
            <span class="s1">defn </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">defn</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">defn</span><span class="s3">:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">defn</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">enforce_no_dels</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Enforce there being no ir.Del nodes in the IR. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">dels </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">dels</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Illegal IR, del found at: %s&quot; </span><span class="s3">% </span><span class="s1">dels</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">raise </span><span class="s1">CompilerError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">dels</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">loc</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">enforce_no_phis</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Enforce there being no ir.Expr.phi nodes in the IR. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">phis </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">find_exprs</span><span class="s3">(</span><span class="s1">op</span><span class="s3">=</span><span class="s5">'phi'</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">phis</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Illegal IR, phi found at: %s&quot; </span><span class="s3">% </span><span class="s1">phis</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">raise </span><span class="s1">CompilerError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">phis</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">legalize_single_scope</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Check the given mapping of ir.Block for containing a single scope. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">len</span><span class="s3">({</span><span class="s1">blk</span><span class="s3">.</span><span class="s1">scope </span><span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()}) == </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">check_and_legalize_ir</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">: </span><span class="s5">&quot;numba.core.compiler.Flags&quot;</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    This checks that the IR presented is legal 
    &quot;&quot;&quot;</span>
    <span class="s1">enforce_no_phis</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">)</span>
    <span class="s1">enforce_no_dels</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">)</span>
    <span class="s0"># postprocess and emit ir.Dels</span>
    <span class="s1">post_proc </span><span class="s3">= </span><span class="s1">postproc</span><span class="s3">.</span><span class="s1">PostProcessor</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">)</span>
    <span class="s1">post_proc</span><span class="s3">.</span><span class="s1">run</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">extend_lifetimes</span><span class="s3">=</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">dbg_extend_lifetimes</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">convert_code_obj_to_function</span><span class="s3">(</span><span class="s1">code_obj</span><span class="s3">, </span><span class="s1">caller_ir</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Converts a code object from a `make_function.code` attr in the IR into a 
    python function, caller_ir is the FunctionIR of the caller and is used for 
    the resolution of freevars. 
    &quot;&quot;&quot;</span>
    <span class="s1">fcode </span><span class="s3">= </span><span class="s1">code_obj</span><span class="s3">.</span><span class="s1">code</span>
    <span class="s1">nfree </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">)</span>

    <span class="s0"># try and resolve freevars if they are consts in the caller's IR</span>
    <span class="s0"># these can be baked into the new function</span>
    <span class="s1">freevars </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">:</span>
        <span class="s0"># not using guard here to differentiate between multiple definition and</span>
        <span class="s0"># non-const variable</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">freevar_def </span><span class="s3">= </span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Cannot capture a constant value for variable '%s' as there &quot;</span>
                   <span class="s5">&quot;are multiple definitions present.&quot; </span><span class="s3">% </span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">code_obj</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">freevar_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">):</span>
            <span class="s1">freevars</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">freevar_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Cannot capture the non-constant value associated with &quot;</span>
                   <span class="s5">&quot;variable '%s' in a function that may escape.&quot; </span><span class="s3">% </span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">code_obj</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s1">func_env </span><span class="s3">= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;</span><span class="s2">\t</span><span class="s5">c_%d = %s&quot; </span><span class="s3">% (</span><span class="s1">i</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">freevars</span><span class="s3">)])</span>
    <span class="s1">func_clo </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;c_%d&quot; </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nfree</span><span class="s3">)])</span>
    <span class="s1">co_varnames </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_varnames</span><span class="s3">)</span>

    <span class="s0"># This is horrible. The code object knows about the number of args present</span>
    <span class="s0"># it also knows the name of the args but these are bundled in with other</span>
    <span class="s0"># vars in `co_varnames`. The make_function IR node knows what the defaults</span>
    <span class="s0"># are, they are defined in the IR as consts. The following finds the total</span>
    <span class="s0"># number of args (args + kwargs with defaults), finds the default values</span>
    <span class="s0"># and infers the number of &quot;kwargs with defaults&quot; from this and then infers</span>
    <span class="s0"># the number of actual arguments from that.</span>
    <span class="s1">n_kwargs </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">n_allargs </span><span class="s3">= </span><span class="s1">fcode</span><span class="s3">.</span><span class="s1">co_argcount</span>
    <span class="s1">kwarg_defaults </span><span class="s3">= </span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">code_obj</span><span class="s3">.</span><span class="s1">defaults</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kwarg_defaults </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kwarg_defaults</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">d </span><span class="s3">= [</span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">value </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">kwarg_defaults</span><span class="s3">]</span>
            <span class="s1">kwarg_defaults_tup </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">d </span><span class="s3">= [</span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">value</span>
                 <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">kwarg_defaults</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
            <span class="s1">kwarg_defaults_tup </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
        <span class="s1">n_kwargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">kwarg_defaults_tup</span><span class="s3">)</span>
    <span class="s1">nargs </span><span class="s3">= </span><span class="s1">n_allargs </span><span class="s3">- </span><span class="s1">n_kwargs</span>

    <span class="s1">func_arg </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;%s&quot; </span><span class="s3">% (</span><span class="s1">co_varnames</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nargs</span><span class="s3">)])</span>
    <span class="s2">if </span><span class="s1">n_kwargs</span><span class="s3">:</span>
        <span class="s1">kw_const </span><span class="s3">= [</span><span class="s5">&quot;%s = %s&quot; </span><span class="s3">% (</span><span class="s1">co_varnames</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s1">nargs</span><span class="s3">], </span><span class="s1">kwarg_defaults_tup</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_kwargs</span><span class="s3">)]</span>
        <span class="s1">func_arg </span><span class="s3">+= </span><span class="s5">&quot;, &quot;</span>
        <span class="s1">func_arg </span><span class="s3">+= </span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">kw_const</span><span class="s3">)</span>

    <span class="s0"># globals are the same as those in the caller</span>
    <span class="s1">glbls </span><span class="s3">= </span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span>

    <span class="s0"># create the function and return it</span>
    <span class="s2">return </span><span class="s1">_create_function_from_code_obj</span><span class="s3">(</span><span class="s1">fcode</span><span class="s3">, </span><span class="s1">func_env</span><span class="s3">, </span><span class="s1">func_arg</span><span class="s3">, </span><span class="s1">func_clo</span><span class="s3">,</span>
                                          <span class="s1">glbls</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fixup_var_define_in_scope</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Fixes the mapping of ir.Block to ensure all referenced ir.Var are 
    defined in every scope used by the function. Such that looking up a variable 
    from any scope in this function will not fail. 
 
    Note: This is a workaround. Ideally, all the blocks should refer to the 
    same ir.Scope, but that property is not maintained by all the passes. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Scan for all used variables</span>
    <span class="s1">used_var </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">scope </span><span class="s3">= </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">scope</span>
        <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">():</span>
                <span class="s1">used_var</span><span class="s3">[</span><span class="s1">var</span><span class="s3">] = </span><span class="s1">inst</span>
    <span class="s0"># Note: not all blocks share a single scope even though they should.</span>
    <span class="s0"># Ensure the scope of each block defines all used variables.</span>
    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">scope </span><span class="s3">= </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">scope</span>
        <span class="s2">for </span><span class="s1">var</span><span class="s3">, </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">used_var</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s0"># add this variable if it's not in scope</span>
            <span class="s2">if </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">:</span>
                <span class="s0"># Note: using a internal method to reuse the same</span>
                <span class="s1">scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">.</span><span class="s1">define</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">transfer_scope</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">scope</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Transfer the ir.Block to use the given ir.Scope. 
    &quot;&quot;&quot;</span>
    <span class="s1">old_scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s2">if </span><span class="s1">old_scope </span><span class="s2">is </span><span class="s1">scope</span><span class="s3">:</span>
        <span class="s0"># bypass if the block is already using the given scope</span>
        <span class="s2">return </span><span class="s1">block</span>
    <span class="s0"># Ensure variables are defined in the new scope</span>
    <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">old_scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">.</span><span class="s1">_con</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">:</span>
            <span class="s1">scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">.</span><span class="s1">define</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>
    <span class="s0"># replace scope</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">= </span><span class="s1">scope</span>
    <span class="s2">return </span><span class="s1">block</span>


<span class="s2">def </span><span class="s1">is_setup_with</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">EnterWith</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_terminator</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Terminator</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_raise</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Raise</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_return</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_pop_block</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PopBlock</span><span class="s3">)</span>
</pre>
</body>
</html>