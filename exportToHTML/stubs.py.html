<html>
<head>
<title>stubs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
stubs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This scripts specifies all PTX special objects. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">Signature</span><span class="s3">, </span><span class="s1">Parameter</span>


<span class="s2">class </span><span class="s1">Stub</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">''' 
    A stub object to represent special objects that are meaningless 
    outside the context of a CUDA kernel 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;ptx special value&gt;'</span>
    <span class="s1">__slots__ </span><span class="s3">= () </span><span class="s5"># don't allocate __dict__</span>

    <span class="s2">def </span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;%s is not instantiable&quot; </span><span class="s3">% </span><span class="s1">cls</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_description_</span>


<span class="s2">def </span><span class="s1">stub_function</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">):</span>
    <span class="s0">''' 
    A stub function to represent special functions that are meaningless 
    outside the context of a CUDA kernel 
    '''</span>
    <span class="s3">@</span><span class="s1">functools</span><span class="s3">.</span><span class="s1">wraps</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">wrapped</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;%s cannot be called from host code&quot; </span><span class="s3">% </span><span class="s1">fn</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># Thread and grid indices and dimensions</span>


<span class="s2">class </span><span class="s1">Dim3</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">'''A triple, (x, y, z)'''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;Dim3&gt;'</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">x</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">y</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">z</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">threadIdx</span><span class="s3">(</span><span class="s1">Dim3</span><span class="s3">):</span>
    <span class="s0">''' 
    The thread indices in the current thread block. Each index is an integer 
    spanning the range from 0 inclusive to the corresponding value of the 
    attribute in :attr:`numba.cuda.blockDim` exclusive. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;threadIdx.{x,y,z}&gt;'</span>


<span class="s2">class </span><span class="s1">blockIdx</span><span class="s3">(</span><span class="s1">Dim3</span><span class="s3">):</span>
    <span class="s0">''' 
    The block indices in the grid of thread blocks. Each index is an integer 
    spanning the range from 0 inclusive to the corresponding value of the 
    attribute in :attr:`numba.cuda.gridDim` exclusive. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;blockIdx.{x,y,z}&gt;'</span>


<span class="s2">class </span><span class="s1">blockDim</span><span class="s3">(</span><span class="s1">Dim3</span><span class="s3">):</span>
    <span class="s0">''' 
    The shape of a block of threads, as declared when instantiating the kernel. 
    This value is the same for all threads in a given kernel launch, even if 
    they belong to different blocks (i.e. each block is &quot;full&quot;). 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;blockDim.{x,y,z}&gt;'</span>


<span class="s2">class </span><span class="s1">gridDim</span><span class="s3">(</span><span class="s1">Dim3</span><span class="s3">):</span>
    <span class="s0">''' 
    The shape of the grid of blocks. This value is the same for all threads in 
    a given kernel launch. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;gridDim.{x,y,z}&gt;'</span>


<span class="s2">class </span><span class="s1">warpsize</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    The size of a warp. All architectures implemented to date have a warp size 
    of 32. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;warpsize&gt;'</span>


<span class="s2">class </span><span class="s1">laneid</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    This thread's lane within a warp. Ranges from 0 to 
    :attr:`numba.cuda.warpsize` - 1. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;laneid&gt;'</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># Array creation</span>

<span class="s2">class </span><span class="s1">shared</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    Shared memory namespace 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;shared&gt;'</span>

    <span class="s3">@</span><span class="s1">stub_function</span>
    <span class="s2">def </span><span class="s1">array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s0">''' 
        Allocate a shared array of the given *shape* and *type*. *shape* is 
        either an integer or a tuple of integers representing the array's 
        dimensions.  *type* is a :ref:`Numba type &lt;numba-types&gt;` of the 
        elements needing to be stored in the array. 
 
        The returned array-like object can be read and written to like any 
        normal device array (e.g. through indexing). 
        '''</span>


<span class="s2">class </span><span class="s1">local</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    Local memory namespace 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;local&gt;'</span>

    <span class="s3">@</span><span class="s1">stub_function</span>
    <span class="s2">def </span><span class="s1">array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s0">''' 
        Allocate a local array of the given *shape* and *type*. The array is 
        private to the current thread, and resides in global memory. An 
        array-like object is returned which can be read and written to like any 
        standard array (e.g.  through indexing). 
        '''</span>


<span class="s2">class </span><span class="s1">const</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    Constant memory namespace 
    '''</span>

    <span class="s3">@</span><span class="s1">stub_function</span>
    <span class="s2">def </span><span class="s1">array_like</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s0">''' 
        Create a const array from *ndarry*. The resulting const array will have 
        the same shape, type, and values as *ndarray*. 
        '''</span>


<span class="s5"># -------------------------------------------------------------------------------</span>
<span class="s5"># warp level operations</span>

<span class="s2">class </span><span class="s1">syncwarp</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    syncwarp(mask=0xFFFFFFFF) 
 
    Synchronizes a masked subset of threads in a warp. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;warp_sync()&gt;'</span>


<span class="s2">class </span><span class="s1">shfl_sync_intrinsic</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    shfl_sync_intrinsic(mask, mode, value, mode_offset, clamp) 
 
    Nvvm intrinsic for shuffling data across a warp 
    docs.nvidia.com/cuda/nvvm-ir-spec/index.html#nvvm-intrin-warp-level-datamove 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;shfl_sync()&gt;'</span>


<span class="s2">class </span><span class="s1">vote_sync_intrinsic</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    vote_sync_intrinsic(mask, mode, predictate) 
 
    Nvvm intrinsic for performing a reduce and broadcast across a warp 
    docs.nvidia.com/cuda/nvvm-ir-spec/index.html#nvvm-intrin-warp-level-vote 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;vote_sync()&gt;'</span>


<span class="s2">class </span><span class="s1">match_any_sync</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    match_any_sync(mask, value) 
 
    Nvvm intrinsic for performing a compare and broadcast across a warp. 
    Returns a mask of threads that have same value as the given value from 
    within the masked warp. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;match_any_sync()&gt;'</span>


<span class="s2">class </span><span class="s1">match_all_sync</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    match_all_sync(mask, value) 
 
    Nvvm intrinsic for performing a compare and broadcast across a warp. 
    Returns a tuple of (mask, pred), where mask is a mask of threads that have 
    same value as the given value from within the masked warp, if they 
    all have the same value, otherwise it is 0. Pred is a boolean of whether 
    or not all threads in the mask warp have the same warp. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;match_all_sync()&gt;'</span>


<span class="s2">class </span><span class="s1">activemask</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    activemask() 
 
    Returns a 32-bit integer mask of all currently active threads in the 
    calling warp. The Nth bit is set if the Nth lane in the warp is active when 
    activemask() is called. Inactive threads are represented by 0 bits in the 
    returned mask. Threads which have exited the kernel are always marked as 
    inactive. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;activemask()&gt;'</span>


<span class="s2">class </span><span class="s1">lanemask_lt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    lanemask_lt() 
 
    Returns a 32-bit integer mask of all lanes (including inactive ones) with 
    ID less than the current lane. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;lanemask_lt()&gt;'</span>


<span class="s5"># -------------------------------------------------------------------------------</span>
<span class="s5"># memory fences</span>

<span class="s2">class </span><span class="s1">threadfence_block</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    A memory fence at thread block level 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;threadfence_block()&gt;'</span>


<span class="s2">class </span><span class="s1">threadfence_system</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    A memory fence at system level: across devices 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;threadfence_system()&gt;'</span>


<span class="s2">class </span><span class="s1">threadfence</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    A memory fence at device level 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;threadfence()&gt;'</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># bit manipulation</span>

<span class="s2">class </span><span class="s1">popc</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    popc(x) 
 
    Returns the number of set bits in x. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">brev</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    brev(x) 
 
    Returns the reverse of the bit pattern of x. For example, 0b10110110 
    becomes 0b01101101. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">clz</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    clz(x) 
 
    Returns the number of leading zeros in z. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ffs</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    ffs(x) 
 
    Returns the position of the first (least significant) bit set to 1 in x, 
    where the least significant bit position is 1. ffs(0) returns 0. 
    &quot;&quot;&quot;</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># comparison and selection instructions</span>

<span class="s2">class </span><span class="s1">selp</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    selp(a, b, c) 
 
    Select between source operands, based on the value of the predicate source 
    operand. 
    &quot;&quot;&quot;</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># single / double precision arithmetic</span>

<span class="s2">class </span><span class="s1">fma</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    fma(a, b, c) 
 
    Perform the fused multiply-add operation. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">cbrt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;&quot; 
    cbrt(a) 
 
    Perform the cube root operation. 
    &quot;&quot;&quot;</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># atomic</span>

<span class="s2">class </span><span class="s1">atomic</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Namespace for atomic operations 
    &quot;&quot;&quot;</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;atomic&gt;'</span>

    <span class="s2">class </span><span class="s1">add</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;add(ary, idx, val) 
 
        Perform atomic ``ary[idx] += val``. Supported on int32, float32, and 
        float64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">sub</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;sub(ary, idx, val) 
 
        Perform atomic ``ary[idx] -= val``. Supported on int32, float32, and 
        float64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">and_</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;and_(ary, idx, val) 
 
        Perform atomic ``ary[idx] &amp;= val``. Supported on int32, int64, uint32 
        and uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">or_</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;or_(ary, idx, val) 
 
        Perform atomic ``ary[idx] |= val``. Supported on int32, int64, uint32 
        and uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">xor</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;xor(ary, idx, val) 
 
        Perform atomic ``ary[idx] ^= val``. Supported on int32, int64, uint32 
        and uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">inc</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;inc(ary, idx, val) 
 
        Perform atomic ``ary[idx] += 1`` up to val, then reset to 0. Supported 
        on uint32, and uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">dec</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;dec(ary, idx, val) 
 
        Performs:: 
 
           ary[idx] = (value if (array[idx] == 0) or 
                       (array[idx] &gt; value) else array[idx] - 1) 
 
        Supported on uint32, and uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">exch</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;exch(ary, idx, val) 
 
        Perform atomic ``ary[idx] = val``. Supported on int32, int64, uint32 and 
        uint64 operands only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">max</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;max(ary, idx, val) 
 
        Perform atomic ``ary[idx] = max(ary[idx], val)``. 
 
        Supported on int32, int64, uint32, uint64, float32, float64 operands 
        only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">min</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;min(ary, idx, val) 
 
        Perform atomic ``ary[idx] = min(ary[idx], val)``. 
 
        Supported on int32, int64, uint32, uint64, float32, float64 operands 
        only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">nanmax</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;nanmax(ary, idx, val) 
 
        Perform atomic ``ary[idx] = max(ary[idx], val)``. 
 
        NOTE: NaN is treated as a missing value such that: 
        nanmax(NaN, n) == n, nanmax(n, NaN) == n 
 
        Supported on int32, int64, uint32, uint64, float32, float64 operands 
        only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">nanmin</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;nanmin(ary, idx, val) 
 
        Perform atomic ``ary[idx] = min(ary[idx], val)``. 
 
        NOTE: NaN is treated as a missing value, such that: 
        nanmin(NaN, n) == n, nanmin(n, NaN) == n 
 
        Supported on int32, int64, uint32, uint64, float32, float64 operands 
        only. 
 
        Returns the old value at the index location as if it is loaded 
        atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">compare_and_swap</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;compare_and_swap(ary, old, val) 
 
        Conditionally assign ``val`` to the first element of an 1D array ``ary`` 
        if the current value matches ``old``. 
 
        Supported on int32, int64, uint32, uint64 operands only. 
 
        Returns the old value as if it is loaded atomically. 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">cas</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;cas(ary, idx, old, val) 
 
        Conditionally assign ``val`` to the element ``idx`` of an array 
        ``ary`` if the current value of ``ary[idx]`` matches ``old``. 
 
        Supported on int32, int64, uint32, uint64 operands only. 
 
        Returns the old value as if it is loaded atomically. 
        &quot;&quot;&quot;</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># timers</span>

<span class="s2">class </span><span class="s1">nanosleep</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">''' 
    nanosleep(ns) 
 
    Suspends the thread for a sleep duration approximately close to the delay 
    `ns`, specified in nanoseconds. 
    '''</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;nansleep()&gt;'</span>

<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># Floating point 16</span>


<span class="s2">class </span><span class="s1">fp16</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Namespace for fp16 operations 
    &quot;&quot;&quot;</span>
    <span class="s1">_description_ </span><span class="s3">= </span><span class="s4">'&lt;fp16&gt;'</span>

    <span class="s2">class </span><span class="s1">hadd</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hadd(a, b) 
 
        Perform fp16 addition, (a + b) in round to nearest mode. Supported 
        on fp16 operands only. 
 
        Returns the fp16 result of the addition. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hsub</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hsub(a, b) 
 
        Perform fp16 subtraction, (a - b) in round to nearest mode. Supported 
        on fp16 operands only. 
 
        Returns the fp16 result of the subtraction. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hmul</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hmul(a, b) 
 
        Perform fp16 multiplication, (a * b) in round to nearest mode. Supported 
        on fp16 operands only. 
 
        Returns the fp16 result of the multiplication. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hdiv</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hdiv(a, b) 
 
        Perform fp16 division, (a / b) in round to nearest mode. Supported 
        on fp16 operands only. 
 
        Returns the fp16 result of the division 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hfma</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hfma(a, b, c) 
 
        Perform fp16 multiply and accumulate, (a * b) + c in round to nearest 
        mode. Supported on fp16 operands only. 
 
        Returns the fp16 result of the multiplication. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hneg</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hneg(a) 
 
        Perform fp16 negation, -(a). Supported on fp16 operands only. 
 
        Returns the fp16 result of the negation. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">habs</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;habs(a) 
 
        Perform fp16 absolute value, |a|. Supported on fp16 operands only. 
 
        Returns the fp16 result of the absolute value. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hsin</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hsin(a) 
 
        Calculate sine in round to nearest even mode. Supported on fp16 
        operands only. 
 
        Returns the sine result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hcos</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hsin(a) 
 
        Calculate cosine in round to nearest even mode. Supported on fp16 
        operands only. 
 
        Returns the cosine result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hlog</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hlog(a) 
 
        Calculate natural logarithm in round to nearest even mode. Supported 
        on fp16 operands only. 
 
        Returns the natural logarithm result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hlog10</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hlog10(a) 
 
        Calculate logarithm base 10 in round to nearest even mode. Supported 
        on fp16 operands only. 
 
        Returns the logarithm base 10 result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hlog2</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hlog2(a) 
 
        Calculate logarithm base 2 in round to nearest even mode. Supported 
        on fp16 operands only. 
 
        Returns the logarithm base 2 result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hexp</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hexp(a) 
 
        Calculate natural exponential, exp(a), in round to nearest mode. 
        Supported on fp16 operands only. 
 
        Returns the natural exponential result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hexp10</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hexp10(a) 
 
        Calculate exponential base 10 (10 ** a) in round to nearest mode. 
        Supported on fp16 operands only. 
 
        Returns the exponential base 10 result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hexp2</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hexp2(a) 
 
        Calculate exponential base 2 (2 ** a) in round to nearest mode. 
        Supported on fp16 operands only. 
 
        Returns the exponential base 2 result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hfloor</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hfloor(a) 
 
        Calculate the floor, the largest integer less than or equal to 'a'. 
        Supported on fp16 operands only. 
 
        Returns the floor result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hceil</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hceil(a) 
 
        Calculate the ceil, the smallest integer greater than or equal to 'a'. 
        Supported on fp16 operands only. 
 
        Returns the ceil result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hsqrt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hsqrt(a) 
 
        Calculate the square root of the input argument in round to nearest 
        mode. Supported on fp16 operands only. 
 
        Returns the square root result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hrsqrt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hrsqrt(a) 
 
        Calculate the reciprocal square root of the input argument in round 
        to nearest even mode. Supported on fp16 operands only. 
 
        Returns the reciprocal square root result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hrcp</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hrcp(a) 
 
        Calculate the reciprocal of the input argument in round to nearest 
        even mode. Supported on fp16 operands only. 
 
        Returns the reciprocal result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hrint</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hrint(a) 
 
        Round the input argument to nearest integer value. Supported on fp16 
        operands only. 
 
        Returns the rounded result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">htrunc</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;htrunc(a) 
 
        Truncate the input argument to its integer portion. Supported 
        on fp16 operands only. 
 
        Returns the truncated result. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">heq</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;heq(a, b) 
 
        Perform fp16 comparison, (a == b). Supported 
        on fp16 operands only. 
 
        Returns True if a and b are equal and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hne</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hne(a, b) 
 
        Perform fp16 comparison, (a != b). Supported 
        on fp16 operands only. 
 
        Returns True if a and b are not equal and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hge</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hge(a, b) 
 
        Perform fp16 comparison, (a &gt;= b). Supported 
        on fp16 operands only. 
 
        Returns True if a is &gt;= b and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hgt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hgt(a, b) 
 
        Perform fp16 comparison, (a &gt; b). Supported 
        on fp16 operands only. 
 
        Returns True if a is &gt; b and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hle</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hle(a, b) 
 
        Perform fp16 comparison, (a &lt;= b). Supported 
        on fp16 operands only. 
 
        Returns True if a is &lt;= b and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hlt</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hlt(a, b) 
 
        Perform fp16 comparison, (a &lt; b). Supported 
        on fp16 operands only. 
 
        Returns True if a is &lt; b and False otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hmax</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hmax(a, b) 
 
        Perform fp16 maximum operation, max(a,b) Supported 
        on fp16 operands only. 
 
        Returns a if a is greater than b, returns b otherwise. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">hmin</span><span class="s3">(</span><span class="s1">Stub</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;hmin(a, b) 
 
        Perform fp16 minimum operation, min(a,b). Supported 
        on fp16 operands only. 
 
        Returns a if a is less than b, returns b otherwise. 
 
        &quot;&quot;&quot;</span>


<span class="s5">#-------------------------------------------------------------------------------</span>
<span class="s5"># vector types</span>

<span class="s2">def </span><span class="s1">make_vector_type_stubs</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Make user facing objects for vector types&quot;&quot;&quot;</span>
    <span class="s1">vector_type_stubs </span><span class="s3">= []</span>
    <span class="s1">vector_type_prefix </span><span class="s3">= (</span>
        <span class="s4">&quot;int8&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int16&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int64&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint8&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint16&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint64&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;float32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;float64&quot;</span>
    <span class="s3">)</span>
    <span class="s1">vector_type_element_counts </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">, </span><span class="s6">4</span><span class="s3">)</span>
    <span class="s1">vector_type_attribute_names </span><span class="s3">= (</span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">, </span><span class="s4">&quot;z&quot;</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">nelem </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">product</span><span class="s3">(</span>
        <span class="s1">vector_type_prefix</span><span class="s3">, </span><span class="s1">vector_type_element_counts</span>
    <span class="s3">):</span>
        <span class="s1">type_name </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">}</span><span class="s4">x</span><span class="s2">{</span><span class="s1">nelem</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">attr_names </span><span class="s3">= </span><span class="s1">vector_type_attribute_names</span><span class="s3">[:</span><span class="s1">nelem</span><span class="s3">]</span>

        <span class="s1">vector_type_stub </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span>
            <span class="s1">type_name</span><span class="s3">, (</span><span class="s1">Stub</span><span class="s3">,),</span>
            <span class="s3">{</span>
                <span class="s3">**{</span><span class="s1">attr</span><span class="s3">: </span><span class="s2">lambda </span><span class="s1">self</span><span class="s3">: </span><span class="s2">None for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attr_names</span><span class="s3">},</span>
                <span class="s3">**{</span>
                    <span class="s4">&quot;_description_&quot;</span><span class="s3">: </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type_name</span><span class="s2">}</span><span class="s4">&gt;&quot;</span><span class="s3">,</span>
                    <span class="s4">&quot;__signature__&quot;</span><span class="s3">: </span><span class="s1">Signature</span><span class="s3">(</span><span class="s1">parameters</span><span class="s3">=[</span>
                        <span class="s1">Parameter</span><span class="s3">(</span>
                            <span class="s1">name</span><span class="s3">=</span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span>
                        <span class="s3">) </span><span class="s2">for </span><span class="s1">attr_name </span><span class="s2">in </span><span class="s1">attr_names</span><span class="s3">[:</span><span class="s1">nelem</span><span class="s3">]</span>
                    <span class="s3">]),</span>
                    <span class="s4">&quot;__doc__&quot;</span><span class="s3">: </span><span class="s4">f&quot;A stub for </span><span class="s2">{</span><span class="s1">type_name</span><span class="s2">} </span><span class="s4">to be used in &quot;</span>
                    <span class="s4">&quot;CUDA kernels.&quot;</span>
                <span class="s3">},</span>
                <span class="s3">**{</span><span class="s4">&quot;aliases&quot;</span><span class="s3">: []}</span>
            <span class="s3">}</span>
        <span class="s3">)</span>
        <span class="s1">vector_type_stubs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">vector_type_stub</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">vector_type_stubs</span>


<span class="s2">def </span><span class="s1">map_vector_type_stubs_to_alias</span><span class="s3">(</span><span class="s1">vector_type_stubs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;For each of the stubs, create its aliases. 
 
    For example: float64x3 -&gt; double3 
    &quot;&quot;&quot;</span>
    <span class="s5"># C-compatible type mapping, see:</span>
    <span class="s5"># https://numpy.org/devdocs/reference/arrays.scalars.html#integer-types</span>
    <span class="s1">base_type_to_alias </span><span class="s3">= {</span>
        <span class="s4">&quot;char&quot;</span><span class="s3">: </span><span class="s4">f&quot;int</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">byte</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;short&quot;</span><span class="s3">: </span><span class="s4">f&quot;int</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">short</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int&quot;</span><span class="s3">: </span><span class="s4">f&quot;int</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;long&quot;</span><span class="s3">: </span><span class="s4">f&quot;int</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;longlong&quot;</span><span class="s3">: </span><span class="s4">f&quot;int</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">longlong</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uchar&quot;</span><span class="s3">: </span><span class="s4">f&quot;uint</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ubyte</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;ushort&quot;</span><span class="s3">: </span><span class="s4">f&quot;uint</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ushort</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint&quot;</span><span class="s3">: </span><span class="s4">f&quot;uint</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uintc</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;ulong&quot;</span><span class="s3">: </span><span class="s4">f&quot;uint</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;ulonglong&quot;</span><span class="s3">: </span><span class="s4">f&quot;uint</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ulonglong</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;float&quot;</span><span class="s3">: </span><span class="s4">f&quot;float</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">single</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;double&quot;</span><span class="s3">: </span><span class="s4">f&quot;float</span><span class="s2">{</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">double</span><span class="s3">).</span><span class="s1">itemsize </span><span class="s3">* </span><span class="s6">8</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s3">}</span>

    <span class="s1">base_type_to_vector_type </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">stub </span><span class="s2">in </span><span class="s1">vector_type_stubs</span><span class="s3">:</span>
        <span class="s1">base_type_to_vector_type</span><span class="s3">[</span><span class="s1">stub</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">[:-</span><span class="s6">2</span><span class="s3">]].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stub</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">alias</span><span class="s3">, </span><span class="s1">base_type </span><span class="s2">in </span><span class="s1">base_type_to_alias</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">vector_type_stubs </span><span class="s3">= </span><span class="s1">base_type_to_vector_type</span><span class="s3">[</span><span class="s1">base_type</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">stub </span><span class="s2">in </span><span class="s1">vector_type_stubs</span><span class="s3">:</span>
            <span class="s1">nelem </span><span class="s3">= </span><span class="s1">stub</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">stub</span><span class="s3">.</span><span class="s1">aliases</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">alias</span><span class="s2">}{</span><span class="s1">nelem</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>


<span class="s1">_vector_type_stubs </span><span class="s3">= </span><span class="s1">make_vector_type_stubs</span><span class="s3">()</span>
<span class="s1">map_vector_type_stubs_to_alias</span><span class="s3">(</span><span class="s1">_vector_type_stubs</span><span class="s3">)</span>
</pre>
</body>
</html>