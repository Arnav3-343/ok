<html>
<head>
<title>npytypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
npytypes.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">cached_property</span>

<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">abstract </span><span class="s0">import </span><span class="s1">DTypeSpec</span><span class="s2">, </span><span class="s1">IteratorType</span><span class="s2">, </span><span class="s1">MutableSequence</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">, </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s1">Buffer</span><span class="s2">, </span><span class="s1">Opaque</span><span class="s2">, </span><span class="s1">SimpleIteratorType</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typeconv </span><span class="s0">import </span><span class="s1">Conversion</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">misc </span><span class="s0">import </span><span class="s1">UnicodeType</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">containers </span><span class="s0">import </span><span class="s1">Bytes</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">class </span><span class="s1">CharSeq</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A fixed-length 8-bit character sequence. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">count</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">= </span><span class="s1">count</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;[char x %d]&quot; </span><span class="s2">% </span><span class="s1">count</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">CharSeq</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">count</span>

    <span class="s0">def </span><span class="s1">can_convert_from</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Bytes</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>


<span class="s0">class </span><span class="s1">UnicodeCharSeq</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A fixed-length unicode character sequence. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">count</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">= </span><span class="s1">count</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;[unichr x %d]&quot; </span><span class="s2">% </span><span class="s1">count</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">UnicodeCharSeq</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">count</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">UnicodeCharSeq</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>

    <span class="s0">def </span><span class="s1">can_convert_from</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">UnicodeType</span><span class="s2">):</span>
            <span class="s5"># Assuming that unicode_type itemsize is not greater than</span>
            <span class="s5"># numpy.dtype('U1').itemsize that UnicodeCharSeq is based</span>
            <span class="s5"># on.</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">f&quot;UnicodeCharSeq(</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">count</span><span class="s0">}</span><span class="s4">)&quot;</span>


<span class="s1">_RecordField </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">namedtuple</span><span class="s2">(</span>
    <span class="s4">'_RecordField'</span><span class="s2">,</span>
    <span class="s4">'type,offset,alignment,title'</span><span class="s2">,</span>
<span class="s2">)</span>


<span class="s0">class </span><span class="s1">Record</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A Record datatype can be mapped to a NumPy structured dtype. 
    A record is very flexible since it is laid out as a list of bytes. 
    Fields can be mapped to arbitrary points inside it, even if they overlap. 
 
    *fields* is a list of `(name:str, data:dict)`. 
        Where `data` is `{ type: Type, offset: int }` 
    *size* is an int; the record size 
    *aligned* is a boolean; whether the record is ABI aligned. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">make_c_struct</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name_types</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Construct a Record type from a list of (name:str, type:Types). 
        The layout of the structure will follow C. 
 
        Note: only scalar types are supported currently. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">registry </span><span class="s0">import </span><span class="s1">cpu_target</span>

        <span class="s1">ctx </span><span class="s2">= </span><span class="s1">cpu_target</span><span class="s2">.</span><span class="s1">target_context</span>
        <span class="s1">offset </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">fields </span><span class="s2">= []</span>
        <span class="s1">lltypes </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">name_types</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, (</span><span class="s1">Number</span><span class="s2">, </span><span class="s1">NestedArray</span><span class="s2">)):</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Only Number and NestedArray types are supported, found: {}. &quot;</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">NestedArray</span><span class="s2">):</span>
                <span class="s1">datatype </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">as_storage_type</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">datatype </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">get_data_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>
            <span class="s1">lltypes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">datatype</span><span class="s2">)</span>
            <span class="s1">size </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">get_abi_sizeof</span><span class="s2">(</span><span class="s1">datatype</span><span class="s2">)</span>
            <span class="s1">align </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">get_abi_alignment</span><span class="s2">(</span><span class="s1">datatype</span><span class="s2">)</span>
            <span class="s5"># align</span>
            <span class="s1">misaligned </span><span class="s2">= </span><span class="s1">offset </span><span class="s2">% </span><span class="s1">align</span>
            <span class="s0">if </span><span class="s1">misaligned</span><span class="s2">:</span>
                <span class="s1">offset </span><span class="s2">+= </span><span class="s1">align </span><span class="s2">- </span><span class="s1">misaligned</span>
            <span class="s1">fields</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">k</span><span class="s2">, {</span>
                <span class="s4">'type'</span><span class="s2">: </span><span class="s1">ty</span><span class="s2">, </span><span class="s4">'offset'</span><span class="s2">: </span><span class="s1">offset</span><span class="s2">, </span><span class="s4">'alignment'</span><span class="s2">: </span><span class="s1">align</span><span class="s2">,</span>
            <span class="s2">}))</span>
            <span class="s1">offset </span><span class="s2">+= </span><span class="s1">size</span>
        <span class="s5"># Adjust sizeof structure</span>
        <span class="s1">abi_size </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">get_abi_sizeof</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">LiteralStructType</span><span class="s2">(</span><span class="s1">lltypes</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">Record</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s1">abi_size</span><span class="s2">, </span><span class="s1">aligned</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">aligned</span><span class="s2">):</span>
        <span class="s1">fields </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_normalize_fields</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fields </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">size </span><span class="s2">= </span><span class="s1">size</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">aligned </span><span class="s2">= </span><span class="s1">aligned</span>

        <span class="s5"># Create description</span>
        <span class="s1">descbuf </span><span class="s2">= []</span>
        <span class="s1">fmt </span><span class="s2">= </span><span class="s4">&quot;{}[type={};offset={}{}]&quot;</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">infos </span><span class="s0">in </span><span class="s1">fields</span><span class="s2">:</span>
            <span class="s1">extra </span><span class="s2">= </span><span class="s4">&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">infos</span><span class="s2">.</span><span class="s1">alignment </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">extra </span><span class="s2">+= </span><span class="s4">';alignment={}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">infos</span><span class="s2">.</span><span class="s1">alignment</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">infos</span><span class="s2">.</span><span class="s1">title </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">extra </span><span class="s2">+= </span><span class="s4">';title={}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">infos</span><span class="s2">.</span><span class="s1">title</span><span class="s2">)</span>
            <span class="s1">descbuf</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">infos</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">infos</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">))</span>

        <span class="s1">desc </span><span class="s2">= </span><span class="s4">','</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">descbuf</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">'Record({};{};{})'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">desc</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Record</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">* </span><span class="s6">8</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_normalize_fields</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        fields: 
            [name: str, 
             value: { 
                 type: Type, 
                 offset: int, 
                 [ alignment: int ], 
                 [ title : str], 
             }] 
        &quot;&quot;&quot;</span>
        <span class="s1">res </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">infos </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: (</span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">][</span><span class="s4">'offset'</span><span class="s2">], </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])):</span>
            <span class="s1">fd </span><span class="s2">= </span><span class="s1">_RecordField</span><span class="s2">(</span>
                <span class="s1">type</span><span class="s2">=</span><span class="s1">infos</span><span class="s2">[</span><span class="s4">'type'</span><span class="s2">],</span>
                <span class="s1">offset</span><span class="s2">=</span><span class="s1">infos</span><span class="s2">[</span><span class="s4">'offset'</span><span class="s2">],</span>
                <span class="s1">alignment</span><span class="s2">=</span><span class="s1">infos</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'alignment'</span><span class="s2">),</span>
                <span class="s1">title</span><span class="s2">=</span><span class="s1">infos</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'title'</span><span class="s2">),</span>
            <span class="s2">)</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">name</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Numpy dtype equality doesn't always succeed, use the name instead</span>
        <span class="s5"># (https://github.com/numpy/numpy/issues/5715)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">mangling_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_code</span><span class="s2">,)</span>

    <span class="s0">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the number of fields 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">offset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get the byte offset of a field from the start of the structure. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">[</span><span class="s1">key</span><span class="s2">].</span><span class="s1">offset</span>

    <span class="s0">def </span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get the type of a field. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">[</span><span class="s1">key</span><span class="s2">].</span><span class="s1">type</span>

    <span class="s0">def </span><span class="s1">alignof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get the specified alignment of the field. 
 
        Since field alignment is optional, this may return None. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">[</span><span class="s1">key</span><span class="s2">].</span><span class="s1">alignment</span>

    <span class="s0">def </span><span class="s1">has_titles</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns True the record uses titles. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">any</span><span class="s2">(</span><span class="s1">fd</span><span class="s2">.</span><span class="s1">title </span><span class="s0">is not None for </span><span class="s1">fd </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">is_title</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns True if the field named *key* is a title. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">[</span><span class="s1">key</span><span class="s2">].</span><span class="s1">title </span><span class="s2">== </span><span class="s1">key</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">members</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;An ordered list of (name, type) for the fields. 
        &quot;&quot;&quot;</span>
        <span class="s1">ordered </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">].</span><span class="s1">offset</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">.</span><span class="s1">type</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">ordered</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">numpy_support </span><span class="s0">import </span><span class="s1">as_struct_dtype</span>

        <span class="s0">return </span><span class="s1">as_struct_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert this Record to the *other*. 
 
        This method only implements width subtyping for records. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">NumbaExperimentalFeatureWarning</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Record</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">) &gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">):</span>
                <span class="s0">return</span>
            <span class="s0">for </span><span class="s1">other_fd</span><span class="s2">, </span><span class="s1">self_fd </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(),</span>
                                         <span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
                <span class="s0">if not </span><span class="s1">other_fd </span><span class="s2">== </span><span class="s1">self_fd</span><span class="s2">:</span>
                    <span class="s0">return</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">has been considered a subtype of </span><span class="s0">{</span><span class="s1">other</span><span class="s0">} </span><span class="s4">&quot;</span>
                          <span class="s4">f&quot; This is an experimental feature.&quot;</span><span class="s2">,</span>
                          <span class="s1">category</span><span class="s2">=</span><span class="s1">NumbaExperimentalFeatureWarning</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fields </span><span class="s2">= [</span><span class="s4">f&quot;('</span><span class="s0">{</span><span class="s1">f_name</span><span class="s0">}</span><span class="s4">', &quot; </span><span class="s2">+</span>
                  <span class="s4">f&quot;</span><span class="s0">{{</span><span class="s4">'type': </span><span class="s0">{</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">f_info</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span><span class="s0">}</span><span class="s4">, &quot; </span><span class="s2">+</span>
                  <span class="s4">f&quot;'offset': </span><span class="s0">{</span><span class="s1">f_info</span><span class="s2">.</span><span class="s1">offset</span><span class="s0">}</span><span class="s4">, &quot; </span><span class="s2">+</span>
                  <span class="s4">f&quot;'alignment': </span><span class="s0">{</span><span class="s1">f_info</span><span class="s2">.</span><span class="s1">alignment</span><span class="s0">}</span><span class="s4">, &quot; </span><span class="s2">+</span>
                  <span class="s4">f&quot;'title': </span><span class="s0">{</span><span class="s1">f_info</span><span class="s2">.</span><span class="s1">title</span><span class="s0">}</span><span class="s4">, &quot; </span><span class="s2">+</span>
                  <span class="s4">f&quot;</span><span class="s0">}}</span><span class="s4">&quot; </span><span class="s2">+</span>
                  <span class="s4">&quot;)&quot;</span>
                  <span class="s0">for </span><span class="s1">f_name</span><span class="s2">, </span><span class="s1">f_info </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                  <span class="s2">]</span>
        <span class="s1">fields </span><span class="s2">= </span><span class="s4">&quot;[&quot; </span><span class="s2">+ </span><span class="s4">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">) + </span><span class="s4">&quot;]&quot;</span>
        <span class="s0">return </span><span class="s4">f&quot;Record(</span><span class="s0">{</span><span class="s1">fields</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">size</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span><span class="s0">}</span><span class="s4">)&quot;</span>

<span class="s0">class </span><span class="s1">DType</span><span class="s2">(</span><span class="s1">DTypeSpec</span><span class="s2">, </span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class associated with the `np.dtype`. 
 
    i.e. :code:`assert type(np.dtype('int32')) == np.dtype` 
 
    np.dtype('int32') 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;dtype(%s)&quot; </span><span class="s2">% (</span><span class="s1">dtype</span><span class="s2">,)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">DTypeSpec</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dtype</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">):</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">DType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">res</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NumpyFlatType</span><span class="s2">(</span><span class="s1">SimpleIteratorType</span><span class="s2">, </span><span class="s1">MutableSequence</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for `ndarray.flat()` objects. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arrty</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">array_type </span><span class="s2">= </span><span class="s1">arrty</span>
        <span class="s1">yield_type </span><span class="s2">= </span><span class="s1">arrty</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">yield_type</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;array.flat({arrayty})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">arrayty</span><span class="s2">=</span><span class="s1">arrty</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyFlatType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">yield_type</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_type</span>


<span class="s0">class </span><span class="s1">NumpyNdEnumerateType</span><span class="s2">(</span><span class="s1">SimpleIteratorType</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for `np.ndenumerate()` objects. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arrty</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">UniTuple</span><span class="s2">, </span><span class="s1">intp</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">array_type </span><span class="s2">= </span><span class="s1">arrty</span>
        <span class="s1">yield_type </span><span class="s2">= </span><span class="s1">Tuple</span><span class="s2">((</span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">arrty</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">), </span><span class="s1">arrty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;ndenumerate({arrayty})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">arrayty</span><span class="s2">=</span><span class="s1">arrty</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyNdEnumerateType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">yield_type</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_type</span>


<span class="s0">class </span><span class="s1">NumpyNdIterType</span><span class="s2">(</span><span class="s1">IteratorType</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for `np.nditer()` objects. 
 
    The layout denotes in which order the logical shape is iterated on. 
    &quot;C&quot; means logical order (corresponding to in-memory order in C arrays), 
    &quot;F&quot; means reverse logical order (corresponding to in-memory order in 
    F arrays). 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">):</span>
        <span class="s5"># Note inputs arrays can also be scalars, in which case they are</span>
        <span class="s5"># broadcast.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">arrays </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_layout</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s4">'dtype'</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s4">'ndim'</span><span class="s2">, </span><span class="s6">0</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;nditer(ndim={ndim}, layout={layout}, inputs={arrays})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
            <span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyNdIterType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_compute_layout</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">):</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">Counter</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">in </span><span class="s4">'CF' </span><span class="s0">and </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">c</span><span class="s2">[</span><span class="s4">'C'</span><span class="s2">] += </span><span class="s6">1</span>
                <span class="s1">c</span><span class="s2">[</span><span class="s4">'F'</span><span class="s2">] += </span><span class="s6">1</span>
            <span class="s0">elif </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt;= </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">c</span><span class="s2">[</span><span class="s1">a</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">] += </span><span class="s6">1</span>
        <span class="s0">return </span><span class="s4">'F' </span><span class="s0">if </span><span class="s1">c</span><span class="s2">[</span><span class="s4">'F'</span><span class="s2">] &gt; </span><span class="s1">c</span><span class="s2">[</span><span class="s4">'C'</span><span class="s2">] </span><span class="s0">else </span><span class="s4">'C'</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">views</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        The views yielded by the iterator. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s4">'C'</span><span class="s2">) </span><span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">yield_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">BaseTuple</span>
        <span class="s1">views </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">views</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">views</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">BaseTuple</span><span class="s2">.</span><span class="s1">from_types</span><span class="s2">(</span><span class="s1">views</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">views</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">indexers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        A list of (kind, start_dim, end_dim, indices) where: 
        - `kind` is either &quot;flat&quot;, &quot;indexed&quot;, &quot;0d&quot; or &quot;scalar&quot; 
        - `start_dim` and `end_dim` are the dimension numbers at which 
          this indexing takes place 
        - `indices` is the indices of the indexed arrays in self.arrays 
        &quot;&quot;&quot;</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">OrderedDict</span><span class="s2">()</span>
        <span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s0">assert </span><span class="s1">layout </span><span class="s0">in </span><span class="s4">'CF'</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">a </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">):</span>
                <span class="s1">indexer </span><span class="s2">= (</span><span class="s4">'scalar'</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">indexer </span><span class="s2">= (</span><span class="s4">'0d'</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">layout </span><span class="s2">== </span><span class="s1">layout </span><span class="s0">or </span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">a</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">in </span><span class="s4">'CF'</span><span class="s2">):</span>
                    <span class="s1">kind </span><span class="s2">= </span><span class="s4">'flat'</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">kind </span><span class="s2">= </span><span class="s4">'indexed'</span>
                <span class="s0">if </span><span class="s1">layout </span><span class="s2">== </span><span class="s4">'C'</span><span class="s2">:</span>
                    <span class="s5"># If iterating in C order, broadcasting is done on the outer indices</span>
                    <span class="s1">indexer </span><span class="s2">= (</span><span class="s1">kind</span><span class="s2">, </span><span class="s1">ndim </span><span class="s2">- </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">indexer </span><span class="s2">= (</span><span class="s1">kind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
            <span class="s1">d</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, []).</span><span class="s1">append</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">k </span><span class="s2">+ (</span><span class="s1">v</span><span class="s2">,) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">d</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">need_shaped_indexing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Whether iterating on this iterator requires keeping track of 
        individual indices inside the shape.  If False, only a single index 
        over the equivalent flat shape is required, which can make the 
        iterator more efficient. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">start_dim</span><span class="s2">, </span><span class="s1">end_dim</span><span class="s2">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexers</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">kind </span><span class="s0">in </span><span class="s2">(</span><span class="s4">'0d'</span><span class="s2">, </span><span class="s4">'scalar'</span><span class="s2">):</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">kind </span><span class="s2">== </span><span class="s4">'flat'</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">start_dim</span><span class="s2">, </span><span class="s1">end_dim</span><span class="s2">) != (</span><span class="s6">0</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">):</span>
                    <span class="s5"># Broadcast flat iteration needs shaped indexing</span>
                    <span class="s5"># to know when to restart iteration.</span>
                    <span class="s0">return True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">NumpyNdIndexType</span><span class="s2">(</span><span class="s1">SimpleIteratorType</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for `np.ndindex()` objects. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">UniTuple</span><span class="s2">, </span><span class="s1">intp</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">= </span><span class="s1">ndim</span>
        <span class="s1">yield_type </span><span class="s2">= </span><span class="s1">UniTuple</span><span class="s2">(</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;ndindex(ndim={ndim})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyNdIndexType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">yield_type</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>


<span class="s0">class </span><span class="s1">Array</span><span class="s2">(</span><span class="s1">Buffer</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for Numpy arrays. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">, </span><span class="s1">readonly</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                 <span class="s1">aligned</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">readonly</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">mutable </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">aligned </span><span class="s0">or</span>
            <span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">Record</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">)):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">aligned </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">NestedArray</span><span class="s2">):</span>
            <span class="s1">ndim </span><span class="s2">+= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">ndim</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">type_name </span><span class="s2">= </span><span class="s4">&quot;array&quot;</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable</span><span class="s2">:</span>
                <span class="s1">type_name </span><span class="s2">= </span><span class="s4">&quot;readonly &quot; </span><span class="s2">+ </span><span class="s1">type_name</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">:</span>
                <span class="s1">type_name </span><span class="s2">= </span><span class="s4">&quot;unaligned &quot; </span><span class="s2">+ </span><span class="s1">type_name</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;%s(%s, %sd, %s)&quot; </span><span class="s2">% (</span><span class="s1">type_name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">mangling_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">,</span>
                <span class="s4">'mutable' </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable </span><span class="s0">else </span><span class="s4">'readonly'</span><span class="s2">,</span>
                <span class="s4">'aligned' </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned </span><span class="s0">else </span><span class="s4">'unaligned'</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">args</span>

    <span class="s0">def </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">readonly</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">ndim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s0">if </span><span class="s1">layout </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span>
        <span class="s0">if </span><span class="s1">readonly </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">readonly </span><span class="s2">= </span><span class="s0">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable</span>
        <span class="s0">return </span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s1">layout</span><span class="s2">, </span><span class="s1">readonly</span><span class="s2">=</span><span class="s1">readonly</span><span class="s2">,</span>
                     <span class="s1">aligned</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Unify this with the *other* Array. 
        &quot;&quot;&quot;</span>
        <span class="s5"># If other is array and the ndim matches</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">) </span><span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s5"># If dtype matches or other.dtype is undefined (inferred)</span>
            <span class="s0">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">or not </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">is_precise</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">:</span>
                    <span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">layout </span><span class="s2">= </span><span class="s4">'A'</span>
                <span class="s1">readonly </span><span class="s2">= </span><span class="s0">not </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable </span><span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">mutable</span><span class="s2">)</span>
                <span class="s1">aligned </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned </span><span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">aligned</span>
                <span class="s0">return </span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s1">layout</span><span class="s2">,</span>
                             <span class="s1">readonly</span><span class="s2">=</span><span class="s1">readonly</span><span class="s2">, </span><span class="s1">aligned</span><span class="s2">=</span><span class="s1">aligned</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert this Array to the *other*. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">) </span><span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>
            <span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">in </span><span class="s2">(</span><span class="s4">'A'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable </span><span class="s0">or not </span><span class="s1">other</span><span class="s2">.</span><span class="s1">mutable</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned </span><span class="s0">or not </span><span class="s1">other</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">)):</span>
                <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>

    <span class="s0">def </span><span class="s1">is_precise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">is_precise</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">box_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the Python type to box to. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s4">f&quot;Array(</span><span class="s0">{</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">}</span><span class="s4">, '</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">layout</span><span class="s0">}</span><span class="s4">', &quot;</span>
            <span class="s4">f&quot;</span><span class="s0">{not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mutable</span><span class="s0">}</span><span class="s4">, aligned=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">aligned</span><span class="s0">}</span><span class="s4">)&quot;</span>
                <span class="s2">)</span>

<span class="s0">class </span><span class="s1">ArrayCTypes</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    This is the type for `np.ndarray.ctypes`. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arytype</span><span class="s2">):</span>
        <span class="s5"># This depends on the ndim for the shape and strides attributes,</span>
        <span class="s5"># even though they are not implemented, yet.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">arytype</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">= </span><span class="s1">arytype</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;ArrayCTypes(dtype={0}, ndim={1})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ArrayCTypes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert this type to the corresponding pointer type. 
        This allows passing a array.ctypes object to a C function taking 
        a raw pointer. 
 
        Note that in pure Python, the array.ctypes object can only be 
        passed to a ctypes function accepting a c_void_p, not a typed 
        pointer. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">CPointer</span><span class="s2">, </span><span class="s1">voidptr</span>
        <span class="s5"># XXX what about readonly</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">CPointer</span><span class="s2">) </span><span class="s0">and </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>
        <span class="s0">elif </span><span class="s1">other </span><span class="s2">== </span><span class="s1">voidptr</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>


<span class="s0">class </span><span class="s1">ArrayFlags</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    This is the type for `np.ndarray.flags`. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arytype</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">array_type </span><span class="s2">= </span><span class="s1">arytype</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;ArrayFlags({0})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_type</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ArrayFlags</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">array_type</span>


<span class="s0">class </span><span class="s1">NestedArray</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A NestedArray is an array nested within a structured type (which are &quot;void&quot; 
    type in NumPy parlance). Unlike an Array, the shape, and not just the number 
    of dimensions is part of the type of a NestedArray. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">NestedArray</span><span class="s2">):</span>
            <span class="s1">tmp </span><span class="s2">= </span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s4">'C'</span><span class="s2">)</span>
            <span class="s1">shape </span><span class="s2">+= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">tmp</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">assert </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">% </span><span class="s6">8 </span><span class="s2">== </span><span class="s6">0</span><span class="s2">, </span><span class="s1">\</span>
            <span class="s4">&quot;Dtype bitwidth must be a multiple of bytes&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;nestedarray(%s, %s)&quot; </span><span class="s2">% (</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NestedArray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s4">'C'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nitems</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">l </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s1">l </span><span class="s2">= </span><span class="s1">l </span><span class="s2">* </span><span class="s1">s</span>
        <span class="s0">return </span><span class="s1">l</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">// </span><span class="s6">8</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">strides</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">stride </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s1">strides </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">):</span>
             <span class="s1">strides</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">)</span>
             <span class="s1">stride </span><span class="s2">*= </span><span class="s1">i</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">strides</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">f&quot;NestedArray(</span><span class="s0">{</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">)&quot;</span>


<span class="s0">class </span><span class="s1">NumPyRandomBitGeneratorType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumPyRandomBitGeneratorType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s4">'NumPyRandomBitGeneratorType'</span>


<span class="s0">class </span><span class="s1">NumPyRandomGeneratorType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">NumPyRandomGeneratorType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s4">'NumPyRandomGeneratorType'</span>


<span class="s0">class </span><span class="s1">PolynomialType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">coef</span><span class="s2">, </span><span class="s1">domain</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">window</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">n_args</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">PolynomialType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s4">f'PolynomialType(</span><span class="s0">{</span><span class="s1">coef</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">domain</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">domain</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">n_args</span><span class="s0">}</span><span class="s4">)'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coef </span><span class="s2">= </span><span class="s1">coef</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">domain </span><span class="s2">= </span><span class="s1">domain</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">window </span><span class="s2">= </span><span class="s1">window</span>
        <span class="s5"># We use n_args to keep track of the number of arguments in the</span>
        <span class="s5"># constructor, since the types of domain and window arguments depend on</span>
        <span class="s5"># that and we need that information when boxing</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n_args </span><span class="s2">= </span><span class="s1">n_args</span>
</pre>
</body>
</html>