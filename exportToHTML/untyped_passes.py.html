<html>
<head>
<title>untyped_passes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
untyped_passes.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span><span class="s2">, </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_machinery </span><span class="s0">import </span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">, </span><span class="s1">AnalysisPass</span><span class="s2">,</span>
                                           <span class="s1">SSACompliantMixin</span><span class="s2">, </span><span class="s1">register_pass</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s2">(</span><span class="s1">errors</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">, </span><span class="s1">bytecode</span><span class="s2">, </span><span class="s1">postproc</span><span class="s2">, </span><span class="s1">rewrites</span><span class="s2">, </span><span class="s1">config</span><span class="s2">,</span>
                        <span class="s1">transforms</span><span class="s2">, </span><span class="s1">consts</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">special </span><span class="s0">import </span><span class="s1">literal_unroll</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">analysis </span><span class="s0">import </span><span class="s2">(</span><span class="s1">dead_branch_prune</span><span class="s2">, </span><span class="s1">rewrite_semantic_constants</span><span class="s2">,</span>
                                 <span class="s1">find_literally_calls</span><span class="s2">, </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">,</span>
                                 <span class="s1">compute_use_defs</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ir_utils </span><span class="s0">import </span><span class="s2">(</span><span class="s1">guard</span><span class="s2">, </span><span class="s1">resolve_func_from_module</span><span class="s2">, </span><span class="s1">simplify_CFG</span><span class="s2">,</span>
                                 <span class="s1">GuardException</span><span class="s2">, </span><span class="s1">convert_code_obj_to_function</span><span class="s2">,</span>
                                 <span class="s1">build_definitions</span><span class="s2">,</span>
                                 <span class="s1">replace_var_names</span><span class="s2">, </span><span class="s1">get_name_var_table</span><span class="s2">,</span>
                                 <span class="s1">compile_to_numba_ir</span><span class="s2">, </span><span class="s1">get_definition</span><span class="s2">,</span>
                                 <span class="s1">find_max_label</span><span class="s2">, </span><span class="s1">rename_labels</span><span class="s2">,</span>
                                 <span class="s1">transfer_scope</span><span class="s2">, </span><span class="s1">fixup_var_define_in_scope</span><span class="s2">,</span>
                                 <span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ssa </span><span class="s0">import </span><span class="s1">reconstruct_ssa</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">interpreter</span>


<span class="s2">@</span><span class="s1">contextmanager</span>
<span class="s0">def </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Wraps code that would signal a fallback to object mode 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">yield</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">state</span><span class="s2">.</span><span class="s1">status</span><span class="s2">.</span><span class="s1">can_fallback</span><span class="s2">:</span>
            <span class="s0">raise</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Clear all references attached to the traceback</span>
            <span class="s1">e </span><span class="s2">= </span><span class="s1">e</span><span class="s2">.</span><span class="s1">with_traceback</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s4"># this emits a warning containing the error message body in the</span>
            <span class="s4"># case of fallback from npm to objmode</span>
            <span class="s1">loop_lift </span><span class="s2">= </span><span class="s5">'' </span><span class="s0">if </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">enable_looplift </span><span class="s0">else </span><span class="s5">'OUT'</span>
            <span class="s1">msg_rewrite </span><span class="s2">= (</span><span class="s5">&quot;</span><span class="s0">\n</span><span class="s5">Compilation is falling back to object mode &quot;</span>
                           <span class="s5">&quot;WITH%s looplifting enabled because %s&quot;</span>
                           <span class="s2">% (</span><span class="s1">loop_lift</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">))</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn_explicit</span><span class="s2">(</span><span class="s5">'%s due to: %s' </span><span class="s2">% (</span><span class="s1">msg_rewrite</span><span class="s2">, </span><span class="s1">e</span><span class="s2">),</span>
                                   <span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaWarning</span><span class="s2">,</span>
                                   <span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">,</span>
                                   <span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">firstlineno</span><span class="s2">)</span>
            <span class="s0">raise</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ExtractByteCode</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;extract_bytecode&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Extract bytecode from function 
        &quot;&quot;&quot;</span>
        <span class="s1">func_id </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'func_id'</span><span class="s2">]</span>
        <span class="s1">bc </span><span class="s2">= </span><span class="s1">bytecode</span><span class="s2">.</span><span class="s1">ByteCode</span><span class="s2">(</span><span class="s1">func_id</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DUMP_BYTECODE</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">bc</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>

        <span class="s1">state</span><span class="s2">[</span><span class="s5">'bc'</span><span class="s2">] = </span><span class="s1">bc</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TranslateByteCode</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;translate_bytecode&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Analyze bytecode and translating to Numba IR 
        &quot;&quot;&quot;</span>
        <span class="s1">func_id </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'func_id'</span><span class="s2">]</span>
        <span class="s1">bc </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'bc'</span><span class="s2">]</span>
        <span class="s1">interp </span><span class="s2">= </span><span class="s1">interpreter</span><span class="s2">.</span><span class="s1">Interpreter</span><span class="s2">(</span><span class="s1">func_id</span><span class="s2">)</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">interp</span><span class="s2">.</span><span class="s1">interpret</span><span class="s2">(</span><span class="s1">bc</span><span class="s2">)</span>
        <span class="s1">state</span><span class="s2">[</span><span class="s5">&quot;func_ir&quot;</span><span class="s2">] = </span><span class="s1">func_ir</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">RVSDGFrontend</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;rvsdg_frontend&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">rvsdg_frontend </span><span class="s0">import </span><span class="s1">bcinterp</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">bytecode </span><span class="s0">import </span><span class="s1">FunctionIdentity</span>

        <span class="s1">func_id</span><span class="s2">: </span><span class="s1">FunctionIdentity </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'func_id'</span><span class="s2">]</span>
        <span class="s4"># Bytecode object is unused here</span>
        <span class="s4"># bc = state['bc']</span>

        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">bcinterp</span><span class="s2">.</span><span class="s1">run_frontend</span><span class="s2">(</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s1">state</span><span class="s2">[</span><span class="s5">&quot;func_ir&quot;</span><span class="s2">] = </span><span class="s1">func_ir</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">FixupArgs</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;fixup_args&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">state</span><span class="s2">[</span><span class="s5">'nargs'</span><span class="s2">] = </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'func_ir'</span><span class="s2">].</span><span class="s1">arg_count</span>
        <span class="s0">if not </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'args'</span><span class="s2">] </span><span class="s0">and </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'flags'</span><span class="s2">].</span><span class="s1">force_pyobject</span><span class="s2">:</span>
            <span class="s4"># Allow an empty argument types specification when object mode</span>
            <span class="s4"># is explicitly requested.</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s5">'args'</span><span class="s2">] = (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">pyobject</span><span class="s2">,) * </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'nargs'</span><span class="s2">]</span>
        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">state</span><span class="s2">[</span><span class="s5">'args'</span><span class="s2">]) != </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'nargs'</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;Signature mismatch: %d argument types given, &quot;</span>
                            <span class="s5">&quot;but function takes %d arguments&quot;</span>
                            <span class="s2">% (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">state</span><span class="s2">[</span><span class="s5">'args'</span><span class="s2">]), </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'nargs'</span><span class="s2">]))</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">IRProcessing</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;ir_processing&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">'func_ir'</span><span class="s2">]</span>
        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DEBUG </span><span class="s0">or </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DUMP_IR</span><span class="s2">:</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_qualname</span>
            <span class="s1">print</span><span class="s2">((</span><span class="s5">&quot;IR DUMP: %s&quot; </span><span class="s2">% </span><span class="s1">name</span><span class="s2">).</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">&quot;-&quot;</span><span class="s2">))</span>
            <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">is_generator</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">((</span><span class="s5">&quot;GENERATOR INFO: %s&quot; </span><span class="s2">% </span><span class="s1">name</span><span class="s2">).</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">&quot;-&quot;</span><span class="s2">))</span>
                <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump_generator_info</span><span class="s2">()</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">RewriteSemanticConstants</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;rewrite_semantic_constants&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This prunes dead branches, a dead branch is one which is derivable as 
        not taken at compile time purely based on const/literal evaluation. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">'Internal error in pre-inference dead branch pruning '</span>
               <span class="s5">'pass encountered during compilation of '</span>
               <span class="s5">'function &quot;%s&quot;' </span><span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">rewrite_semantic_constants</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">DeadBranchPrune</span><span class="s2">(</span><span class="s1">SSACompliantMixin</span><span class="s2">, </span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;dead_branch_prune&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This prunes dead branches, a dead branch is one which is derivable as 
        not taken at compile time purely based on const/literal evaluation. 
        &quot;&quot;&quot;</span>

        <span class="s4"># purely for demonstration purposes, obtain the analysis from a pass</span>
        <span class="s4"># declare as a required dependent</span>
        <span class="s1">semantic_const_analysis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_analysis</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))  </span><span class="s4"># noqa</span>

        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">'Internal error in pre-inference dead branch pruning '</span>
               <span class="s5">'pass encountered during compilation of '</span>
               <span class="s5">'function &quot;%s&quot;' </span><span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">dead_branch_prune</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">get_analysis_usage</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">AU</span><span class="s2">):</span>
        <span class="s1">AU</span><span class="s2">.</span><span class="s1">add_required</span><span class="s2">(</span><span class="s1">RewriteSemanticConstants</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">InlineClosureLikes</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;inline_closure_likes&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>

        <span class="s4"># if the return type is a pyobject, there's no type info available and</span>
        <span class="s4"># no ability to resolve certain typed function calls in the array</span>
        <span class="s4"># inlining code, use this variable to indicate</span>
        <span class="s1">typed_pass </span><span class="s2">= </span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">PyObject</span><span class="s2">)</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">inline_closurecall </span><span class="s0">import </span><span class="s1">InlineClosureCallPass</span>
        <span class="s1">inline_pass </span><span class="s2">= </span><span class="s1">InlineClosureCallPass</span><span class="s2">(</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">.</span><span class="s1">replaced_fns</span><span class="s2">,</span>
            <span class="s1">typed_pass</span><span class="s2">)</span>
        <span class="s1">inline_pass</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s4"># Remove all Dels, and re-run postproc</span>
        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s1">fixup_var_define_in_scope</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">GenericRewrites</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;generic_rewrites&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform any intermediate representation rewrites before type 
        inference. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">'Internal error in pre-inference rewriting '</span>
               <span class="s5">'pass encountered during compilation of '</span>
               <span class="s5">'function &quot;%s&quot;' </span><span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">rewrites</span><span class="s2">.</span><span class="s1">rewrite_registry</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s5">'before-inference'</span><span class="s2">, </span><span class="s1">state</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">WithLifting</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;with_lifting&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Extract with-contexts 
        &quot;&quot;&quot;</span>
        <span class="s1">main</span><span class="s2">, </span><span class="s1">withs </span><span class="s2">= </span><span class="s1">transforms</span><span class="s2">.</span><span class="s1">with_lifting</span><span class="s2">(</span>
            <span class="s1">func_ir</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
            <span class="s1">typingctx</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
            <span class="s1">targetctx</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
            <span class="s1">flags</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
            <span class="s1">locals</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">locals</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">withs</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">compile_ir</span><span class="s2">, </span><span class="s1">_EarlyPipelineCompletion</span>
            <span class="s1">cres </span><span class="s2">= </span><span class="s1">compile_ir</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">, </span><span class="s1">main</span><span class="s2">,</span>
                              <span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                              <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">locals</span><span class="s2">,</span>
                              <span class="s1">lifted</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">withs</span><span class="s2">), </span><span class="s1">lifted_from</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                              <span class="s1">pipeline_class</span><span class="s2">=</span><span class="s1">type</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">pipeline</span><span class="s2">))</span>
            <span class="s0">raise </span><span class="s1">_EarlyPipelineCompletion</span><span class="s2">(</span><span class="s1">cres</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">InlineInlinables</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    This pass will inline a function wrapped by the numba.jit decorator directly 
    into the site of its call depending on the value set in the 'inline' kwarg 
    to the decorator. 
 
    This is an untyped pass. CFG simplification is performed at the end of the 
    pass but no block level clean up is performed on the mutated IR (typing 
    information is not available to do so). 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;inline_inlinables&quot;</span>
    <span class="s1">_DEBUG </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Run inlining of inlinables 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">'before inline'</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">''</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">))</span>

        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">inline_closurecall </span><span class="s0">import </span><span class="s2">(</span><span class="s1">InlineWorker</span><span class="s2">,</span>
                                                   <span class="s1">callee_ir_validator</span><span class="s2">)</span>
        <span class="s1">inline_worker </span><span class="s2">= </span><span class="s1">InlineWorker</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">locals</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">pipeline</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
                                     <span class="s1">validator</span><span class="s2">=</span><span class="s1">callee_ir_validator</span><span class="s2">)</span>

        <span class="s1">modified </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s4"># use a work list, look for call sites via `ir.Expr.op == call` and</span>
        <span class="s4"># then pass these to `self._do_work` to make decisions about inlining.</span>
        <span class="s1">work_list </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s0">while </span><span class="s1">work_list</span><span class="s2">:</span>
            <span class="s1">label</span><span class="s2">, </span><span class="s1">block </span><span class="s2">= </span><span class="s1">work_list</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">instr </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instr</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s1">expr </span><span class="s2">= </span><span class="s1">instr</span><span class="s2">.</span><span class="s1">value</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'call'</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_do_work</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">work_list</span><span class="s2">, </span><span class="s1">block</span><span class="s2">, </span><span class="s1">i</span><span class="s2">,</span>
                                 <span class="s1">expr</span><span class="s2">, </span><span class="s1">inline_worker</span><span class="s2">):</span>
                            <span class="s1">modified </span><span class="s2">= </span><span class="s0">True</span>
                            <span class="s0">break  </span><span class="s4"># because block structure changed</span>

        <span class="s0">if </span><span class="s1">modified</span><span class="s2">:</span>
            <span class="s4"># clean up unconditional branches that appear due to inlined</span>
            <span class="s4"># functions introducing blocks</span>
            <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">dead </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">dead_nodes</span><span class="s2">():</span>
                <span class="s0">del </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">dead</span><span class="s2">]</span>
            <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
            <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">'after inline'</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">''</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">))</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_do_work</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">work_list</span><span class="s2">, </span><span class="s1">block</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">inline_worker</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">run_frontend</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">cpu </span><span class="s0">import </span><span class="s1">InlineOptions</span>

        <span class="s4"># try and get a definition for the call, this isn't always possible as</span>
        <span class="s4"># it might be a eval(str)/part generated awaiting update etc. (parfors)</span>
        <span class="s1">to_inline </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">to_inline </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_definition</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;Cannot find definition for %s&quot; </span><span class="s2">% </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">return False</span>
        <span class="s4"># do not handle closure inlining here, another pass deals with that.</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">to_inline</span><span class="s2">, </span><span class="s5">'op'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) == </span><span class="s5">'make_function'</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s4"># see if the definition is a &quot;getattr&quot;, in which case walk the IR to</span>
        <span class="s4"># try and find the python function via the module from which it's</span>
        <span class="s4"># imported, this should all be encoded in the IR.</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">to_inline</span><span class="s2">, </span><span class="s5">'op'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) == </span><span class="s5">'getattr'</span><span class="s2">:</span>
            <span class="s1">val </span><span class="s2">= </span><span class="s1">resolve_func_from_module</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">to_inline</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># This is likely a freevar or global</span>
            <span class="s4">#</span>
            <span class="s4"># NOTE: getattr 'value' on a call may fail if it's an ir.Expr as</span>
            <span class="s4"># getattr is overloaded to look in _kws.</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">val </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">to_inline</span><span class="s2">, </span><span class="s5">'value'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">GuardException</span>

        <span class="s4"># if something was found...</span>
        <span class="s0">if </span><span class="s1">val</span><span class="s2">:</span>
            <span class="s4"># check it's dispatcher-like, the targetoptions attr holds the</span>
            <span class="s4"># kwargs supplied in the jit decorator and is where 'inline' will</span>
            <span class="s4"># be if it is present.</span>
            <span class="s1">topt </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s5">'targetoptions'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">topt</span><span class="s2">:</span>
                <span class="s1">inline_type </span><span class="s2">= </span><span class="s1">topt</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'inline'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s4"># has 'inline' been specified?</span>
                <span class="s0">if </span><span class="s1">inline_type </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">inline_opt </span><span class="s2">= </span><span class="s1">InlineOptions</span><span class="s2">(</span><span class="s1">inline_type</span><span class="s2">)</span>
                    <span class="s4"># Could this be inlinable?</span>
                    <span class="s0">if not </span><span class="s1">inline_opt</span><span class="s2">.</span><span class="s1">is_never_inline</span><span class="s2">:</span>
                        <span class="s4"># yes, it could be inlinable</span>
                        <span class="s1">do_inline </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s1">pyfunc </span><span class="s2">= </span><span class="s1">val</span><span class="s2">.</span><span class="s1">py_func</span>
                        <span class="s4"># Has it got an associated cost model?</span>
                        <span class="s0">if </span><span class="s1">inline_opt</span><span class="s2">.</span><span class="s1">has_cost_model</span><span class="s2">:</span>
                            <span class="s4"># yes, it has a cost model, use it to determine</span>
                            <span class="s4"># whether to do the inline</span>
                            <span class="s1">py_func_ir </span><span class="s2">= </span><span class="s1">run_frontend</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">)</span>
                            <span class="s1">do_inline </span><span class="s2">= </span><span class="s1">inline_type</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                                    <span class="s1">py_func_ir</span><span class="s2">)</span>
                        <span class="s4"># if do_inline is True then inline!</span>
                        <span class="s0">if </span><span class="s1">do_inline</span><span class="s2">:</span>
                            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">new_blocks </span><span class="s2">= </span><span class="s1">\</span>
                                <span class="s1">inline_worker</span><span class="s2">.</span><span class="s1">inline_function</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                                              <span class="s1">block</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">,)</span>
                            <span class="s0">if </span><span class="s1">work_list </span><span class="s0">is not None</span><span class="s2">:</span>
                                <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">new_blocks</span><span class="s2">:</span>
                                    <span class="s1">work_list</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)</span>
                            <span class="s0">return True</span>
        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PreserveIR</span><span class="s2">(</span><span class="s1">AnalysisPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Preserves the IR in the metadata 
    &quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;preserve_ir&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">AnalysisPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span><span class="s2">[</span><span class="s5">'preserved_ir'</span><span class="s2">] = </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">FindLiterallyCalls</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Find calls to `numba.literally()` and signal if its requirement is not 
    satisfied. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;find_literally&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">find_literally_calls</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CanonicalizeLoopExit</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A pass to canonicalize loop exit by splitting it from function exit. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;canonicalize_loop_exit&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">fir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">status </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">loop </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">loops</span><span class="s2">().</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">exit_label </span><span class="s0">in </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">exits</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">exit_label </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">exit_points</span><span class="s2">():</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_split_exit_block</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">, </span><span class="s1">exit_label</span><span class="s2">)</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">fir</span><span class="s2">.</span><span class="s1">_reset_analysis_variables</span><span class="s2">()</span>

        <span class="s1">vlt </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">VariableLifetime</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">variable_lifetime </span><span class="s2">= </span><span class="s1">vlt</span>
        <span class="s0">return </span><span class="s1">status</span>

    <span class="s0">def </span><span class="s1">_split_exit_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">, </span><span class="s1">exit_label</span><span class="s2">):</span>
        <span class="s1">curblock </span><span class="s2">= </span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">exit_label</span><span class="s2">]</span>
        <span class="s1">newlabel </span><span class="s2">= </span><span class="s1">exit_label </span><span class="s2">+ </span><span class="s6">1</span>
        <span class="s1">newlabel </span><span class="s2">= </span><span class="s1">find_max_label</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) + </span><span class="s6">1</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">newlabel</span><span class="s2">] = </span><span class="s1">curblock</span>
        <span class="s1">newblock </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">=</span><span class="s1">curblock</span><span class="s2">.</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">curblock</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">newblock</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">(</span><span class="s1">newlabel</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">curblock</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">))</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">exit_label</span><span class="s2">] = </span><span class="s1">newblock</span>
        <span class="s4"># Rename all labels</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">rename_labels</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">CanonicalizeLoopEntry</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A pass to canonicalize loop header by splitting it from function entry. 
 
    This is needed for loop-lifting; esp in py3.8 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;canonicalize_loop_entry&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">fir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">status </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">loop </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">loops</span><span class="s2">().</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">entries</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s2">[</span><span class="s1">entry_label</span><span class="s2">] = </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">entries</span>
                <span class="s0">if </span><span class="s1">entry_label </span><span class="s2">== </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">entry_point</span><span class="s2">():</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_split_entry_block</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">, </span><span class="s1">entry_label</span><span class="s2">)</span>
                    <span class="s1">status </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">_reset_analysis_variables</span><span class="s2">()</span>

        <span class="s1">vlt </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">VariableLifetime</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">variable_lifetime </span><span class="s2">= </span><span class="s1">vlt</span>
        <span class="s0">return </span><span class="s1">status</span>

    <span class="s0">def </span><span class="s1">_split_entry_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">, </span><span class="s1">entry_label</span><span class="s2">):</span>
        <span class="s4"># Find iterator inputs into the for-loop header</span>
        <span class="s1">header_block </span><span class="s2">= </span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">]</span>
        <span class="s1">deps </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">expr </span><span class="s0">in </span><span class="s1">header_block</span><span class="s2">.</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s1">op</span><span class="s2">=</span><span class="s5">&quot;iternext&quot;</span><span class="s2">):</span>
            <span class="s1">deps</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s4"># Find the getiter for each iterator</span>
        <span class="s1">entry_block </span><span class="s2">= </span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">entry_label</span><span class="s2">]</span>

        <span class="s4"># Find the start of loop entry statement that needs to be included.</span>
        <span class="s1">startpt </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">list_of_insts </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">assign </span><span class="s0">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">list_of_insts</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">target </span><span class="s0">in </span><span class="s1">deps</span><span class="s2">:</span>
                <span class="s1">rhs </span><span class="s2">= </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">value</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Var</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">rhs</span><span class="s2">.</span><span class="s1">is_temp</span><span class="s2">:</span>
                        <span class="s1">deps</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                    <span class="s1">expr </span><span class="s2">= </span><span class="s1">rhs</span>
                    <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'getiter'</span><span class="s2">:</span>
                        <span class="s1">startpt </span><span class="s2">= </span><span class="s1">assign</span>
                        <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">is_temp</span><span class="s2">:</span>
                            <span class="s1">deps</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">elif </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'call'</span><span class="s2">:</span>
                        <span class="s1">defn </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">fir</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">defn</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">):</span>
                            <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">is_temp</span><span class="s2">:</span>
                                <span class="s1">deps</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">) </span><span class="s0">and </span><span class="s1">rhs</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">range</span><span class="s2">:</span>
                    <span class="s1">startpt </span><span class="s2">= </span><span class="s1">assign</span>

        <span class="s0">if </span><span class="s1">startpt </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return</span>

        <span class="s1">splitpt </span><span class="s2">= </span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">startpt</span><span class="s2">)</span>
        <span class="s1">new_block </span><span class="s2">= </span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">new_block</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= </span><span class="s1">new_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[</span><span class="s1">splitpt</span><span class="s2">:]</span>
        <span class="s1">new_block</span><span class="s2">.</span><span class="s1">loc </span><span class="s2">= </span><span class="s1">new_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">loc</span>
        <span class="s1">new_label </span><span class="s2">= </span><span class="s1">find_max_label</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) + </span><span class="s6">1</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= </span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[:</span><span class="s1">splitpt</span><span class="s2">]</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">(</span><span class="s1">new_label</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">new_block</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">))</span>

        <span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">new_label</span><span class="s2">] = </span><span class="s1">new_block</span>
        <span class="s4"># Rename all labels</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">rename_labels</span><span class="s2">(</span><span class="s1">fir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PrintIRCFG</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;print_ir_cfg&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ver </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">fir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ver </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">fir</span><span class="s2">.</span><span class="s1">render_dot</span><span class="s2">(</span><span class="s1">filename_prefix</span><span class="s2">=</span><span class="s5">'v{}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ver</span><span class="s2">)).</span><span class="s1">render</span><span class="s2">()</span>
        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MakeFunctionToJitFunction</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    This swaps an ir.Expr.op == &quot;make_function&quot; i.e. a closure, for a compiled 
    function containing the closure body and puts it in ir.Global. It's a 1:1 
    statement value swap. `make_function` is already untyped 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;make_function_op_code_to_jit_function&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">njit</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">mutated </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;make_function&quot;</span><span class="s2">:</span>
                            <span class="s1">node </span><span class="s2">= </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span>
                            <span class="s1">getdef </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_definition</span>
                            <span class="s1">kw_default </span><span class="s2">= </span><span class="s1">getdef</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">defaults</span><span class="s2">)</span>
                            <span class="s1">ok </span><span class="s2">= </span><span class="s0">False</span>
                            <span class="s0">if </span><span class="s2">(</span><span class="s1">kw_default </span><span class="s0">is None or</span>
                                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">kw_default</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">)):</span>
                                <span class="s1">ok </span><span class="s2">= </span><span class="s0">True</span>
                            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">kw_default</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                                <span class="s1">ok </span><span class="s2">= </span><span class="s1">all</span><span class="s2">([</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">getdef</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">)</span>
                                          <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">kw_default</span><span class="s2">])</span>
                            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">kw_default</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                                <span class="s0">if </span><span class="s1">kw_default</span><span class="s2">.</span><span class="s1">op </span><span class="s2">!= </span><span class="s5">&quot;build_tuple&quot;</span><span class="s2">:</span>
                                    <span class="s0">continue</span>
                                <span class="s1">ok </span><span class="s2">= </span><span class="s1">all</span><span class="s2">([</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">getdef</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">)</span>
                                          <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">kw_default</span><span class="s2">.</span><span class="s1">items</span><span class="s2">])</span>
                            <span class="s0">if not </span><span class="s1">ok</span><span class="s2">:</span>
                                <span class="s0">continue</span>

                            <span class="s1">pyfunc </span><span class="s2">= </span><span class="s1">convert_code_obj_to_function</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">)</span>
                            <span class="s1">func </span><span class="s2">= </span><span class="s1">njit</span><span class="s2">()(</span><span class="s1">pyfunc</span><span class="s2">)</span>
                            <span class="s1">new_node </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">code</span><span class="s2">.</span><span class="s1">co_name</span><span class="s2">, </span><span class="s1">func</span><span class="s2">,</span>
                                                 <span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                            <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">new_node</span>
                            <span class="s1">mutated </span><span class="s2">|= </span><span class="s0">True</span>

        <span class="s4"># if a change was made the del ordering is probably wrong, patch up</span>
        <span class="s0">if </span><span class="s1">mutated</span><span class="s2">:</span>
            <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">)</span>
            <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s0">return </span><span class="s1">mutated</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TransformLiteralUnrollConstListToTuple</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; This pass spots a `literal_unroll([&lt;constant values&gt;])` and rewrites it 
    as a `literal_unroll(tuple(&lt;constant values&gt;))`. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;transform_literal_unroll_const_list_to_tuple&quot;</span>

    <span class="s1">_accepted_types </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">LiteralList</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">mutated </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s0">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">calls </span><span class="s2">= [</span><span class="s1">_ </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s5">'call'</span><span class="s2">)]</span>
            <span class="s0">for </span><span class="s1">call </span><span class="s0">in </span><span class="s1">calls</span><span class="s2">:</span>
                <span class="s1">glbl </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">call</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">glbl </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">glbl</span><span class="s2">, (</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">)):</span>
                    <span class="s4"># find a literal_unroll</span>
                    <span class="s0">if </span><span class="s1">glbl</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">literal_unroll</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
                            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;literal_unroll takes one argument, found %s&quot;</span>
                            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg </span><span class="s2">% </span><span class="s1">len</span><span class="s2">(</span><span class="s1">call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">),</span>
                                                          <span class="s1">call</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                        <span class="s4"># get the arg, make sure its a build_list</span>
                        <span class="s1">unroll_var </span><span class="s2">= </span><span class="s1">call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
                        <span class="s1">to_unroll </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">unroll_var</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and</span>
                                <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;build_list&quot;</span><span class="s2">):</span>
                            <span class="s4"># make sure they are all const items in the list</span>
                            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">items</span><span class="s2">):</span>
                                <span class="s1">val </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">item</span><span class="s2">)</span>
                                <span class="s0">if not </span><span class="s1">val</span><span class="s2">:</span>
                                    <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;multiple definitions for variable &quot;</span>
                                           <span class="s5">&quot;%s, cannot resolve constant&quot;</span><span class="s2">)</span>
                                    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg </span><span class="s2">% </span><span class="s1">item</span><span class="s2">,</span>
                                                                  <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">):</span>
                                    <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Found non-constant value at &quot;</span>
                                           <span class="s5">&quot;position %s in a list argument to &quot;</span>
                                           <span class="s5">&quot;literal_unroll&quot; </span><span class="s2">% </span><span class="s1">i</span><span class="s2">)</span>
                                    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">,</span>
                                                                  <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                            <span class="s4"># The above appears ok, now swap the build_list for</span>
                            <span class="s4"># a built tuple.</span>

                            <span class="s4"># find the assignment for the unroll target</span>
                            <span class="s1">to_unroll_lhs </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,</span>
                                                  <span class="s1">unroll_var</span><span class="s2">, </span><span class="s1">lhs_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

                            <span class="s0">if </span><span class="s1">to_unroll_lhs </span><span class="s0">is None</span><span class="s2">:</span>
                                <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;multiple definitions for variable &quot;</span>
                                       <span class="s5">&quot;%s, cannot resolve constant&quot;</span><span class="s2">)</span>
                                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg </span><span class="s2">% </span><span class="s1">unroll_var</span><span class="s2">,</span>
                                                              <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                            <span class="s4"># scan all blocks looking for the LHS</span>
                            <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                                <span class="s1">asgn </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">find_variable_assignment</span><span class="s2">(</span>
                                    <span class="s1">to_unroll_lhs</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                                <span class="s0">if </span><span class="s1">asgn </span><span class="s0">is not None</span><span class="s2">:</span>
                                    <span class="s0">break</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Cannot find assignment for known &quot;</span>
                                       <span class="s5">&quot;variable %s&quot;</span><span class="s2">) % </span><span class="s1">to_unroll_lhs</span><span class="s2">.</span><span class="s1">name</span>
                                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">CompilerError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

                            <span class="s4"># Create a tuple with the list items as contents</span>
                            <span class="s1">tup </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">build_tuple</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">items</span><span class="s2">,</span>
                                                      <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

                            <span class="s4"># swap the list for the tuple</span>
                            <span class="s1">asgn</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">tup</span>
                            <span class="s1">mutated </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s0">elif </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and</span>
                              <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;build_tuple&quot;</span><span class="s2">):</span>
                            <span class="s4"># this is fine, do nothing</span>
                            <span class="s0">pass</span>
                        <span class="s0">elif </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, (</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">)) </span><span class="s0">and</span>
                              <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
                            <span class="s4"># this is fine, do nothing</span>
                            <span class="s0">pass</span>
                        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Arg</span><span class="s2">):</span>
                            <span class="s4"># this is only fine if the arg is a tuple</span>
                            <span class="s1">ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">):</span>
                                <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Invalid use of literal_unroll with a &quot;</span>
                                       <span class="s5">&quot;function argument, only tuples are &quot;</span>
                                       <span class="s5">&quot;supported as function arguments, found &quot;</span>
                                       <span class="s5">&quot;%s&quot;</span><span class="s2">) % </span><span class="s1">ty</span>
                                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">,</span>
                                                              <span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">extra </span><span class="s2">= </span><span class="s0">None</span>
                            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                                <span class="s4"># probably a slice</span>
                                <span class="s0">if </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;getitem&quot;</span><span class="s2">:</span>
                                    <span class="s1">ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                                    <span class="s4"># check if this is a tuple slice</span>
                                    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">):</span>
                                        <span class="s1">extra </span><span class="s2">= </span><span class="s5">&quot;operation %s&quot; </span><span class="s2">% </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">op</span>
                                        <span class="s1">loc </span><span class="s2">= </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span>
                            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">to_unroll</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Arg</span><span class="s2">):</span>
                                <span class="s1">extra </span><span class="s2">= </span><span class="s5">&quot;non-const argument %s&quot; </span><span class="s2">% </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">name</span>
                                <span class="s1">loc </span><span class="s2">= </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s0">if </span><span class="s1">to_unroll </span><span class="s0">is None</span><span class="s2">:</span>
                                    <span class="s1">extra </span><span class="s2">= (</span><span class="s5">'multiple definitions of '</span>
                                             <span class="s5">'variable &quot;%s&quot;.' </span><span class="s2">% </span><span class="s1">unroll_var</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                                    <span class="s1">loc </span><span class="s2">= </span><span class="s1">unroll_var</span><span class="s2">.</span><span class="s1">loc</span>
                                <span class="s0">else</span><span class="s2">:</span>
                                    <span class="s1">loc </span><span class="s2">= </span><span class="s1">to_unroll</span><span class="s2">.</span><span class="s1">loc</span>
                                    <span class="s1">extra </span><span class="s2">= </span><span class="s5">&quot;unknown problem&quot;</span>

                            <span class="s0">if </span><span class="s1">extra</span><span class="s2">:</span>
                                <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Invalid use of literal_unroll, &quot;</span>
                                       <span class="s5">&quot;argument should be a tuple or a list &quot;</span>
                                       <span class="s5">&quot;of constant values. Failure reason: &quot;</span>
                                       <span class="s5">&quot;found %s&quot; </span><span class="s2">% </span><span class="s1">extra</span><span class="s2">)</span>
                                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">mutated</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">MixedContainerUnroller</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;mixed_container_unroller&quot;</span>

    <span class="s1">_DEBUG </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s1">_accepted_types </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">LiteralList</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">analyse_tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tup</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a map of type-&gt;list(indexes) for a typed tuple 
        &quot;&quot;&quot;</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
            <span class="s1">d</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">d</span>

    <span class="s0">def </span><span class="s1">add_offset_to_labels_w_ignore</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;add an offset to all block labels and jump/branch targets 
        don't add an offset to anything in the ignore list 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">ignore </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">ignore </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

        <span class="s1">new_blocks </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4"># some parfor last blocks might be empty</span>
            <span class="s1">term </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">b</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s1">term </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">term</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">term</span><span class="s2">.</span><span class="s1">target </span><span class="s0">not in </span><span class="s1">ignore</span><span class="s2">:</span>
                    <span class="s1">b</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">(</span><span class="s1">term</span><span class="s2">.</span><span class="s1">target </span><span class="s2">+ </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">term</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">term</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Branch</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">term</span><span class="s2">.</span><span class="s1">truebr </span><span class="s0">not in </span><span class="s1">ignore</span><span class="s2">:</span>
                    <span class="s1">new_true </span><span class="s2">= </span><span class="s1">term</span><span class="s2">.</span><span class="s1">truebr </span><span class="s2">+ </span><span class="s1">offset</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_true </span><span class="s2">= </span><span class="s1">term</span><span class="s2">.</span><span class="s1">truebr</span>

                <span class="s0">if </span><span class="s1">term</span><span class="s2">.</span><span class="s1">falsebr </span><span class="s0">not in </span><span class="s1">ignore</span><span class="s2">:</span>
                    <span class="s1">new_false </span><span class="s2">= </span><span class="s1">term</span><span class="s2">.</span><span class="s1">falsebr </span><span class="s2">+ </span><span class="s1">offset</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_false </span><span class="s2">= </span><span class="s1">term</span><span class="s2">.</span><span class="s1">falsebr</span>
                <span class="s1">b</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Branch</span><span class="s2">(</span><span class="s1">term</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">, </span><span class="s1">new_true</span><span class="s2">, </span><span class="s1">new_false</span><span class="s2">, </span><span class="s1">term</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">new_blocks</span><span class="s2">[</span><span class="s1">l </span><span class="s2">+ </span><span class="s1">offset</span><span class="s2">] = </span><span class="s1">b</span>
        <span class="s0">return </span><span class="s1">new_blocks</span>

    <span class="s0">def </span><span class="s1">inject_loop_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">switch_ir</span><span class="s2">, </span><span class="s1">loop_ir</span><span class="s2">, </span><span class="s1">caller_max_label</span><span class="s2">,</span>
                         <span class="s1">dont_replace</span><span class="s2">, </span><span class="s1">switch_data</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Injects the &quot;loop body&quot; held in `loop_ir` into `switch_ir` where ever 
        there is a statement of the form `SENTINEL.&lt;int&gt; = RHS`. It also: 
        * Finds and then deliberately does not relabel non-local jumps so as to 
          make the switch table suitable for injection into the IR from which 
          the loop body was derived. 
        * Looks for `typed_getitem` and wires them up to loop body version 
          specific variables or, if possible, directly writes in their constant 
          value at their use site. 
 
        Args: 
        - switch_ir, the switch table with SENTINELS as generated by 
          self.gen_switch 
        - loop_ir, the IR of the loop blocks (derived from the original func_ir) 
        - caller_max_label, the maximum label in the func_ir caller 
        - dont_replace, variables that should not be renamed (to handle 
          references to variables that are incoming at the loop head/escaping at 
          the loop exit. 
        - switch_data, the switch table data used to generated the switch_ir, 
          can be generated by self.analyse_tuple. 
 
        Returns: 
        - A type specific switch table with each case containing a versioned 
          loop body suitable for injection as a replacement for the loop_ir. 
        &quot;&quot;&quot;</span>

        <span class="s4"># Switch IR came from code gen, immediately relabel to prevent</span>
        <span class="s4"># collisions with IR derived from the user code (caller)</span>
        <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">add_offset_to_labels_w_ignore</span><span class="s2">(</span>
            <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">caller_max_label </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)</span>

        <span class="s4"># Find the sentinels and validate the form</span>
        <span class="s1">sentinel_exits </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">sentinel_blocks </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">lbl</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s5">&quot;SENTINEL&quot; </span><span class="s0">in </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">:</span>
                        <span class="s1">sentinel_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">lbl</span><span class="s2">)</span>
                        <span class="s1">sentinel_exits</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">].</span><span class="s1">target</span><span class="s2">)</span>
                        <span class="s0">break</span>

        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sentinel_exits</span><span class="s2">) == </span><span class="s6">1  </span><span class="s4"># should only be 1 exit</span>
        <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">sentinel_exits</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">())  </span><span class="s4"># kill the exit, it's dead</span>

        <span class="s4"># find jumps that are non-local, we won't relabel these</span>
        <span class="s1">ignore_set </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">local_lbl </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">loop_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()]</span>
        <span class="s0">for </span><span class="s1">lbl</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">loop_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target </span><span class="s0">not in </span><span class="s1">local_lbl</span><span class="s2">:</span>
                        <span class="s1">ignore_set</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Branch</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">truebr </span><span class="s0">not in </span><span class="s1">local_lbl</span><span class="s2">:</span>
                        <span class="s1">ignore_set</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">truebr</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">falsebr </span><span class="s0">not in </span><span class="s1">local_lbl</span><span class="s2">:</span>
                        <span class="s1">ignore_set</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">falsebr</span><span class="s2">)</span>

        <span class="s4"># make sure the generated switch table matches the switch data</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sentinel_blocks</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">switch_data</span><span class="s2">)</span>

        <span class="s4"># replace the sentinel_blocks with the loop body</span>
        <span class="s0">for </span><span class="s1">lbl</span><span class="s2">, </span><span class="s1">branch_ty </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">sentinel_blocks</span><span class="s2">, </span><span class="s1">switch_data</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()):</span>
            <span class="s1">loop_blocks </span><span class="s2">= </span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">loop_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s4"># relabel blocks WRT switch table, each block replacement will shift</span>
            <span class="s4"># the maximum label</span>
            <span class="s1">max_label </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s1">loop_blocks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">add_offset_to_labels_w_ignore</span><span class="s2">(</span>
                <span class="s1">loop_blocks</span><span class="s2">, </span><span class="s1">max_label </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">ignore_set</span><span class="s2">)</span>

            <span class="s4"># start label</span>
            <span class="s1">loop_start_lbl </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>

            <span class="s4"># fix the typed_getitem locations in the loop blocks</span>
            <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">loop_blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s1">new_body </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and</span>
                                <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;typed_getitem&quot;</span><span class="s2">):</span>
                            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">branch_ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">):</span>
                                <span class="s1">scope </span><span class="s2">= </span><span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbl</span><span class="s2">].</span><span class="s1">scope</span>
                                <span class="s1">new_const_name </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span>
                                    <span class="s5">&quot;branch_const&quot;</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">).</span><span class="s1">name</span>
                                <span class="s1">new_const_var </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Var</span><span class="s2">(</span>
                                    <span class="s1">blk</span><span class="s2">.</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">new_const_name</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">new_const_val </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">(</span>
                                    <span class="s1">branch_ty</span><span class="s2">.</span><span class="s1">literal_value</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">const_assign </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span>
                                    <span class="s1">new_const_val</span><span class="s2">, </span><span class="s1">new_const_var</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">new_assign </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span>
                                    <span class="s1">new_const_var</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">new_body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">const_assign</span><span class="s2">)</span>
                                <span class="s1">new_body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">new_assign</span><span class="s2">)</span>
                                <span class="s1">dont_replace</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">new_const_name</span><span class="s2">)</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s1">orig </span><span class="s2">= </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span>
                                <span class="s1">new_typed_getitem </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">typed_getitem</span><span class="s2">(</span>
                                    <span class="s1">value</span><span class="s2">=</span><span class="s1">orig</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">branch_ty</span><span class="s2">,</span>
                                    <span class="s1">index</span><span class="s2">=</span><span class="s1">orig</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">orig</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">new_assign </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span>
                                    <span class="s1">new_typed_getitem</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                                <span class="s1">new_body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">new_assign</span><span class="s2">)</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">new_body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">new_body</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">)</span>
                <span class="s1">blk</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= </span><span class="s1">new_body</span>

            <span class="s4"># rename</span>
            <span class="s1">var_table </span><span class="s2">= </span><span class="s1">get_name_var_table</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">)</span>
            <span class="s1">drop_keys </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">var_table</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">dont_replace</span><span class="s2">:</span>
                    <span class="s1">drop_keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">drop_keys</span><span class="s2">:</span>
                <span class="s1">var_table</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>

            <span class="s1">new_var_dict </span><span class="s2">= {}</span>
            <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">var </span><span class="s0">in </span><span class="s1">var_table</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s1">scope </span><span class="s2">= </span><span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbl</span><span class="s2">].</span><span class="s1">scope</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">scope</span><span class="s2">.</span><span class="s1">get_exact</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NotDefinedError</span><span class="s2">:</span>
                    <span class="s4"># In case the scope doesn't have the variable, we need to</span>
                    <span class="s4"># define it prior creating new copies of it! This is</span>
                    <span class="s4"># because the scope of the function and the scope of the</span>
                    <span class="s4"># loop are different and the variable needs to be redefined</span>
                    <span class="s4"># within the scope of the loop.</span>
                    <span class="s1">scope</span><span class="s2">.</span><span class="s1">define</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">var</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                <span class="s1">new_var_dict</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">var</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">).</span><span class="s1">name</span>
            <span class="s1">replace_var_names</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">, </span><span class="s1">new_var_dict</span><span class="s2">)</span>

            <span class="s4"># clobber the sentinel body and then stuff in the rest</span>
            <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbl</span><span class="s2">] = </span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">[</span><span class="s1">loop_start_lbl</span><span class="s2">])</span>
            <span class="s1">remaining_keys </span><span class="s2">= [</span><span class="s1">y </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">loop_blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()]</span>
            <span class="s1">remaining_keys</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">loop_start_lbl</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">remaining_keys</span><span class="s2">:</span>
                <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;-&quot; </span><span class="s2">* </span><span class="s6">80 </span><span class="s2">+ </span><span class="s5">&quot;EXIT STUFFER&quot;</span><span class="s2">)</span>
            <span class="s1">switch_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">()</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;-&quot; </span><span class="s2">* </span><span class="s6">80</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">switch_ir</span>

    <span class="s0">def </span><span class="s1">gen_switch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Generates a function with a switch table like 
        def foo(): 
            if PLACEHOLDER_INDEX in (&lt;integers&gt;): 
                SENTINEL = None 
            elif PLACEHOLDER_INDEX in (&lt;integers&gt;): 
                SENTINEL = None 
            ... 
            else: 
                raise RuntimeError 
 
        The data is a map of (type : indexes) for example: 
        (int64, int64, float64) 
        might give: 
        {int64: [0, 1], float64: [2]} 
 
        The index is the index variable for the driving range loop over the 
        mixed tuple. 
        &quot;&quot;&quot;</span>
        <span class="s1">elif_tplt </span><span class="s2">= </span><span class="s5">&quot;</span><span class="s0">\n\t</span><span class="s5">elif PLACEHOLDER_INDEX in (%s,):</span><span class="s0">\n\t\t</span><span class="s5">SENTINEL = None&quot;</span>

        <span class="s4"># Note regarding the insertion of the garbage/defeat variables below:</span>
        <span class="s4"># These values have been designed and inserted to defeat a specific</span>
        <span class="s4"># behaviour of the cpython optimizer. The optimization was introduced</span>
        <span class="s4"># in Python 3.10.</span>

        <span class="s4"># The URL for the BPO is:</span>
        <span class="s4"># https://bugs.python.org/issue44626</span>
        <span class="s4"># The code for the optimization can be found at:</span>
        <span class="s4"># https://github.com/python/cpython/blob/d41abe8/Python/compile.c#L7533-L7557</span>

        <span class="s4"># Essentially the CPython optimizer will inline the exit block under</span>
        <span class="s4"># certain circumstances and thus replace the jump with a return if the</span>
        <span class="s4"># exit block is small enough.  This is an issue for unroller, as it</span>
        <span class="s4"># looks for a jump, not a return, when it inserts the generated switch</span>
        <span class="s4"># table.</span>

        <span class="s4"># Part of the condition for this optimization to be applied is that the</span>
        <span class="s4"># exit block not exceed a certain (4 at the time of writing) number of</span>
        <span class="s4"># bytecode instructions. We defeat the optimizer by inserting a</span>
        <span class="s4"># sufficient number of instructions so that the exit block is big</span>
        <span class="s4"># enough. We don't care about this garbage, because the generated exit</span>
        <span class="s4"># block is discarded anyway when we smash the switch table into the</span>
        <span class="s4"># original function and so all the inserted garbage is dropped again.</span>

        <span class="s4"># The final lines of the stacktrace w/o this will look like:</span>
        <span class="s4">#</span>
        <span class="s4">#  File &quot;/numba/numba/core/untyped_passes.py&quot;, line 830, \</span>
        <span class="s4">#       in inject_loop_body</span>
        <span class="s4">#   sentinel_exits.add(blk.body[-1].target)</span>
        <span class="s4"># AttributeError: Failed in nopython mode pipeline \</span>
        <span class="s4">#       (step: handles literal_unroll)</span>
        <span class="s4"># Failed in literal_unroll_subpipeline mode pipeline \</span>
        <span class="s4">#       (step: performs mixed container unroll)</span>
        <span class="s4"># 'Return' object has no attribute 'target'</span>
        <span class="s4">#</span>
        <span class="s4"># Which indicates that a Return has been found instead of a Jump</span>

        <span class="s1">b </span><span class="s2">= (</span><span class="s5">'def foo():</span><span class="s0">\n\t</span><span class="s5">if PLACEHOLDER_INDEX in (%s,):</span><span class="s0">\n\t\t</span><span class="s5">'</span>
             <span class="s5">'SENTINEL = None</span><span class="s0">\n</span><span class="s5">%s</span><span class="s0">\n\t</span><span class="s5">else:</span><span class="s0">\n\t\t</span><span class="s5">'</span>
             <span class="s5">'raise RuntimeError(&quot;Unreachable&quot;)</span><span class="s0">\n\t</span><span class="s5">'</span>
             <span class="s5">'py310_defeat1 = 1</span><span class="s0">\n\t</span><span class="s5">'</span>
             <span class="s5">'py310_defeat2 = 2</span><span class="s0">\n\t</span><span class="s5">'</span>
             <span class="s5">'py310_defeat3 = 3</span><span class="s0">\n\t</span><span class="s5">'</span>
             <span class="s5">'py310_defeat4 = 4</span><span class="s0">\n\t</span><span class="s5">'</span>
             <span class="s2">)</span>
        <span class="s1">keys </span><span class="s2">= [</span><span class="s1">k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">data</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()]</span>

        <span class="s1">elifs </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">)):</span>
            <span class="s1">elifs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">elif_tplt </span><span class="s2">% </span><span class="s5">','</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">str</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">keys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]])))</span>
        <span class="s1">src </span><span class="s2">= </span><span class="s1">b </span><span class="s2">% (</span><span class="s5">','</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">str</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">keys</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]])), </span><span class="s5">''</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">elifs</span><span class="s2">))</span>
        <span class="s1">wstr </span><span class="s2">= </span><span class="s1">src</span>
        <span class="s1">l </span><span class="s2">= {}</span>
        <span class="s1">exec</span><span class="s2">(</span><span class="s1">wstr</span><span class="s2">, {}, </span><span class="s1">l</span><span class="s2">)</span>
        <span class="s1">bfunc </span><span class="s2">= </span><span class="s1">l</span><span class="s2">[</span><span class="s5">'foo'</span><span class="s2">]</span>
        <span class="s1">branches </span><span class="s2">= </span><span class="s1">compile_to_numba_ir</span><span class="s2">(</span><span class="s1">bfunc</span><span class="s2">, {})</span>
        <span class="s0">for </span><span class="s1">lbl</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">branches</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s5">&quot;PLACEHOLDER_INDEX&quot;</span><span class="s2">:</span>
                            <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">index</span>
        <span class="s0">return </span><span class="s1">branches</span>

    <span class="s0">def </span><span class="s1">apply_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4"># compute new CFG</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s4"># find loops</span>
        <span class="s1">loops </span><span class="s2">= </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">loops</span><span class="s2">()</span>

        <span class="s4"># 0. Find the loops containing literal_unroll and store this</span>
        <span class="s4">#    information</span>
        <span class="s1">unroll_info </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span>
            <span class="s5">&quot;unroll_info&quot;</span><span class="s2">, [</span>
                <span class="s5">&quot;loop&quot;</span><span class="s2">, </span><span class="s5">&quot;call&quot;</span><span class="s2">, </span><span class="s5">&quot;arg&quot;</span><span class="s2">, </span><span class="s5">&quot;getitem&quot;</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">get_call_args</span><span class="s2">(</span><span class="s1">init_arg</span><span class="s2">, </span><span class="s1">want</span><span class="s2">):</span>
            <span class="s4"># Chases the assignment of a called value back through a specific</span>
            <span class="s4"># call to a global function &quot;want&quot; and returns the arguments</span>
            <span class="s4"># supplied to that function's call</span>
            <span class="s1">some_call </span><span class="s2">= </span><span class="s1">get_definition</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">init_arg</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">some_call</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">GuardException</span>
            <span class="s0">if not </span><span class="s1">some_call</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;call&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">GuardException</span>
            <span class="s1">the_global </span><span class="s2">= </span><span class="s1">get_definition</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">some_call</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">the_global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">GuardException</span>
            <span class="s0">if </span><span class="s1">the_global</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is not </span><span class="s1">want</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">GuardException</span>
            <span class="s0">return </span><span class="s1">some_call</span>

        <span class="s0">def </span><span class="s1">find_unroll_loops</span><span class="s2">(</span><span class="s1">loops</span><span class="s2">):</span>
            <span class="s3">&quot;&quot;&quot;This finds loops which are compliant with the form: 
            for i in range(len(literal_unroll(&lt;something&gt;&gt;)))&quot;&quot;&quot;</span>
            <span class="s1">unroll_loops </span><span class="s2">= {}</span>
            <span class="s0">for </span><span class="s1">header_lbl</span><span class="s2">, </span><span class="s1">loop </span><span class="s0">in </span><span class="s1">loops</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4"># TODO: check the loop head has literal_unroll, if it does but</span>
                <span class="s4"># does not conform to the following then raise</span>

                <span class="s4"># scan loop header</span>
                <span class="s1">iternexts </span><span class="s2">= [</span><span class="s1">_ </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in</span>
                             <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s5">'iternext'</span><span class="s2">)]</span>
                <span class="s4"># needs to be an single iternext driven loop</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">iternexts</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s0">for </span><span class="s1">iternext </span><span class="s0">in </span><span class="s1">iternexts</span><span class="s2">:</span>
                    <span class="s4"># Walk the canonicalised loop structure and check it</span>
                    <span class="s4"># Check loop form range(literal_unroll(container)))</span>
                    <span class="s1">phi </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">iternext</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">phi </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>

                    <span class="s4"># check call global &quot;range&quot;</span>
                    <span class="s1">range_call </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_call_args</span><span class="s2">, </span><span class="s1">phi</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">range</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">range_call </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">range_arg </span><span class="s2">= </span><span class="s1">range_call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

                    <span class="s4"># check call global &quot;len&quot;</span>
                    <span class="s1">len_call </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_call_args</span><span class="s2">, </span><span class="s1">range_arg</span><span class="s2">, </span><span class="s1">len</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">len_call </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">len_arg </span><span class="s2">= </span><span class="s1">len_call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

                    <span class="s4"># check literal_unroll</span>
                    <span class="s1">literal_unroll_call </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,</span>
                                                <span class="s1">len_arg</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">literal_unroll_call </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">literal_unroll_call</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">literal_unroll_call</span><span class="s2">.</span><span class="s1">op </span><span class="s2">!= </span><span class="s5">&quot;call&quot;</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">literal_func </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">literal_unroll_call</span><span class="s2">, </span><span class="s5">'func'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                    <span class="s0">if not </span><span class="s1">literal_func</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">call_func </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,</span>
                                      <span class="s1">literal_unroll_call</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">call_func </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s1">call_func_value </span><span class="s2">= </span><span class="s1">call_func</span><span class="s2">.</span><span class="s1">value</span>

                    <span class="s0">if </span><span class="s1">call_func_value </span><span class="s0">is </span><span class="s1">literal_unroll</span><span class="s2">:</span>
                        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">literal_unroll_call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span>
                        <span class="s1">unroll_loops</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">] = </span><span class="s1">literal_unroll_call</span>
            <span class="s0">return </span><span class="s1">unroll_loops</span>

        <span class="s0">def </span><span class="s1">ensure_no_nested_unroll</span><span class="s2">(</span><span class="s1">unroll_loops</span><span class="s2">):</span>
            <span class="s4"># Validate loop nests, nested literal_unroll loops are unsupported.</span>
            <span class="s4"># This doesn't check that there's a getitem or anything else</span>
            <span class="s4"># required for the transform to work, simply just that there's no</span>
            <span class="s4"># nesting.</span>
            <span class="s0">for </span><span class="s1">test_loop </span><span class="s0">in </span><span class="s1">unroll_loops</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">ref_loop </span><span class="s0">in </span><span class="s1">unroll_loops</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">test_loop </span><span class="s2">== </span><span class="s1">ref_loop</span><span class="s2">:  </span><span class="s4"># comparing to self! skip</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">test_loop</span><span class="s2">.</span><span class="s1">header </span><span class="s0">in </span><span class="s1">ref_loop</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Nesting of literal_unroll is unsupported&quot;</span><span class="s2">)</span>
                        <span class="s1">loc </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">test_loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">loc</span>
                        <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">UnsupportedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">collect_literal_unroll_info</span><span class="s2">(</span><span class="s1">literal_unroll_loops</span><span class="s2">):</span>
            <span class="s3">&quot;&quot;&quot;Finds the loops induced by `literal_unroll`, returns a list of 
            unroll_info namedtuples for use in the transform pass. 
            &quot;&quot;&quot;</span>

            <span class="s1">literal_unroll_info </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">loop</span><span class="s2">, </span><span class="s1">literal_unroll_call </span><span class="s0">in </span><span class="s1">literal_unroll_loops</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s1">arg </span><span class="s2">= </span><span class="s1">literal_unroll_call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
                <span class="s1">typemap </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span>
                <span class="s1">resolved_arg </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">,</span>
                                     <span class="s1">lhs_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s1">ty </span><span class="s2">= </span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">resolved_arg</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">)</span>
                <span class="s4"># loop header is spelled ok, now make sure the body</span>
                <span class="s4"># actually contains a getitem</span>

                <span class="s4"># find a &quot;getitem&quot;... only looks in the blocks that belong</span>
                <span class="s4"># _solely_ to this literal_unroll (there should not be nested</span>
                <span class="s4"># literal_unroll loops, this is unsupported).</span>
                <span class="s1">tuple_getitem </span><span class="s2">= </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">lbli </span><span class="s0">in </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                    <span class="s1">blk </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbli</span><span class="s2">]</span>
                    <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                            <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and</span>
                                    <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;getitem&quot;</span><span class="s2">):</span>
                                <span class="s4"># check for something like a[i]</span>
                                <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value </span><span class="s2">!= </span><span class="s1">arg</span><span class="s2">:</span>
                                    <span class="s4"># that failed, so check for the</span>
                                    <span class="s4"># definition</span>
                                    <span class="s1">dfn </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,</span>
                                                <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                                    <span class="s0">if </span><span class="s1">dfn </span><span class="s0">is None</span><span class="s2">:</span>
                                        <span class="s0">continue</span>
                                    <span class="s0">try</span><span class="s2">:</span>
                                        <span class="s1">args </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dfn</span><span class="s2">, </span><span class="s5">'args'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                                        <span class="s0">continue</span>
                                    <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
                                        <span class="s0">continue</span>
                                    <span class="s0">if not </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s1">arg</span><span class="s2">:</span>
                                        <span class="s0">continue</span>
                                <span class="s1">target_ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                                <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target_ty</span><span class="s2">,</span>
                                                  <span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">):</span>
                                    <span class="s0">continue</span>
                                <span class="s1">tuple_getitem </span><span class="s2">= </span><span class="s1">stmt</span>
                                <span class="s0">break</span>
                    <span class="s0">if </span><span class="s1">tuple_getitem</span><span class="s2">:</span>
                        <span class="s0">break</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">continue  </span><span class="s4"># no getitem in this loop</span>

                <span class="s1">ui </span><span class="s2">= </span><span class="s1">unroll_info</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">literal_unroll_call</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">,</span>
                                 <span class="s1">tuple_getitem</span><span class="s2">)</span>
                <span class="s1">literal_unroll_info</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ui</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">literal_unroll_info</span>

        <span class="s4"># 1. Collect info about the literal_unroll loops, ensure they are legal</span>
        <span class="s1">literal_unroll_loops </span><span class="s2">= </span><span class="s1">find_unroll_loops</span><span class="s2">(</span><span class="s1">loops</span><span class="s2">)</span>
        <span class="s4"># validate</span>
        <span class="s1">ensure_no_nested_unroll</span><span class="s2">(</span><span class="s1">literal_unroll_loops</span><span class="s2">)</span>
        <span class="s4"># assemble info</span>
        <span class="s1">literal_unroll_info </span><span class="s2">= </span><span class="s1">collect_literal_unroll_info</span><span class="s2">(</span><span class="s1">literal_unroll_loops</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">literal_unroll_info</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s4"># 2. Do the unroll, get a loop and process it!</span>
        <span class="s1">info </span><span class="s2">= </span><span class="s1">literal_unroll_info</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">unroll_loop</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">info</span><span class="s2">)</span>

        <span class="s4"># 3. Rebuild the state, the IR has taken a hammering</span>
        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">'-' </span><span class="s2">* </span><span class="s6">80 </span><span class="s2">+ </span><span class="s5">&quot;END OF PASS, SIMPLIFY DONE&quot;</span><span class="s2">)</span>
            <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">()</span>
        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">unroll_loop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">loop_info</span><span class="s2">):</span>
        <span class="s4"># The general idea here is to:</span>
        <span class="s4"># 1. Find *a* getitem that conforms to the literal_unroll semantic,</span>
        <span class="s4">#    i.e. one that is targeting a tuple with a loop induced index</span>
        <span class="s4"># 2. Compute a structure from the tuple that describes which</span>
        <span class="s4">#    iterations of a loop will have which type</span>
        <span class="s4"># 3. Generate a switch table in IR form for the structure in 2</span>
        <span class="s4"># 4. Switch out getitems for the tuple for a `typed_getitem`</span>
        <span class="s4"># 5. Inject switch table as replacement loop body</span>
        <span class="s4"># 6. Patch up</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">getitem_target </span><span class="s2">= </span><span class="s1">loop_info</span><span class="s2">.</span><span class="s1">arg</span>
        <span class="s1">target_ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">getitem_target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target_ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">)</span>

        <span class="s4"># 1. find a &quot;getitem&quot; that conforms</span>
        <span class="s1">tuple_getitem </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">lbl </span><span class="s0">in </span><span class="s1">loop_info</span><span class="s2">.</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbl</span><span class="s2">]</span>
            <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,</span>
                                  <span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;getitem&quot;</span><span class="s2">:</span>
                        <span class="s4"># try a couple of spellings... a[i] and ref(a)[i]</span>
                        <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value </span><span class="s2">!= </span><span class="s1">getitem_target</span><span class="s2">:</span>
                            <span class="s1">dfn </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_definition</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                            <span class="s0">try</span><span class="s2">:</span>
                                <span class="s1">args </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dfn</span><span class="s2">, </span><span class="s5">'args'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                                <span class="s0">continue</span>
                            <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
                                <span class="s0">continue</span>
                            <span class="s0">if not </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s1">getitem_target</span><span class="s2">:</span>
                                <span class="s0">continue</span>
                        <span class="s1">target_ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">getitem_target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">target_ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">):</span>
                            <span class="s0">continue</span>
                        <span class="s1">tuple_getitem</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">tuple_getitem</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;Loop unrolling analysis has failed, there's no getitem &quot;</span>
                   <span class="s5">&quot;in loop body that conforms to literal_unroll &quot;</span>
                   <span class="s5">&quot;requirements.&quot;</span><span class="s2">)</span>
            <span class="s1">LOC </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop_info</span><span class="s2">.</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">loc</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">CompilerError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>

        <span class="s4"># 2. get switch data</span>
        <span class="s1">switch_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">analyse_tuple</span><span class="s2">(</span><span class="s1">target_ty</span><span class="s2">)</span>

        <span class="s4"># 3. generate switch IR</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions</span><span class="s2">[</span><span class="s1">tuple_getitem</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">value</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">name</span><span class="s2">][</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">branches </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gen_switch</span><span class="s2">(</span><span class="s1">switch_data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>

        <span class="s4"># 4. swap getitems for a typed_getitem, these are actually just</span>
        <span class="s4"># placeholders at this point. When the loop is duplicated they can</span>
        <span class="s4"># be swapped for a typed_getitem of the correct type or if the item</span>
        <span class="s4"># is literal it can be shoved straight into the duplicated loop body</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">tuple_getitem</span><span class="s2">:</span>
            <span class="s1">old </span><span class="s2">= </span><span class="s1">item</span><span class="s2">.</span><span class="s1">value</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">typed_getitem</span><span class="s2">(</span>
                <span class="s1">old</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">void</span><span class="s2">, </span><span class="s1">old</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">old</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">item</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">new</span>

        <span class="s4"># 5. Inject switch table</span>

        <span class="s4"># Find the actual loop without the header (that won't get replaced)</span>
        <span class="s4"># and derive some new IR for this set of blocks</span>
        <span class="s1">this_loop </span><span class="s2">= </span><span class="s1">loop_info</span><span class="s2">.</span><span class="s1">loop</span>
        <span class="s1">this_loop_body </span><span class="s2">= </span><span class="s1">this_loop</span><span class="s2">.</span><span class="s1">body </span><span class="s2">- </span><span class="s1">\</span>
            <span class="s1">set</span><span class="s2">([</span><span class="s1">this_loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">])</span>
        <span class="s1">loop_blocks </span><span class="s2">= {</span>
            <span class="s1">x</span><span class="s2">: </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">x</span><span class="s2">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">this_loop_body</span><span class="s2">}</span>
        <span class="s1">new_ir </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">derive</span><span class="s2">(</span><span class="s1">loop_blocks</span><span class="s2">)</span>

        <span class="s4"># Work out what is live on entry and exit so as to prevent</span>
        <span class="s4"># replacement (defined vars can escape, used vars live at the header</span>
        <span class="s4"># need to remain as-is so their references are correct, they can</span>
        <span class="s4"># also escape).</span>

        <span class="s1">usedefs </span><span class="s2">= </span><span class="s1">compute_use_defs</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">this_loop</span><span class="s2">.</span><span class="s1">header</span>
        <span class="s1">keep </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">keep </span><span class="s2">|= </span><span class="s1">usedefs</span><span class="s2">.</span><span class="s1">usemap</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] | </span><span class="s1">usedefs</span><span class="s2">.</span><span class="s1">defmap</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
        <span class="s1">keep </span><span class="s2">|= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">variable_lifetime</span><span class="s2">.</span><span class="s1">livemap</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
        <span class="s1">dont_replace </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s2">(</span><span class="s1">keep</span><span class="s2">)]</span>

        <span class="s4"># compute the unrolled body</span>
        <span class="s1">unrolled_body </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">inject_loop_body</span><span class="s2">(</span>
            <span class="s1">branches</span><span class="s2">, </span><span class="s1">new_ir</span><span class="s2">, </span><span class="s1">max</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) + </span><span class="s6">1</span><span class="s2">,</span>
            <span class="s1">dont_replace</span><span class="s2">, </span><span class="s1">switch_data</span><span class="s2">)</span>

        <span class="s4"># 6. Patch in the unrolled body and fix up</span>
        <span class="s1">blks </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span>
        <span class="s1">the_scope </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">blks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())).</span><span class="s1">scope</span>
        <span class="s1">orig_lbl </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">this_loop_body</span><span class="s2">)</span>

        <span class="s1">replace</span><span class="s2">, *</span><span class="s1">delete </span><span class="s2">= </span><span class="s1">orig_lbl</span>
        <span class="s1">unroll</span><span class="s2">, </span><span class="s1">header_block </span><span class="s2">= </span><span class="s1">unrolled_body</span><span class="s2">, </span><span class="s1">this_loop</span><span class="s2">.</span><span class="s1">header</span>
        <span class="s1">unroll_lbl </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">unroll</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())]</span>
        <span class="s1">blks</span><span class="s2">[</span><span class="s1">replace</span><span class="s2">] = </span><span class="s1">transfer_scope</span><span class="s2">(</span><span class="s1">unroll</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">unroll_lbl</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]], </span><span class="s1">the_scope</span><span class="s2">)</span>
        <span class="s2">[</span><span class="s1">blks</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">delete</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">unroll_lbl</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]:</span>
            <span class="s1">blks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">transfer_scope</span><span class="s2">(</span><span class="s1">unroll</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">the_scope</span><span class="s2">)</span>
        <span class="s4"># stitch up the loop predicate true -&gt; new loop body jump</span>
        <span class="s1">blks</span><span class="s2">[</span><span class="s1">header_block</span><span class="s2">].</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">].</span><span class="s1">truebr </span><span class="s2">= </span><span class="s1">replace</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">mutated </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s4"># first limit the work by squashing the CFG if possible</span>
        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;-&quot; </span><span class="s2">* </span><span class="s6">80 </span><span class="s2">+ </span><span class="s5">&quot;PASS ENTRY&quot;</span><span class="s2">)</span>
            <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">()</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;-&quot; </span><span class="s2">* </span><span class="s6">80</span><span class="s2">)</span>

        <span class="s4"># limitations:</span>
        <span class="s4"># 1. No nested unrolls</span>
        <span class="s4"># 2. Opt in via `numba.literal_unroll`</span>
        <span class="s4"># 3. No multiple mix-tuple use</span>

        <span class="s4"># keep running the transform loop until it reports no more changes</span>
        <span class="s0">while </span><span class="s2">(</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s1">stat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply_transform</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>
            <span class="s1">mutated </span><span class="s2">|= </span><span class="s1">stat</span>
            <span class="s0">if not </span><span class="s1">stat</span><span class="s2">:</span>
                <span class="s0">break</span>

        <span class="s4"># reset type inference now we are done with the partial results</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap </span><span class="s2">= {}</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">mutated</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">IterLoopCanonicalization</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; Transforms loops that are induced by `getiter` into range() driven loops 
    If the typemap is available this will only impact Tuple and UniTuple, if it 
    is not available it will impact all matching loops. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;iter_loop_canonicalisation&quot;</span>

    <span class="s1">_DEBUG </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s4"># if partial typing info is available it will only look at these types</span>
    <span class="s1">_accepted_types </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">LiteralList</span><span class="s2">)</span>
    <span class="s1">_accepted_calls </span><span class="s2">= (</span><span class="s1">literal_unroll</span><span class="s2">,)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assess_loop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">partial_typemap</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4"># it's a iter loop if:</span>
        <span class="s4"># - loop header is driven by an iternext</span>
        <span class="s4"># - the iternext value is a phi derived from getiter()</span>

        <span class="s4"># check header</span>
        <span class="s1">iternexts </span><span class="s2">= [</span><span class="s1">_ </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in</span>
                     <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s5">'iternext'</span><span class="s2">)]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">iternexts</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s0">for </span><span class="s1">iternext </span><span class="s0">in </span><span class="s1">iternexts</span><span class="s2">:</span>
            <span class="s1">phi </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">iternext</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">phi </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return False</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">phi</span><span class="s2">, </span><span class="s5">'op'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) == </span><span class="s5">'getiter'</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">partial_typemap</span><span class="s2">:</span>
                    <span class="s4"># check that the call site is accepted, until we're</span>
                    <span class="s4"># confident that tuple unrolling is behaving require opt-in</span>
                    <span class="s4"># guard of `literal_unroll`, remove this later!</span>
                    <span class="s1">phi_val_defn </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">phi</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">phi_val_defn</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                        <span class="s0">return False</span>
                    <span class="s0">if not </span><span class="s1">phi_val_defn</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;call&quot;</span><span class="s2">:</span>
                        <span class="s0">return False</span>
                    <span class="s1">call </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">phi_val_defn</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">call </span><span class="s0">is None or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
                        <span class="s0">return False</span>
                    <span class="s1">func_var </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">call</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
                    <span class="s1">func </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">func_var</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">func </span><span class="s0">is None or not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">,</span>
                                                      <span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">)):</span>
                        <span class="s0">return False</span>
                    <span class="s0">if </span><span class="s2">(</span><span class="s1">func</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is None or</span>
                            <span class="s1">func</span><span class="s2">.</span><span class="s1">value </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_calls</span><span class="s2">):</span>
                        <span class="s0">return False</span>

                    <span class="s4"># now check the type is supported</span>
                    <span class="s1">ty </span><span class="s2">= </span><span class="s1">partial_typemap</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">call</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">ty </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accepted_types</span><span class="s2">):</span>
                        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">entries</span><span class="s2">) == </span><span class="s6">1</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">entries</span><span class="s2">) == </span><span class="s6">1</span>

    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">get_range</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">a</span><span class="s2">))</span>

        <span class="s1">iternext </span><span class="s2">= [</span><span class="s1">_ </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in</span>
                    <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s5">'iternext'</span><span class="s2">)][</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">LOC </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">loc</span>
        <span class="s1">scope </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">].</span><span class="s1">scope</span>
        <span class="s1">get_range_var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">&quot;CANONICALISER_get_range_gbl&quot;</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>
        <span class="s1">get_range_global </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">(</span><span class="s5">'get_range'</span><span class="s2">, </span><span class="s1">get_range</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>
        <span class="s1">assgn </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">get_range_global</span><span class="s2">, </span><span class="s1">get_range_var</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>

        <span class="s1">loop_entry </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">entries</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">entry_block </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop_entry</span><span class="s2">]</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">assgn</span><span class="s2">)</span>

        <span class="s1">iterarg </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">,  </span><span class="s1">iternext</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">iterarg </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">iterarg </span><span class="s2">= </span><span class="s1">iterarg</span><span class="s2">.</span><span class="s1">value</span>

        <span class="s4"># look for iternext</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,</span>
                              <span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'getiter'</span><span class="s2">:</span>
                    <span class="s0">break</span>
            <span class="s1">idx </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;problem&quot;</span><span class="s2">)</span>

        <span class="s4"># create a range(len(tup)) and inject it</span>
        <span class="s1">call_get_range_var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">'CANONICALISER_call_get_range'</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>
        <span class="s1">make_call </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">get_range_var</span><span class="s2">, (</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value</span><span class="s2">,), (), </span><span class="s1">LOC</span><span class="s2">)</span>
        <span class="s1">assgn_call </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">make_call</span><span class="s2">, </span><span class="s1">call_get_range_var</span><span class="s2">, </span><span class="s1">LOC</span><span class="s2">)</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">assgn_call</span><span class="s2">)</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">[</span><span class="s1">idx </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">].</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">call_get_range_var</span>

        <span class="s1">glbls </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__globals__</span><span class="s2">)</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">inline_closurecall </span><span class="s0">import </span><span class="s1">inline_closure_call</span>
        <span class="s1">inline_closure_call</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">glbls</span><span class="s2">, </span><span class="s1">entry_block</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">get_range</span><span class="s2">,)</span>
        <span class="s1">kill </span><span class="s2">= </span><span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">assgn</span><span class="s2">)</span>
        <span class="s1">entry_block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">kill</span><span class="s2">)</span>

        <span class="s4"># find the induction variable + references in the loop header</span>
        <span class="s4"># fixed point iter to do this, it's a bit clunky</span>
        <span class="s1">induction_vars </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">header_block </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">]</span>

        <span class="s4"># find induction var</span>
        <span class="s1">ind </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">header_block</span><span class="s2">.</span><span class="s1">find_exprs</span><span class="s2">(</span><span class="s5">'pair_first'</span><span class="s2">)]</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">ind</span><span class="s2">:</span>
            <span class="s1">induction_vars</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_assignee</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">))</span>
        <span class="s4"># find aliases of the induction var</span>
        <span class="s1">tmp </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">induction_vars</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:  </span><span class="s4"># there's not always an alias, e.g. loop from inlined closure</span>
                <span class="s1">tmp</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_assignee</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">))</span>
            <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s0">pass</span>
        <span class="s1">induction_vars </span><span class="s2">|= </span><span class="s1">tmp</span>
        <span class="s1">induction_var_names </span><span class="s2">= </span><span class="s1">set</span><span class="s2">([</span><span class="s1">x</span><span class="s2">.</span><span class="s1">name </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">induction_vars</span><span class="s2">])</span>

        <span class="s4"># Find the downstream blocks that might reference the induction var</span>
        <span class="s1">succ </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">lbl </span><span class="s0">in </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">exits</span><span class="s2">:</span>
            <span class="s1">succ </span><span class="s2">|= </span><span class="s1">set</span><span class="s2">([</span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">successors</span><span class="s2">(</span><span class="s1">lbl</span><span class="s2">)])</span>
        <span class="s1">check_blocks </span><span class="s2">= (</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">body </span><span class="s2">| </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">exits </span><span class="s2">| </span><span class="s1">succ</span><span class="s2">) ^ {</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">header</span><span class="s2">}</span>

        <span class="s4"># replace RHS use of induction var with getitem</span>
        <span class="s0">for </span><span class="s1">lbl </span><span class="s0">in </span><span class="s1">check_blocks</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">lbl</span><span class="s2">].</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s4"># check for aliases</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">lookup </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s5">'name'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">lookup </span><span class="s0">and </span><span class="s1">lookup </span><span class="s0">in </span><span class="s1">induction_var_names</span><span class="s2">:</span>
                        <span class="s1">stmt</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">getitem</span><span class="s2">(</span>
                            <span class="s1">iterarg</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">loops </span><span class="s2">= </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">loops</span><span class="s2">()</span>

        <span class="s1">mutated </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">header</span><span class="s2">, </span><span class="s1">loop </span><span class="s0">in </span><span class="s1">loops</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">stat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assess_loop</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">stat</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;Canonicalising loop&quot;</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">cfg</span><span class="s2">)</span>
                <span class="s1">mutated </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;NOT Canonicalising loop&quot;</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">)</span>

        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">mutated</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PropagateLiterals</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Implement literal propagation based on partial type inference&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;PropagateLiterals&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_analysis_usage</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">AU</span><span class="s2">):</span>
        <span class="s1">AU</span><span class="s2">.</span><span class="s1">add_required</span><span class="s2">(</span><span class="s1">ReconstructSSA</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">typemap </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span>
        <span class="s1">flags </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span>

        <span class="s1">accepted_functions </span><span class="s2">= (</span><span class="s5">'isinstance'</span><span class="s2">, </span><span class="s5">'hasattr'</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s5">'_definitions'</span><span class="s2">) </span><span class="s1">\</span>
                <span class="s0">and not </span><span class="s1">flags</span><span class="s2">.</span><span class="s1">enable_ssa</span><span class="s2">:</span>
            <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s1">changed </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">assign </span><span class="s0">in </span><span class="s1">block</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">value</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Arg</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">)):</span>
                    <span class="s0">continue</span>

                <span class="s4"># 1) Don't change return stmt in the form</span>
                <span class="s4"># $return_xyz = cast(value=ABC)</span>
                <span class="s4"># 2) Don't propagate literal values that are not primitives</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">\</span>
                        <span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s0">in </span><span class="s2">(</span><span class="s5">'cast'</span><span class="s2">, </span><span class="s5">'build_map'</span><span class="s2">, </span><span class="s5">'build_list'</span><span class="s2">,</span>
                                     <span class="s5">'build_tuple'</span><span class="s2">, </span><span class="s5">'build_set'</span><span class="s2">):</span>
                    <span class="s0">continue</span>

                <span class="s1">target </span><span class="s2">= </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">target</span>
                <span class="s0">if not </span><span class="s1">flags</span><span class="s2">.</span><span class="s1">enable_ssa</span><span class="s2">:</span>
                    <span class="s4"># SSA is disabled when doing inlining</span>
                    <span class="s0">if </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">) </span><span class="s0">is None</span><span class="s2">:  </span><span class="s4"># noqa: E501</span>
                        <span class="s0">continue</span>

                <span class="s4"># Numba cannot safely determine if an isinstance call</span>
                <span class="s4"># with a PHI node is True/False. For instance, in</span>
                <span class="s4"># the case below, the partial type inference step can coerce</span>
                <span class="s4"># '$z' to float, so any call to 'isinstance(z, int)' would fail.</span>
                <span class="s4">#</span>
                <span class="s4">#   def fn(x):</span>
                <span class="s4">#       if x &gt; 4:</span>
                <span class="s4">#           z = 1</span>
                <span class="s4">#       else:</span>
                <span class="s4">#           z = 3.14</span>
                <span class="s4">#       if isinstance(z, int):</span>
                <span class="s4">#           print('int')</span>
                <span class="s4">#       else:</span>
                <span class="s4">#           print('float')</span>
                <span class="s4">#</span>
                <span class="s4"># At the moment, one avoid propagating the literal</span>
                <span class="s4"># value if the argument is a PHI node</span>

                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'call'</span><span class="s2">:</span>

                    <span class="s1">fn </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">value</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">fn </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">continue</span>

                    <span class="s0">if not </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">) </span><span class="s0">and </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">name </span><span class="s0">in</span>
                            <span class="s1">accepted_functions</span><span class="s2">):</span>
                        <span class="s0">continue</span>

                    <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">value</span><span class="s2">.</span><span class="s1">args</span><span class="s2">:</span>
                        <span class="s4"># check if any of the args to isinstance is a PHI node</span>
                        <span class="s1">iv </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">iv</span><span class="s2">) == </span><span class="s6">1  </span><span class="s4"># SSA!</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">iv</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">iv</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'phi'</span><span class="s2">:</span>
                            <span class="s1">msg </span><span class="s2">= (</span><span class="s5">f'</span><span class="s0">{</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">() cannot determine the '</span>
                                   <span class="s5">f'type of variable &quot;</span><span class="s0">{</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">unversioned_name</span><span class="s0">}</span><span class="s5">&quot; '</span>
                                   <span class="s5">'due to a branch.'</span><span class="s2">)</span>
                            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">assign</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

                <span class="s4"># Only propagate a PHI node if all arguments are the same</span>
                <span class="s4"># constant</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">'phi'</span><span class="s2">:</span>
                    <span class="s4"># typemap will return None in case `inc.name` not in typemap</span>
                    <span class="s1">v </span><span class="s2">= [</span><span class="s1">typemap</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">.</span><span class="s1">name</span><span class="s2">) </span><span class="s0">for </span><span class="s1">inc </span><span class="s0">in </span><span class="s1">value</span><span class="s2">.</span><span class="s1">incoming_values</span><span class="s2">]</span>
                    <span class="s4"># stop if the elements in `v` do not hold the same value</span>
                    <span class="s0">if </span><span class="s1">v</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">is not None and </span><span class="s1">any</span><span class="s2">([</span><span class="s1">v</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s1">vi </span><span class="s0">for </span><span class="s1">vi </span><span class="s0">in </span><span class="s1">v</span><span class="s2">]):</span>
                        <span class="s0">continue</span>

                <span class="s1">lit </span><span class="s2">= </span><span class="s1">typemap</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">lit </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lit</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Literal</span><span class="s2">):</span>
                    <span class="s4"># replace assign instruction by ir.Const(lit) iff</span>
                    <span class="s4"># lit is a literal value</span>
                    <span class="s1">rhs </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">(</span><span class="s1">lit</span><span class="s2">.</span><span class="s1">literal_value</span><span class="s2">, </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>
                    <span class="s1">new_assign </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

                    <span class="s4"># replace instruction</span>
                    <span class="s1">block</span><span class="s2">.</span><span class="s1">insert_after</span><span class="s2">(</span><span class="s1">new_assign</span><span class="s2">, </span><span class="s1">assign</span><span class="s2">)</span>
                    <span class="s1">block</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">)</span>

                    <span class="s1">changed </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s4"># reset type inference now we are done with the partial results</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">changed</span><span class="s2">:</span>
            <span class="s4"># Rebuild definitions</span>
            <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">changed</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">LiteralPropagationSubPipelinePass</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Implement literal propagation based on partial type inference&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;LiteralPropagation&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4"># Determine whether to even attempt this pass... if there's no</span>
        <span class="s4"># `isinstance` as a global or as a freevar then just skip.</span>

        <span class="s1">found </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">asgn </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">asgn</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">)):</span>
                    <span class="s1">value </span><span class="s2">= </span><span class="s1">asgn</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value</span>
                    <span class="s0">if </span><span class="s1">value </span><span class="s0">is </span><span class="s1">isinstance </span><span class="s0">or </span><span class="s1">value </span><span class="s0">is </span><span class="s1">hasattr</span><span class="s2">:</span>
                        <span class="s1">found </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">found</span><span class="s2">:</span>
                <span class="s0">break</span>
        <span class="s0">if not </span><span class="s1">found</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s4"># run as subpipeline</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_machinery </span><span class="s0">import </span><span class="s1">PassManager</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typed_passes </span><span class="s0">import </span><span class="s1">PartialTypeInference</span>
        <span class="s1">pm </span><span class="s2">= </span><span class="s1">PassManager</span><span class="s2">(</span><span class="s5">&quot;literal_propagation_subpipeline&quot;</span><span class="s2">)</span>

        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">PartialTypeInference</span><span class="s2">, </span><span class="s5">&quot;performs partial type inference&quot;</span><span class="s2">)</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">PropagateLiterals</span><span class="s2">, </span><span class="s5">&quot;performs propagation of literal values&quot;</span><span class="s2">)</span>

        <span class="s4"># rewrite consts / dead branch pruning</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">RewriteSemanticConstants</span><span class="s2">, </span><span class="s5">&quot;rewrite semantic constants&quot;</span><span class="s2">)</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">DeadBranchPrune</span><span class="s2">, </span><span class="s5">&quot;dead branch pruning&quot;</span><span class="s2">)</span>

        <span class="s1">pm</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">()</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">get_analysis_usage</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">AU</span><span class="s2">):</span>
        <span class="s1">AU</span><span class="s2">.</span><span class="s1">add_required</span><span class="s2">(</span><span class="s1">ReconstructSSA</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">LiteralUnroll</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Implement the literal_unroll semantics&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;literal_unroll&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4"># Determine whether to even attempt this pass... if there's no</span>
        <span class="s4"># `literal_unroll` as a global or as a freevar then just skip.</span>
        <span class="s1">found </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">asgn </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">asgn</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">)):</span>
                    <span class="s0">if </span><span class="s1">asgn</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">literal_unroll</span><span class="s2">:</span>
                        <span class="s1">found </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">found</span><span class="s2">:</span>
                <span class="s0">break</span>
        <span class="s0">if not </span><span class="s1">found</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s4"># run as subpipeline</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_machinery </span><span class="s0">import </span><span class="s1">PassManager</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typed_passes </span><span class="s0">import </span><span class="s1">PartialTypeInference</span>
        <span class="s1">pm </span><span class="s2">= </span><span class="s1">PassManager</span><span class="s2">(</span><span class="s5">&quot;literal_unroll_subpipeline&quot;</span><span class="s2">)</span>
        <span class="s4"># get types where possible to help with list-&gt;tuple change</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">PartialTypeInference</span><span class="s2">, </span><span class="s5">&quot;performs partial type inference&quot;</span><span class="s2">)</span>
        <span class="s4"># make const lists tuples</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">TransformLiteralUnrollConstListToTuple</span><span class="s2">,</span>
                    <span class="s5">&quot;switch const list for tuples&quot;</span><span class="s2">)</span>
        <span class="s4"># recompute partial typemap following IR change</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">PartialTypeInference</span><span class="s2">, </span><span class="s5">&quot;performs partial type inference&quot;</span><span class="s2">)</span>
        <span class="s4"># canonicalise loops</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">IterLoopCanonicalization</span><span class="s2">,</span>
                    <span class="s5">&quot;switch iter loops for range driven loops&quot;</span><span class="s2">)</span>
        <span class="s4"># rewrite consts</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">RewriteSemanticConstants</span><span class="s2">, </span><span class="s5">&quot;rewrite semantic constants&quot;</span><span class="s2">)</span>
        <span class="s4"># do the unroll</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">MixedContainerUnroller</span><span class="s2">, </span><span class="s5">&quot;performs mixed container unroll&quot;</span><span class="s2">)</span>
        <span class="s4"># rewrite dynamic getitem to static getitem as it's possible some more</span>
        <span class="s4"># getitems will now be statically resolvable</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">GenericRewrites</span><span class="s2">, </span><span class="s5">&quot;Generic Rewrites&quot;</span><span class="s2">)</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">add_pass</span><span class="s2">(</span><span class="s1">RewriteSemanticConstants</span><span class="s2">, </span><span class="s5">&quot;rewrite semantic constants&quot;</span><span class="s2">)</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">()</span>
        <span class="s1">pm</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">SimplifyCFG</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Perform CFG simplification&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;simplify_cfg&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">blks </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span>
        <span class="s1">new_blks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">blks</span><span class="s2">)</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">new_blks</span>
        <span class="s1">mutated </span><span class="s2">= </span><span class="s1">blks </span><span class="s2">!= </span><span class="s1">new_blks</span>
        <span class="s0">return </span><span class="s1">mutated</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ReconstructSSA</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Perform SSA-reconstruction 
 
    Produces minimal SSA. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;reconstruct_ssa&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir </span><span class="s2">= </span><span class="s1">reconstruct_ssa</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_patch_locals</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>

        <span class="s4"># Rebuild definitions</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s4"># Rerun postprocessor to update metadata</span>
        <span class="s4"># example generator_info</span>
        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">emit_dels</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DEBUG </span><span class="s0">or </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DUMP_SSA</span><span class="s2">:</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_qualname</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">f&quot;SSA IR DUMP: </span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s5">&quot;-&quot;</span><span class="s2">))</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">()</span>

        <span class="s0">return True      </span><span class="s4"># XXX detect if it actually got changed</span>

    <span class="s0">def </span><span class="s1">_patch_locals</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4"># Fix dispatcher locals dictionary type annotation</span>
        <span class="s1">locals_dict </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'locals'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">locals_dict </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return</span>

        <span class="s1">first_blk</span><span class="s2">, *</span><span class="s1">_ </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s1">scope </span><span class="s2">= </span><span class="s1">first_blk</span><span class="s2">.</span><span class="s1">scope</span>
        <span class="s0">for </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">redefs </span><span class="s0">in </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">var_redefinitions</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">parent </span><span class="s0">in </span><span class="s1">locals_dict</span><span class="s2">:</span>
                <span class="s1">typ </span><span class="s2">= </span><span class="s1">locals_dict</span><span class="s2">[</span><span class="s1">parent</span><span class="s2">]</span>
                <span class="s0">for </span><span class="s1">derived </span><span class="s0">in </span><span class="s1">redefs</span><span class="s2">:</span>
                    <span class="s1">locals_dict</span><span class="s2">[</span><span class="s1">derived</span><span class="s2">] = </span><span class="s1">typ</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">RewriteDynamicRaises</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Replace existing raise statements by dynamic raises in Numba IR. 
    &quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s5">&quot;Rewrite dynamic raises&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">changed </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">raise_ </span><span class="s0">in </span><span class="s1">block</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">((</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Raise</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">TryRaise</span><span class="s2">)):</span>
                <span class="s1">call_inst </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">raise_</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">call_inst </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s1">exc_type </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">infer_constant</span><span class="s2">(</span><span class="s1">call_inst</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                <span class="s1">exc_args </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">exc_arg </span><span class="s0">in </span><span class="s1">call_inst</span><span class="s2">.</span><span class="s1">args</span><span class="s2">:</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">const </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">infer_constant</span><span class="s2">(</span><span class="s1">exc_arg</span><span class="s2">)</span>
                        <span class="s1">exc_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">const</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">consts</span><span class="s2">.</span><span class="s1">ConstantInferenceError</span><span class="s2">:</span>
                        <span class="s1">exc_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">exc_arg</span><span class="s2">)</span>
                <span class="s1">loc </span><span class="s2">= </span><span class="s1">raise_</span><span class="s2">.</span><span class="s1">loc</span>

                <span class="s1">cls </span><span class="s2">= {</span>
                    <span class="s1">ir</span><span class="s2">.</span><span class="s1">TryRaise</span><span class="s2">: </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">DynamicTryRaise</span><span class="s2">,</span>
                    <span class="s1">ir</span><span class="s2">.</span><span class="s1">Raise</span><span class="s2">: </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">DynamicRaise</span><span class="s2">,</span>
                <span class="s2">}[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">raise_</span><span class="s2">)]</span>

                <span class="s1">dyn_raise </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">exc_args</span><span class="s2">), </span><span class="s1">loc</span><span class="s2">)</span>
                <span class="s1">block</span><span class="s2">.</span><span class="s1">insert_after</span><span class="s2">(</span><span class="s1">dyn_raise</span><span class="s2">, </span><span class="s1">raise_</span><span class="s2">)</span>
                <span class="s1">block</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">raise_</span><span class="s2">)</span>
                <span class="s1">changed </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">changed</span>
</pre>
</body>
</html>