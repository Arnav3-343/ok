<html>
<head>
<title>typeinfer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typeinfer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Type inference base on CPA. 
The algorithm guarantees monotonic growth of type-sets for each variable. 
 
Steps: 
    1. seed initial types 
    2. build constraints 
    3. propagate constraints 
    4. unify types 
 
Constraint propagation is precise and does not regret (no backtracing). 
Constraints push types forward following the dataflow. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">pprint </span><span class="s2">import </span><span class="s1">pprint</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span><span class="s3">, </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">utils</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">, </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">templates </span><span class="s2">import </span><span class="s1">Signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s3">(</span><span class="s1">TypingError</span><span class="s3">, </span><span class="s1">UntypedAttributeError</span><span class="s3">,</span>
                               <span class="s1">new_error_context</span><span class="s3">, </span><span class="s1">termcolor</span><span class="s3">, </span><span class="s1">UnsupportedError</span><span class="s3">,</span>
                               <span class="s1">ForceLiteralArg</span><span class="s3">, </span><span class="s1">CompilerError</span><span class="s3">, </span><span class="s1">NumbaValueError</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">funcdesc </span><span class="s2">import </span><span class="s1">qualifying_prefix</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typeconv </span><span class="s2">import </span><span class="s1">Conversion</span>

<span class="s1">_logger </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s1">__name__</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">NOTSET</span><span class="s3">:</span>
    <span class="s2">pass</span>


<span class="s4"># terminal color markup</span>
<span class="s1">_termcolor </span><span class="s3">= </span><span class="s1">termcolor</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">var</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">var </span><span class="s3">= </span><span class="s1">var</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">locked </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s4"># Stores source location of first definition</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s4"># Qualifiers</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">literal_value </span><span class="s3">= </span><span class="s1">NOTSET</span>

    <span class="s2">def </span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Type</span><span class="s3">), </span><span class="s1">type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s4"># Special case for _undef_var.</span>
        <span class="s4"># If the typevar is the _undef_var, use the incoming type directly.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">_undef_var</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">tp</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">locked</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">tp </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">can_convert</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;No conversion from %s to %s for '%s', &quot;</span>
                           <span class="s5">&quot;defined at %s&quot;</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var</span><span class="s3">,</span>
                                             <span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc</span><span class="s3">),</span>
                                      <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">unified </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_pairs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">unified </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot unify %s and %s for '%s', defined at %s&quot;</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var</span><span class="s3">,</span>
                                             <span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc</span><span class="s3">),</span>
                                      <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># First time definition</span>
                <span class="s1">unified </span><span class="s3">= </span><span class="s1">tp</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc </span><span class="s3">= </span><span class="s1">loc</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">unified</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s2">def </span><span class="s1">lock</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">literal_value</span><span class="s3">=</span><span class="s1">NOTSET</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Type</span><span class="s3">), </span><span class="s1">type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">locked</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Invalid reassignment of a type-variable detected, type &quot;</span>
                   <span class="s5">&quot;variables are locked according to the user provided &quot;</span>
                   <span class="s5">&quot;function signature or from an ir.Const node. This is a &quot;</span>
                   <span class="s5">&quot;bug! Type={}. {}&quot;</span><span class="s3">).</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">CompilerError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s4"># If there is already a type, ensure we can convert it to the</span>
        <span class="s4"># locked type.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None and</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">can_convert</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;No conversion from %s to %s for &quot;</span>
                              <span class="s5">&quot;'%s'&quot; </span><span class="s3">% (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">tp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">locked </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">define_loc </span><span class="s3">= </span><span class="s1">loc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">literal_value </span><span class="s3">= </span><span class="s1">literal_value</span>

    <span class="s2">def </span><span class="s1">union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">'%s := %s' </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">or </span><span class="s5">&quot;&lt;undecided&gt;&quot;</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">defined</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,) </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None else </span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">getone</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Undecided type {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None else </span><span class="s6">0</span>


<span class="s2">class </span><span class="s1">ConstraintNetwork</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    TODO: It is possible to optimize constraint propagation to consider only 
          dirty type variables. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints </span><span class="s3">= []</span>

    <span class="s2">def </span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">propagate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Execute all constraints.  Errors are caught and returned as a list. 
        This allows progressing even though some constraints may fail 
        due to lack of information 
        (e.g. imprecise types such as List(undefined)). 
        &quot;&quot;&quot;</span>
        <span class="s1">errors </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">:</span>
            <span class="s1">loc </span><span class="s3">= </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">loc</span>
            <span class="s2">with </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">,</span>
                                                   <span class="s1">lineno</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line</span><span class="s3">):</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">constraint</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">ForceLiteralArg </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s1">errors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">TypingError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">&quot;captured error&quot;</span><span class="s3">, </span><span class="s1">exc_info</span><span class="s3">=</span><span class="s1">e</span><span class="s3">)</span>
                    <span class="s1">new_exc </span><span class="s3">= </span><span class="s1">TypingError</span><span class="s3">(</span>
                        <span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                        <span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">errors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">chain_exception</span><span class="s3">(</span><span class="s1">new_exc</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">use_old_style_errors</span><span class="s3">():</span>
                        <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">&quot;captured error&quot;</span><span class="s3">, </span><span class="s1">exc_info</span><span class="s3">=</span><span class="s1">e</span><span class="s3">)</span>
                        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Internal error at {con}.</span><span class="s2">\n</span><span class="s5">{err}</span><span class="s2">\n</span><span class="s5">&quot;</span>
                               <span class="s5">&quot;Enable logging at debug level for details.&quot;</span><span class="s3">)</span>
                        <span class="s1">new_exc </span><span class="s3">= </span><span class="s1">TypingError</span><span class="s3">(</span>
                            <span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">con</span><span class="s3">=</span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">err</span><span class="s3">=</span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)),</span>
                            <span class="s1">loc</span><span class="s3">=</span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                            <span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                        <span class="s3">)</span>
                        <span class="s1">errors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">chain_exception</span><span class="s3">(</span><span class="s1">new_exc</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>
                    <span class="s2">elif </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">use_new_style_errors</span><span class="s3">():</span>
                        <span class="s2">raise </span><span class="s1">e</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Unknown CAPTURED_ERRORS style: &quot;</span>
                               <span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">config</span><span class="s3">.</span><span class="s1">CAPTURED_ERRORS</span><span class="s2">}</span><span class="s5">'.&quot;</span><span class="s3">)</span>
                        <span class="s2">assert </span><span class="s6">0</span><span class="s3">, </span><span class="s1">msg</span>

        <span class="s2">return </span><span class="s1">errors</span>


<span class="s2">class </span><span class="s1">Propagate</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A simple constraint for direct propagation of types for assignments. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dst </span><span class="s3">= </span><span class="s1">dst</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">src </span><span class="s3">= </span><span class="s1">src</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of assignment at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                               <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">copy_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">src</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s4"># If `dst` is refined, notify us</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dst</span><span class="s3">] = </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">refine</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">target_type</span><span class="s3">):</span>
        <span class="s4"># Do not back-propagate to locked variables (e.g. constants)</span>
        <span class="s2">assert </span><span class="s1">target_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">src</span><span class="s3">, </span><span class="s1">target_type</span><span class="s3">, </span><span class="s1">unless_locked</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                           <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ArgConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dst </span><span class="s3">= </span><span class="s1">dst</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">src </span><span class="s3">= </span><span class="s1">src</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of argument at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">src </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">src</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">src</span><span class="s3">.</span><span class="s1">defined</span><span class="s3">:</span>
                <span class="s2">return</span>
            <span class="s1">ty </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Omitted</span><span class="s3">):</span>
                <span class="s1">ty </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_value_type_prefer_literal</span><span class="s3">(</span>
                    <span class="s1">ty</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">'non-precise type {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">))</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BuildTupleConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">items</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">items </span><span class="s3">= </span><span class="s1">items</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of tuple at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">tsets </span><span class="s3">= [</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">i</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">vals </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">product</span><span class="s3">(*</span><span class="s1">tsets</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">vals </span><span class="s2">and </span><span class="s1">all</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vals</span><span class="s3">):</span>
                    <span class="s1">tup </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">vals</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">count</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># empty tuples fall here as well</span>
                    <span class="s1">tup </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">)</span>
                <span class="s2">assert </span><span class="s1">tup</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_BuildContainerConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">items</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">items </span><span class="s3">= </span><span class="s1">items</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of {0} at {1}&quot;</span><span class="s3">,</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">container_type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">tsets </span><span class="s3">= [</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">i</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">tsets</span><span class="s3">:</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                   <span class="s1">self</span><span class="s3">.</span><span class="s1">container_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">undefined</span><span class="s3">),</span>
                                   <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">typs </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">product</span><span class="s3">(*</span><span class="s1">tsets</span><span class="s3">):</span>
                    <span class="s1">unified </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_types</span><span class="s3">(*</span><span class="s1">typs</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">unified </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                           <span class="s1">self</span><span class="s3">.</span><span class="s1">container_type</span><span class="s3">(</span><span class="s1">unified</span><span class="s3">),</span>
                                           <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BuildListConstraint</span><span class="s3">(</span><span class="s1">_BuildContainerConstraint</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">items</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">items </span><span class="s3">= </span><span class="s1">items</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of {0} at {1}&quot;</span><span class="s3">,</span>
                               <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">tsets </span><span class="s3">= [</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">i</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">tsets</span><span class="s3">:</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                   <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">undefined</span><span class="s3">),</span>
                                   <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">typs </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">product</span><span class="s3">(*</span><span class="s1">tsets</span><span class="s3">):</span>
                    <span class="s1">unified </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_types</span><span class="s3">(*</span><span class="s1">typs</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">unified </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s4"># pull out literals if available</span>
                        <span class="s1">islit </span><span class="s3">= [</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">typs</span><span class="s3">]</span>
                        <span class="s1">iv </span><span class="s3">= </span><span class="s2">None</span>
                        <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">islit</span><span class="s3">):</span>
                            <span class="s1">iv </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">literal_value </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">typs</span><span class="s3">]</span>
                        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                           <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">(</span><span class="s1">unified</span><span class="s3">,</span>
                                                      <span class="s1">initial_value</span><span class="s3">=</span><span class="s1">iv</span><span class="s3">),</span>
                                           <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                           <span class="s1">types</span><span class="s3">.</span><span class="s1">LiteralList</span><span class="s3">(</span><span class="s1">typs</span><span class="s3">),</span>
                                           <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BuildSetConstraint</span><span class="s3">(</span><span class="s1">_BuildContainerConstraint</span><span class="s3">):</span>
    <span class="s1">container_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Set</span>


<span class="s2">class </span><span class="s1">BuildMapConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">items</span><span class="s3">, </span><span class="s1">special_value</span><span class="s3">, </span><span class="s1">value_indexes</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">items </span><span class="s3">= </span><span class="s1">items</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">special_value </span><span class="s3">= </span><span class="s1">special_value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value_indexes </span><span class="s3">= </span><span class="s1">value_indexes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>

        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of dict at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>

            <span class="s4"># figure out what sort of dict is being dealt with</span>
            <span class="s1">tsets </span><span class="s3">= [(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">k</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">(), </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">())</span>
                     <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>

            <span class="s2">if not </span><span class="s1">tsets</span><span class="s3">:</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                   <span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">undefined</span><span class="s3">,</span>
                                                  <span class="s1">types</span><span class="s3">.</span><span class="s1">undefined</span><span class="s3">,</span>
                                                  <span class="s1">self</span><span class="s3">.</span><span class="s1">special_value</span><span class="s3">),</span>
                                   <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># all the info is known about the dict, if its</span>
                <span class="s4"># str keys -&gt; random heterogeneous values treat as literalstrkey</span>
                <span class="s1">ktys </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">tsets</span><span class="s3">]</span>
                <span class="s1">vtys </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">tsets</span><span class="s3">]</span>
                <span class="s1">strkey </span><span class="s3">= </span><span class="s1">all</span><span class="s3">([</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ktys</span><span class="s3">])</span>
                <span class="s1">literalvty </span><span class="s3">= </span><span class="s1">all</span><span class="s3">([</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vtys</span><span class="s3">])</span>
                <span class="s1">vt0 </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">unliteral</span><span class="s3">(</span><span class="s1">vtys</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>

                <span class="s4"># homogeneous values comes in the form of being able to cast</span>
                <span class="s4"># all the other values in the ctor to the type of the first.</span>
                <span class="s4"># The order is important as `typed.Dict` takes it's type from</span>
                <span class="s4"># the first element.</span>
                <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
                    <span class="s1">conv </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">can_convert</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">vt0</span><span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">conv </span><span class="s2">is not None and </span><span class="s1">conv </span><span class="s3">&lt; </span><span class="s1">Conversion</span><span class="s3">.</span><span class="s1">unsafe</span>
                <span class="s1">homogeneous </span><span class="s3">= </span><span class="s1">all</span><span class="s3">([</span><span class="s1">check</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unliteral</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vtys</span><span class="s3">])</span>

                <span class="s4"># Special cases:</span>
                <span class="s4"># Single key:value in ctor, key is str, value is an otherwise</span>
                <span class="s4"># illegal container type, e.g. LiteralStrKeyDict or</span>
                <span class="s4"># List, there's no way to put this into a typed.Dict, so make it</span>
                <span class="s4"># a LiteralStrKeyDict, same goes for LiteralList.</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">vtys</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s1">valty </span><span class="s3">= </span><span class="s1">vtys</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">valty</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">LiteralStrKeyDict</span><span class="s3">,</span>
                                          <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">,</span>
                                          <span class="s1">types</span><span class="s3">.</span><span class="s1">LiteralList</span><span class="s3">)):</span>
                        <span class="s1">homogeneous </span><span class="s3">= </span><span class="s2">False</span>

                <span class="s2">if </span><span class="s1">strkey </span><span class="s2">and not </span><span class="s1">homogeneous</span><span class="s3">:</span>
                    <span class="s1">resolved_dict </span><span class="s3">= {</span><span class="s1">x</span><span class="s3">: </span><span class="s1">y </span><span class="s2">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">ktys</span><span class="s3">, </span><span class="s1">vtys</span><span class="s3">)}</span>
                    <span class="s1">ty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">LiteralStrKeyDict</span><span class="s3">(</span><span class="s1">resolved_dict</span><span class="s3">,</span>
                                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">value_indexes</span><span class="s3">)</span>
                    <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">init_value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">special_value </span><span class="s2">if </span><span class="s1">literalvty </span><span class="s2">else None</span>
                    <span class="s1">key_type</span><span class="s3">, </span><span class="s1">value_type </span><span class="s3">= </span><span class="s1">tsets</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                    <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                       <span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">(</span><span class="s1">key_type</span><span class="s3">,</span>
                                                      <span class="s1">value_type</span><span class="s3">,</span>
                                                      <span class="s1">init_value</span><span class="s3">),</span>
                                       <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ExhaustIterConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count </span><span class="s3">= </span><span class="s1">count</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">iterator </span><span class="s3">= </span><span class="s1">iterator</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of exhaust iter at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">():</span>
                <span class="s4"># unpack optional</span>
                <span class="s1">tp </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">type </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">) </span><span class="s2">else </span><span class="s1">tp</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">) == </span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">:</span>
                        <span class="s2">assert </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                        <span class="s2">break</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">f&quot;wrong tuple length for </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterator</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">: &quot;</span><span class="s3">,</span>
                               <span class="s5">f&quot;expected </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s2">}</span><span class="s5">, got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
                        <span class="s2">raise </span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IterableType</span><span class="s3">):</span>
                    <span class="s1">tup </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">iterator_type</span><span class="s3">.</span><span class="s1">yield_type</span><span class="s3">,</span>
                                         <span class="s1">count</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
                    <span class="s2">assert </span><span class="s1">tup</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                    <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;failed to unpack {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">),</span>
                                      <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">PairFirstConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">pair</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pair </span><span class="s3">= </span><span class="s1">pair</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of pair-first at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pair</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">():</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Pair</span><span class="s3">):</span>
                    <span class="s4"># XXX is this an error?</span>
                    <span class="s2">continue</span>
                <span class="s2">assert </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">first_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UndefinedFunctionType</span><span class="s3">)</span>
                        <span class="s2">or </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">first_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">())</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">first_type</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">PairSecondConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">pair</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pair </span><span class="s3">= </span><span class="s1">pair</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of pair-second at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">for </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pair</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">():</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Pair</span><span class="s3">):</span>
                    <span class="s4"># XXX is this an error?</span>
                    <span class="s2">continue</span>
                <span class="s2">assert </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">second_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">second_type</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">StaticGetItemConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s2">if </span><span class="s1">index_var </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fallback </span><span class="s3">= </span><span class="s1">IntrinsicCallConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">,</span>
                                                    <span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">), {},</span>
                                                    <span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fallback </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of static-get-item at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">for </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">():</span>
                <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_static_getitem</span><span class="s3">(</span>
                    <span class="s1">value</span><span class="s3">=</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                <span class="s3">)</span>

                <span class="s2">if </span><span class="s1">sig </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">itemty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
                    <span class="s4"># if the itemty is not precise, let it through, unification</span>
                    <span class="s4"># will catch it and produce a better error message</span>
                    <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">itemty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fallback </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">fallback</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4"># The signature is only needed for the fallback case in lowering</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fallback </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fallback</span><span class="s3">.</span><span class="s1">get_call_signature</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">TypedGetItemConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of typed-get-item at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">idx_ty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">()</span>
            <span class="s1">ty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">Signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ty </span><span class="s3">+ </span><span class="s1">idx_ty</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">def </span><span class="s1">fold_arg_vars</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">vararg</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fold and resolve the argument variables of a function call. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Fetch all argument types, bail if any is unknown</span>
    <span class="s1">n_pos_args </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">kwds </span><span class="s3">= [</span><span class="s1">kw </span><span class="s2">for </span><span class="s3">(</span><span class="s1">kw</span><span class="s3">, </span><span class="s1">var</span><span class="s3">) </span><span class="s2">in </span><span class="s1">kws</span><span class="s3">]</span>
    <span class="s1">argtypes </span><span class="s3">= [</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
    <span class="s1">argtypes </span><span class="s3">+= [</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] </span><span class="s2">for </span><span class="s3">(</span><span class="s1">kw</span><span class="s3">, </span><span class="s1">var</span><span class="s3">) </span><span class="s2">in </span><span class="s1">kws</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">vararg </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">argtypes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">vararg</span><span class="s3">.</span><span class="s1">name</span><span class="s3">])</span>

    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">defined </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">argtypes</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">argtypes</span><span class="s3">)</span>

    <span class="s1">pos_args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:</span><span class="s1">n_pos_args</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">vararg </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">errmsg </span><span class="s3">= </span><span class="s5">&quot;*args in function call should be a tuple, got %s&quot;</span>
        <span class="s4"># Handle constant literal used for `*args`</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">):</span>
            <span class="s1">const_val </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">literal_value</span>
            <span class="s4"># Is the constant value a tuple?</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">const_val</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% (</span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">],))</span>
            <span class="s4"># Append the elements in the const tuple to the positional args</span>
            <span class="s1">pos_args </span><span class="s3">+= </span><span class="s1">const_val</span>
        <span class="s4"># Handle non-constant</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
            <span class="s4"># Unsuitable for *args</span>
            <span class="s4"># (Python is more lenient and accepts all iterables)</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% (</span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">],))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Append the elements in the tuple to the positional args</span>
            <span class="s1">pos_args </span><span class="s3">+= </span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">types</span>
        <span class="s4"># Drop the last arg</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">kw_args </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">kwds</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s1">n_pos_args</span><span class="s3">:]))</span>
    <span class="s2">return </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span>


<span class="s2">def </span><span class="s1">_is_array_not_precise</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check type is array and it is not precise 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">CallConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Constraint for calling functions. 
    Perform case analysis foreach combinations of argument types. 
    &quot;&quot;&quot;</span>
    <span class="s1">signature </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">, </span><span class="s1">vararg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kws </span><span class="s3">= </span><span class="s1">kws </span><span class="s2">or </span><span class="s3">{}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vararg </span><span class="s3">= </span><span class="s1">vararg</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;typing of call at {0}</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span>
                    <span class="s5">&quot;resolving caller type: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">)):</span>
                <span class="s1">fnty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;resolving callee type: {0}&quot;</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">fnty</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">fold_arg_vars</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s4"># Cannot resolve call type until all argument types are known</span>
            <span class="s2">return</span>
        <span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args </span><span class="s3">= </span><span class="s1">r</span>

        <span class="s4"># Check argument to be precise</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">chain</span><span class="s3">(</span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()):</span>
            <span class="s4"># Forbids imprecise type except array of undefined dtype</span>
            <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">() </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                <span class="s2">return</span>

        <span class="s4"># Resolve call type</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">TypeRef</span><span class="s3">):</span>
            <span class="s4"># Unwrap TypeRef</span>
            <span class="s1">fnty </span><span class="s3">= </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">instance_type</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">resolve_call</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ForceLiteralArg </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s4"># Adjust for bound methods</span>
            <span class="s1">folding_args </span><span class="s3">= ((</span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">this</span><span class="s3">,) + </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BoundFunction</span><span class="s3">)</span>
                            <span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">folded </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">fold_arguments</span><span class="s3">(</span><span class="s1">folding_args</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">)</span>
            <span class="s1">requested </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s1">unsatisfied </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">e</span><span class="s3">.</span><span class="s1">requested_args</span><span class="s3">:</span>
                <span class="s1">maybe_arg </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">folded</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">maybe_arg</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
                    <span class="s1">requested</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">maybe_arg</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">unsatisfied</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">unsatisfied</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Cannot request literal type.&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">requested</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ForceLiteralArg</span><span class="s3">(</span><span class="s1">requested</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s4"># Note: duplicated error checking.</span>
            <span class="s4">#       See types.BaseFunction.get_call_type</span>
            <span class="s4"># Arguments are invalid =&gt; explain why</span>
            <span class="s1">headtemp </span><span class="s3">= </span><span class="s5">&quot;Invalid use of {0} with parameters ({1})&quot;</span>
            <span class="s1">args </span><span class="s3">= [</span><span class="s1">str</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">pos_args</span><span class="s3">]</span>
            <span class="s1">args </span><span class="s3">+= [</span><span class="s5">&quot;%s=%s&quot; </span><span class="s3">% (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">kw_args</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())]</span>
            <span class="s1">head </span><span class="s3">= </span><span class="s1">headtemp</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)))</span>
            <span class="s1">desc </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">explain_function_type</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">)</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">head</span><span class="s3">, </span><span class="s1">desc</span><span class="s3">])</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s4"># If the function is a bound function and its receiver type</span>
        <span class="s4"># was refined, propagate it.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BoundFunction</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">recvr </span><span class="s2">is not None</span>
                <span class="s2">and </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">recvr </span><span class="s3">!= </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">this</span><span class="s3">):</span>
            <span class="s1">refined_this </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_pairs</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">recvr</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">this</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">refined_this </span><span class="s2">is None and</span>
                    <span class="s1">fnty</span><span class="s3">.</span><span class="s1">this</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">() </span><span class="s2">and</span>
                    <span class="s1">sig</span><span class="s3">.</span><span class="s1">recvr</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()):</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot refine type {} to {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                    <span class="s1">sig</span><span class="s3">.</span><span class="s1">recvr</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">this</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">refined_this </span><span class="s2">is not None and </span><span class="s1">refined_this</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
                <span class="s1">refined_fnty </span><span class="s3">= </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">this</span><span class="s3">=</span><span class="s1">refined_this</span><span class="s3">)</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">propagate_refined_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">refined_fnty</span><span class="s3">)</span>

        <span class="s4"># If the return type is imprecise but can be unified with the</span>
        <span class="s4"># target variable's inferred type, use the latter.</span>
        <span class="s4"># Useful for code such as::</span>
        <span class="s4">#    s = set()</span>
        <span class="s4">#    s.add(1)</span>
        <span class="s4"># (the set() call must be typed as int64(), not undefined())</span>
        <span class="s2">if not </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
            <span class="s1">target </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">target</span><span class="s3">.</span><span class="s1">defined</span><span class="s3">:</span>
                <span class="s1">targetty </span><span class="s3">= </span><span class="s1">target</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_pairs</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">) == </span><span class="s1">targetty</span><span class="s3">:</span>
                    <span class="s1">sig </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">=</span><span class="s1">targetty</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_refine_map</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_add_refine_map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Add this expression to the refine_map base on the type of target_type 
        &quot;&quot;&quot;</span>
        <span class="s1">target_type </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
        <span class="s4"># Array</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Undefined</span><span class="s3">)):</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">] = </span><span class="s1">self</span>
        <span class="s4"># DictType</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">target_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()):</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">] = </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">refine</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">updated_type</span><span class="s3">):</span>
        <span class="s4"># Is getitem?</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func </span><span class="s3">== </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">:</span>
            <span class="s1">aryty </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s4"># is array not precise?</span>
            <span class="s2">if </span><span class="s1">_is_array_not_precise</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">):</span>
                <span class="s4"># allow refinement of dtype</span>
                <span class="s2">assert </span><span class="s1">updated_type</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                <span class="s1">newtype </span><span class="s3">= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">updated_type</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">name</span><span class="s3">, </span><span class="s1">newtype</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s5">'no type refinement implemented for function {} updating to {}'</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">updated_type</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">IntrinsicCallConstraint</span><span class="s3">(</span><span class="s1">CallConstraint</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of intrinsic-call at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">fnty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span>
            <span class="s2">if </span><span class="s1">fnty </span><span class="s2">in </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">OPERATORS_TO_BUILTINS</span><span class="s3">:</span>
                <span class="s1">fnty </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">=</span><span class="s1">fnty</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">GetAttrConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">attr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">inst </span><span class="s3">= </span><span class="s1">inst</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of get attribute at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s1">valtys </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">get</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">valtys</span><span class="s3">:</span>
                <span class="s1">attrty </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_getattr</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">attrty </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">UntypedAttributeError</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">,</span>
                                                <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">attrty</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
                    <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">attrty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">] = </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">refine</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">target_type</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BoundFunction</span><span class="s3">):</span>
            <span class="s1">recvr </span><span class="s3">= </span><span class="s1">target_type</span><span class="s3">.</span><span class="s1">this</span>
            <span class="s2">assert </span><span class="s1">recvr</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">()</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">recvr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">source_constraint </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">source_constraint </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">source_constraint</span><span class="s3">.</span><span class="s1">refine</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">recvr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">'resolving type of attribute &quot;{attr}&quot; of &quot;{value}&quot;'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">value</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">SetItemRefinement</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A mixin class to provide the common refinement logic in setitem 
    and static setitem. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_refine_target_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Refine the target-type given the known index type and value type. 
        &quot;&quot;&quot;</span>
        <span class="s4"># For array setitem, refine imprecise array dtype</span>
        <span class="s2">if </span><span class="s1">_is_array_not_precise</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">):</span>
            <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s4"># For Dict setitem</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">targetty</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
                <span class="s1">refined </span><span class="s3">= </span><span class="s1">targetty</span><span class="s3">.</span><span class="s1">refine</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">refined</span><span class="s3">,</span>
                    <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">LiteralStrKeyDict</span><span class="s3">):</span>
                <span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DictType</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">),</span>
                    <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                <span class="s3">)</span>


<span class="s2">class </span><span class="s1">SetItemConstraint</span><span class="s3">(</span><span class="s1">SetItemRefinement</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of setitem at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">defined</span>
                       <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)):</span>
                <span class="s2">return</span>
            <span class="s1">targetty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">idxty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">valty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>

            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_setitem</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Cannot resolve setitem: %s[%s] = %s&quot; </span><span class="s3">%</span>
                                  <span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_refine_target_type</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">StaticSetItemConstraint</span><span class="s3">(</span><span class="s1">SetItemRefinement</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index_var </span><span class="s3">= </span><span class="s1">index_var</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of staticsetitem at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">defined</span>
                       <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)):</span>
                <span class="s2">return</span>
            <span class="s1">targetty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">idxty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">valty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>

            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_static_setitem</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">,</span>
                                                           <span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_setitem</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Cannot resolve setitem: %s[%r] = %s&quot; </span><span class="s3">%</span>
                                  <span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_refine_target_type</span><span class="s3">(</span><span class="s1">typeinfer</span><span class="s3">, </span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">DelItemConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of delitem at {0}&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">defined</span>
                       <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)):</span>
                <span class="s2">return</span>
            <span class="s1">targetty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">idxty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>

            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_delitem</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Cannot resolve delitem: %s[%s]&quot; </span><span class="s3">%</span>
                                  <span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">SetAttrConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">attr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">new_error_context</span><span class="s3">(</span><span class="s5">&quot;typing of set attribute {0!r} at {1}&quot;</span><span class="s3">,</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>
            <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">defined</span>
                       <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)):</span>
                <span class="s2">return</span>
            <span class="s1">targetty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">valty </span><span class="s3">= </span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">()</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_setattr</span><span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">,</span>
                                                    <span class="s1">valty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sig </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Cannot resolve setattr: (%s).%s = %s&quot; </span><span class="s3">%</span>
                                  <span class="s3">(</span><span class="s1">targetty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">),</span>
                                  <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">PrintConstraint</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">vararg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vararg </span><span class="s3">= </span><span class="s1">vararg</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">loc</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s1">typevars </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">fold_arg_vars</span><span class="s3">(</span><span class="s1">typevars</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">, {})</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s4"># Cannot resolve call type until all argument types are known</span>
            <span class="s2">return</span>
        <span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args </span><span class="s3">= </span><span class="s1">r</span>

        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">print</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">fnty </span><span class="s2">is not None</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">resolve_call</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>

    <span class="s2">def </span><span class="s1">get_call_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span>


<span class="s2">class </span><span class="s1">TypeVarMap</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">set_context</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">(</span><span class="s1">TypeVarMap</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s5">&quot;Cannot redefine typevar %s&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">super</span><span class="s3">(</span><span class="s1">TypeVarMap</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s4"># A temporary mapping of {function name: dispatcher object}</span>
<span class="s1">_temporary_dispatcher_map </span><span class="s3">= {}</span>
<span class="s4"># A temporary mapping of {function name: dispatcher object reference count}</span>
<span class="s4"># Reference: https://github.com/numba/numba/issues/3658</span>
<span class="s1">_temporary_dispatcher_map_ref_count </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">register_dispatcher</span><span class="s3">(</span><span class="s1">disp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Register a Dispatcher for inference while it is not yet stored 
    as global or closure variable (e.g. during execution of the @jit() 
    call).  This allows resolution of recursive calls with eager 
    compilation. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">disp</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">disp</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">)</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">disp</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s1">_temporary_dispatcher_map</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">disp</span>
    <span class="s1">_temporary_dispatcher_map_ref_count</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] += </span><span class="s6">1</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">_temporary_dispatcher_map_ref_count</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] -= </span><span class="s6">1</span>
        <span class="s2">if not </span><span class="s1">_temporary_dispatcher_map_ref_count</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]:</span>
            <span class="s2">del </span><span class="s1">_temporary_dispatcher_map</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>


<span class="s1">typeinfer_extensions </span><span class="s3">= {}</span>


<span class="s2">class </span><span class="s1">TypeInferer</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Operates on block that shares the same ir.Scope. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">warnings</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s4"># sort based on label, ensure iteration order!</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">OrderedDict</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">generator_info </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">generator_info</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func_id </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir </span><span class="s3">= </span><span class="s1">func_ir</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">typevars </span><span class="s3">= </span><span class="s1">TypeVarMap</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">.</span><span class="s1">set_context</span><span class="s3">(</span><span class="s1">context</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints </span><span class="s3">= </span><span class="s1">ConstraintNetwork</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">warnings </span><span class="s3">= </span><span class="s1">warnings</span>

        <span class="s4"># { index: mangled name }</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names </span><span class="s3">= {}</span>
        <span class="s4"># self.return_type = None</span>
        <span class="s4"># Set of assumed immutable globals</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assumed_immutables </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s4"># Track all calls and associated constraints</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls </span><span class="s3">= []</span>
        <span class="s4"># The inference result of the above calls</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes </span><span class="s3">= </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">UniqueDict</span><span class="s3">()</span>
        <span class="s4"># Target var -&gt; constraint with refine hook</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">refine_map </span><span class="s3">= {}</span>

        <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG </span><span class="s2">or </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_TYPEINFER</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">debug </span><span class="s3">= </span><span class="s1">TypeInferDebug</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">debug </span><span class="s3">= </span><span class="s1">NullDebug</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_recursion </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">skip_recursion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">clone </span><span class="s3">= </span><span class="s1">TypeInferer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">warnings</span><span class="s3">)</span>
        <span class="s1">clone</span><span class="s3">.</span><span class="s1">arg_names </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">clone</span><span class="s3">.</span><span class="s1">_skip_recursion </span><span class="s3">= </span><span class="s1">skip_recursion</span>

        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if not </span><span class="s1">v</span><span class="s3">.</span><span class="s1">locked </span><span class="s2">and </span><span class="s1">v</span><span class="s3">.</span><span class="s1">defined</span><span class="s3">:</span>
                <span class="s1">clone</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">k</span><span class="s3">].</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">(), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">v</span><span class="s3">.</span><span class="s1">define_loc</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">clone</span>

    <span class="s2">def </span><span class="s1">_mangle_arg_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s4"># Disambiguise argument name</span>
        <span class="s2">return </span><span class="s5">&quot;arg.%s&quot; </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">_get_return_vars</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">rets </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">inst </span><span class="s3">= </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">terminator</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
                <span class="s1">rets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">rets</span>

    <span class="s2">def </span><span class="s1">get_argument_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">k</span><span class="s3">].</span><span class="s1">getone</span><span class="s3">() </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()]</span>

    <span class="s2">def </span><span class="s1">seed_argument</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">):</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mangle_arg_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">seed_type</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">seed_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;All arguments should be seeded. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lock_type</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">seed_return</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Seeding of return value is optional. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_vars</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lock_type</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build_constraint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">constrain_statement</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_types_from_partial</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Resume type inference partially to deduce the return type. 
        Note: No side-effect to `self`. 
 
        Returns the inferred return type or None if it cannot deduce the return 
        type. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Clone the typeinferer and disable typing recursive calls</span>
        <span class="s1">cloned </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">skip_recursion</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s4"># rebuild constraint network</span>
        <span class="s1">cloned</span><span class="s3">.</span><span class="s1">build_constraint</span><span class="s3">()</span>
        <span class="s4"># propagate without raising</span>
        <span class="s1">cloned</span><span class="s3">.</span><span class="s1">propagate</span><span class="s3">(</span><span class="s1">raise_errors</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s4"># get return types</span>
        <span class="s1">rettypes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">retvar </span><span class="s2">in </span><span class="s1">cloned</span><span class="s3">.</span><span class="s1">_get_return_vars</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">retvar</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">cloned</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">:</span>
                <span class="s1">typevar </span><span class="s3">= </span><span class="s1">cloned</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">retvar</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">typevar </span><span class="s2">and </span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">defined</span><span class="s3">:</span>
                    <span class="s1">rettypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unliteral</span><span class="s3">(</span><span class="s1">typevar</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">()))</span>
        <span class="s2">if not </span><span class="s1">rettypes</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s4"># unify return types</span>
        <span class="s2">return </span><span class="s1">cloned</span><span class="s3">.</span><span class="s1">_unify_return_types</span><span class="s3">(</span><span class="s1">rettypes</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">propagate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">raise_errors</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">newtoken </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_state_token</span><span class="s3">()</span>
        <span class="s1">oldtoken </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s4"># Since the number of types are finite, the typesets will eventually</span>
        <span class="s4"># stop growing.</span>

        <span class="s2">while </span><span class="s1">newtoken </span><span class="s3">!= </span><span class="s1">oldtoken</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">.</span><span class="s1">propagate_started</span><span class="s3">()</span>
            <span class="s1">oldtoken </span><span class="s3">= </span><span class="s1">newtoken</span>
            <span class="s4"># Errors can appear when the type set is incomplete; only</span>
            <span class="s4"># raise them when there is no progress anymore.</span>
            <span class="s1">errors </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">propagate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">newtoken </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_state_token</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">.</span><span class="s1">propagate_finished</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">errors</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s1">force_lit_args </span><span class="s3">= [</span><span class="s1">e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">errors</span>
                                  <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">ForceLiteralArg</span><span class="s3">)]</span>
                <span class="s2">if not </span><span class="s1">force_lit_args</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">errors</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">, </span><span class="s1">force_lit_args</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">errors</span>

    <span class="s2">def </span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">unless_locked</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">str</span><span class="s3">), </span><span class="s1">type</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
        <span class="s1">tv </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">unless_locked </span><span class="s2">and </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">locked</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">oldty </span><span class="s3">= </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s1">unified </span><span class="s3">= </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">unified </span><span class="s3">!= </span><span class="s1">oldty</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">propagate_refined_type</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">unified</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">add_calltype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">signature </span><span class="s2">is not None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">[</span><span class="s1">inst</span><span class="s3">] = </span><span class="s1">signature</span>

    <span class="s2">def </span><span class="s1">copy_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">src_var</span><span class="s3">, </span><span class="s1">dest_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">dest_var</span><span class="s3">].</span><span class="s1">union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">src_var</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lock_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">literal_value</span><span class="s3">=</span><span class="s1">NOTSET</span><span class="s3">):</span>
        <span class="s1">tv </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">var</span><span class="s3">]</span>
        <span class="s1">tv</span><span class="s3">.</span><span class="s1">lock</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">literal_value</span><span class="s3">=</span><span class="s1">literal_value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">propagate_refined_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">updated_var</span><span class="s3">, </span><span class="s1">updated_type</span><span class="s3">):</span>
        <span class="s1">source_constraint </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">refine_map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">updated_var</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">source_constraint </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">source_constraint</span><span class="s3">.</span><span class="s1">refine</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">updated_type</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unify</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">raise_errors</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Run the final unification pass over all inferred types, and 
        catch imprecise types. 
        &quot;&quot;&quot;</span>
        <span class="s1">typdict </span><span class="s3">= </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">UniqueDict</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">find_offender</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">exhaustive</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s4"># finds the offending variable definition by name</span>
            <span class="s4"># if exhaustive is set it will try and trace through temporary</span>
            <span class="s4"># variables to find a concrete offending definition.</span>
            <span class="s1">offender </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                <span class="s1">offender </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_variable_assignment</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">offender </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">exhaustive</span><span class="s3">:</span>
                        <span class="s2">break</span>
                    <span class="s2">try</span><span class="s3">:  </span><span class="s4"># simple assignment</span>
                        <span class="s1">hasattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s5">'name'</span><span class="s3">)</span>
                        <span class="s1">offender_value </span><span class="s3">= </span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s2">except </span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                        <span class="s2">break</span>
                    <span class="s1">orig_offender </span><span class="s3">= </span><span class="s1">offender</span>
                    <span class="s2">if </span><span class="s1">offender_value</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'$'</span><span class="s3">):</span>
                        <span class="s1">offender </span><span class="s3">= </span><span class="s1">find_offender</span><span class="s3">(</span><span class="s1">offender_value</span><span class="s3">,</span>
                                                 <span class="s1">exhaustive</span><span class="s3">=</span><span class="s1">exhaustive</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">offender </span><span class="s2">is None</span><span class="s3">:</span>
                            <span class="s1">offender </span><span class="s3">= </span><span class="s1">orig_offender</span>
                    <span class="s2">break</span>
            <span class="s2">return </span><span class="s1">offender</span>

        <span class="s2">def </span><span class="s1">diagnose_imprecision</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">):</span>
            <span class="s4"># helper for diagnosing imprecise types</span>

            <span class="s1">list_msg </span><span class="s3">= </span><span class="s5">&quot;&quot;&quot;</span><span class="s2">\n</span>
<span class="s5">For Numba to be able to compile a list, the list must have a known and 
precise type that can be inferred from the other variables. Whilst sometimes 
the type of empty lists can be inferred, this is not always the case, see this 
documentation for help: 
 
https://numba.readthedocs.io/en/stable/user/troubleshoot.html#my-code-has-an-untyped-list-problem 
&quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">offender </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s4"># This block deals with imprecise lists</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">, </span><span class="s5">'value'</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s5">'op'</span><span class="s3">):</span>
                        <span class="s4"># might be `foo = []`</span>
                        <span class="s2">if </span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_list'</span><span class="s3">:</span>
                            <span class="s2">return </span><span class="s1">list_msg</span>
                        <span class="s4"># or might be `foo = list()`</span>
                        <span class="s2">elif </span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
                            <span class="s2">try</span><span class="s3">:  </span><span class="s4"># assignment involving a call</span>
                                <span class="s1">call_name </span><span class="s3">= </span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span>
                                <span class="s4"># find the offender based on the call name</span>
                                <span class="s1">offender </span><span class="s3">= </span><span class="s1">find_offender</span><span class="s3">(</span><span class="s1">call_name</span><span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">):</span>
                                    <span class="s2">if </span><span class="s1">offender</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">'list'</span><span class="s3">:</span>
                                        <span class="s2">return </span><span class="s1">list_msg</span>
                            <span class="s2">except </span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                                <span class="s2">pass</span>
            <span class="s2">return </span><span class="s5">&quot;&quot;  </span><span class="s4"># no help possible</span>

        <span class="s2">def </span><span class="s1">check_var</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">tv </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">defined</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                    <span class="s1">offender </span><span class="s3">= </span><span class="s1">find_offender</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s1">val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">, </span><span class="s5">'value'</span><span class="s3">, </span><span class="s5">'unknown operation'</span><span class="s3">)</span>
                    <span class="s1">loc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">, </span><span class="s5">'loc'</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">unknown_loc</span><span class="s3">)</span>
                    <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Type of variable '%s' cannot be determined, &quot;</span>
                           <span class="s5">&quot;operation: %s, location: %s&quot;</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">var</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">typdict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown</span>
                    <span class="s2">return</span>
            <span class="s1">tp </span><span class="s3">= </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">getone</span><span class="s3">()</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UndefinedFunctionType</span><span class="s3">):</span>
                <span class="s1">tp </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_precise</span><span class="s3">()</span>

            <span class="s2">if not </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
                <span class="s1">offender </span><span class="s3">= </span><span class="s1">find_offender</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">exhaustive</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Cannot infer the type of variable '%s'%s, &quot;</span>
                       <span class="s5">&quot;have imprecise type: %s. %s&quot;</span><span class="s3">)</span>
                <span class="s1">istmp </span><span class="s3">= </span><span class="s5">&quot; (temporary variable)&quot; </span><span class="s2">if </span><span class="s1">var</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'$'</span><span class="s3">) </span><span class="s2">else </span><span class="s5">&quot;&quot;</span>
                <span class="s1">loc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">, </span><span class="s5">'loc'</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">unknown_loc</span><span class="s3">)</span>
                <span class="s4"># is this an untyped list? try and provide help</span>
                <span class="s1">extra_msg </span><span class="s3">= </span><span class="s1">diagnose_imprecision</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">var</span><span class="s3">, </span><span class="s1">istmp</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">extra_msg</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">typdict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown</span>
                    <span class="s2">return</span>
            <span class="s2">else</span><span class="s3">:  </span><span class="s4"># type is precise, hold it</span>
                <span class="s1">typdict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">] = </span><span class="s1">tp</span>

        <span class="s4"># For better error display, check first user-visible vars, then</span>
        <span class="s4"># temporaries</span>
        <span class="s1">temps </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars </span><span class="s2">if not </span><span class="s1">k</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">isalpha</span><span class="s3">())</span>
        <span class="s1">others </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">) - </span><span class="s1">temps</span>
        <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">others</span><span class="s3">):</span>
            <span class="s1">check_var</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">temps</span><span class="s3">):</span>
            <span class="s1">check_var</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">retty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_return_type</span><span class="s3">(</span><span class="s1">typdict</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s4"># partial type inference may raise e.g. attribute error if a</span>
            <span class="s4"># constraint has no computable signature, ignore this as needed</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">e</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">retty </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">typdict </span><span class="s3">= </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">UniqueDict</span><span class="s3">(</span>
                <span class="s1">typdict</span><span class="s3">, **{</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name</span><span class="s3">: </span><span class="s1">retty </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_vars</span><span class="s3">()})</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">fntys </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_function_types</span><span class="s3">(</span><span class="s1">typdict</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s4"># partial type inference may raise e.g. attribute error if a</span>
            <span class="s4"># constraint has no computable signature, ignore this as needed</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">e</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">fntys </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generator_info</span><span class="s3">:</span>
            <span class="s1">retty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_generator_type</span><span class="s3">(</span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">,</span>
                                            <span class="s1">raise_errors</span><span class="s3">=</span><span class="s1">raise_errors</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">check_undef_var_in_calls</span><span class="s3">():</span>
            <span class="s4"># Check for undefined variables in the call arguments.</span>
            <span class="s2">for </span><span class="s1">callnode</span><span class="s3">, </span><span class="s1">calltype </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">calltype </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">calltype</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
                        <span class="s2">if </span><span class="s1">v </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">_undef_var</span><span class="s3">:</span>
                            <span class="s1">m </span><span class="s3">= </span><span class="s5">f&quot;undefined variable used in call argument #</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">&quot;</span>
                            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">callnode</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s1">check_undef_var_in_calls</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">.</span><span class="s1">unify_finished</span><span class="s3">(</span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">fntys</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">fntys</span>

    <span class="s2">def </span><span class="s1">get_generator_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">raise_errors</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">gi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generator_info</span>
        <span class="s1">arg_types </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">arg_types</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">typdict</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

        <span class="s1">state_types </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">state_types </span><span class="s3">= [</span><span class="s1">typdict</span><span class="s3">[</span><span class="s1">var_name</span><span class="s3">] </span><span class="s2">for </span><span class="s1">var_name </span><span class="s2">in </span><span class="s1">gi</span><span class="s3">.</span><span class="s1">state_vars</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot type generator: state variable types cannot be found&quot;</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s1">state_types </span><span class="s3">= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">gi</span><span class="s3">.</span><span class="s1">state_vars</span><span class="s3">]</span>

        <span class="s1">yield_types </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">yield_types </span><span class="s3">= [</span><span class="s1">typdict</span><span class="s3">[</span><span class="s1">y</span><span class="s3">.</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                           <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">gi</span><span class="s3">.</span><span class="s1">get_yield_points</span><span class="s3">()]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot type generator: yield type cannot be found&quot;</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">yield_types</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot type generator: it does not yield any value&quot;</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s1">yield_types </span><span class="s3">= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">gi</span><span class="s3">.</span><span class="s1">get_yield_points</span><span class="s3">()]</span>

        <span class="s2">if not </span><span class="s1">yield_types </span><span class="s2">or </span><span class="s1">all</span><span class="s3">(</span><span class="s1">yield_types</span><span class="s3">) == </span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown</span><span class="s3">:</span>
            <span class="s4"># unknown yield, probably partial type inference, escape</span>
            <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Generator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">unknown</span><span class="s3">, </span><span class="s1">arg_types</span><span class="s3">,</span>
                                   <span class="s1">state_types</span><span class="s3">, </span><span class="s1">has_finalizer</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">yield_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_types</span><span class="s3">(*</span><span class="s1">yield_types</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">yield_type </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">yield_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Cannot type generator: cannot unify yielded types %s&quot;</span>
            <span class="s1">yp_highlights </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">gi</span><span class="s3">.</span><span class="s1">get_yield_points</span><span class="s3">():</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s1">_termcolor</span><span class="s3">.</span><span class="s1">errmsg</span><span class="s3">(</span><span class="s5">&quot;Yield of: IR '%s', type '%s', &quot;</span>
                                         <span class="s5">&quot;location: %s&quot;</span><span class="s3">))</span>
                <span class="s1">yp_highlights</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">str</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">inst</span><span class="s3">),</span>
                                            <span class="s1">typdict</span><span class="s3">[</span><span class="s1">y</span><span class="s3">.</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">],</span>
                                            <span class="s1">y</span><span class="s3">.</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">strformat</span><span class="s3">()))</span>

            <span class="s1">explain_ty </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">yield_types</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
                    <span class="s1">explain_ty</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
                    <span class="s1">explain_ty</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">(</span><span class="s5">'none'</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">explain_ty</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">raise_errors</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Can't unify yield type from the &quot;</span>
                                  <span class="s5">&quot;following types: %s&quot;</span>
                                  <span class="s3">% </span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">explain_ty</span><span class="s3">))) +</span>
                                  <span class="s5">&quot;</span><span class="s2">\n\n</span><span class="s5">&quot; </span><span class="s3">+ </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">yp_highlights</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Generator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">yield_type</span><span class="s3">, </span><span class="s1">arg_types</span><span class="s3">,</span>
                               <span class="s1">state_types</span><span class="s3">, </span><span class="s1">has_finalizer</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_function_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fill and return the calltypes map. 
        &quot;&quot;&quot;</span>
        <span class="s4"># XXX why can't this be done on the fly?</span>
        <span class="s1">calltypes </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes</span>
        <span class="s2">for </span><span class="s1">call</span><span class="s3">, </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">:</span>
            <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">call</span><span class="s3">] = </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">get_call_signature</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">calltypes</span>

    <span class="s2">def </span><span class="s1">_unify_return_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">rettypes</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">rettypes</span><span class="s3">:</span>
            <span class="s1">unified </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">unify_types</span><span class="s3">(*</span><span class="s1">rettypes</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">unified</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
                <span class="s4"># unified is allowed to be UndefinedFunctionType</span>
                <span class="s4"># instance (that is imprecise).</span>
                <span class="s2">return </span><span class="s1">unified</span>
            <span class="s2">if </span><span class="s1">unified </span><span class="s2">is None or not </span><span class="s1">unified</span><span class="s3">.</span><span class="s1">is_precise</span><span class="s3">():</span>
                <span class="s2">def </span><span class="s1">check_type</span><span class="s3">(</span><span class="s1">atype</span><span class="s3">):</span>
                    <span class="s1">lst </span><span class="s3">= []</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">if </span><span class="s1">atype </span><span class="s3">== </span><span class="s1">v</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
                            <span class="s1">lst</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                    <span class="s1">returns </span><span class="s3">= {}</span>
                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">):</span>
                        <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                            <span class="s2">for </span><span class="s1">instr </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
                                <span class="s1">value </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
                                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                                    <span class="s1">name </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span>
                                <span class="s2">else</span><span class="s3">:</span>
                                    <span class="s2">pass</span>
                                <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s1">name</span><span class="s3">:</span>
                                    <span class="s1">returns</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">instr</span>
                                    <span class="s2">break</span>

                    <span class="s1">interped </span><span class="s3">= </span><span class="s5">&quot;&quot;</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">offender </span><span class="s2">in </span><span class="s1">returns</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s1">loc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">offender</span><span class="s3">, </span><span class="s5">'loc'</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">unknown_loc</span><span class="s3">)</span>
                        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Return of: IR name '%s', type '%s', &quot;</span>
                               <span class="s5">&quot;location: %s&quot;</span><span class="s3">)</span>
                        <span class="s1">interped </span><span class="s3">= </span><span class="s1">msg </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">strformat</span><span class="s3">())</span>
                    <span class="s2">return </span><span class="s1">interped</span>

                <span class="s1">problem_str </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">xtype </span><span class="s2">in </span><span class="s1">rettypes</span><span class="s3">:</span>
                    <span class="s1">problem_str</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_termcolor</span><span class="s3">.</span><span class="s1">errmsg</span><span class="s3">(</span><span class="s1">check_type</span><span class="s3">(</span><span class="s1">xtype</span><span class="s3">)))</span>

                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Can't unify return type from the &quot;</span>
                                  <span class="s5">&quot;following types: %s&quot;</span>
                                  <span class="s3">% </span><span class="s5">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">rettypes</span><span class="s3">))) +</span>
                                  <span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s3">+ </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">problem_str</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">unified</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Function without a successful return path</span>
            <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span>

    <span class="s2">def </span><span class="s1">get_return_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
        <span class="s1">rettypes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_vars</span><span class="s3">():</span>
            <span class="s1">rettypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">])</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_unify_return_types</span><span class="s3">(</span><span class="s1">rettypes</span><span class="s3">)</span>
        <span class="s4"># Check return value is not undefined</span>
        <span class="s2">if </span><span class="s1">retty </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">_undef_var</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;return value is undefined&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">retty</span>

    <span class="s2">def </span><span class="s1">get_state_token</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;The algorithm is monotonic.  It can only grow or &quot;refine&quot; the 
        typevar map. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">tv</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tv </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())]</span>

    <span class="s2">def </span><span class="s1">constrain_statement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_assign</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_setitem</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticSetItem</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_static_setitem</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DelItem</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_delitem</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetAttr</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_setattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Print</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_print</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StoreMap</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_storemap</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">)):</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DynamicRaise</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DynamicTryRaise</span><span class="s3">)):</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticRaise</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticTryRaise</span><span class="s3">)):</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PopBlock</span><span class="s3">):</span>
            <span class="s2">pass </span><span class="s4"># It's a marker statement</span>
        <span class="s2">elif </span><span class="s1">type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">) </span><span class="s2">in </span><span class="s1">typeinfer_extensions</span><span class="s3">:</span>
            <span class="s4"># let external calls handle stmt if type matches</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">typeinfer_extensions</span><span class="s3">[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)]</span>
            <span class="s1">f</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Unsupported constraint encountered: %s&quot; </span><span class="s3">% </span><span class="s1">inst</span>
            <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">SetItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                                       <span class="s1">value</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_storemap</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">SetItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">dct</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">key</span><span class="s3">,</span>
                                       <span class="s1">value</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_static_setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">StaticSetItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">,</span>
                                             <span class="s1">index</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                                             <span class="s1">index_var</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">,</span>
                                             <span class="s1">value</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_delitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">DelItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                                       <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">SetAttrConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">,</span>
                                       <span class="s1">value</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_print</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">PrintConstraint</span><span class="s3">(</span><span class="s1">args</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">vararg</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">,</span>
                                     <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_assign</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_const</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">Propagate</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                              <span class="s1">src</span><span class="s3">=</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_global</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_arg</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_expr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_yield</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Unsupported assignment encountered: %s %s&quot; </span><span class="s3">%</span>
                   <span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">), </span><span class="s1">str</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)))</span>
            <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Resolve the type of a simple Python value, such as can be 
        represented by literals. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_arg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">):</span>
        <span class="s1">src_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mangle_arg_name</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ArgConstraint</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">=</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                              <span class="s1">src</span><span class="s3">=</span><span class="s1">src_name</span><span class="s3">,</span>
                                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_const</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">const</span><span class="s3">):</span>
        <span class="s1">ty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">const</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">use_literal_type</span><span class="s3">:</span>
            <span class="s1">lit </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">maybe_literal</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">const</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lit </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">lit </span><span class="s2">or </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_yield</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">yield_</span><span class="s3">):</span>
        <span class="s4"># Sending values into generators isn't supported.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">sentry_modified_builtin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">gvar</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Ensure that builtins are not modified. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">'range' </span><span class="s2">and </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value </span><span class="s2">is not </span><span class="s1">range</span><span class="s3">:</span>
            <span class="s1">bad </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">'slice' </span><span class="s2">and </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value </span><span class="s2">is not </span><span class="s1">slice</span><span class="s3">:</span>
            <span class="s1">bad </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s5">'len' </span><span class="s2">and </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value </span><span class="s2">is not </span><span class="s1">len</span><span class="s3">:</span>
            <span class="s1">bad </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">bad </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">bad</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;Modified builtin '%s'&quot; </span><span class="s3">% </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">resolve_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Resolve a call to a given function type.  A signature is returned. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">get_call_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">RecursiveCall</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_recursion</span><span class="s3">:</span>
            <span class="s4"># Recursive call</span>
            <span class="s1">disp </span><span class="s3">= </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">dispatcher_type</span><span class="s3">.</span><span class="s1">dispatcher</span>
            <span class="s1">pysig</span><span class="s3">, </span><span class="s1">args </span><span class="s3">= </span><span class="s1">disp</span><span class="s3">.</span><span class="s1">fold_argument_types</span><span class="s3">(</span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>

            <span class="s1">frame </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">callstack</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">disp</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

            <span class="s4"># If the signature is not being compiled</span>
            <span class="s2">if </span><span class="s1">frame </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">sig </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_function_type</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">dispatcher_type</span><span class="s3">,</span>
                                                         <span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>
                <span class="s1">fndesc </span><span class="s3">= </span><span class="s1">disp</span><span class="s3">.</span><span class="s1">overloads</span><span class="s3">[</span><span class="s1">args</span><span class="s3">].</span><span class="s1">fndesc</span>
                <span class="s1">qual </span><span class="s3">= </span><span class="s1">qualifying_prefix</span><span class="s3">(</span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">modname</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">qualname</span><span class="s3">)</span>
                <span class="s1">fnty</span><span class="s3">.</span><span class="s1">add_overloads</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">qual</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">uid</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">sig</span>

            <span class="s1">fnid </span><span class="s3">= </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">func_id</span>
            <span class="s1">qual </span><span class="s3">= </span><span class="s1">qualifying_prefix</span><span class="s3">(</span><span class="s1">fnid</span><span class="s3">.</span><span class="s1">modname</span><span class="s3">, </span><span class="s1">fnid</span><span class="s3">.</span><span class="s1">func_qualname</span><span class="s3">)</span>
            <span class="s1">fnty</span><span class="s3">.</span><span class="s1">add_overloads</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">qual</span><span class="s3">, </span><span class="s1">fnid</span><span class="s3">.</span><span class="s1">unique_id</span><span class="s3">)</span>
            <span class="s4"># Resume propagation in parent frame</span>
            <span class="s1">return_type </span><span class="s3">= </span><span class="s1">frame</span><span class="s3">.</span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">return_types_from_partial</span><span class="s3">()</span>
            <span class="s4"># No known return type</span>
            <span class="s2">if </span><span class="s1">return_type </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s5">&quot;cannot type infer runaway recursion&quot;</span><span class="s3">)</span>

            <span class="s1">sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">pysig</span><span class="s3">=</span><span class="s1">pysig</span><span class="s3">)</span>
            <span class="s4"># Keep track of unique return_type</span>
            <span class="s1">frame</span><span class="s3">.</span><span class="s1">add_return_type</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">sig</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Normal non-recursive call</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_function_type</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">pos_args</span><span class="s3">, </span><span class="s1">kw_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_global</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">gvar</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">typ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">TypingError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func_name</span>
                    <span class="s2">and </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">_temporary_dispatcher_map</span><span class="s3">):</span>
                <span class="s4"># Self-recursion case where the dispatcher is not (yet?) known</span>
                <span class="s4"># as a global variable</span>
                <span class="s1">typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Dispatcher</span><span class="s3">(</span><span class="s1">_temporary_dispatcher_map</span><span class="s3">[</span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">misc </span><span class="s2">import </span><span class="s1">special</span>

                <span class="s1">nm </span><span class="s3">= </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">name</span>
                <span class="s4"># check if the problem is actually a name error</span>
                <span class="s1">func_glbls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">nm </span><span class="s2">not in </span><span class="s1">func_glbls</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">() </span><span class="s2">and</span>
                        <span class="s1">nm </span><span class="s2">not in </span><span class="s1">special</span><span class="s3">.</span><span class="s1">__all__ </span><span class="s2">and</span>
                        <span class="s1">nm </span><span class="s2">not in </span><span class="s1">__builtins__</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">() </span><span class="s2">and</span>
                        <span class="s1">nm </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">code</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">):</span>
                    <span class="s1">errstr </span><span class="s3">= </span><span class="s5">&quot;NameError: name '%s' is not defined&quot;</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s1">_termcolor</span><span class="s3">.</span><span class="s1">errmsg</span><span class="s3">(</span><span class="s1">errstr </span><span class="s3">% </span><span class="s1">nm</span><span class="s3">)</span>
                    <span class="s1">e</span><span class="s3">.</span><span class="s1">patch_message</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
                    <span class="s2">raise</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s1">_termcolor</span><span class="s3">.</span><span class="s1">errmsg</span><span class="s3">(</span><span class="s5">&quot;Untyped global name '%s':&quot; </span><span class="s3">% </span><span class="s1">nm</span><span class="s3">)</span>
                <span class="s1">msg </span><span class="s3">+= </span><span class="s5">&quot; %s&quot;  </span><span class="s4"># interps the actual error</span>

                <span class="s4"># if the untyped global is a numba internal function then add</span>
                <span class="s4"># to the error message asking if it's been imported.</span>

                <span class="s2">if </span><span class="s1">nm </span><span class="s2">in </span><span class="s1">special</span><span class="s3">.</span><span class="s1">__all__</span><span class="s3">:</span>
                    <span class="s1">tmp </span><span class="s3">= (</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">'%s' looks like a Numba internal function, has &quot;</span>
                           <span class="s5">&quot;it been imported (i.e. 'from numba import %s')?</span><span class="s2">\n</span><span class="s5">&quot; </span><span class="s3">%</span>
                           <span class="s3">(</span><span class="s1">nm</span><span class="s3">, </span><span class="s1">nm</span><span class="s3">))</span>
                    <span class="s1">msg </span><span class="s3">+= </span><span class="s1">_termcolor</span><span class="s3">.</span><span class="s1">errmsg</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">)</span>
                <span class="s1">e</span><span class="s3">.</span><span class="s1">patch_message</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">e</span><span class="s3">)</span>
                <span class="s2">raise</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Dispatcher</span><span class="s3">) </span><span class="s2">and </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dispatcher</span><span class="s3">.</span><span class="s1">is_compiling</span><span class="s3">:</span>
            <span class="s4"># Recursive call</span>
            <span class="s1">callstack </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">callstack</span>
            <span class="s1">callframe </span><span class="s3">= </span><span class="s1">callstack</span><span class="s3">.</span><span class="s1">findfirst</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dispatcher</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">callframe </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">RecursiveCall</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                    <span class="s5">&quot;call to %s: unsupported recursion&quot;</span>
                    <span class="s3">% </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dispatcher</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
            <span class="s4"># Global array in nopython mode is constant</span>
            <span class="s1">typ </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseAnonymousTuple</span><span class="s3">):</span>
            <span class="s4"># if it's a tuple of literal types, swap the type for the more</span>
            <span class="s4"># specific literal version</span>
            <span class="s1">literaled </span><span class="s3">= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">maybe_literal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">literaled</span><span class="s3">):</span>
                <span class="s1">typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">(</span><span class="s1">literaled</span><span class="s3">)</span>

            <span class="s4"># if any of the items in the tuple are arrays, they need to be</span>
            <span class="s4"># typed as readonly, mutating an array in a global container</span>
            <span class="s4"># is not supported (should be compile time constant etc).</span>
            <span class="s2">def </span><span class="s1">mark_array_ro</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
                <span class="s1">newtup </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">tup</span><span class="s3">.</span><span class="s1">types</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                        <span class="s1">item </span><span class="s3">= </span><span class="s1">item</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseAnonymousTuple</span><span class="s3">):</span>
                        <span class="s1">item </span><span class="s3">= </span><span class="s1">mark_array_ro</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
                    <span class="s1">newtup</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">.</span><span class="s1">from_types</span><span class="s3">(</span><span class="s1">newtup</span><span class="s3">)</span>
            <span class="s1">typ </span><span class="s3">= </span><span class="s1">mark_array_ro</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">sentry_modified_builtin</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">gvar</span><span class="s3">)</span>
        <span class="s4"># Setting literal_value for globals because they are handled</span>
        <span class="s4"># like const value in numba</span>
        <span class="s1">lit </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">maybe_literal</span><span class="s3">(</span><span class="s1">gvar</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s4"># The user may have provided the type for this variable already.</span>
        <span class="s4"># In this case, call add_type() to make sure the value type is</span>
        <span class="s4"># consistent. See numba.tests.test_array_reductions</span>
        <span class="s4"># TestArrayReductions.test_array_cumsum for examples.</span>
        <span class="s4"># Variable type locked by using the locals dict.</span>
        <span class="s1">tv </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">[</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">tv</span><span class="s3">.</span><span class="s1">locked</span><span class="s3">:</span>
            <span class="s1">tv</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">lit </span><span class="s2">or </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lock_type</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">lit </span><span class="s2">or </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assumed_immutables</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_expr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s2">in </span><span class="s3">(</span><span class="s5">'getiter'</span><span class="s3">, </span><span class="s5">'iternext'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'exhaust_iter'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">ExhaustIterConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">count</span><span class="s3">,</span>
                                               <span class="s1">iterator</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                               <span class="s1">loc</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'pair_first'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">PairFirstConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">pair</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                             <span class="s1">loc</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'pair_second'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">PairSecondConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">pair</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'binop'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">lhs</span><span class="s3">,</span>
                                       <span class="s1">expr</span><span class="s3">.</span><span class="s1">rhs</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'inplace_binop'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">,</span>
                                       <span class="s1">expr</span><span class="s3">.</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">rhs</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'unary'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'static_getitem'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">StaticGetItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                                 <span class="s1">index</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                                                 <span class="s1">index_var</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">,</span>
                                                 <span class="s1">loc</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getitem'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">,</span>
                                       <span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'typed_getitem'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">TypedGetItemConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                                                <span class="s1">dtype</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
                                                <span class="s1">index</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,</span>
                                                <span class="s1">loc</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'getattr'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">GetAttrConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">,</span>
                                           <span class="s1">value</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                                           <span class="s1">inst</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_tuple'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">BuildTupleConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">items</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">items</span><span class="s3">,</span>
                                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_list'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">BuildListConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">items</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">items</span><span class="s3">,</span>
                                             <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_set'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">BuildSetConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">items</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">items</span><span class="s3">,</span>
                                            <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_map'</span><span class="s3">:</span>
            <span class="s1">constraint </span><span class="s3">= </span><span class="s1">BuildMapConstraint</span><span class="s3">(</span>
                <span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                <span class="s1">items</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">items</span><span class="s3">,</span>
                <span class="s1">special_value</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">,</span>
                <span class="s1">value_indexes</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value_indexes</span><span class="s3">,</span>
                <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'cast'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">Propagate</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">=</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                              <span class="s1">src</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'phi'</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">iv </span><span class="s2">in </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">incoming_values</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">iv </span><span class="s2">is not </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">UNDEFINED</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">Propagate</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">=</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                                      <span class="s1">src</span><span class="s3">=</span><span class="s1">iv</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                                                      <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'make_function'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lock_type</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MakeFunctionLiteral</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">),</span>
                           <span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">literal_value</span><span class="s3">=</span><span class="s1">expr</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'undef'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_type</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">_undef_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Unsupported op-code encountered: %s&quot; </span><span class="s3">% </span><span class="s1">expr</span>
            <span class="s2">raise </span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">typeof_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">call</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">CallConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">call</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">call</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,</span>
                                    <span class="s1">call</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">, </span><span class="s1">call</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typeof_intrinsic_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">constraint </span><span class="s3">= </span><span class="s1">IntrinsicCallConstraint</span><span class="s3">(</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                                             <span class="s1">kws</span><span class="s3">=(), </span><span class="s1">vararg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constraints</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calls</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">NullDebug</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">propagate_started</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">propagate_finished</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">unify_finished</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">fntys</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TypeInferDebug</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typeinfer</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typeinfer </span><span class="s3">= </span><span class="s1">typeinfer</span>

    <span class="s2">def </span><span class="s1">_dump_state</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">'---- type variables ----'</span><span class="s3">)</span>
        <span class="s1">pprint</span><span class="s3">([</span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">typeinfer</span><span class="s3">.</span><span class="s1">typevars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())])</span>

    <span class="s2">def </span><span class="s1">propagate_started</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;propagate&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">'-'</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">propagate_finished</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_dump_state</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">unify_finished</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typdict</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">fntys</span><span class="s3">):</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Variable types&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
        <span class="s1">pprint</span><span class="s3">(</span><span class="s1">typdict</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Return type&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
        <span class="s1">pprint</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Call types&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
        <span class="s1">pprint</span><span class="s3">(</span><span class="s1">fntys</span><span class="s3">)</span>
</pre>
</body>
</html>