<html>
<head>
<title>misc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
misc.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">types</span><span class="s2">.</span><span class="s1">abstract </span><span class="s0">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">Hashable</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">types</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">, </span><span class="s1">IterableType</span><span class="s2">, </span><span class="s1">Opaque</span><span class="s2">,</span>
                                     <span class="s1">SimpleIteratorType</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typeconv </span><span class="s0">import </span><span class="s1">Conversion</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">TypingError</span><span class="s2">, </span><span class="s1">LiteralTypingError</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ir </span><span class="s0">import </span><span class="s1">UndefinedType</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">get_hashable_key</span>


<span class="s0">class </span><span class="s1">PyObject</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A generic CPython object. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">is_precise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">Phantom</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A type that cannot be materialized.  A Phantom cannot be used as 
    argument or return type. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Undefined</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A type that is left imprecise.  This is used as a temporaray placeholder 
    during type inference in the hope that the type can be later refined. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">is_precise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">UndefVar</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A type that is created by Expr.undef to represent an undefined variable. 
    This type can be promoted to any other type. 
    This is introduced to handle Python 3.12 LOAD_FAST_AND_CLEAR. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">promote</span>


<span class="s0">class </span><span class="s1">RawPointer</span><span class="s2">(</span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A raw pointer without any specific meaning. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">StringLiteral</span><span class="s2">(</span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">Dummy</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">UnicodeType</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span>


<span class="s1">Literal</span><span class="s2">.</span><span class="s1">ctor_map</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">StringLiteral</span>


<span class="s0">def </span><span class="s1">unliteral</span><span class="s2">(</span><span class="s1">lit_type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Get base type from Literal type. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">lit_type</span><span class="s2">, </span><span class="s4">'__unliteral__'</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">lit_type</span><span class="s2">.</span><span class="s1">__unliteral__</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">lit_type</span><span class="s2">, </span><span class="s4">'literal_type'</span><span class="s2">, </span><span class="s1">lit_type</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">literal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Returns a Literal instance or raise LiteralTypingError 
    &quot;&quot;&quot;</span>
    <span class="s1">ty </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;the function does not accept a Literal type; got {} ({})&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">))</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">ctor </span><span class="s2">= </span><span class="s1">Literal</span><span class="s2">.</span><span class="s1">ctor_map</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">LiteralTypingError</span><span class="s2">(</span><span class="s4">&quot;{} cannot be used as a literal&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">ctor</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">maybe_literal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Get a Literal type for the value or None. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">literal</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">LiteralTypingError</span><span class="s2">:</span>
        <span class="s0">return</span>


<span class="s0">class </span><span class="s1">Omitted</span><span class="s2">(</span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    An omitted function argument with a default value. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s5"># Use helper function to support both hashable and non-hashable</span>
        <span class="s5"># values. See discussion in gh #6957.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_key </span><span class="s2">= </span><span class="s1">get_hashable_key</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Omitted</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s4">&quot;omitted(default=%r)&quot; </span><span class="s2">% (</span><span class="s1">value</span><span class="s2">,))</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_key</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span>


<span class="s0">class </span><span class="s1">VarArg</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Special type representing a variable number of arguments at the 
    end of a function's signature.  Only used for signature matching, 
    not for actual values. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">VarArg</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s4">&quot;*%s&quot; </span><span class="s2">% </span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>


<span class="s0">class </span><span class="s1">Module</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pymod</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pymod </span><span class="s2">= </span><span class="s1">pymod</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Module</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s4">&quot;Module(%s)&quot; </span><span class="s2">% </span><span class="s1">pymod</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pymod</span>


<span class="s0">class </span><span class="s1">MemInfoPointer</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Pointer to a Numba &quot;meminfo&quot; (i.e. the information for a managed 
    piece of memory). 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;memory-managed *%s&quot; </span><span class="s2">% </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">MemInfoPointer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>


<span class="s0">class </span><span class="s1">CPointer</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for pointers to other types. 
 
    Attributes 
    ---------- 
        dtype : The pointee type 
        addrspace : int 
            The address space pointee belongs to. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">addrspace</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">addrspace </span><span class="s2">= </span><span class="s1">addrspace</span>
        <span class="s0">if </span><span class="s1">addrspace </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;%s_%s*&quot; </span><span class="s2">% (</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">addrspace</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;%s*&quot; </span><span class="s2">% </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">CPointer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">addrspace</span>


<span class="s0">class </span><span class="s1">EphemeralPointer</span><span class="s2">(</span><span class="s1">CPointer</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for pointers which aren't guaranteed to last long - e.g. 
    stack-allocated slots.  The data model serializes such pointers 
    by copying the data pointed to. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">EphemeralArray</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Similar to EphemeralPointer, but pointing to an array of elements, 
    rather than a single one.  The array size must be known at compile-time. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">count</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">= </span><span class="s1">count</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;*%s[%d]&quot; </span><span class="s2">% (</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">count</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">EphemeralArray</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">count</span>


<span class="s0">class </span><span class="s1">Object</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s5"># XXX unused?</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">clsobj</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cls </span><span class="s2">= </span><span class="s1">clsobj</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;Object(%s)&quot; </span><span class="s2">% </span><span class="s1">clsobj</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Object</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cls</span>


<span class="s0">class </span><span class="s1">Optional</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Type class for optional types, i.e. union { some type, None } 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, (</span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">NoneType</span><span class="s2">))</span>
        <span class="s1">typ </span><span class="s2">= </span><span class="s1">unliteral</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">type </span><span class="s2">= </span><span class="s1">typ</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;OptionalType(%s)&quot; </span><span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">can_convert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">conv </span><span class="s2">= </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">can_convert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">conv </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">max</span><span class="s2">(</span><span class="s1">conv</span><span class="s2">, </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">safe</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">can_convert_from</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">NoneType</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">promote</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">can_convert</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">conv </span><span class="s2">= </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">can_convert</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">conv </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">max</span><span class="s2">(</span><span class="s1">conv</span><span class="s2">, </span><span class="s1">Conversion</span><span class="s2">.</span><span class="s1">promote</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">):</span>
            <span class="s1">unified </span><span class="s2">= </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">unify_pairs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">unified </span><span class="s2">= </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">unify_pairs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">unified </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">unified</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">unified</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">Optional</span><span class="s2">(</span><span class="s1">unified</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NoneType</span><span class="s2">(</span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type for None. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Turn anything to a Optional type; 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, (</span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">NoneType</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">other</span>
        <span class="s0">return </span><span class="s1">Optional</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">EllipsisType</span><span class="s2">(</span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type for the Ellipsis singleton. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">ExceptionClass</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Phantom</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type of exception classes (not instances). 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">exc_class</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">exc_class</span><span class="s2">, </span><span class="s1">BaseException</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;%s&quot; </span><span class="s2">% (</span><span class="s1">exc_class</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">exc_class </span><span class="s2">= </span><span class="s1">exc_class</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ExceptionClass</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_call_signatures</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">][</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">get_call_signatures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typing</span>
        <span class="s1">return_type </span><span class="s2">= </span><span class="s1">ExceptionInstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">exc_class</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">)], </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">get_impl_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">exc_class</span>


<span class="s0">class </span><span class="s1">ExceptionInstance</span><span class="s2">(</span><span class="s1">Phantom</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type of exception instances.  *exc_class* should be the 
    exception class. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">exc_class</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">exc_class</span><span class="s2">, </span><span class="s1">BaseException</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;%s(...)&quot; </span><span class="s2">% (</span><span class="s1">exc_class</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">exc_class </span><span class="s2">= </span><span class="s1">exc_class</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ExceptionInstance</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">exc_class</span>


<span class="s0">class </span><span class="s1">SliceType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">members</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">members </span><span class="s0">in </span><span class="s2">(</span><span class="s6">2</span><span class="s2">, </span><span class="s6">3</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">members </span><span class="s2">= </span><span class="s1">members</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">has_step </span><span class="s2">= </span><span class="s1">members </span><span class="s2">&gt;= </span><span class="s6">3</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">SliceType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">members</span>


<span class="s0">class </span><span class="s1">SliceLiteral</span><span class="s2">(</span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">SliceType</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_init</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">'Literal[slice]({})'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">members </span><span class="s2">= </span><span class="s6">2 </span><span class="s0">if </span><span class="s1">value</span><span class="s2">.</span><span class="s1">step </span><span class="s0">is None else </span><span class="s6">3</span>
        <span class="s1">SliceType</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">members</span><span class="s2">=</span><span class="s1">members</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">sl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">literal_value</span>
        <span class="s0">return </span><span class="s1">sl</span><span class="s2">.</span><span class="s1">start</span><span class="s2">, </span><span class="s1">sl</span><span class="s2">.</span><span class="s1">stop</span><span class="s2">, </span><span class="s1">sl</span><span class="s2">.</span><span class="s1">step</span>


<span class="s1">Literal</span><span class="s2">.</span><span class="s1">ctor_map</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">] = </span><span class="s1">SliceLiteral</span>


<span class="s0">class </span><span class="s1">ClassInstanceType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type of a jitted class *instance*.  It will be the return-type 
    of the constructor of the class. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">name_prefix </span><span class="s2">= </span><span class="s4">&quot;instance&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">class_type</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">class_type </span><span class="s2">= </span><span class="s1">class_type</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;{0}.{1}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name_prefix</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClassInstanceType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_data_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">ClassDataType</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_reference_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">key</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">classname</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">class_name</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">jit_props</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">jit_props</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">jit_static_methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">jit_static_methods</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">jit_methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">jit_methods</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">struct</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">struct</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">methods</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">static_methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">static_methods</span>


<span class="s0">class </span><span class="s1">ClassType</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Opaque</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The type of the jitted class (not instance).  When the type of a class 
    is called, its constructor is invoked. 
    &quot;&quot;&quot;</span>
    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">name_prefix </span><span class="s2">= </span><span class="s4">&quot;jitclass&quot;</span>
    <span class="s1">instance_type_class </span><span class="s2">= </span><span class="s1">ClassInstanceType</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">class_def</span><span class="s2">, </span><span class="s1">ctor_template_cls</span><span class="s2">, </span><span class="s1">struct</span><span class="s2">, </span><span class="s1">jit_methods</span><span class="s2">,</span>
                 <span class="s1">jit_props</span><span class="s2">, </span><span class="s1">jit_static_methods</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">class_name </span><span class="s2">= </span><span class="s1">class_def</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">class_doc </span><span class="s2">= </span><span class="s1">class_def</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ctor_template_class </span><span class="s2">= </span><span class="s1">ctor_template_cls</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">jit_methods </span><span class="s2">= </span><span class="s1">jit_methods</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">jit_props </span><span class="s2">= </span><span class="s1">jit_props</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">jit_static_methods </span><span class="s2">= </span><span class="s1">jit_static_methods</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">struct </span><span class="s2">= </span><span class="s1">struct</span>
        <span class="s1">fielddesc </span><span class="s2">= </span><span class="s4">','</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s4">&quot;{0}:{1}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;{0}.{1}#{2:x}&lt;{3}&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name_prefix</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_name</span><span class="s2">,</span>
                                           <span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">fielddesc</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClassType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ctor_template</span><span class="s2">(</span><span class="s1">context</span><span class="s2">).</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_call_signatures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(), </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_impl_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v</span><span class="s2">.</span><span class="s1">py_func </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">jit_methods</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">static_methods</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v</span><span class="s2">.</span><span class="s1">py_func </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">jit_static_methods</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">instance_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">ClassInstanceType</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ctor_template</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_specialize_template</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ctor_template_class</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_specialize_template</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">basecls</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">basecls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (</span><span class="s1">basecls</span><span class="s2">,), </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">self</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">DeferredType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Represents a type that will be defined later.  It must be defined 
    before it is materialized (used in the compiler).  Once defined, it 
    behaves exactly as the type it is defining. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_define </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;{0}#{1}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">DeferredType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_define </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s4">&quot;deferred type not defined&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_define</span>

    <span class="s0">def </span><span class="s1">define</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_define </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;deferred type already defined&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;arg is not a Type; got: {0}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_define </span><span class="s2">= </span><span class="s1">typ</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">unify_pairs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">ClassDataType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Internal only. 
    Represents the data of the instance.  The representation of 
    ClassInstanceType contains a pointer to a ClassDataType which represents 
    a C structure that contains all the data fields of the class instance. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">classtyp</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">class_type </span><span class="s2">= </span><span class="s1">classtyp</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;data.{0}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">class_type</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClassDataType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">ContextManager</span><span class="s2">(</span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Phantom</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    An overly-simple ContextManager type that cannot be materialized. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cm</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cm </span><span class="s2">= </span><span class="s1">cm</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ContextManager</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s4">&quot;ContextManager({})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">cm</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">get_call_signatures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cm</span><span class="s2">.</span><span class="s1">is_callable</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;contextmanager {} is not callable&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cm</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s2">(), </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typing</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cm</span><span class="s2">.</span><span class="s1">is_callable</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;contextmanager {} is not callable&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cm</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s1">posargs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) + [</span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">kws</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())]</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">posargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_impl_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">UnicodeType</span><span class="s2">(</span><span class="s1">IterableType</span><span class="s2">, </span><span class="s1">Hashable</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">UnicodeType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">iterator_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">UnicodeIteratorType</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">UnicodeIteratorType</span><span class="s2">(</span><span class="s1">SimpleIteratorType</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s4">&quot;iter_unicode&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">UnicodeIteratorType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
</pre>
</body>
</html>