<html>
<head>
<title>devicearray.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
devicearray.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
The Device Array API is not implemented in the simulator. This module provides 
stubs to allow tests to import correctly. 
'''</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s1">numpy_version</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>


<span class="s1">DeviceRecord </span><span class="s3">= </span><span class="s2">None</span>
<span class="s1">from_record_like </span><span class="s3">= </span><span class="s2">None</span>


<span class="s1">errmsg_contiguous_buffer </span><span class="s3">= (</span><span class="s4">&quot;Array contains non-contiguous buffer and cannot &quot;</span>
                            <span class="s4">&quot;be transferred as a single memory region. Please &quot;</span>
                            <span class="s4">&quot;ensure contiguous buffer with numpy &quot;</span>
                            <span class="s4">&quot;.ascontiguousarray()&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">FakeShape</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">):</span>
    <span class="s0">''' 
    The FakeShape class is used to provide a shape which does not allow negative 
    indexing, similar to the shape in CUDA Python. (Numpy shape arrays allow 
    negative indexing) 
    '''</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">int</span><span class="s3">) </span><span class="s2">and </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">IndexError</span><span class="s3">(</span><span class="s4">'tuple index out of range'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">(</span><span class="s1">FakeShape</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">FakeWithinKernelCUDAArray</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">''' 
    Created to emulate the behavior of arrays within kernels, where either 
    array.item or array['item'] is valid (that is, give all structured 
    arrays `numpy.recarray`-like semantics). This behaviour does not follow 
    the semantics of Python and NumPy with non-jitted code, and will be 
    deprecated and removed. 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">FakeCUDAArray</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">[</span><span class="s4">'_item'</span><span class="s3">] = </span><span class="s1">item</span>

    <span class="s2">def </span><span class="s1">__wrap_if_fake</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">FakeCUDAArray</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">FakeWithinKernelCUDAArray</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">item</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">attrname </span><span class="s2">in </span><span class="s1">dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">):  </span><span class="s6"># For e.g. array size.</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__wrap_if_fake</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__wrap_if_fake</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">attrname</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nm</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">nm</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__wrap_if_fake</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__array_ufunc__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6"># ufuncs can only be called directly on instances of numpy.ndarray (not</span>
        <span class="s6"># things that implement its interfaces, like the FakeCUDAArray or</span>
        <span class="s6"># FakeWithinKernelCUDAArray). For other objects, __array_ufunc__ is</span>
        <span class="s6"># called when they are arguments to ufuncs, to provide an opportunity</span>
        <span class="s6"># to somehow implement the ufunc. Since the FakeWithinKernelCUDAArray</span>
        <span class="s6"># is just a thin wrapper over an ndarray, we can implement all ufuncs</span>
        <span class="s6"># by passing the underlying ndarrays to a call to the intended ufunc.</span>
        <span class="s1">call </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">convert_fakes</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">FakeWithinKernelCUDAArray</span><span class="s3">):</span>
                <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_item</span><span class="s3">.</span><span class="s1">_ary</span>

            <span class="s2">return </span><span class="s1">obj</span>

        <span class="s1">out </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'out'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">out</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s4">'out'</span><span class="s3">] = </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">convert_fakes</span><span class="s3">(</span><span class="s1">o</span><span class="s3">) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">convert_fakes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">call</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">''' 
    Implements the interface of a DeviceArray/DeviceRecord, but mostly just 
    wraps a NumPy array. 
    '''</span>

    <span class="s1">__cuda_ndarray__ </span><span class="s3">= </span><span class="s2">True  </span><span class="s6"># There must be gpu_data attribute</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">= </span><span class="s1">ary</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stream </span><span class="s3">= </span><span class="s1">stream</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">alloc_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">nbytes</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">nbytes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6"># return nbytes -- FakeCUDAArray is a wrapper around NumPy</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">nbytes</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">attr </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">attr</span>
        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Wrapped array has no attribute '%s'&quot; </span><span class="s3">% </span><span class="s1">attrname</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">T</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">):</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">) </span><span class="s2">not in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">void</span><span class="s3">]:</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stream</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">copy_to_host</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">ary </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">ary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">check_array_compatibility</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">copyto</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ary</span>

    <span class="s2">def </span><span class="s1">copy_to_device</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s0">''' 
        Copy from the provided array into this array. 
 
        This may be less forgiving than the CUDA Python implementation, which 
        will copy data up to the length of the smallest of the two arrays, 
        whereas this expects the size of the arrays to be equal. 
        '''</span>
        <span class="s1">sentry_contiguous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">self_core</span><span class="s3">, </span><span class="s1">ary_core </span><span class="s3">= </span><span class="s1">array_core</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), </span><span class="s1">array_core</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">FakeCUDAArray</span><span class="s3">):</span>
            <span class="s1">sentry_contiguous</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
            <span class="s1">check_array_compatibility</span><span class="s3">(</span><span class="s1">self_core</span><span class="s3">, </span><span class="s1">ary_core</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ary_core </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                <span class="s1">ary_core</span><span class="s3">,</span>
                <span class="s1">order</span><span class="s3">=</span><span class="s4">'C' </span><span class="s2">if </span><span class="s1">self_core</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'C_CONTIGUOUS'</span><span class="s3">] </span><span class="s2">else </span><span class="s4">'F'</span><span class="s3">,</span>
                <span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">copy</span><span class="s3">=</span><span class="s2">False if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">else None</span><span class="s3">)</span>
            <span class="s1">check_array_compatibility</span><span class="s3">(</span><span class="s1">self_core</span><span class="s3">, </span><span class="s1">ary_core</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">copyto</span><span class="s3">(</span><span class="s1">self_core</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">ary_core</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeShape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">is_c_contiguous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">c_contiguous</span>

    <span class="s2">def </span><span class="s1">is_f_contiguous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">f_contiguous</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">)</span>

    <span class="s6"># TODO: Add inplace, bitwise, unary magic methods</span>
    <span class="s6">#  (or maybe inherit this class from numpy)?</span>
    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">== </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">!= </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__lt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">&lt; </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__le__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">&lt;= </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__gt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">&gt; </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__ge__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">&gt;= </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__add__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">+ </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__sub__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">- </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__mul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">* </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__floordiv__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">// </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__truediv__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">/ </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__mod__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">% </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__pow__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary </span><span class="s3">** </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">section</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ary</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s1">section</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), </span><span class="s1">section</span><span class="s3">))</span>
        <span class="s3">]</span>


<span class="s2">def </span><span class="s1">array_core</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract the repeated core of a broadcast array. 
 
    Broadcast arrays are by definition non-contiguous due to repeated 
    dimensions, i.e., dimensions with stride 0. In order to ascertain memory 
    contiguity and copy the underlying data from such arrays, we must create 
    a view without the repeated dimensions. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides </span><span class="s2">or not </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">ary</span>
    <span class="s1">core_index </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">stride </span><span class="s2">in </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">:</span>
        <span class="s1">core_index</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0 </span><span class="s2">if </span><span class="s1">stride </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">ary</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">core_index</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">is_contiguous</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns True iff `ary` is C-style contiguous while ignoring 
    broadcasted and 1-sized dimensions. 
    As opposed to array_core(), it does not call require_context(), 
    which can be quite expensive. 
    &quot;&quot;&quot;</span>
    <span class="s1">size </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">itemsize</span>
    <span class="s2">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">stride </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">shape </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">stride </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s3">!= </span><span class="s1">stride</span><span class="s3">:</span>
                <span class="s2">return False</span>
            <span class="s1">size </span><span class="s3">*= </span><span class="s1">shape</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">sentry_contiguous</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s1">core </span><span class="s3">= </span><span class="s1">array_core</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">core</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'C_CONTIGUOUS'</span><span class="s3">] </span><span class="s2">and not </span><span class="s1">core</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'F_CONTIGUOUS'</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg_contiguous_buffer</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_array_compatibility</span><span class="s3">(</span><span class="s1">ary1</span><span class="s3">, </span><span class="s1">ary2</span><span class="s3">):</span>
    <span class="s1">ary1sq</span><span class="s3">, </span><span class="s1">ary2sq </span><span class="s3">= </span><span class="s1">ary1</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(), </span><span class="s1">ary2</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">ary1</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">ary2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'incompatible dtype: %s vs. %s' </span><span class="s3">%</span>
                        <span class="s3">(</span><span class="s1">ary1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ary2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">ary1sq</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">ary2sq</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'incompatible shape: %s vs. %s' </span><span class="s3">%</span>
                         <span class="s3">(</span><span class="s1">ary1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ary2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">ary1sq</span><span class="s3">.</span><span class="s1">strides </span><span class="s3">!= </span><span class="s1">ary2sq</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'incompatible strides: %s vs. %s' </span><span class="s3">%</span>
                         <span class="s3">(</span><span class="s1">ary1</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ary2</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">to</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">,</span>
                   <span class="s1">copy</span><span class="s3">=</span><span class="s2">False if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">else None</span><span class="s3">,</span>
                   <span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">sentry_contiguous</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">to </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">buffer_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64 </span><span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">in </span><span class="s4">'Mm' </span><span class="s2">else </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">(</span>
                <span class="s1">buffer</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">array_core</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">buffer_dtype</span><span class="s3">),</span>
                <span class="s1">dtype</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
                <span class="s1">shape</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                <span class="s1">strides</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
            <span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">type</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)),</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">to</span><span class="s3">.</span><span class="s1">copy_to_device</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">pinned</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
    <span class="s2">yield</span>


<span class="s2">def </span><span class="s1">mapped_array</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">unused_arg </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'portable'</span><span class="s3">, </span><span class="s4">'wc'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">unused_arg </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">unused_arg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">device_array</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pinned_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">managed_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">device_array</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'stream'</span><span class="s3">) </span><span class="s2">if </span><span class="s4">'stream' </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">else </span><span class="s5">0</span>
    <span class="s2">return </span><span class="s1">FakeCUDAArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">), </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_contiguous_strides_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given an array, compute strides for a new contiguous array of the same 
    shape. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Don't recompute strides if the default strides will be sufficient to</span>
    <span class="s6"># create a contiguous array.</span>
    <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'C_CONTIGUOUS'</span><span class="s3">] </span><span class="s2">or </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'F_CONTIGUOUS'</span><span class="s3">] </span><span class="s2">or </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return None</span>

    <span class="s6"># Otherwise, we need to compute new strides using an algorithm adapted from</span>
    <span class="s6"># NumPy v1.17.4's PyArray_NewLikeArrayWithShape in</span>
    <span class="s6"># core/src/multiarray/ctors.c. We permute the strides in ascending order</span>
    <span class="s6"># then compute the stride for the dimensions with the same permutation.</span>

    <span class="s6"># Stride permutation. E.g. a stride array (4, -2, 12) becomes</span>
    <span class="s6"># [(1, -2), (0, 4), (2, 12)]</span>
    <span class="s1">strideperm </span><span class="s3">= [ </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">) ]</span>
    <span class="s1">strideperm</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s6"># Compute new strides using permutation</span>
    <span class="s1">strides </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">stride </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">itemsize</span>
    <span class="s2">for </span><span class="s1">i_perm</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">strideperm</span><span class="s3">:</span>
        <span class="s1">strides</span><span class="s3">[</span><span class="s1">i_perm</span><span class="s3">] = </span><span class="s1">stride</span>
        <span class="s1">stride </span><span class="s3">*= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i_perm</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_order_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'F_CONTIGUOUS'</span><span class="s3">] </span><span class="s2">and not </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s4">'C_CONTIGUOUS'</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s4">'F'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">'C'</span>


<span class="s2">def </span><span class="s1">device_array_like</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">_contiguous_strides_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s1">_order_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">device_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                        <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pinned_array_like</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">_contiguous_strides_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s1">_order_like_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pinned_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                        <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">auto_device</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">FakeCUDAArray</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">, </span><span class="s2">False</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">void</span><span class="s3">):</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
            <span class="s1">ary</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s2">False if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">else None</span><span class="s3">,</span>
            <span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">), </span><span class="s2">True</span>


<span class="s2">def </span><span class="s1">is_cuda_ndarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s0">&quot;Check if an object is a CUDA ndarray&quot;</span>
    <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">'__cuda_ndarray__'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">verify_cuda_ndarray_interface</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s0">&quot;Verify the CUDA ndarray interface for an obj&quot;</span>
    <span class="s1">require_cuda_ndarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">requires_attr</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">), </span><span class="s1">typ</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">'%s must be of type %s' </span><span class="s3">% (</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">))</span>

    <span class="s1">requires_attr</span><span class="s3">(</span><span class="s4">'shape'</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)</span>
    <span class="s1">requires_attr</span><span class="s3">(</span><span class="s4">'strides'</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)</span>
    <span class="s1">requires_attr</span><span class="s3">(</span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">requires_attr</span><span class="s3">(</span><span class="s4">'size'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">require_cuda_ndarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s0">&quot;Raises ValueError is is_cuda_ndarray(obj) evaluates False&quot;</span>
    <span class="s2">if not </span><span class="s1">is_cuda_ndarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'require an cuda ndarray object'</span><span class="s3">)</span>
</pre>
</body>
</html>