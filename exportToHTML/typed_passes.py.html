<html>
<head>
<title>typed_passes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typed_passes.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s2">(</span><span class="s1">errors</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">, </span><span class="s1">funcdesc</span><span class="s2">, </span><span class="s1">rewrites</span><span class="s2">,</span>
                        <span class="s1">typeinfer</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">lowering</span><span class="s2">)</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">PreParforPass </span><span class="s0">as </span><span class="s1">_parfor_PreParforPass</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">ParforPass </span><span class="s0">as </span><span class="s1">_parfor_ParforPass</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">ParforFusionPass </span><span class="s0">as </span><span class="s1">_parfor_ParforFusionPass</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">ParforPreLoweringPass </span><span class="s0">as </span><span class="s1">\</span>
    <span class="s1">_parfor_ParforPreLoweringPass</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">Parfor</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">parfors</span><span class="s2">.</span><span class="s1">parfor_lowering </span><span class="s0">import </span><span class="s1">ParforLower</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_machinery </span><span class="s0">import </span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">, </span><span class="s1">LoweringPass</span><span class="s2">,</span>
                                           <span class="s1">AnalysisPass</span><span class="s2">, </span><span class="s1">register_pass</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">annotations </span><span class="s0">import </span><span class="s1">type_annotations</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ir_utils </span><span class="s0">import </span><span class="s2">(</span><span class="s1">raise_on_unsupported_feature</span><span class="s2">, </span><span class="s1">warn_deprecated</span><span class="s2">,</span>
                                 <span class="s1">check_and_legalize_ir</span><span class="s2">, </span><span class="s1">guard</span><span class="s2">,</span>
                                 <span class="s1">dead_code_elimination</span><span class="s2">, </span><span class="s1">simplify_CFG</span><span class="s2">,</span>
                                 <span class="s1">get_definition</span><span class="s2">,</span>
                                 <span class="s1">build_definitions</span><span class="s2">, </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">,</span>
                                 <span class="s1">is_operator_or_getitem</span><span class="s2">,</span>
                                 <span class="s1">replace_vars</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">postproc</span>
<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">binding </span><span class="s0">as </span><span class="s1">llvm</span>


<span class="s3"># Outputs of type inference pass</span>
<span class="s1">_TypingResults </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s4">&quot;_TypingResults&quot;</span><span class="s2">, [</span>
    <span class="s4">&quot;typemap&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;return_type&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;calltypes&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;typing_errors&quot;</span><span class="s2">,</span>
<span class="s2">])</span>


<span class="s2">@</span><span class="s1">contextmanager</span>
<span class="s0">def </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Wraps code that would signal a fallback to object mode 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">yield</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">state</span><span class="s2">.</span><span class="s1">status</span><span class="s2">.</span><span class="s1">can_fallback</span><span class="s2">:</span>
            <span class="s0">raise</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># Clear all references attached to the traceback</span>
            <span class="s1">e </span><span class="s2">= </span><span class="s1">e</span><span class="s2">.</span><span class="s1">with_traceback</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s3"># this emits a warning containing the error message body in the</span>
            <span class="s3"># case of fallback from npm to objmode</span>
            <span class="s1">loop_lift </span><span class="s2">= </span><span class="s4">'' </span><span class="s0">if </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">enable_looplift </span><span class="s0">else </span><span class="s4">'OUT'</span>
            <span class="s1">msg_rewrite </span><span class="s2">= (</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">Compilation is falling back to object mode &quot;</span>
                           <span class="s4">&quot;WITH%s looplifting enabled because %s&quot;</span>
                           <span class="s2">% (</span><span class="s1">loop_lift</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">))</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn_explicit</span><span class="s2">(</span><span class="s4">'%s due to: %s' </span><span class="s2">% (</span><span class="s1">msg_rewrite</span><span class="s2">, </span><span class="s1">e</span><span class="s2">),</span>
                                   <span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaWarning</span><span class="s2">,</span>
                                   <span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">,</span>
                                   <span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">firstlineno</span><span class="s2">)</span>
            <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">type_inference_stage</span><span class="s2">(</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">targetctx</span><span class="s2">, </span><span class="s1">interp</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">,</span>
                         <span class="s1">locals</span><span class="s2">={}, </span><span class="s1">raise_errors</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) != </span><span class="s1">interp</span><span class="s2">.</span><span class="s1">arg_count</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Mismatch number of argument types&quot;</span><span class="s2">)</span>
    <span class="s1">warnings </span><span class="s2">= </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">WarningsFixer</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaWarning</span><span class="s2">)</span>

    <span class="s1">infer </span><span class="s2">= </span><span class="s1">typeinfer</span><span class="s2">.</span><span class="s1">TypeInferer</span><span class="s2">(</span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">interp</span><span class="s2">, </span><span class="s1">warnings</span><span class="s2">)</span>
    <span class="s1">callstack_ctx </span><span class="s2">= </span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">callstack</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">infer</span><span class="s2">,</span>
                                                 <span class="s1">interp</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s3"># Setup two contexts: 1) callstack setup/teardown 2) flush warnings</span>
    <span class="s0">with </span><span class="s1">callstack_ctx</span><span class="s2">, </span><span class="s1">warnings</span><span class="s2">:</span>
        <span class="s3"># Seed argument types</span>
        <span class="s0">for </span><span class="s1">index</span><span class="s2">, (</span><span class="s1">name</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">interp</span><span class="s2">.</span><span class="s1">arg_names</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)):</span>
            <span class="s1">infer</span><span class="s2">.</span><span class="s1">seed_argument</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>

        <span class="s3"># Seed return type</span>
        <span class="s0">if </span><span class="s1">return_type </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">infer</span><span class="s2">.</span><span class="s1">seed_return</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">)</span>

        <span class="s3"># Seed local types</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">locals</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">infer</span><span class="s2">.</span><span class="s1">seed_type</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>

        <span class="s1">infer</span><span class="s2">.</span><span class="s1">build_constraint</span><span class="s2">()</span>
        <span class="s3"># return errors in case of partial typing</span>
        <span class="s1">errs </span><span class="s2">= </span><span class="s1">infer</span><span class="s2">.</span><span class="s1">propagate</span><span class="s2">(</span><span class="s1">raise_errors</span><span class="s2">=</span><span class="s1">raise_errors</span><span class="s2">)</span>
        <span class="s1">typemap</span><span class="s2">, </span><span class="s1">restype</span><span class="s2">, </span><span class="s1">calltypes </span><span class="s2">= </span><span class="s1">infer</span><span class="s2">.</span><span class="s1">unify</span><span class="s2">(</span><span class="s1">raise_errors</span><span class="s2">=</span><span class="s1">raise_errors</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_TypingResults</span><span class="s2">(</span><span class="s1">typemap</span><span class="s2">, </span><span class="s1">restype</span><span class="s2">, </span><span class="s1">calltypes</span><span class="s2">, </span><span class="s1">errs</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">BaseTypeInference</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_raise_errors </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Type inference and legalization 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s4">'Function &quot;%s&quot; failed type inference'</span>
                              <span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,)):</span>
            <span class="s3"># Type inference</span>
            <span class="s1">typemap</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">calltypes</span><span class="s2">, </span><span class="s1">errs </span><span class="s2">= </span><span class="s1">type_inference_stage</span><span class="s2">(</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">,</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">locals</span><span class="s2">,</span>
                <span class="s1">raise_errors</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_errors</span><span class="s2">)</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap </span><span class="s2">= </span><span class="s1">typemap</span>
            <span class="s3"># save errors in case of partial typing</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">typing_errors </span><span class="s2">= </span><span class="s1">errs</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_errors</span><span class="s2">:</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type </span><span class="s2">= </span><span class="s1">return_type</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes </span><span class="s2">= </span><span class="s1">calltypes</span>

        <span class="s0">def </span><span class="s1">legalize_return_type</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">interp</span><span class="s2">, </span><span class="s1">targetctx</span><span class="s2">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Only accept array return type iff it is passed into the function. 
            Reject function object return types if in nopython mode. 
            &quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">enable_nrt </span><span class="s0">and</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">)):</span>
                <span class="s3"># Walk IR to discover all arguments and all return statements</span>
                <span class="s1">retstmts </span><span class="s2">= []</span>
                <span class="s1">caststmts </span><span class="s2">= {}</span>
                <span class="s1">argvars </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
                <span class="s0">for </span><span class="s1">bid</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">interp</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s0">for </span><span class="s1">inst </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Return</span><span class="s2">):</span>
                            <span class="s1">retstmts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
                        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                            <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">)</span>
                                    <span class="s0">and </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">'cast'</span><span class="s2">):</span>
                                <span class="s1">caststmts</span><span class="s2">[</span><span class="s1">inst</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">value</span>
                            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Arg</span><span class="s2">):</span>
                                <span class="s1">argvars</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">.</span><span class="s1">target</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

                <span class="s0">assert </span><span class="s1">retstmts</span><span class="s2">, </span><span class="s4">&quot;No return statements?&quot;</span>

                <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">retstmts</span><span class="s2">:</span>
                    <span class="s1">cast </span><span class="s2">= </span><span class="s1">caststmts</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">var</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">cast </span><span class="s0">is None or </span><span class="s1">cast</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">name </span><span class="s0">not in </span><span class="s1">argvars</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_errors</span><span class="s2">:</span>
                            <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;Only accept returning of array passed into &quot;</span>
                                   <span class="s4">&quot;the function as argument&quot;</span><span class="s2">)</span>
                            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

            <span class="s0">elif </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">) </span><span class="s0">or</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Phantom</span><span class="s2">)):</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_errors</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Can't return function object ({}) in nopython mode&quot;</span>
                    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">))</span>

        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s4">'Function &quot;%s&quot; has invalid return type'</span>
                              <span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,)):</span>
            <span class="s1">legalize_return_type</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                 <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NopythonTypeInference</span><span class="s2">(</span><span class="s1">BaseTypeInference</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;nopython_type_inference&quot;</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PartialTypeInference</span><span class="s2">(</span><span class="s1">BaseTypeInference</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;partial_type_inference&quot;</span>
    <span class="s1">_raise_errors </span><span class="s2">= </span><span class="s0">False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">AnnotateTypes</span><span class="s2">(</span><span class="s1">AnalysisPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;annotate_types&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">AnalysisPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_analysis_usage</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">AU</span><span class="s2">):</span>
        <span class="s1">AU</span><span class="s2">.</span><span class="s1">add_required</span><span class="s2">(</span><span class="s1">IRLegalization</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Create type annotation after type inference 
        &quot;&quot;&quot;</span>
        <span class="s1">func_ir </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">type_annotation </span><span class="s2">= </span><span class="s1">type_annotations</span><span class="s2">.</span><span class="s1">TypeAnnotation</span><span class="s2">(</span>
            <span class="s1">func_ir</span><span class="s2">=</span><span class="s1">func_ir</span><span class="s2">,</span>
            <span class="s1">typemap</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
            <span class="s1">calltypes</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
            <span class="s1">lifted</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">lifted</span><span class="s2">,</span>
            <span class="s1">lifted_from</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">lifted_from</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">,</span>
            <span class="s1">return_type</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
            <span class="s1">html_output</span><span class="s2">=</span><span class="s1">config</span><span class="s2">.</span><span class="s1">HTML</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">ANNOTATE</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">&quot;ANNOTATION&quot;</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">type_annotation</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">'=' </span><span class="s2">* </span><span class="s6">80</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">HTML</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">open</span><span class="s2">(</span><span class="s1">config</span><span class="s2">.</span><span class="s1">HTML</span><span class="s2">, </span><span class="s4">'w'</span><span class="s2">) </span><span class="s0">as </span><span class="s1">fout</span><span class="s2">:</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">type_annotation</span><span class="s2">.</span><span class="s1">html_annotate</span><span class="s2">(</span><span class="s1">fout</span><span class="s2">)</span>

        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NopythonRewrites</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;nopython_rewrites&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Perform any intermediate representation rewrites after type 
        inference. 
        &quot;&quot;&quot;</span>
        <span class="s3"># a bunch of these passes are either making assumptions or rely on some</span>
        <span class="s3"># very picky and slightly bizarre state particularly in relation to</span>
        <span class="s3"># ir.Del presence. To accommodate, ir.Dels are added ahead of running</span>
        <span class="s3"># this pass and stripped at the end.</span>

        <span class="s3"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s4">'typemap'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">), </span><span class="s1">dict</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s4">'calltypes'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">), </span><span class="s1">dict</span><span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s4">'Internal error in post-inference rewriting '</span>
               <span class="s4">'pass encountered during compilation of '</span>
               <span class="s4">'function &quot;%s&quot;' </span><span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>

        <span class="s1">pp </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">pp</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">rewrites</span><span class="s2">.</span><span class="s1">rewrite_registry</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s4">'after-inference'</span><span class="s2">, </span><span class="s1">state</span><span class="s2">)</span>
        <span class="s1">pp</span><span class="s2">.</span><span class="s1">remove_dels</span><span class="s2">()</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PreParforPass</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;pre_parfor_pass&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Preprocessing for data-parallel computations. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">preparfor_pass </span><span class="s2">= </span><span class="s1">_parfor_PreParforPass</span><span class="s2">(</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">.</span><span class="s1">replaced_fns</span>
        <span class="s2">)</span>

        <span class="s1">preparfor_pass</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>
        <span class="s0">return True</span>


<span class="s3"># this is here so it pickles and for no other reason</span>
<span class="s0">def </span><span class="s1">_reload_parfors</span><span class="s2">():</span>
    <span class="s5">&quot;&quot;&quot;Reloader for cached parfors 
    &quot;&quot;&quot;</span>
    <span class="s3"># Re-initialize the parallel backend when load from cache.</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">parallel </span><span class="s0">import </span><span class="s1">_launch_threads</span>
    <span class="s1">_launch_threads</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ParforPass</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;parfor_pass&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert data-parallel computations into Parfor nodes 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">parfor_pass </span><span class="s2">= </span><span class="s1">_parfor_ParforPass</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span><span class="s2">,</span>
                                         <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">)</span>
        <span class="s1">parfor_pass</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s3"># check the parfor pass worked and warn if it didn't</span>
        <span class="s1">has_parfor </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">stmnt </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">body</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stmnt</span><span class="s2">, </span><span class="s1">Parfor</span><span class="s2">):</span>
                    <span class="s1">has_parfor </span><span class="s2">= </span><span class="s0">True</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s0">break</span>

        <span class="s0">if not </span><span class="s1">has_parfor</span><span class="s2">:</span>
            <span class="s3"># parfor calls the compiler chain again with a string</span>
            <span class="s0">if not </span><span class="s2">(</span><span class="s1">config</span><span class="s2">.</span><span class="s1">DISABLE_PERFORMANCE_WARNINGS </span><span class="s0">or</span>
                    <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">.</span><span class="s1">filename </span><span class="s2">== </span><span class="s4">'&lt;string&gt;'</span><span class="s2">):</span>
                <span class="s1">url </span><span class="s2">= (</span><span class="s4">&quot;https://numba.readthedocs.io/en/stable/user/&quot;</span>
                       <span class="s4">&quot;parallel.html#diagnostics&quot;</span><span class="s2">)</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">The keyword argument 'parallel=True' was specified &quot;</span>
                       <span class="s4">&quot;but no transformation for parallel execution was &quot;</span>
                       <span class="s4">&quot;possible.</span><span class="s0">\n\n</span><span class="s4">To find out why, try turning on parallel &quot;</span>
                       <span class="s4">&quot;diagnostics, see %s for help.&quot; </span><span class="s2">% </span><span class="s1">url</span><span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaPerformanceWarning</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">,</span>
                                                             <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">))</span>

        <span class="s3"># Add reload function to initialize the parallel backend.</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">reload_init</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_reload_parfors</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ParforFusionPass</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;parfor_fusion_pass&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Do fusion of parfor nodes. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">parfor_pass </span><span class="s2">= </span><span class="s1">_parfor_ParforFusionPass</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span><span class="s2">,</span>
                                               <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">)</span>
        <span class="s1">parfor_pass</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">ParforPreLoweringPass</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;parfor_prelowering_pass&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Prepare parfors for lowering. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ensure we have an IR and type information.</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span>
        <span class="s1">parfor_pass </span><span class="s2">= </span><span class="s1">_parfor_ParforPreLoweringPass</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span><span class="s2">,</span>
                                                    <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">)</span>
        <span class="s1">parfor_pass</span><span class="s2">.</span><span class="s1">run</span><span class="s2">()</span>

        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">DumpParforDiagnostics</span><span class="s2">(</span><span class="s1">AnalysisPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;dump_parfor_diagnostics&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">AnalysisPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">.</span><span class="s1">enabled</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">PARALLEL_DIAGNOSTICS</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">state</span><span class="s2">.</span><span class="s1">parfor_diagnostics</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">(</span><span class="s1">config</span><span class="s2">.</span><span class="s1">PARALLEL_DIAGNOSTICS</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s4">&quot;Diagnostics failed.&quot;</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s0">class </span><span class="s1">BaseNativeLowering</span><span class="s2">(</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABC</span><span class="s2">, </span><span class="s1">LoweringPass</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;The base class for a lowering pass. The lowering functionality must be 
    specified in inheriting classes by providing an appropriate lowering class 
    implementation in the overridden `lowering_class` property.&quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">LoweringPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">lowering_class</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the class that performs the lowering of the IR describing the 
        function that is the target of the current compilation.&quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">state</span><span class="s2">.</span><span class="s1">library </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">codegen </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">codegen</span><span class="s2">()</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">library </span><span class="s2">= </span><span class="s1">codegen</span><span class="s2">.</span><span class="s1">create_library</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_qualname</span><span class="s2">)</span>
            <span class="s3"># Enable object caching upfront, so that the library can</span>
            <span class="s3"># be later serialized.</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">library</span><span class="s2">.</span><span class="s1">enable_object_caching</span><span class="s2">()</span>

        <span class="s1">library </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">library</span>
        <span class="s1">targetctx </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span>
        <span class="s1">interp </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir  </span><span class="s3"># why is it called this?!</span>
        <span class="s1">typemap </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span>
        <span class="s1">restype </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span>
        <span class="s1">calltypes </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span>
        <span class="s1">flags </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span>
        <span class="s1">metadata </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span>
        <span class="s1">pre_stats </span><span class="s2">= </span><span class="s1">llvm</span><span class="s2">.</span><span class="s1">passmanagers</span><span class="s2">.</span><span class="s1">dump_refprune_stats</span><span class="s2">()</span>

        <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;Function %s failed at nopython &quot;</span>
               <span class="s4">&quot;mode lowering&quot; </span><span class="s2">% (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">with </span><span class="s1">fallback_context</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s3"># Lowering</span>
            <span class="s1">fndesc </span><span class="s2">= </span><span class="s1">\</span>
                <span class="s1">funcdesc</span><span class="s2">.</span><span class="s1">PythonFunctionDescriptor</span><span class="s2">.</span><span class="s1">from_specialized_function</span><span class="s2">(</span>
                    <span class="s1">interp</span><span class="s2">, </span><span class="s1">typemap</span><span class="s2">, </span><span class="s1">restype</span><span class="s2">, </span><span class="s1">calltypes</span><span class="s2">,</span>
                    <span class="s1">mangler</span><span class="s2">=</span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">mangler</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">=</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">forceinline</span><span class="s2">,</span>
                    <span class="s1">noalias</span><span class="s2">=</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">noalias</span><span class="s2">, </span><span class="s1">abi_tags</span><span class="s2">=[</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">get_mangle_string</span><span class="s2">()])</span>

            <span class="s0">with </span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">push_code_library</span><span class="s2">(</span><span class="s1">library</span><span class="s2">):</span>
                <span class="s1">lower </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lowering_class</span><span class="s2">(</span><span class="s1">targetctx</span><span class="s2">, </span><span class="s1">library</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">interp</span><span class="s2">,</span>
                                            <span class="s1">metadata</span><span class="s2">=</span><span class="s1">metadata</span><span class="s2">)</span>
                <span class="s1">lower</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
                <span class="s0">if not </span><span class="s1">flags</span><span class="s2">.</span><span class="s1">no_cpython_wrapper</span><span class="s2">:</span>
                    <span class="s1">lower</span><span class="s2">.</span><span class="s1">create_cpython_wrapper</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">release_gil</span><span class="s2">)</span>

                <span class="s0">if not </span><span class="s1">flags</span><span class="s2">.</span><span class="s1">no_cfunc_wrapper</span><span class="s2">:</span>
                    <span class="s3"># skip cfunc wrapper generation if unsupported</span>
                    <span class="s3"># argument or return types are used</span>
                    <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Omitted</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">)):</span>
                            <span class="s0">break</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">restype</span><span class="s2">,</span>
                                      <span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">)):</span>
                            <span class="s0">pass</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">lower</span><span class="s2">.</span><span class="s1">create_cfunc_wrapper</span><span class="s2">()</span>

                <span class="s1">env </span><span class="s2">= </span><span class="s1">lower</span><span class="s2">.</span><span class="s1">env</span>
                <span class="s1">call_helper </span><span class="s2">= </span><span class="s1">lower</span><span class="s2">.</span><span class="s1">call_helper</span>
                <span class="s0">del </span><span class="s1">lower</span>

            <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">_LowerResult  </span><span class="s3"># TODO: move this</span>
            <span class="s0">if </span><span class="s1">flags</span><span class="s2">.</span><span class="s1">no_compile</span><span class="s2">:</span>
                <span class="s1">state</span><span class="s2">[</span><span class="s4">'cr'</span><span class="s2">] = </span><span class="s1">_LowerResult</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">call_helper</span><span class="s2">,</span>
                                           <span class="s1">cfunc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">env</span><span class="s2">=</span><span class="s1">env</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># Prepare for execution</span>
                <span class="s3"># Insert native function for use by other jitted-functions.</span>
                <span class="s3"># We also register its library to allow for inlining.</span>
                <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">targetctx</span><span class="s2">.</span><span class="s1">get_executable</span><span class="s2">(</span><span class="s1">library</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">env</span><span class="s2">)</span>
                <span class="s1">targetctx</span><span class="s2">.</span><span class="s1">insert_user_function</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, [</span><span class="s1">library</span><span class="s2">])</span>
                <span class="s1">state</span><span class="s2">[</span><span class="s4">'cr'</span><span class="s2">] = </span><span class="s1">_LowerResult</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">call_helper</span><span class="s2">,</span>
                                           <span class="s1">cfunc</span><span class="s2">=</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">env</span><span class="s2">=</span><span class="s1">env</span><span class="s2">)</span>

            <span class="s3"># capture pruning stats</span>
            <span class="s1">post_stats </span><span class="s2">= </span><span class="s1">llvm</span><span class="s2">.</span><span class="s1">passmanagers</span><span class="s2">.</span><span class="s1">dump_refprune_stats</span><span class="s2">()</span>
            <span class="s1">metadata</span><span class="s2">[</span><span class="s4">'prune_stats'</span><span class="s2">] = </span><span class="s1">post_stats </span><span class="s2">- </span><span class="s1">pre_stats</span>

            <span class="s3"># Save the LLVM pass timings</span>
            <span class="s1">metadata</span><span class="s2">[</span><span class="s4">'llvm_pass_timings'</span><span class="s2">] = </span><span class="s1">library</span><span class="s2">.</span><span class="s1">recorded_timings</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NativeLowering</span><span class="s2">(</span><span class="s1">BaseNativeLowering</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Lowering pass for a native function IR described solely in terms of 
     Numba's standard `numba.core.ir` nodes.&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;native_lowering&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">lowering_class</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">lowering</span><span class="s2">.</span><span class="s1">Lower</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NativeParforLowering</span><span class="s2">(</span><span class="s1">BaseNativeLowering</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Lowering pass for a native function IR described using Numba's standard 
    `numba.core.ir` nodes and also parfor.Parfor nodes.&quot;&quot;&quot;</span>
    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;native_parfor_lowering&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">lowering_class</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">ParforLower</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NoPythonSupportedFeatureValidation</span><span class="s2">(</span><span class="s1">AnalysisPass</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;NoPython Mode check: Validates the IR to ensure that features in use are 
    in a form that is supported&quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;nopython_supported_feature_validation&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">AnalysisPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">raise_on_unsupported_feature</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">)</span>
        <span class="s1">warn_deprecated</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">)</span>
        <span class="s0">return False</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">IRLegalization</span><span class="s2">(</span><span class="s1">AnalysisPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;ir_legalization&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">AnalysisPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s3"># NOTE: this function call must go last, it checks and fixes invalid IR!</span>
        <span class="s1">check_and_legalize_ir</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NoPythonBackend</span><span class="s2">(</span><span class="s1">LoweringPass</span><span class="s2">):</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;nopython_backend&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">LoweringPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Back-end: Generate LLVM IR from Numba IR, compile to machine code 
        &quot;&quot;&quot;</span>
        <span class="s1">lowered </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s4">'cr'</span><span class="s2">]</span>
        <span class="s1">signature </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, *</span><span class="s1">state</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">compile_result</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">cr </span><span class="s2">= </span><span class="s1">compile_result</span><span class="s2">(</span>
            <span class="s1">typing_context</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
            <span class="s1">target_context</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
            <span class="s1">entry_point</span><span class="s2">=</span><span class="s1">lowered</span><span class="s2">.</span><span class="s1">cfunc</span><span class="s2">,</span>
            <span class="s1">typing_error</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">status</span><span class="s2">.</span><span class="s1">fail_reason</span><span class="s2">,</span>
            <span class="s1">type_annotation</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">type_annotation</span><span class="s2">,</span>
            <span class="s1">library</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">library</span><span class="s2">,</span>
            <span class="s1">call_helper</span><span class="s2">=</span><span class="s1">lowered</span><span class="s2">.</span><span class="s1">call_helper</span><span class="s2">,</span>
            <span class="s1">signature</span><span class="s2">=</span><span class="s1">signature</span><span class="s2">,</span>
            <span class="s1">objectmode</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">lifted</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">lifted</span><span class="s2">,</span>
            <span class="s1">fndesc</span><span class="s2">=</span><span class="s1">lowered</span><span class="s2">.</span><span class="s1">fndesc</span><span class="s2">,</span>
            <span class="s1">environment</span><span class="s2">=</span><span class="s1">lowered</span><span class="s2">.</span><span class="s1">env</span><span class="s2">,</span>
            <span class="s1">metadata</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">metadata</span><span class="s2">,</span>
            <span class="s1">reload_init</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">reload_init</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">InlineOverloads</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    This pass will inline a function wrapped by the numba.extending.overload 
    decorator directly into the site of its call depending on the value set in 
    the 'inline' kwarg to the decorator. 
 
    This is a typed pass. CFG simplification and DCE are performed on 
    completion. 
    &quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;inline_overloads&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s1">_DEBUG </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Run inlining of overloads 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">'before overload inline'</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">unique_name</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">''</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">inline_closurecall </span><span class="s0">import </span><span class="s2">(</span><span class="s1">InlineWorker</span><span class="s2">,</span>
                                                   <span class="s1">callee_ir_validator</span><span class="s2">)</span>
        <span class="s1">inline_worker </span><span class="s2">= </span><span class="s1">InlineWorker</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">targetctx</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">locals</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">pipeline</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">,</span>
                                     <span class="s1">callee_ir_validator</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
                                     <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
                                     <span class="s2">)</span>
        <span class="s1">modified </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">work_list </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s3"># use a work list, look for call sites via `ir.Expr.op == call` and</span>
        <span class="s3"># then pass these to `self._do_work` to make decisions about inlining.</span>
        <span class="s0">while </span><span class="s1">work_list</span><span class="s2">:</span>
            <span class="s1">label</span><span class="s2">, </span><span class="s1">block </span><span class="s2">= </span><span class="s1">work_list</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">instr </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">block</span><span class="s2">.</span><span class="s1">body</span><span class="s2">):</span>
                <span class="s3"># TO-DO: other statements (setitem)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">instr</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                    <span class="s1">expr </span><span class="s2">= </span><span class="s1">instr</span><span class="s2">.</span><span class="s1">value</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                        <span class="s1">workfn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_do_work_expr</span>

                        <span class="s0">if </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">workfn</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">work_list</span><span class="s2">, </span><span class="s1">block</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">,</span>
                                 <span class="s1">inline_worker</span><span class="s2">):</span>
                            <span class="s1">modified </span><span class="s2">= </span><span class="s0">True</span>
                            <span class="s0">break  </span><span class="s3"># because block structure changed</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">'after overload inline'</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">unique_name</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">''</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">modified</span><span class="s2">:</span>
            <span class="s3"># Remove dead blocks, this is safe as it relies on the CFG only.</span>
            <span class="s1">cfg </span><span class="s2">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">dead </span><span class="s0">in </span><span class="s1">cfg</span><span class="s2">.</span><span class="s1">dead_nodes</span><span class="s2">():</span>
                <span class="s0">del </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">dead</span><span class="s2">]</span>
            <span class="s3"># clean up blocks</span>
            <span class="s1">dead_code_elimination</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                  <span class="s1">typemap</span><span class="s2">=</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">)</span>
            <span class="s3"># clean up unconditional branches that appear due to inlined</span>
            <span class="s3"># functions introducing blocks</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">simplify_CFG</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_DEBUG</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">'after overload inline DCE'</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">unique_name</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">())</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">''</span><span class="s2">.</span><span class="s1">center</span><span class="s2">(</span><span class="s6">80</span><span class="s2">, </span><span class="s4">'-'</span><span class="s2">))</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_get_attr_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>
        <span class="s1">recv_type </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s1">recv_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">unliteral</span><span class="s2">(</span><span class="s1">recv_type</span><span class="s2">)</span>
        <span class="s1">matched </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">find_matching_getattr_template</span><span class="s2">(</span>
            <span class="s1">recv_type</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">attr</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">matched</span><span class="s2">:</span>
            <span class="s0">return None</span>

        <span class="s1">template </span><span class="s2">= </span><span class="s1">matched</span><span class="s2">[</span><span class="s4">'template'</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">template</span><span class="s2">, </span><span class="s4">'is_method'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s3"># The attribute template is representing a method.</span>
            <span class="s3"># Don't inline the getattr.</span>
            <span class="s0">return None</span>

        <span class="s1">templates </span><span class="s2">= [</span><span class="s1">template</span><span class="s2">]</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">matched</span><span class="s2">[</span><span class="s4">'return_type'</span><span class="s2">], </span><span class="s1">recv_type</span><span class="s2">)</span>
        <span class="s1">arg_typs </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">is_method </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">templates</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">is_method</span>

    <span class="s0">def </span><span class="s1">_get_callable_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">get_func_type</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>
            <span class="s1">func_ty </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">'call'</span><span class="s2">:</span>
                <span class="s3"># check this is a known and typed function</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">func_ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                    <span class="s3"># e.g. Calls to CUDA Intrinsic have no mapped type</span>
                    <span class="s3"># so KeyError</span>
                    <span class="s0">return None</span>
                <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">func_ty</span><span class="s2">, </span><span class="s4">'get_call_type'</span><span class="s2">):</span>
                    <span class="s0">return None</span>

            <span class="s0">elif </span><span class="s1">is_operator_or_getitem</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">):</span>
                <span class="s1">func_ty </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typingctx</span><span class="s2">.</span><span class="s1">resolve_value_type</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">fn</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return None</span>

            <span class="s0">return </span><span class="s1">func_ty</span>

        <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">'call'</span><span class="s2">:</span>
            <span class="s3"># try and get a definition for the call, this isn't always</span>
            <span class="s3"># possible as it might be a eval(str)/part generated</span>
            <span class="s3"># awaiting update etc. (parfors)</span>
            <span class="s1">to_inline </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">to_inline </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">get_definition</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
                <span class="s0">return None</span>

            <span class="s3"># do not handle closure inlining here, another pass deals with that</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">to_inline</span><span class="s2">, </span><span class="s4">'op'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) == </span><span class="s4">'make_function'</span><span class="s2">:</span>
                <span class="s0">return None</span>

        <span class="s1">func_ty </span><span class="s2">= </span><span class="s1">get_func_type</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">func_ty </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return None</span>

        <span class="s1">sig </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">[</span><span class="s1">expr</span><span class="s2">]</span>
        <span class="s0">if not </span><span class="s1">sig</span><span class="s2">:</span>
            <span class="s0">return None</span>

        <span class="s1">templates</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">is_method </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">func_ty</span><span class="s2">, </span><span class="s4">'template'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s3"># @overload_method</span>
            <span class="s1">is_method </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">templates </span><span class="s2">= [</span><span class="s1">func_ty</span><span class="s2">.</span><span class="s1">template</span><span class="s2">]</span>
            <span class="s1">arg_typs </span><span class="s2">= (</span><span class="s1">func_ty</span><span class="s2">.</span><span class="s1">template</span><span class="s2">.</span><span class="s1">this</span><span class="s2">,) + </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># @overload case</span>
            <span class="s1">templates </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">func_ty</span><span class="s2">, </span><span class="s4">'templates'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">arg_typs </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>

        <span class="s0">return </span><span class="s1">templates</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">is_method</span>

    <span class="s0">def </span><span class="s1">_do_work_expr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">work_list</span><span class="s2">, </span><span class="s1">block</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">inline_worker</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">select_template</span><span class="s2">(</span><span class="s1">templates</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">templates </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return None</span>

            <span class="s1">impl </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">template </span><span class="s0">in </span><span class="s1">templates</span><span class="s2">:</span>
                <span class="s1">inline_type </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">template</span><span class="s2">, </span><span class="s4">'_inline'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">inline_type </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s3"># inline not defined</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">args </span><span class="s0">not in </span><span class="s1">template</span><span class="s2">.</span><span class="s1">_inline_overloads</span><span class="s2">:</span>
                    <span class="s3"># skip overloads not matching signature</span>
                    <span class="s0">continue</span>
                <span class="s0">if not </span><span class="s1">inline_type</span><span class="s2">.</span><span class="s1">is_never_inline</span><span class="s2">:</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">impl </span><span class="s2">= </span><span class="s1">template</span><span class="s2">.</span><span class="s1">_overload_func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">impl </span><span class="s0">is None</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">Exception  </span><span class="s3"># abort for this template</span>
                        <span class="s0">break</span>
                    <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
                        <span class="s0">continue</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return None</span>

            <span class="s0">return </span><span class="s1">template</span><span class="s2">, </span><span class="s1">inline_type</span><span class="s2">, </span><span class="s1">impl</span>

        <span class="s1">inlinee_info </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">'getattr'</span><span class="s2">:</span>
            <span class="s1">inlinee_info </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_attr_info</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">inlinee_info </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_callable_info</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">inlinee_info</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s1">templates</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">is_method </span><span class="s2">= </span><span class="s1">inlinee_info</span>
        <span class="s1">inlinee </span><span class="s2">= </span><span class="s1">select_template</span><span class="s2">(</span><span class="s1">templates</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">inlinee </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s1">template</span><span class="s2">, </span><span class="s1">inlinee_type</span><span class="s2">, </span><span class="s1">impl </span><span class="s2">= </span><span class="s1">inlinee</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_run_inliner</span><span class="s2">(</span>
            <span class="s1">state</span><span class="s2">, </span><span class="s1">inlinee_type</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">template</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">block</span><span class="s2">,</span>
            <span class="s1">work_list</span><span class="s2">, </span><span class="s1">is_method</span><span class="s2">, </span><span class="s1">inline_worker</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_run_inliner</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">inline_type</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">template</span><span class="s2">, </span><span class="s1">arg_typs</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">block</span><span class="s2">,</span>
        <span class="s1">work_list</span><span class="s2">, </span><span class="s1">is_method</span><span class="s2">, </span><span class="s1">inline_worker</span><span class="s2">,</span>
    <span class="s2">):</span>

        <span class="s1">do_inline </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if not </span><span class="s1">inline_type</span><span class="s2">.</span><span class="s1">is_always_inline</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">templates </span><span class="s0">import </span><span class="s1">_inline_info</span>
            <span class="s1">caller_inline_info </span><span class="s2">= </span><span class="s1">_inline_info</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                              <span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">,</span>
                                              <span class="s1">state</span><span class="s2">.</span><span class="s1">calltypes</span><span class="s2">,</span>
                                              <span class="s1">sig</span><span class="s2">)</span>

            <span class="s3"># must be a cost-model function, run the function</span>
            <span class="s1">iinfo </span><span class="s2">= </span><span class="s1">template</span><span class="s2">.</span><span class="s1">_inline_overloads</span><span class="s2">[</span><span class="s1">arg_typs</span><span class="s2">][</span><span class="s4">'iinfo'</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">inline_type</span><span class="s2">.</span><span class="s1">has_cost_model</span><span class="s2">:</span>
                <span class="s1">do_inline </span><span class="s2">= </span><span class="s1">inline_type</span><span class="s2">.</span><span class="s1">value</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">caller_inline_info</span><span class="s2">, </span><span class="s1">iinfo</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s4">'unreachable'</span>

        <span class="s0">if </span><span class="s1">do_inline</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">is_method</span><span class="s2">:</span>
                <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_add_method_self_arg</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>
                    <span class="s0">return False</span>
            <span class="s1">arg_typs </span><span class="s2">= </span><span class="s1">template</span><span class="s2">.</span><span class="s1">_inline_overloads</span><span class="s2">[</span><span class="s1">arg_typs</span><span class="s2">][</span><span class="s4">'folded_args'</span><span class="s2">]</span>
            <span class="s1">iinfo </span><span class="s2">= </span><span class="s1">template</span><span class="s2">.</span><span class="s1">_inline_overloads</span><span class="s2">[</span><span class="s1">arg_typs</span><span class="s2">][</span><span class="s4">'iinfo'</span><span class="s2">]</span>
            <span class="s1">freevars </span><span class="s2">= </span><span class="s1">iinfo</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_freevars</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">new_blocks </span><span class="s2">= </span><span class="s1">inline_worker</span><span class="s2">.</span><span class="s1">inline_ir</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                                          <span class="s1">block</span><span class="s2">,</span>
                                                          <span class="s1">i</span><span class="s2">,</span>
                                                          <span class="s1">iinfo</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">,</span>
                                                          <span class="s1">freevars</span><span class="s2">,</span>
                                                          <span class="s1">arg_typs</span><span class="s2">=</span><span class="s1">arg_typs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">work_list </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">new_blocks</span><span class="s2">:</span>
                    <span class="s1">work_list</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)</span>
            <span class="s0">return True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_add_method_self_arg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">):</span>
        <span class="s1">func_def </span><span class="s2">= </span><span class="s1">guard</span><span class="s2">(</span><span class="s1">get_definition</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">func_def </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s1">expr</span><span class="s2">.</span><span class="s1">args</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">func_def</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">DeadCodeElimination</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Does dead code elimination 
    &quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;dead_code_elimination&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">dead_code_elimination</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">)</span>
        <span class="s0">return True</span>


<span class="s2">@</span><span class="s1">register_pass</span><span class="s2">(</span><span class="s1">mutates_CFG</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">analysis_only</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">PreLowerStripPhis</span><span class="s2">(</span><span class="s1">FunctionPass</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Remove phi nodes (ir.Expr.phi) introduced by SSA. 
 
    This is needed before Lowering because the phi nodes in Numba IR do not 
    match the semantics of phi nodes in LLVM IR. In Numba IR, phi nodes may 
    expand into multiple LLVM instructions. 
    &quot;&quot;&quot;</span>

    <span class="s1">_name </span><span class="s2">= </span><span class="s4">&quot;strip_phis&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">FunctionPass</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_pass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_strip_phi_nodes</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s4">&quot;flags&quot; </span><span class="s0">in </span><span class="s1">state </span><span class="s0">and </span><span class="s1">state</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">auto_parallel</span><span class="s2">.</span><span class="s1">enabled</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_simplify_conditionally_defined_variable</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

        <span class="s3"># Rerun postprocessor to update metadata</span>
        <span class="s1">post_proc </span><span class="s2">= </span><span class="s1">postproc</span><span class="s2">.</span><span class="s1">PostProcessor</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">)</span>
        <span class="s1">post_proc</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">emit_dels</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s3"># Ensure we are not in objectmode generator</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">generator_info </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap </span><span class="s0">is not None</span><span class="s2">):</span>
            <span class="s3"># Rebuild generator type</span>
            <span class="s3"># TODO: move this into PostProcessor</span>
            <span class="s1">gentype </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">return_type</span>
            <span class="s1">state_vars </span><span class="s2">= </span><span class="s1">state</span><span class="s2">.</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">generator_info</span><span class="s2">.</span><span class="s1">state_vars</span>
            <span class="s1">state_types </span><span class="s2">= [</span><span class="s1">state</span><span class="s2">.</span><span class="s1">typemap</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">state_vars</span><span class="s2">]</span>
            <span class="s1">state</span><span class="s2">.</span><span class="s1">return_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">(</span>
                <span class="s1">gen_func</span><span class="s2">=</span><span class="s1">gentype</span><span class="s2">.</span><span class="s1">gen_func</span><span class="s2">,</span>
                <span class="s1">yield_type</span><span class="s2">=</span><span class="s1">gentype</span><span class="s2">.</span><span class="s1">yield_type</span><span class="s2">,</span>
                <span class="s1">arg_types</span><span class="s2">=</span><span class="s1">gentype</span><span class="s2">.</span><span class="s1">arg_types</span><span class="s2">,</span>
                <span class="s1">state_types</span><span class="s2">=</span><span class="s1">state_types</span><span class="s2">,</span>
                <span class="s1">has_finalizer</span><span class="s2">=</span><span class="s1">gentype</span><span class="s2">.</span><span class="s1">has_finalizer</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_strip_phi_nodes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Strip Phi nodes from ``func_ir`` 
 
        For each phi node, put incoming value to their respective incoming 
        basic-block at possibly the latest position (i.e. after the latest 
        assignment to the corresponding variable). 
        &quot;&quot;&quot;</span>
        <span class="s1">exporters </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)</span>
        <span class="s1">phis </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s3"># Find all variables that needs to be exported</span>
        <span class="s0">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">assign </span><span class="s0">in </span><span class="s1">block</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">'phi'</span><span class="s2">:</span>
                        <span class="s1">phis</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">)</span>
                        <span class="s1">phi </span><span class="s2">= </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">value</span>
                        <span class="s0">for </span><span class="s1">ib</span><span class="s2">, </span><span class="s1">iv </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">phi</span><span class="s2">.</span><span class="s1">incoming_blocks</span><span class="s2">,</span>
                                          <span class="s1">phi</span><span class="s2">.</span><span class="s1">incoming_values</span><span class="s2">):</span>
                            <span class="s1">exporters</span><span class="s2">[</span><span class="s1">ib</span><span class="s2">].</span><span class="s1">append</span><span class="s2">((</span><span class="s1">assign</span><span class="s2">.</span><span class="s1">target</span><span class="s2">, </span><span class="s1">iv</span><span class="s2">))</span>

        <span class="s3"># Rewrite the blocks with the new exporting assignments</span>
        <span class="s1">newblocks </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">newblk </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">block</span><span class="s2">)</span>
            <span class="s1">newblocks</span><span class="s2">[</span><span class="s1">label</span><span class="s2">] = </span><span class="s1">newblk</span>

            <span class="s3"># strip phis</span>
            <span class="s1">newblk</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= [</span><span class="s1">stmt </span><span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">block</span><span class="s2">.</span><span class="s1">body </span><span class="s0">if </span><span class="s1">stmt </span><span class="s0">not in </span><span class="s1">phis</span><span class="s2">]</span>

            <span class="s3"># insert exporters</span>
            <span class="s0">for </span><span class="s1">target</span><span class="s2">, </span><span class="s1">rhs </span><span class="s0">in </span><span class="s1">exporters</span><span class="s2">[</span><span class="s1">label</span><span class="s2">]:</span>
                <span class="s3"># If RHS is undefined</span>
                <span class="s0">if </span><span class="s1">rhs </span><span class="s0">is </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">UNDEFINED</span><span class="s2">:</span>
                    <span class="s3"># Put in a NULL initializer, set the location to be in what</span>
                    <span class="s3"># will eventually materialize as the prologue.</span>
                    <span class="s1">rhs </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">null</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">=</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">loc</span><span class="s2">)</span>

                <span class="s1">assign </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span>
                    <span class="s1">target</span><span class="s2">=</span><span class="s1">target</span><span class="s2">,</span>
                    <span class="s1">value</span><span class="s2">=</span><span class="s1">rhs</span><span class="s2">,</span>
                    <span class="s1">loc</span><span class="s2">=</span><span class="s1">rhs</span><span class="s2">.</span><span class="s1">loc</span>
                <span class="s2">)</span>
                <span class="s3"># Insert at the earliest possible location; i.e. after the</span>
                <span class="s3"># last assignment to rhs</span>
                <span class="s1">assignments </span><span class="s2">= [</span><span class="s1">stmt </span><span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">newblk</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">)</span>
                               <span class="s0">if </span><span class="s1">stmt</span><span class="s2">.</span><span class="s1">target </span><span class="s2">== </span><span class="s1">rhs</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">assignments</span><span class="s2">:</span>
                    <span class="s1">last_assignment </span><span class="s2">= </span><span class="s1">assignments</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                    <span class="s1">newblk</span><span class="s2">.</span><span class="s1">insert_after</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">, </span><span class="s1">last_assignment</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">newblk</span><span class="s2">.</span><span class="s1">prepend</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">)</span>

        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">newblocks</span>
        <span class="s0">return </span><span class="s1">func_ir</span>

    <span class="s0">def </span><span class="s1">_simplify_conditionally_defined_variable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Rewrite assignments like: 
 
            ver1 = null() 
            ... 
            ver1 = ver 
            ... 
            uses(ver1) 
 
        into: 
            # delete all assignments to ver1 
            uses(ver) 
 
        This is only needed for parfors because the SSA pass will create extra 
        variable assignments that the parfor code does not expect. 
        This pass helps avoid problems by reverting the effect of SSA. 
        &quot;&quot;&quot;</span>
        <span class="s1">any_block </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()))</span>
        <span class="s1">scope </span><span class="s2">= </span><span class="s1">any_block</span><span class="s2">.</span><span class="s1">scope</span>
        <span class="s1">defs </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions</span>

        <span class="s0">def </span><span class="s1">unver_or_undef</span><span class="s2">(</span><span class="s1">unver</span><span class="s2">, </span><span class="s1">defn</span><span class="s2">):</span>
            <span class="s3"># Is the definition undefined or pointing to the unversioned name?</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">defn</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Var</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">defn</span><span class="s2">.</span><span class="s1">unversioned_name </span><span class="s2">== </span><span class="s1">unver</span><span class="s2">:</span>
                    <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">defn</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">defn</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s4">&quot;null&quot;</span><span class="s2">:</span>
                    <span class="s0">return True</span>
            <span class="s0">return False</span>

        <span class="s0">def </span><span class="s1">legalize_all_versioned_names</span><span class="s2">(</span><span class="s1">var</span><span class="s2">):</span>
            <span class="s3"># Are all versioned names undefined or defined to the same</span>
            <span class="s3"># variable chain?</span>
            <span class="s0">if not </span><span class="s1">var</span><span class="s2">.</span><span class="s1">versioned_names</span><span class="s2">:</span>
                <span class="s0">return False</span>
            <span class="s0">for </span><span class="s1">versioned </span><span class="s0">in </span><span class="s1">var</span><span class="s2">.</span><span class="s1">versioned_names</span><span class="s2">:</span>
                <span class="s1">vs </span><span class="s2">= </span><span class="s1">defs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">versioned</span><span class="s2">, ())</span>
                <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">unver_or_undef</span><span class="s2">, </span><span class="s1">k</span><span class="s2">), </span><span class="s1">vs</span><span class="s2">)):</span>
                    <span class="s0">return False</span>
            <span class="s0">return True</span>

        <span class="s3"># Find unversioned variables that met the conditions</span>
        <span class="s1">suspects </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">defs</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s3"># This may fail?</span>
                <span class="s1">var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">get_exact</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NotDefinedError</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s3"># is the var name unversioned?</span>
            <span class="s0">if </span><span class="s1">var</span><span class="s2">.</span><span class="s1">unversioned_name </span><span class="s2">== </span><span class="s1">k</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">legalize_all_versioned_names</span><span class="s2">(</span><span class="s1">var</span><span class="s2">):</span>
                    <span class="s1">suspects</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">var</span><span class="s2">)</span>

        <span class="s1">delete_set </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">replace_map </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">suspects</span><span class="s2">:</span>
            <span class="s3"># rewrite Var uses to the unversioned name</span>
            <span class="s0">for </span><span class="s1">versioned </span><span class="s0">in </span><span class="s1">var</span><span class="s2">.</span><span class="s1">versioned_names</span><span class="s2">:</span>
                <span class="s1">ver_var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">get_exact</span><span class="s2">(</span><span class="s1">versioned</span><span class="s2">)</span>
                <span class="s3"># delete assignment to the versioned name</span>
                <span class="s1">delete_set</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">ver_var</span><span class="s2">)</span>
                <span class="s3"># replace references to versioned name with the unversioned</span>
                <span class="s1">replace_map</span><span class="s2">[</span><span class="s1">versioned</span><span class="s2">] = </span><span class="s1">var</span>

        <span class="s3"># remove assignments to the versioned names</span>
        <span class="s0">for </span><span class="s1">_label</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">for </span><span class="s1">assign </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">find_insts</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">assign</span><span class="s2">.</span><span class="s1">target </span><span class="s0">in </span><span class="s1">delete_set</span><span class="s2">:</span>
                    <span class="s1">blk</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">assign</span><span class="s2">)</span>
        <span class="s3"># do variable replacement</span>
        <span class="s1">replace_vars</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">replace_map</span><span class="s2">)</span>
</pre>
</body>
</html>