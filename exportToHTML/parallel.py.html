<html>
<head>
<title>parallel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parallel.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file implements the code-generator for parallel-vectorize. 
 
ParallelUFunc is the platform independent base class for generating 
the thread dispatcher.  This thread dispatcher launches threads 
that execute the generated function of UFuncCore. 
UFuncCore is subclassed to specialize for the input/output types. 
The actual workload is invoked inside the function generated by UFuncCore. 
UFuncCore also defines a work-stealing mechanism that allows idle threads 
to steal works from other threads. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">threading </span><span class="s2">import </span><span class="s1">RLock </span><span class="s2">as </span><span class="s1">threadRLock</span>
<span class="s2">from </span><span class="s1">ctypes </span><span class="s2">import </span><span class="s1">CFUNCTYPE</span><span class="s3">, </span><span class="s1">c_int</span><span class="s3">, </span><span class="s1">CDLL</span><span class="s3">, </span><span class="s1">POINTER</span><span class="s3">, </span><span class="s1">c_uint</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">llvmlite</span><span class="s3">.</span><span class="s1">binding </span><span class="s2">as </span><span class="s1">ll</span>
<span class="s2">from </span><span class="s1">llvmlite </span><span class="s2">import </span><span class="s1">ir</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s1">as_dtype</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">errors</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">wrappers </span><span class="s2">import </span><span class="s1">_wrapper_info</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc </span><span class="s2">import </span><span class="s1">ufuncbuilder</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">overload</span><span class="s3">, </span><span class="s1">intrinsic</span>

<span class="s1">_IS_OSX </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'darwin'</span><span class="s3">)</span>
<span class="s1">_IS_LINUX </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'linux'</span><span class="s3">)</span>
<span class="s1">_IS_WINDOWS </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'win32'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_thread_count</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Gets the available thread count. 
    &quot;&quot;&quot;</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Number of threads specified must be &gt; 0.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">t</span>


<span class="s1">NUM_THREADS </span><span class="s3">= </span><span class="s1">get_thread_count</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">build_gufunc_kernel</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">info</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">inner_ndim</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Wrap the original CPU ufunc/gufunc with a parallel dispatcher. 
    This function will wrap gufuncs and ufuncs something like. 
 
    Args 
    ---- 
    ctx 
        numba's codegen context 
 
    info: (library, env, name) 
        inner function info 
 
    sig 
        type signature of the gufunc 
 
    inner_ndim 
        inner dimension of the gufunc (this is len(sig.args) in the case of a 
        ufunc) 
 
    Returns 
    ------- 
    wrapper_info : (library, env, name) 
        The info for the gufunc wrapper. 
 
    Details 
    ------- 
 
    The kernel signature looks like this: 
 
    void kernel(char **args, npy_intp *dimensions, npy_intp* steps, void* data) 
 
    args - the input arrays + output arrays 
    dimensions - the dimensions of the arrays 
    steps - the step size for the array (this is like sizeof(type)) 
    data - any additional data 
 
    The parallel backend then stages multiple calls to this kernel concurrently 
    across a number of threads. Practically, for each item of work, the backend 
    duplicates `dimensions` and adjusts the first entry to reflect the size of 
    the item of work, it also forms up an array of pointers into the args for 
    offsets to read/write from/to with respect to its position in the items of 
    work. This allows the same kernel to be used for each item of work, with 
    simply adjusted reads/writes/domain sizes and is safe by virtue of the 
    domain partitioning. 
 
    NOTE: The execution backend is passed the requested thread count, but it can 
    choose to ignore it (TBB)! 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">info</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)  </span><span class="s6"># guard against old usage</span>
    <span class="s6"># Declare types and function</span>
    <span class="s1">byte_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)</span>
    <span class="s1">byte_ptr_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">byte_t</span><span class="s3">)</span>
    <span class="s1">byte_ptr_ptr_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">byte_ptr_t</span><span class="s3">)</span>

    <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">intp_ptr_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">)</span>

    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">(), [</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">byte_ptr_t</span><span class="s3">),</span>
                                           <span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">),</span>
                                           <span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">),</span>
                                           <span class="s1">byte_ptr_t</span><span class="s3">])</span>
    <span class="s1">wrapperlib </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">codegen</span><span class="s3">().</span><span class="s1">create_library</span><span class="s3">(</span><span class="s4">'parallelgufuncwrapper'</span><span class="s3">)</span>
    <span class="s1">mod </span><span class="s3">= </span><span class="s1">wrapperlib</span><span class="s3">.</span><span class="s1">create_ir_module</span><span class="s3">(</span><span class="s4">'parallel.gufunc.wrapper'</span><span class="s3">)</span>
    <span class="s1">kernel_name </span><span class="s3">= </span><span class="s4">&quot;.kernel.{}_{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">env</span><span class="s3">), </span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">lfunc </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">kernel_name</span><span class="s3">)</span>

    <span class="s1">bb_entry </span><span class="s3">= </span><span class="s1">lfunc</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>

    <span class="s6"># Function body starts</span>
    <span class="s1">builder </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IRBuilder</span><span class="s3">(</span><span class="s1">bb_entry</span><span class="s3">)</span>

    <span class="s1">args</span><span class="s3">, </span><span class="s1">dimensions</span><span class="s3">, </span><span class="s1">steps</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= </span><span class="s1">lfunc</span><span class="s3">.</span><span class="s1">args</span>

    <span class="s6"># Release the GIL (and ensure we have the GIL)</span>
    <span class="s6"># Note: numpy ufunc may not always release the GIL; thus,</span>
    <span class="s6">#       we need to ensure we have the GIL.</span>
    <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">gil_state </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">gil_ensure</span><span class="s3">()</span>
    <span class="s1">thread_state </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">save_thread</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">as_void_ptr</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">byte_ptr_t</span><span class="s3">)</span>

    <span class="s6"># Array count depends on whether an &quot;output&quot; array is needed. In the case</span>
    <span class="s6"># of a void return type cf. gufunc it is the number of args, in the case of</span>
    <span class="s6"># a non-void return type cf. ufunc it is the number of args + 1 so as to</span>
    <span class="s6"># account for the output array.</span>
    <span class="s1">array_count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
        <span class="s1">array_count </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s1">parallel_for_ty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">(),</span>
                                      <span class="s3">[</span><span class="s1">byte_ptr_t</span><span class="s3">] * </span><span class="s5">5 </span><span class="s3">+ [</span><span class="s1">intp_t</span><span class="s3">, ] * </span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">parallel_for </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">parallel_for_ty</span><span class="s3">,</span>
                                                  <span class="s4">'numba_parallel_for'</span><span class="s3">)</span>

    <span class="s6"># Reference inner-function and link</span>
    <span class="s1">innerfunc_fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span>
        <span class="s1">ir</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">(),</span>
        <span class="s3">[</span><span class="s1">byte_ptr_ptr_t</span><span class="s3">, </span><span class="s1">intp_ptr_t</span><span class="s3">, </span><span class="s1">intp_ptr_t</span><span class="s3">, </span><span class="s1">byte_ptr_t</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s1">tmp_voidptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">innerfunc_fnty</span><span class="s3">,</span>
                                                 <span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,)</span>
    <span class="s1">wrapperlib</span><span class="s3">.</span><span class="s1">add_linking_library</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">library</span><span class="s3">)</span>

    <span class="s1">get_num_threads </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">,</span>
        <span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">.</span><span class="s1">bitwidth</span><span class="s3">), []),</span>
        <span class="s4">&quot;get_num_threads&quot;</span><span class="s3">)</span>

    <span class="s1">num_threads </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">get_num_threads</span><span class="s3">, [])</span>

    <span class="s6"># Prepare call</span>
    <span class="s1">fnptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">tmp_voidptr</span><span class="s3">, </span><span class="s1">byte_ptr_t</span><span class="s3">)</span>
    <span class="s1">innerargs </span><span class="s3">= [</span><span class="s1">as_void_ptr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x</span>
                 <span class="s2">in </span><span class="s3">[</span><span class="s1">args</span><span class="s3">, </span><span class="s1">dimensions</span><span class="s3">, </span><span class="s1">steps</span><span class="s3">, </span><span class="s1">data</span><span class="s3">]]</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">parallel_for</span><span class="s3">, [</span><span class="s1">fnptr</span><span class="s3">] + </span><span class="s1">innerargs </span><span class="s3">+</span>
                 <span class="s3">[</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s1">inner_ndim</span><span class="s3">, </span><span class="s1">array_count</span><span class="s3">)] + [</span><span class="s1">num_threads</span><span class="s3">])</span>

    <span class="s6"># Release the GIL</span>
    <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">restore_thread</span><span class="s3">(</span><span class="s1">thread_state</span><span class="s3">)</span>
    <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">gil_release</span><span class="s3">(</span><span class="s1">gil_state</span><span class="s3">)</span>

    <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret_void</span><span class="s3">()</span>

    <span class="s1">wrapperlib</span><span class="s3">.</span><span class="s1">add_ir_module</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">)</span>
    <span class="s1">wrapperlib</span><span class="s3">.</span><span class="s1">add_linking_library</span><span class="s3">(</span><span class="s1">library</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_wrapper_info</span><span class="s3">(</span><span class="s1">library</span><span class="s3">=</span><span class="s1">wrapperlib</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">lfunc</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">env</span><span class="s3">=</span><span class="s1">info</span><span class="s3">.</span><span class="s1">env</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">ParallelUFuncBuilder</span><span class="s3">(</span><span class="s1">ufuncbuilder</span><span class="s3">.</span><span class="s1">UFuncBuilder</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">build</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s1">_launch_threads</span><span class="s3">()</span>

        <span class="s6"># Builder wrapper for ufunc entry point</span>
        <span class="s1">ctx </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">target_context</span>
        <span class="s1">signature </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">signature</span>
        <span class="s1">library </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span>
        <span class="s1">fname </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">llvm_func_name</span>

        <span class="s1">info </span><span class="s3">= </span><span class="s1">build_ufunc_wrapper</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">)</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_pointer_to_function</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s6"># Get dtypes</span>
        <span class="s1">dtypenums </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">).</span><span class="s1">num </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">signature</span><span class="s3">.</span><span class="s1">args</span><span class="s3">]</span>
        <span class="s1">dtypenums</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">signature</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">name</span><span class="s3">).</span><span class="s1">num</span><span class="s3">)</span>
        <span class="s1">keepalive </span><span class="s3">= ()</span>
        <span class="s2">return </span><span class="s1">dtypenums</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">keepalive</span>


<span class="s2">def </span><span class="s1">build_ufunc_wrapper</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">):</span>
    <span class="s1">innerfunc </span><span class="s3">= </span><span class="s1">ufuncbuilder</span><span class="s3">.</span><span class="s1">build_ufunc_wrapper</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">,</span>
                                                 <span class="s1">signature</span><span class="s3">, </span><span class="s1">objmode</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                                 <span class="s1">cres</span><span class="s3">=</span><span class="s1">cres</span><span class="s3">)</span>
    <span class="s1">info </span><span class="s3">= </span><span class="s1">build_gufunc_kernel</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">innerfunc</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">,</span>
                               <span class="s1">len</span><span class="s3">(</span><span class="s1">signature</span><span class="s3">.</span><span class="s1">args</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">info</span>

<span class="s6"># ---------------------------------------------------------------------------</span>


<span class="s2">class </span><span class="s1">ParallelGUFuncBuilder</span><span class="s3">(</span><span class="s1">ufuncbuilder</span><span class="s3">.</span><span class="s1">GUFuncBuilder</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">py_func</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                 <span class="s1">targetoptions</span><span class="s3">={}, </span><span class="s1">writable_args</span><span class="s3">=()):</span>
        <span class="s6"># Force nopython mode</span>
        <span class="s1">targetoptions</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">nopython</span><span class="s3">=</span><span class="s2">True</span><span class="s3">))</span>
        <span class="s1">super</span><span class="s3">(</span>
            <span class="s1">ParallelGUFuncBuilder</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(</span>
            <span class="s1">py_func</span><span class="s3">=</span><span class="s1">py_func</span><span class="s3">,</span>
            <span class="s1">signature</span><span class="s3">=</span><span class="s1">signature</span><span class="s3">,</span>
            <span class="s1">identity</span><span class="s3">=</span><span class="s1">identity</span><span class="s3">,</span>
            <span class="s1">cache</span><span class="s3">=</span><span class="s1">cache</span><span class="s3">,</span>
            <span class="s1">targetoptions</span><span class="s3">=</span><span class="s1">targetoptions</span><span class="s3">,</span>
            <span class="s1">writable_args</span><span class="s3">=</span><span class="s1">writable_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns (dtype numbers, function ptr, EnvironmentObject) 
        &quot;&quot;&quot;</span>
        <span class="s1">_launch_threads</span><span class="s3">()</span>

        <span class="s6"># Build wrapper for ufunc entry point</span>
        <span class="s1">info </span><span class="s3">= </span><span class="s1">build_gufunc_wrapper</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sout</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">,</span>
            <span class="s1">is_parfors</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_pointer_to_function</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">env </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">env</span>

        <span class="s6"># Get dtypes</span>
        <span class="s1">dtypenums </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                <span class="s1">ty </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ty </span><span class="s3">= </span><span class="s1">a</span>
            <span class="s1">dtypenums</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">).</span><span class="s1">num</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">dtypenums</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">env</span>


<span class="s6"># This is not a member of the ParallelGUFuncBuilder function because it is</span>
<span class="s6"># called without an enclosing instance from parfors</span>

<span class="s2">def </span><span class="s1">build_gufunc_wrapper</span><span class="s3">(</span><span class="s1">py_func</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">, </span><span class="s1">is_parfors</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Build gufunc wrapper for the given arguments. 
    The *is_parfors* is a boolean indicating whether the gufunc is being 
    built for use as a ParFors kernel. This changes codegen and caching 
    behavior. 
    &quot;&quot;&quot;</span>
    <span class="s1">library </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span>
    <span class="s1">ctx </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">target_context</span>
    <span class="s1">signature </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">signature</span>
    <span class="s1">innerinfo </span><span class="s3">= </span><span class="s1">ufuncbuilder</span><span class="s3">.</span><span class="s1">build_gufunc_wrapper</span><span class="s3">(</span>
        <span class="s1">py_func</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s1">cache</span><span class="s3">, </span><span class="s1">is_parfors</span><span class="s3">=</span><span class="s1">is_parfors</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">sym_in </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">sym </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">sin </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">term</span><span class="s3">)</span>
    <span class="s1">sym_out </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">sym </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">sout </span><span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">term</span><span class="s3">)</span>
    <span class="s1">inner_ndim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sym_in </span><span class="s3">| </span><span class="s1">sym_out</span><span class="s3">)</span>

    <span class="s1">info </span><span class="s3">= </span><span class="s1">build_gufunc_kernel</span><span class="s3">(</span>
        <span class="s1">library</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">innerinfo</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">inner_ndim</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">info</span>

<span class="s6"># ---------------------------------------------------------------------------</span>


<span class="s1">_backend_init_thread_lock </span><span class="s3">= </span><span class="s1">threadRLock</span><span class="s3">()</span>

<span class="s1">_windows </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'win32'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_nop</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A no-op contextmanager 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__enter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">__exit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s1">_backend_init_process_lock </span><span class="s3">= </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_set_init_process_lock</span><span class="s3">():</span>
    <span class="s2">global </span><span class="s1">_backend_init_process_lock</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s6"># Force the use of an RLock in the case a fork was used to start the</span>
        <span class="s6"># process and thereby the init sequence, some of the threading backend</span>
        <span class="s6"># init sequences are not fork safe. Also, windows global mp locks seem</span>
        <span class="s6"># to be fine.</span>
        <span class="s2">with </span><span class="s1">_backend_init_thread_lock</span><span class="s3">: </span><span class="s6"># protect part-initialized module access</span>
            <span class="s2">import </span><span class="s1">multiprocessing</span>
            <span class="s2">if </span><span class="s4">&quot;fork&quot; </span><span class="s2">in </span><span class="s1">multiprocessing</span><span class="s3">.</span><span class="s1">get_start_method</span><span class="s3">() </span><span class="s2">or </span><span class="s1">_windows</span><span class="s3">:</span>
                <span class="s1">ctx </span><span class="s3">= </span><span class="s1">multiprocessing</span><span class="s3">.</span><span class="s1">get_context</span><span class="s3">()</span>
                <span class="s1">_backend_init_process_lock </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">RLock</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">_backend_init_process_lock </span><span class="s3">= </span><span class="s1">_nop</span><span class="s3">()</span>

    <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>

        <span class="s6"># probably lack of /dev/shm for semaphore writes, warn the user</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;Could not obtain multiprocessing lock due to OS level error: %s</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;A likely cause of this problem is '/dev/shm' is missing or &quot;</span>
            <span class="s4">&quot;read-only such that necessary semaphores cannot be written.</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;*** The responsibility of ensuring multiprocessing safe access to &quot;</span>
            <span class="s4">&quot;this initialization sequence/module import is deferred to the &quot;</span>
            <span class="s4">&quot;user! ***</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s3">)</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">), </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaSystemWarning</span><span class="s3">)</span>

        <span class="s1">_backend_init_process_lock </span><span class="s3">= </span><span class="s1">_nop</span><span class="s3">()</span>


<span class="s1">_is_initialized </span><span class="s3">= </span><span class="s2">False</span>

<span class="s6"># this is set by _launch_threads</span>
<span class="s1">_threading_layer </span><span class="s3">= </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">threading_layer</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the name of the threading layer in use for parallel CPU targets 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_threading_layer </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Threading layer is not initialized.&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_threading_layer</span>


<span class="s2">def </span><span class="s1">_check_tbb_version_compatible</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks that if TBB is present it is of a compatible version. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s6"># first check that the TBB version is new enough</span>
        <span class="s2">if </span><span class="s1">_IS_WINDOWS</span><span class="s3">:</span>
            <span class="s1">libtbb_name </span><span class="s3">= </span><span class="s4">'tbb12.dll'</span>
        <span class="s2">elif </span><span class="s1">_IS_OSX</span><span class="s3">:</span>
            <span class="s1">libtbb_name </span><span class="s3">= </span><span class="s4">'libtbb.12.dylib'</span>
        <span class="s2">elif </span><span class="s1">_IS_LINUX</span><span class="s3">:</span>
            <span class="s1">libtbb_name </span><span class="s3">= </span><span class="s4">'libtbb.so.12'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown operating system&quot;</span><span class="s3">)</span>
        <span class="s1">libtbb </span><span class="s3">= </span><span class="s1">CDLL</span><span class="s3">(</span><span class="s1">libtbb_name</span><span class="s3">)</span>
        <span class="s1">version_func </span><span class="s3">= </span><span class="s1">libtbb</span><span class="s3">.</span><span class="s1">TBB_runtime_interface_version</span>
        <span class="s1">version_func</span><span class="s3">.</span><span class="s1">argtypes </span><span class="s3">= []</span>
        <span class="s1">version_func</span><span class="s3">.</span><span class="s1">restype </span><span class="s3">= </span><span class="s1">c_int</span>
        <span class="s1">tbb_iface_ver </span><span class="s3">= </span><span class="s1">version_func</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">tbb_iface_ver </span><span class="s3">&lt; </span><span class="s5">12060</span><span class="s3">: </span><span class="s6"># magic number from TBB</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;The TBB threading layer requires TBB &quot;</span>
                   <span class="s4">&quot;version 2021 update 6 or later i.e., &quot;</span>
                   <span class="s4">&quot;TBB_INTERFACE_VERSION &gt;= 12060. Found &quot;</span>
                   <span class="s4">&quot;TBB_INTERFACE_VERSION = %s. The TBB &quot;</span>
                   <span class="s4">&quot;threading layer is disabled.&quot;</span><span class="s3">) % </span><span class="s1">tbb_iface_ver</span>
            <span class="s1">problem </span><span class="s3">= </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaWarning</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">problem</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s4">&quot;Problem with TBB. Reason: %s&quot; </span><span class="s3">% </span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">OSError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s6"># Translate as an ImportError for consistent error class use, this error</span>
        <span class="s6"># will never materialise</span>
        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s4">&quot;Problem with TBB. Reason: %s&quot; </span><span class="s3">% </span><span class="s1">e</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_launch_threads</span><span class="s3">():</span>
    <span class="s2">if not </span><span class="s1">_backend_init_process_lock</span><span class="s3">:</span>
        <span class="s1">_set_init_process_lock</span><span class="s3">()</span>

    <span class="s2">with </span><span class="s1">_backend_init_process_lock</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">_backend_init_thread_lock</span><span class="s3">:</span>
            <span class="s2">global </span><span class="s1">_is_initialized</span>
            <span class="s2">if </span><span class="s1">_is_initialized</span><span class="s3">:</span>
                <span class="s2">return</span>

            <span class="s2">def </span><span class="s1">select_known_backend</span><span class="s3">(</span><span class="s1">backend</span><span class="s3">):</span>
                <span class="s0">&quot;&quot;&quot; 
                Loads a specific threading layer backend based on string 
                &quot;&quot;&quot;</span>
                <span class="s1">lib </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">backend</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;tbb&quot;</span><span class="s3">):</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s6"># check if TBB is present and compatible</span>
                        <span class="s1">_check_tbb_version_compatible</span><span class="s3">()</span>
                        <span class="s6"># now try and load the backend</span>
                        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc </span><span class="s2">import </span><span class="s1">tbbpool </span><span class="s2">as </span><span class="s1">lib</span>
                    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
                        <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">backend</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;omp&quot;</span><span class="s3">):</span>
                    <span class="s6"># TODO: Check that if MKL is present that it is a version</span>
                    <span class="s6"># that understands GNU OMP might be present</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc </span><span class="s2">import </span><span class="s1">omppool </span><span class="s2">as </span><span class="s1">lib</span>
                    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
                        <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">backend</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;workqueue&quot;</span><span class="s3">):</span>
                    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc </span><span class="s2">import </span><span class="s1">workqueue </span><span class="s2">as </span><span class="s1">lib</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Unknown value specified for threading layer: %s&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">backend</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">lib</span>

            <span class="s2">def </span><span class="s1">select_from_backends</span><span class="s3">(</span><span class="s1">backends</span><span class="s3">):</span>
                <span class="s0">&quot;&quot;&quot; 
                Selects from presented backends and returns the first working 
                &quot;&quot;&quot;</span>
                <span class="s1">lib </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">for </span><span class="s1">backend </span><span class="s2">in </span><span class="s1">backends</span><span class="s3">:</span>
                    <span class="s1">lib </span><span class="s3">= </span><span class="s1">select_known_backend</span><span class="s3">(</span><span class="s1">backend</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">lib </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">backend </span><span class="s3">= </span><span class="s4">''</span>
                <span class="s2">return </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">backend</span>

            <span class="s1">t </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">config</span><span class="s3">.</span><span class="s1">THREADING_LAYER</span><span class="s3">).</span><span class="s1">lower</span><span class="s3">()</span>
            <span class="s1">namedbackends </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">THREADING_LAYER_PRIORITY</span>
            <span class="s2">if not </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">namedbackends</span><span class="s3">) == </span><span class="s5">3 </span><span class="s2">and</span>
                    <span class="s1">set</span><span class="s3">(</span><span class="s1">namedbackends</span><span class="s3">) == {</span><span class="s4">'tbb'</span><span class="s3">, </span><span class="s4">'omp'</span><span class="s3">, </span><span class="s4">'workqueue'</span><span class="s3">}):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;THREADING_LAYER_PRIORITY invalid: %s. &quot;</span>
                    <span class="s4">&quot;It must be a permutation of &quot;</span>
                    <span class="s4">&quot;{'tbb', 'omp', 'workqueue'}&quot;</span>
                    <span class="s3">% </span><span class="s1">namedbackends</span>
                <span class="s3">)</span>

            <span class="s1">lib </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">err_helpers </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
            <span class="s1">err_helpers</span><span class="s3">[</span><span class="s4">'TBB'</span><span class="s3">] = (</span><span class="s4">&quot;Intel TBB is required, try:</span><span class="s2">\n</span><span class="s4">&quot;</span>
                                  <span class="s4">&quot;$ conda/pip install tbb&quot;</span><span class="s3">)</span>
            <span class="s1">err_helpers</span><span class="s3">[</span><span class="s4">'OSX_OMP'</span><span class="s3">] = (</span><span class="s4">&quot;Intel OpenMP is required, try:</span><span class="s2">\n</span><span class="s4">&quot;</span>
                                      <span class="s4">&quot;$ conda/pip install intel-openmp&quot;</span><span class="s3">)</span>
            <span class="s1">requirements </span><span class="s3">= []</span>

            <span class="s2">def </span><span class="s1">raise_with_hint</span><span class="s3">(</span><span class="s1">required</span><span class="s3">):</span>
                <span class="s1">errmsg </span><span class="s3">= </span><span class="s4">&quot;No threading layer could be loaded.</span><span class="s2">\n</span><span class="s4">%s&quot;</span>
                <span class="s1">hintmsg </span><span class="s3">= </span><span class="s4">&quot;HINT:</span><span class="s2">\n</span><span class="s4">%s&quot;</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">required</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">hint </span><span class="s3">= </span><span class="s4">''</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">required</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">hint </span><span class="s3">= </span><span class="s1">hintmsg </span><span class="s3">% </span><span class="s1">err_helpers</span><span class="s3">[</span><span class="s1">required</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">required</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">options </span><span class="s3">= </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">OR</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">err_helpers</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">required</span><span class="s3">])</span>
                    <span class="s1">hint </span><span class="s3">= </span><span class="s1">hintmsg </span><span class="s3">% (</span><span class="s4">&quot;One of:</span><span class="s2">\n</span><span class="s4">%s&quot; </span><span class="s3">% </span><span class="s1">options</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s1">hint</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">in </span><span class="s1">namedbackends</span><span class="s3">:</span>
                <span class="s6"># Try and load the specific named backend</span>
                <span class="s1">lib </span><span class="s3">= </span><span class="s1">select_known_backend</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">lib</span><span class="s3">:</span>
                    <span class="s6"># something is missing preventing a valid backend from</span>
                    <span class="s6"># loading, set requirements for hinting</span>
                    <span class="s2">if </span><span class="s1">t </span><span class="s3">== </span><span class="s4">'tbb'</span><span class="s3">:</span>
                        <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'TBB'</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">t </span><span class="s3">== </span><span class="s4">'omp' </span><span class="s2">and </span><span class="s1">_IS_OSX</span><span class="s3">:</span>
                        <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'OSX_OMP'</span><span class="s3">)</span>
                <span class="s1">libname </span><span class="s3">= </span><span class="s1">t</span>
            <span class="s2">elif </span><span class="s1">t </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'threadsafe'</span><span class="s3">, </span><span class="s4">'forksafe'</span><span class="s3">, </span><span class="s4">'safe'</span><span class="s3">]:</span>
                <span class="s6"># User wants a specific behaviour...</span>
                <span class="s1">available </span><span class="s3">= [</span><span class="s4">'tbb'</span><span class="s3">]</span>
                <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'TBB'</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s3">== </span><span class="s4">&quot;safe&quot;</span><span class="s3">:</span>
                    <span class="s6"># &quot;safe&quot; is TBB, which is fork and threadsafe everywhere</span>
                    <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">t </span><span class="s3">== </span><span class="s4">&quot;threadsafe&quot;</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">_IS_OSX</span><span class="s3">:</span>
                        <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'OSX_OMP'</span><span class="s3">)</span>
                    <span class="s6"># omp is threadsafe everywhere</span>
                    <span class="s1">available</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'omp'</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">t </span><span class="s3">== </span><span class="s4">&quot;forksafe&quot;</span><span class="s3">:</span>
                    <span class="s6"># everywhere apart from linux (GNU OpenMP) has a guaranteed</span>
                    <span class="s6"># forksafe OpenMP, as OpenMP has better performance, prefer</span>
                    <span class="s6"># this to workqueue</span>
                    <span class="s2">if not </span><span class="s1">_IS_LINUX</span><span class="s3">:</span>
                        <span class="s1">available</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'omp'</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">_IS_OSX</span><span class="s3">:</span>
                        <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'OSX_OMP'</span><span class="s3">)</span>
                    <span class="s6"># workqueue is forksafe everywhere</span>
                    <span class="s1">available</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'workqueue'</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:  </span><span class="s6"># unreachable</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;No threading layer available for purpose %s&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">t</span><span class="s3">)</span>
                <span class="s6"># select amongst available</span>
                <span class="s1">lib</span><span class="s3">, </span><span class="s1">libname </span><span class="s3">= </span><span class="s1">select_from_backends</span><span class="s3">(</span><span class="s1">available</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">t </span><span class="s3">== </span><span class="s4">'default'</span><span class="s3">:</span>
                <span class="s6"># If default is supplied, try them in order, tbb, omp,</span>
                <span class="s6"># workqueue</span>
                <span class="s1">lib</span><span class="s3">, </span><span class="s1">libname </span><span class="s3">= </span><span class="s1">select_from_backends</span><span class="s3">(</span><span class="s1">namedbackends</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">lib</span><span class="s3">:</span>
                    <span class="s6"># set requirements for hinting</span>
                    <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'TBB'</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">_IS_OSX</span><span class="s3">:</span>
                        <span class="s1">requirements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'OSX_OMP'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The threading layer requested '%s' is unknown to Numba.&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">t</span><span class="s3">)</span>

            <span class="s6"># No lib found, raise and hint</span>
            <span class="s2">if not </span><span class="s1">lib</span><span class="s3">:</span>
                <span class="s1">raise_with_hint</span><span class="s3">(</span><span class="s1">requirements</span><span class="s3">)</span>

            <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'numba_parallel_for'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">parallel_for</span><span class="s3">)</span>
            <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'do_scheduling_signed'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">do_scheduling_signed</span><span class="s3">)</span>
            <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'do_scheduling_unsigned'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">do_scheduling_unsigned</span><span class="s3">)</span>
            <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'allocate_sched'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">allocate_sched</span><span class="s3">)</span>
            <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'deallocate_sched'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">deallocate_sched</span><span class="s3">)</span>

            <span class="s1">launch_threads </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">c_int</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">launch_threads</span><span class="s3">)</span>
            <span class="s1">launch_threads</span><span class="s3">(</span><span class="s1">NUM_THREADS</span><span class="s3">)</span>

            <span class="s1">_load_threading_functions</span><span class="s3">(</span><span class="s1">lib</span><span class="s3">)  </span><span class="s6"># load late</span>

            <span class="s6"># set library name so it can be queried</span>
            <span class="s2">global </span><span class="s1">_threading_layer</span>
            <span class="s1">_threading_layer </span><span class="s3">= </span><span class="s1">libname</span>
            <span class="s1">_is_initialized </span><span class="s3">= </span><span class="s2">True</span>


<span class="s2">def </span><span class="s1">_load_threading_functions</span><span class="s3">(</span><span class="s1">lib</span><span class="s3">):</span>

    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'get_num_threads'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_num_threads</span><span class="s3">)</span>
    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'set_num_threads'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">set_num_threads</span><span class="s3">)</span>
    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'get_thread_id'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_thread_id</span><span class="s3">)</span>

    <span class="s2">global </span><span class="s1">_set_num_threads</span>
    <span class="s1">_set_num_threads </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">c_int</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">set_num_threads</span><span class="s3">)</span>
    <span class="s1">_set_num_threads</span><span class="s3">(</span><span class="s1">NUM_THREADS</span><span class="s3">)</span>

    <span class="s2">global </span><span class="s1">_get_num_threads</span>
    <span class="s1">_get_num_threads </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s1">c_int</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_num_threads</span><span class="s3">)</span>

    <span class="s2">global </span><span class="s1">_get_thread_id</span>
    <span class="s1">_get_thread_id </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s1">c_int</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_thread_id</span><span class="s3">)</span>

    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'set_parallel_chunksize'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">set_parallel_chunksize</span><span class="s3">)</span>
    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'get_parallel_chunksize'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_parallel_chunksize</span><span class="s3">)</span>
    <span class="s1">ll</span><span class="s3">.</span><span class="s1">add_symbol</span><span class="s3">(</span><span class="s4">'get_sched_size'</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_sched_size</span><span class="s3">)</span>
    <span class="s2">global </span><span class="s1">_set_parallel_chunksize</span>
    <span class="s1">_set_parallel_chunksize </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s1">c_uint</span><span class="s3">,</span>
                                        <span class="s1">c_uint</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">set_parallel_chunksize</span><span class="s3">)</span>
    <span class="s2">global </span><span class="s1">_get_parallel_chunksize</span>
    <span class="s1">_get_parallel_chunksize </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s1">c_uint</span><span class="s3">)(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_parallel_chunksize</span><span class="s3">)</span>
    <span class="s2">global </span><span class="s1">_get_sched_size</span>
    <span class="s1">_get_sched_size </span><span class="s3">= </span><span class="s1">CFUNCTYPE</span><span class="s3">(</span><span class="s1">c_uint</span><span class="s3">,</span>
                                <span class="s1">c_uint</span><span class="s3">,</span>
                                <span class="s1">c_uint</span><span class="s3">,</span>
                                <span class="s1">POINTER</span><span class="s3">(</span><span class="s1">c_int</span><span class="s3">),</span>
                                <span class="s1">POINTER</span><span class="s3">(</span><span class="s1">c_int</span><span class="s3">))(</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">get_sched_size</span><span class="s3">)</span>


<span class="s6"># Some helpers to make set_num_threads jittable</span>

<span class="s2">def </span><span class="s1">gen_snt_check</span><span class="s3">():</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">config </span><span class="s2">import </span><span class="s1">NUMBA_NUM_THREADS</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The number of threads must be between 1 and %s&quot; </span><span class="s3">% </span><span class="s1">NUMBA_NUM_THREADS</span>

    <span class="s2">def </span><span class="s1">snt_check</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s1">NUMBA_NUM_THREADS </span><span class="s2">or </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">snt_check</span>


<span class="s1">snt_check </span><span class="s3">= </span><span class="s1">gen_snt_check</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">snt_check</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_snt_check</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">snt_check</span>


<span class="s2">def </span><span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set the number of threads to use for parallel execution. 
 
    By default, all :obj:`numba.config.NUMBA_NUM_THREADS` threads are used. 
 
    This functionality works by masking out threads that are not used. 
    Therefore, the number of threads *n* must be less than or equal to 
    :obj:`~.NUMBA_NUM_THREADS`, the total number of threads that are launched. 
    See its documentation for more details. 
 
    This function can be used inside of a jitted function. 
 
    Parameters 
    ---------- 
    n: The number of threads. Must be between 1 and NUMBA_NUM_THREADS. 
 
    See Also 
    -------- 
    get_num_threads, numba.config.NUMBA_NUM_THREADS, 
    numba.config.NUMBA_DEFAULT_NUM_THREADS, :envvar:`NUMBA_NUM_THREADS` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;The number of threads specified must be an integer&quot;</span><span class="s3">)</span>
    <span class="s1">snt_check</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">_set_num_threads</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">set_num_threads</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_set_num_threads</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The number of threads specified must be an integer&quot;</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">snt_check</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">_set_num_threads</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">get_num_threads</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the number of threads used for parallel execution. 
 
    By default (if :func:`~.set_num_threads` is never called), all 
    :obj:`numba.config.NUMBA_NUM_THREADS` threads are used. 
 
    This number is less than or equal to the total number of threads that are 
    launched, :obj:`numba.config.NUMBA_NUM_THREADS`. 
 
    This function can be used inside of a jitted function. 
 
    Returns 
    ------- 
    The number of threads. 
 
    See Also 
    -------- 
    set_num_threads, numba.config.NUMBA_NUM_THREADS, 
    numba.config.NUMBA_DEFAULT_NUM_THREADS, :envvar:`NUMBA_NUM_THREADS` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s1">num_threads </span><span class="s3">= </span><span class="s1">_get_num_threads</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">num_threads </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;Invalid number of threads. &quot;</span>
                           <span class="s4">&quot;This likely indicates a bug in Numba. &quot;</span>
                           <span class="s4">&quot;(thread_id=%s, num_threads=%s)&quot; </span><span class="s3">%</span>
                           <span class="s3">(</span><span class="s1">get_thread_id</span><span class="s3">(), </span><span class="s1">num_threads</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">num_threads</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">get_num_threads</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_get_num_threads</span><span class="s3">():</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
        <span class="s1">num_threads </span><span class="s3">= </span><span class="s1">_get_num_threads</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">num_threads </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;Broken thread_id: &quot;</span><span class="s3">, </span><span class="s1">get_thread_id</span><span class="s3">())</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;num_threads: &quot;</span><span class="s3">, </span><span class="s1">num_threads</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;Invalid number of threads. &quot;</span>
                               <span class="s4">&quot;This likely indicates a bug in Numba.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">num_threads</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_iget_num_threads</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">):</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">mod </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, [])</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s4">&quot;get_num_threads&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [])</span>
    <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">), </span><span class="s1">codegen</span>


<span class="s2">def </span><span class="s1">get_thread_id</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a unique ID for each thread in the range 0 (inclusive) 
    to :func:`~.get_num_threads` (exclusive). 
    &quot;&quot;&quot;</span>
    <span class="s6"># Called from the interpreter directly, this should return 0</span>
    <span class="s6"># Called from a sequential JIT region, this should return 0</span>
    <span class="s6"># Called from a parallel JIT region, this should return 0..N</span>
    <span class="s6"># Called from objmode in a parallel JIT region, this should return 0..N</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">_get_thread_id</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">get_thread_id</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_get_thread_id</span><span class="s3">():</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
        <span class="s2">return </span><span class="s1">_iget_thread_id</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_iget_thread_id</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">mod </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, [])</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s4">&quot;get_thread_id&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [])</span>
    <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">), </span><span class="s1">codegen</span>


<span class="s1">_DYLD_WORKAROUND_SET </span><span class="s3">= </span><span class="s4">'NUMBA_DYLD_WORKAROUND' </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span>
<span class="s1">_DYLD_WORKAROUND_VAL </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'NUMBA_DYLD_WORKAROUND'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

<span class="s2">if </span><span class="s1">_DYLD_WORKAROUND_SET </span><span class="s2">and </span><span class="s1">_DYLD_WORKAROUND_VAL</span><span class="s3">:</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;The parallel chunksize must be an integer&quot;</span><span class="s3">)</span>
    <span class="s2">global </span><span class="s1">_set_parallel_chunksize</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;chunksize must be greater than or equal to zero&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_set_parallel_chunksize</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_parallel_chunksize</span><span class="s3">():</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">global </span><span class="s1">_get_parallel_chunksize</span>
    <span class="s2">return </span><span class="s1">_get_parallel_chunksize</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">set_parallel_chunksize</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_set_parallel_chunksize</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The parallel chunksize must be an integer&quot;</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;chunksize must be greater than or equal to zero&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_set_parallel_chunksize</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_get_parallel_chunksize</span><span class="s3">():</span>
    <span class="s1">_launch_threads</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
        <span class="s2">return </span><span class="s1">_get_parallel_chunksize</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl</span>
</pre>
</body>
</html>