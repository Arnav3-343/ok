<html>
<head>
<title>npyimpl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
npyimpl.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of functions in the Numpy package. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>

<span class="s2">import </span><span class="s1">llvmlite</span><span class="s3">.</span><span class="s1">ir </span><span class="s2">as </span><span class="s1">ir</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np </span><span class="s2">import </span><span class="s1">arrayobj</span><span class="s3">, </span><span class="s1">ufunc_db</span><span class="s3">, </span><span class="s1">numpy_support</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">sigparse </span><span class="s2">import </span><span class="s1">parse_signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">imputils </span><span class="s2">import </span><span class="s3">(</span><span class="s1">Registry</span><span class="s3">, </span><span class="s1">impl_ret_new_ref</span><span class="s3">, </span><span class="s1">force_error_model</span><span class="s3">,</span>
                                 <span class="s1">impl_ret_borrowed</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">utils</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">, </span><span class="s1">callconv</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ufunc_find_matching_loop</span><span class="s3">, </span><span class="s1">select_array_wrapper</span><span class="s3">, </span><span class="s1">from_dtype</span><span class="s3">, </span><span class="s1">_ufunc_loop_sig</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arrayobj </span><span class="s2">import </span><span class="s1">_getitem_array_generic</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">npydecl</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">overload</span><span class="s3">, </span><span class="s1">intrinsic</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">errors</span>

<span class="s1">registry </span><span class="s3">= </span><span class="s1">Registry</span><span class="s3">(</span><span class="s4">'npyimpl'</span><span class="s3">)</span>


<span class="s5">########################################################################</span>

<span class="s5"># In the way we generate code, ufuncs work with scalar as well as</span>
<span class="s5"># with array arguments. The following helper classes help dealing</span>
<span class="s5"># with scalar and array arguments in a regular way.</span>
<span class="s5">#</span>
<span class="s5"># In short, the classes provide a uniform interface. The interface</span>
<span class="s5"># handles the indexing of as many dimensions as the array may have.</span>
<span class="s5"># For scalars, all indexing is ignored and when the value is read,</span>
<span class="s5"># the scalar is returned. For arrays code for actual indexing is</span>
<span class="s5"># generated and reading performs the appropriate indirection.</span>

<span class="s2">class </span><span class="s1">_ScalarIndexingHelper</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">update_indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">loop_indices</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">as_values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">_ScalarHelper</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Helper class to handle scalar arguments (and result). 
    Note that store_data is only used when generating code for 
    a scalar ufunc and to write the output value. 
 
    For loading, the value is directly used without having any 
    kind of indexing nor memory backing it up. This is the use 
    for input arguments. 
 
    For storing, a variable is created in the stack where the 
    value will be written. 
 
    Note that it is not supported (as it is unneeded for our 
    current use-cases) reading back a stored value. This class 
    will always &quot;load&quot; the original value it got at its creation. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ctxt</span><span class="s3">, </span><span class="s1">bld</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">ctxt</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">bld</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">val </span><span class="s3">= </span><span class="s1">val</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">base_type </span><span class="s3">= </span><span class="s1">ty</span>
        <span class="s1">intpty </span><span class="s3">= </span><span class="s1">ctxt</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= [</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)]</span>

        <span class="s1">lty </span><span class="s3">= </span><span class="s1">ctxt</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ty </span><span class="s3">!= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean </span><span class="s2">else </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">bld</span><span class="s3">, </span><span class="s1">lty</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">create_iter_indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_ScalarIndexingHelper</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">load_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">store_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ptr</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">return_val</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ptr</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_ArrayIndexingHelper</span><span class="s3">(</span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'_ArrayIndexingHelper'</span><span class="s3">,</span>
                                      <span class="s3">(</span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'indices'</span><span class="s3">))):</span>
    <span class="s2">def </span><span class="s1">update_indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">loop_indices</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">bld </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">intpty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">ONE </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">.</span><span class="s1">width</span><span class="s3">), </span><span class="s6">1</span><span class="s3">)</span>

        <span class="s5"># we are only interested in as many inner dimensions as dimensions</span>
        <span class="s5"># the indexed array has (the outer dimensions are broadcast, so</span>
        <span class="s5"># ignoring the outer indices produces the desired result.</span>
        <span class="s1">indices </span><span class="s3">= </span><span class="s1">loop_indices</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">loop_indices</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">):]</span>
        <span class="s2">for </span><span class="s1">src</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s1">cond </span><span class="s3">= </span><span class="s1">bld</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'&gt;'</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">, </span><span class="s1">ONE</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">bld</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">):</span>
                <span class="s1">bld</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">as_values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        The indexing helper is built using alloca for each value, so it 
        actually contains pointers to the actual indices to load. Note 
        that update_indices assumes the same. This method returns the 
        indices as values 
        &quot;&quot;&quot;</span>
        <span class="s1">bld </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">bld</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">index</span><span class="s3">) </span><span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">_ArrayHelper</span><span class="s3">(</span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'_ArrayHelper'</span><span class="s3">, (</span><span class="s4">'context'</span><span class="s3">, </span><span class="s4">'builder'</span><span class="s3">,</span>
                                               <span class="s4">'shape'</span><span class="s3">, </span><span class="s4">'strides'</span><span class="s3">, </span><span class="s4">'data'</span><span class="s3">,</span>
                                               <span class="s4">'layout'</span><span class="s3">, </span><span class="s4">'base_type'</span><span class="s3">, </span><span class="s4">'ndim'</span><span class="s3">,</span>
                                               <span class="s4">'return_val'</span><span class="s3">))):</span>
    <span class="s0">&quot;&quot;&quot;Helper class to handle array arguments/result. 
    It provides methods to generate code loading/storing specific 
    items as well as support code for handling indices. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">create_iter_indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">intpty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">ZERO </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">.</span><span class="s1">width</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">indices </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">.</span><span class="s1">width</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ZERO</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_ArrayIndexingHelper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">,</span>
                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">,</span>
                                         <span class="s1">data</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                                         <span class="s1">shape</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                                         <span class="s1">strides</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
                                         <span class="s1">layout</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">,</span>
                                         <span class="s1">inds</span><span class="s3">=</span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">load_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s1">model </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">]</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">model</span><span class="s3">.</span><span class="s1">load_from_data_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">store_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s1">ctx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span>
        <span class="s1">bld </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">store_value </span><span class="s3">= </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">get_value_as_data</span><span class="s3">(</span><span class="s1">bld</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">) == </span><span class="s1">store_value</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s1">bld</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">store_value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">_ArrayGUHelper</span><span class="s3">(</span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'_ArrayHelper'</span><span class="s3">, (</span><span class="s4">'context'</span><span class="s3">, </span><span class="s4">'builder'</span><span class="s3">,</span>
                                                 <span class="s4">'shape'</span><span class="s3">, </span><span class="s4">'strides'</span><span class="s3">, </span><span class="s4">'data'</span><span class="s3">,</span>
                                                 <span class="s4">'layout'</span><span class="s3">, </span><span class="s4">'base_type'</span><span class="s3">, </span><span class="s4">'ndim'</span><span class="s3">,</span>
                                                 <span class="s4">'inner_arr_ty'</span><span class="s3">, </span><span class="s4">'is_input_arg'</span><span class="s3">))):</span>
    <span class="s0">&quot;&quot;&quot;Helper class to handle array arguments/result. 
    It provides methods to generate code loading/storing specific 
    items as well as support code for handling indices. 
 
    Contrary to _ArrayHelper, this class can create a view to a subarray 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">create_iter_indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">intpty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">ZERO </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">.</span><span class="s1">width</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">indices </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intpty</span><span class="s3">.</span><span class="s1">width</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ZERO</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_ArrayIndexingHelper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">arr_ty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arr_ty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">,</span>
                                         <span class="s1">builder</span><span class="s3">,</span>
                                         <span class="s1">data</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                                         <span class="s1">shape</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                                         <span class="s1">strides</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
                                         <span class="s1">layout</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">,</span>
                                         <span class="s1">inds</span><span class="s3">=</span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">load_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s1">context</span><span class="s3">, </span><span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_input_arg</span><span class="s3">:</span>
            <span class="s5"># scalar case for input arguments</span>
            <span class="s1">model </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">]</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">model</span><span class="s3">.</span><span class="s1">load_from_data_pointer</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_input_arg</span><span class="s3">:</span>
            <span class="s5"># Output arrays are handled as 1d with shape=(1,) when its</span>
            <span class="s5"># signature represents a scalar. For instance: &quot;(n),(m) -&gt; ()&quot;</span>
            <span class="s1">intpty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">one </span><span class="s3">= </span><span class="s1">intpty</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>

            <span class="s1">fromty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
            <span class="s1">toty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
            <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">intpty</span><span class="s3">(</span><span class="s1">arrayobj</span><span class="s3">.</span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">))</span>

            <span class="s5"># create a view from the original ndarray to a 1d array</span>
            <span class="s1">arr_from </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">fromty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">,</span>
                                                       <span class="s1">builder</span><span class="s3">,</span>
                                                       <span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s1">arr_to </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">toty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
            <span class="s1">arrayobj</span><span class="s3">.</span><span class="s1">populate_array</span><span class="s3">(</span>
                <span class="s1">arr_to</span><span class="s3">,</span>
                <span class="s1">data</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_effective_address</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">),</span>
                <span class="s1">shape</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, [</span><span class="s1">one</span><span class="s3">]),</span>
                <span class="s1">strides</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, [</span><span class="s1">itemsize</span><span class="s3">]),</span>
                <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">arr_from</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">arr_from</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                <span class="s1">parent</span><span class="s3">=</span><span class="s1">arr_from</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">arr_to</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># generic case</span>
            <span class="s5"># getitem n-dim array -&gt; m-dim array, where N &gt; M</span>
            <span class="s1">index_types </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">,) * (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">arrty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">base_type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">_getitem_array_generic</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">,</span>
                                         <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">guard_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">loopshape</span><span class="s3">):</span>
        <span class="s1">inner_ndim </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">def </span><span class="s1">raise_impl</span><span class="s3">(</span><span class="s1">loop_shape</span><span class="s3">, </span><span class="s1">array_shape</span><span class="s3">):</span>
            <span class="s5"># This would in fact be a test for broadcasting.</span>
            <span class="s5"># Broadcast would fail if, ignoring the core dimensions, the</span>
            <span class="s5"># remaining ones are different than indices given by loop shape.</span>

            <span class="s1">remaining </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">array_shape</span><span class="s3">) - </span><span class="s1">inner_ndim</span>
            <span class="s1">_raise </span><span class="s3">= (</span><span class="s1">remaining </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loop_shape</span><span class="s3">))</span>
            <span class="s2">if not </span><span class="s1">_raise</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">remaining</span><span class="s3">):</span>
                    <span class="s1">_raise </span><span class="s3">|= (</span><span class="s1">array_shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">loop_shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">_raise</span><span class="s3">:</span>
                <span class="s5"># Ideally we should call `np.broadcast_shapes` with loop and</span>
                <span class="s5"># array shapes. But since broadcasting is not supported here,</span>
                <span class="s5"># we just raise an error</span>
                <span class="s5"># TODO: check why raising a dynamic exception here fails</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Loop and array shapes are incompatible'</span><span class="s3">)</span>

        <span class="s1">context</span><span class="s3">, </span><span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loopshape</span><span class="s3">)),</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)),</span>
        <span class="s3">)</span>
        <span class="s1">tup </span><span class="s3">= (</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">loopshape</span><span class="s3">),</span>
               <span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">))</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">raise_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">guard_match_core_dims</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s4">'_ArrayGUHelper'</span><span class="s3">, </span><span class="s1">ndims</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s5"># arguments with the same signature should match their core dimensions</span>
        <span class="s5">#</span>
        <span class="s5"># @guvectorize('(n,m), (n,m) -&gt; (n)')</span>
        <span class="s5"># def foo(x, y, res):</span>
        <span class="s5">#     ...</span>
        <span class="s5">#</span>
        <span class="s5"># x and y should have the same core (2D) dimensions</span>
        <span class="s2">def </span><span class="s1">raise_impl</span><span class="s3">(</span><span class="s1">self_shape</span><span class="s3">, </span><span class="s1">other_shape</span><span class="s3">):</span>
            <span class="s1">same </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self_shape</span><span class="s3">) - </span><span class="s1">ndims</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other_shape</span><span class="s3">) - </span><span class="s1">ndims</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndims</span><span class="s3">):</span>
                <span class="s1">same </span><span class="s3">&amp;= </span><span class="s1">self_shape</span><span class="s3">[</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">] == </span><span class="s1">other_shape</span><span class="s3">[</span><span class="s1">b </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">same</span><span class="s3">:</span>
                <span class="s5"># NumPy raises the following:</span>
                <span class="s5"># ValueError: gufunc: Input operand 1 has a mismatch in its</span>
                <span class="s5"># core dimension 0, with gufunc signature (n),(n) -&gt; ()</span>
                <span class="s5"># (size 3 is different from 2)</span>
                <span class="s5"># But since we cannot raise a dynamic exception here, we just</span>
                <span class="s5"># (try) something meaninful</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'Operand has a mismatch in one of its core dimensions. '</span>
                       <span class="s4">'Please, check if all arguments to a @guvectorize '</span>
                       <span class="s4">'function have the same core dimensions.'</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">context</span><span class="s3">, </span><span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)),</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)),</span>
        <span class="s3">)</span>
        <span class="s1">tup </span><span class="s3">= (</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">),</span>
               <span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">other</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">),)</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">raise_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_prepare_argument</span><span class="s3">(</span><span class="s1">ctxt</span><span class="s3">, </span><span class="s1">bld</span><span class="s3">, </span><span class="s1">inp</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s4">'input operand'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;returns an instance of the appropriate Helper (either 
    _ScalarHelper or _ArrayHelper) class to handle the argument. 
    using the polymorphic interface of the Helper classes, scalar 
    and array cases can be handled with the same code&quot;&quot;&quot;</span>

    <span class="s5"># first un-Optional Optionals</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">oty </span><span class="s3">= </span><span class="s1">tyinp</span>
        <span class="s1">tyinp </span><span class="s3">= </span><span class="s1">tyinp</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s1">inp </span><span class="s3">= </span><span class="s1">ctxt</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">bld</span><span class="s3">, </span><span class="s1">inp</span><span class="s3">, </span><span class="s1">oty</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">)</span>

    <span class="s5"># then prepare the arg for a concrete instance</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">):</span>
        <span class="s1">ary     </span><span class="s3">= </span><span class="s1">ctxt</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">)(</span><span class="s1">ctxt</span><span class="s3">, </span><span class="s1">bld</span><span class="s3">, </span><span class="s1">inp</span><span class="s3">)</span>
        <span class="s1">shape   </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">bld</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">bld</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_ArrayHelper</span><span class="s3">(</span><span class="s1">ctxt</span><span class="s3">, </span><span class="s1">bld</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                            <span class="s1">tyinp</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">inp</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unliteral</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">) </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">number_domain </span><span class="s3">| {</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">}</span>
          <span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">scalars</span><span class="s3">.</span><span class="s1">_NPDatetimeBase</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">_ScalarHelper</span><span class="s3">(</span><span class="s1">ctxt</span><span class="s3">, </span><span class="s1">bld</span><span class="s3">, </span><span class="s1">inp</span><span class="s3">, </span><span class="s1">tyinp</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">'unsupported type for {0}: {1}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">where</span><span class="s3">,</span>
                                  <span class="s1">str</span><span class="s3">(</span><span class="s1">tyinp</span><span class="s3">)))</span>


<span class="s1">_broadcast_onto_sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">),</span>
                                 <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">_broadcast_onto</span><span class="s3">(</span><span class="s1">src_ndim</span><span class="s3">, </span><span class="s1">src_shape</span><span class="s3">, </span><span class="s1">dest_ndim</span><span class="s3">, </span><span class="s1">dest_shape</span><span class="s3">):</span>
    <span class="s0">'''Low-level utility function used in calculating a shape for 
    an implicit output array.  This function assumes that the 
    destination shape is an LLVM pointer to a C-style array that was 
    already initialized to a size of one along all axes. 
 
    Returns an integer value: 
    &gt;= 1  :  Succeeded.  Return value should equal the number of dimensions in 
             the destination shape. 
    0     :  Failed to broadcast because source shape is larger than the 
             destination shape (this case should be weeded out at type 
             checking). 
    &lt; 0   :  Failed to broadcast onto destination axis, at axis number == 
             -(return_value + 1). 
    '''</span>
    <span class="s2">if </span><span class="s1">src_ndim </span><span class="s3">&gt; </span><span class="s1">dest_ndim</span><span class="s3">:</span>
        <span class="s5"># This check should have been done during type checking, but</span>
        <span class="s5"># let's be defensive anyway...</span>
        <span class="s2">return </span><span class="s6">0</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">src_index </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">dest_index </span><span class="s3">= </span><span class="s1">dest_ndim </span><span class="s3">- </span><span class="s1">src_ndim</span>
        <span class="s2">while </span><span class="s1">src_index </span><span class="s3">&lt; </span><span class="s1">src_ndim</span><span class="s3">:</span>
            <span class="s1">src_dim_size </span><span class="s3">= </span><span class="s1">src_shape</span><span class="s3">[</span><span class="s1">src_index</span><span class="s3">]</span>
            <span class="s1">dest_dim_size </span><span class="s3">= </span><span class="s1">dest_shape</span><span class="s3">[</span><span class="s1">dest_index</span><span class="s3">]</span>
            <span class="s5"># Check to see if we've already mutated the destination</span>
            <span class="s5"># shape along this axis.</span>
            <span class="s2">if </span><span class="s1">dest_dim_size </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s5"># If we have mutated the destination shape already,</span>
                <span class="s5"># then the source axis size must either be one,</span>
                <span class="s5"># or the destination axis size.</span>
                <span class="s2">if </span><span class="s1">src_dim_size </span><span class="s3">!= </span><span class="s1">dest_dim_size </span><span class="s2">and </span><span class="s1">src_dim_size </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s3">-(</span><span class="s1">dest_index </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">src_dim_size </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s5"># If the destination size is still its initial</span>
                <span class="s1">dest_shape</span><span class="s3">[</span><span class="s1">dest_index</span><span class="s3">] = </span><span class="s1">src_dim_size</span>
            <span class="s1">src_index </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s1">dest_index </span><span class="s3">+= </span><span class="s6">1</span>
    <span class="s2">return </span><span class="s1">dest_index</span>

<span class="s2">def </span><span class="s1">_build_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_ty</span><span class="s3">, </span><span class="s1">input_types</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Utility function to handle allocation of an implicit output array 
    given the target context, builder, output array type, and a list of 
    _ArrayHelper instances. 
    &quot;&quot;&quot;</span>
    <span class="s5"># First, strip optional types, ufunc loops are typed on concrete types</span>
    <span class="s1">input_types </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">type </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">) </span><span class="s2">else </span><span class="s1">x</span>
                   <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_types</span><span class="s3">]</span>

    <span class="s1">intp_ty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">make_intp_const</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s1">ZERO </span><span class="s3">= </span><span class="s1">make_intp_const</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">ONE </span><span class="s3">= </span><span class="s1">make_intp_const</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s1">src_shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_ty</span><span class="s3">, </span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,</span>
                                    <span class="s4">&quot;src_shape&quot;</span><span class="s3">)</span>
    <span class="s1">dest_ndim </span><span class="s3">= </span><span class="s1">make_intp_const</span><span class="s3">(</span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">dest_shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_ty</span><span class="s3">, </span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,</span>
                                     <span class="s4">&quot;dest_shape&quot;</span><span class="s3">)</span>
    <span class="s1">dest_shape_addrs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest_shape</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                             <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>

    <span class="s5"># Initialize the destination shape with all ones.</span>
    <span class="s2">for </span><span class="s1">dest_shape_addr </span><span class="s2">in </span><span class="s1">dest_shape_addrs</span><span class="s3">:</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ONE</span><span class="s3">, </span><span class="s1">dest_shape_addr</span><span class="s3">)</span>

    <span class="s5"># For each argument, try to broadcast onto the destination shape,</span>
    <span class="s5"># mutating along any axis where the argument shape is not one and</span>
    <span class="s5"># the destination shape is one.</span>
    <span class="s2">for </span><span class="s1">arg_number</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s4">&quot;ndim&quot;</span><span class="s3">): </span><span class="s5"># Skip scalar arguments</span>
            <span class="s2">continue</span>
        <span class="s1">arg_ndim </span><span class="s3">= </span><span class="s1">make_intp_const</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">index</span><span class="s3">],</span>
                          <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_shape</span><span class="s3">, </span><span class="s1">index</span><span class="s3">))</span>
        <span class="s1">arg_result </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">, </span><span class="s1">_broadcast_onto</span><span class="s3">, </span><span class="s1">_broadcast_onto_sig</span><span class="s3">,</span>
            <span class="s3">[</span><span class="s1">arg_ndim</span><span class="s3">, </span><span class="s1">src_shape</span><span class="s3">, </span><span class="s1">dest_ndim</span><span class="s3">, </span><span class="s1">dest_shape</span><span class="s3">])</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                 <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">arg_result</span><span class="s3">, </span><span class="s1">ONE</span><span class="s3">)):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;unable to broadcast argument %d to output array&quot; </span><span class="s3">% (</span>
                <span class="s1">arg_number</span><span class="s3">,)</span>

            <span class="s1">loc </span><span class="s3">= </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">loc_info</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'loc'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">loc </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">+= </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">File &quot;%s&quot;, line %d, ' </span><span class="s3">% (</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line</span><span class="s3">)</span>

            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

    <span class="s1">real_array_ty </span><span class="s3">= </span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">as_array</span>

    <span class="s1">dest_shape_tup </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">dest_shape_addr</span><span class="s3">)</span>
                           <span class="s2">for </span><span class="s1">dest_shape_addr </span><span class="s2">in </span><span class="s1">dest_shape_addrs</span><span class="s3">)</span>
    <span class="s1">array_val </span><span class="s3">= </span><span class="s1">arrayobj</span><span class="s3">.</span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">real_array_ty</span><span class="s3">,</span>
                                        <span class="s1">dest_shape_tup</span><span class="s3">)</span>

    <span class="s5"># Get the best argument to call __array_wrap__ on</span>
    <span class="s1">array_wrapper_index </span><span class="s3">= </span><span class="s1">select_array_wrapper</span><span class="s3">(</span><span class="s1">input_types</span><span class="s3">)</span>
    <span class="s1">array_wrapper_ty </span><span class="s3">= </span><span class="s1">input_types</span><span class="s3">[</span><span class="s1">array_wrapper_index</span><span class="s3">]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s5"># __array_wrap__(source wrapped array, out array) -&gt; out wrapped array</span>
        <span class="s1">array_wrap </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s4">'__array_wrap__'</span><span class="s3">,</span>
                                          <span class="s1">array_ty</span><span class="s3">(</span><span class="s1">array_wrapper_ty</span><span class="s3">, </span><span class="s1">real_array_ty</span><span class="s3">))</span>
    <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
        <span class="s5"># If it's the same priority as a regular array, assume we</span>
        <span class="s5"># should use the allocated array unchanged.</span>
        <span class="s2">if </span><span class="s1">array_wrapper_ty</span><span class="s3">.</span><span class="s1">array_priority </span><span class="s3">!= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">array_priority</span><span class="s3">:</span>
            <span class="s2">raise</span>
        <span class="s1">out_val </span><span class="s3">= </span><span class="s1">array_val</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">wrap_args </span><span class="s3">= (</span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">array_wrapper_index</span><span class="s3">].</span><span class="s1">return_val</span><span class="s3">, </span><span class="s1">array_val</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>
        <span class="s1">out_val </span><span class="s3">= </span><span class="s1">array_wrap</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">wrap_args</span><span class="s3">)</span>

    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">shape   </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_val</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_val</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_ArrayHelper</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">array_val</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                        <span class="s1">array_ty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">array_ty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">,</span>
                        <span class="s1">out_val</span><span class="s3">)</span>

<span class="s5"># ufuncs either return a single result when nout == 1, else a tuple of results</span>

<span class="s2">def </span><span class="s1">_unpack_output_types</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_unpack_output_values</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">values</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">values</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_pack_output_values</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">values</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel_class</span><span class="s3">):</span>
    <span class="s5"># This is the code generator that builds all the looping needed</span>
    <span class="s5"># to execute a numpy functions over several dimensions (including</span>
    <span class="s5"># scalar cases).</span>
    <span class="s5">#</span>
    <span class="s5"># context - the code generation context</span>
    <span class="s5"># builder - the code emitter</span>
    <span class="s5"># sig - signature of the ufunc</span>
    <span class="s5"># args - the args to the ufunc</span>
    <span class="s5"># ufunc - the ufunc itself</span>
    <span class="s5"># kernel_class -  a code generating subclass of _Kernel that provides</span>

    <span class="s1">arguments </span><span class="s3">= [</span><span class="s1">_prepare_argument</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">tyarg</span><span class="s3">)</span>
                 <span class="s2">for </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">tyarg </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)]</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">) &lt; </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
            <span class="s4">&quot;Not enough inputs to {}, expected {} got {}&quot;</span>
            <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">)))</span>

    <span class="s2">for </span><span class="s1">out_i</span><span class="s3">, </span><span class="s1">ret_ty </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">_unpack_output_types</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">+ </span><span class="s1">out_i </span><span class="s3">&gt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">):</span>
            <span class="s5"># this out argument is not provided</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret_ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">):</span>
                <span class="s1">output </span><span class="s3">= </span><span class="s1">_build_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret_ty</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">output </span><span class="s3">= </span><span class="s1">_prepare_argument</span><span class="s3">(</span>
                    <span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                    <span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">ret_ty</span><span class="s3">), </span><span class="s2">None</span><span class="s3">), </span><span class="s1">ret_ty</span><span class="s3">)</span>
            <span class="s1">arguments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">output</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
            <span class="s5"># Incref the output</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">incref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret_ty</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">+ </span><span class="s1">out_i</span><span class="s3">])</span>

    <span class="s1">inputs </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[:</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">]</span>
    <span class="s1">outputs </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">:]</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">) == </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout</span>

    <span class="s1">outer_sig </span><span class="s3">= </span><span class="s1">_ufunc_loop_sig</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">base_type </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">outputs</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">base_type </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">kernel </span><span class="s3">= </span><span class="s1">kernel_class</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">)</span>
    <span class="s1">intpty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s1">indices </span><span class="s3">= [</span><span class="s1">inp</span><span class="s3">.</span><span class="s1">create_iter_indices</span><span class="s3">() </span><span class="s2">for </span><span class="s1">inp </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">]</span>

    <span class="s5"># assume outputs are all the same size, which numpy requires</span>

    <span class="s1">loopshape </span><span class="s3">= </span><span class="s1">outputs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">shape</span>

    <span class="s5"># count the number of C and F layout arrays, respectively</span>
    <span class="s1">input_layouts </span><span class="s3">= [</span><span class="s1">inp</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">for </span><span class="s1">inp </span><span class="s2">in </span><span class="s1">inputs</span>
                     <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inp</span><span class="s3">, </span><span class="s1">_ArrayHelper</span><span class="s3">)]</span>
    <span class="s1">num_c_layout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_layouts </span><span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s4">'C'</span><span class="s3">])</span>
    <span class="s1">num_f_layout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_layouts </span><span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">])</span>

    <span class="s5"># Only choose F iteration order if more arrays are in F layout.</span>
    <span class="s5"># Default to C order otherwise.</span>
    <span class="s5"># This is a best effort for performance. NumPy has more fancy logic that</span>
    <span class="s5"># uses array iterators in non-trivial cases.</span>
    <span class="s2">if </span><span class="s1">num_f_layout </span><span class="s3">&gt; </span><span class="s1">num_c_layout</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s4">'F'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s4">'C'</span>

    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">loopshape</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">=</span><span class="s1">intpty</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop_indices</span><span class="s3">:</span>
        <span class="s1">vals_in </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">index</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">)):</span>
            <span class="s1">index</span><span class="s3">.</span><span class="s1">update_indices</span><span class="s3">(</span><span class="s1">loop_indices</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">vals_in</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">load_data</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">as_values</span><span class="s3">()))</span>

        <span class="s1">vals_out </span><span class="s3">= </span><span class="s1">_unpack_output_values</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">generate</span><span class="s3">(*</span><span class="s1">vals_in</span><span class="s3">))</span>
        <span class="s2">for </span><span class="s1">val_out</span><span class="s3">, </span><span class="s1">output </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">vals_out</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">):</span>
            <span class="s1">output</span><span class="s3">.</span><span class="s1">store_data</span><span class="s3">(</span><span class="s1">loop_indices</span><span class="s3">, </span><span class="s1">val_out</span><span class="s3">)</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">_pack_output_values</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, [</span><span class="s1">o</span><span class="s3">.</span><span class="s1">return_val </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">outputs</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">numpy_gufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel_class</span><span class="s3">):</span>
    <span class="s1">arguments </span><span class="s3">= []</span>
    <span class="s1">expected_ndims </span><span class="s3">= </span><span class="s1">kernel_class</span><span class="s3">.</span><span class="s1">dufunc</span><span class="s3">.</span><span class="s1">expected_ndims</span><span class="s3">()</span>
    <span class="s1">expected_ndims </span><span class="s3">= </span><span class="s1">expected_ndims</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">expected_ndims</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">is_input </span><span class="s3">= [</span><span class="s2">True</span><span class="s3">] * </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">+ [</span><span class="s2">False</span><span class="s3">] * </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout</span>
    <span class="s2">for </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">exp_ndim</span><span class="s3">, </span><span class="s1">is_inp </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">expected_ndims</span><span class="s3">, </span><span class="s1">is_input</span><span class="s3">):  </span><span class="s5"># noqa: E501</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">):</span>
            <span class="s5"># Create an array helper that iteration returns a subarray</span>
            <span class="s5"># with ndim specified by &quot;exp_ndim&quot;</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">inner_arr_ty </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">exp_ndim</span><span class="s3">)</span>
            <span class="s1">ndim </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s1">layout </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">layout</span>
            <span class="s1">base_type </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">dtype</span>
            <span class="s1">array_helper </span><span class="s3">= </span><span class="s1">_ArrayGUHelper</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                          <span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">,</span>
                                          <span class="s1">layout</span><span class="s3">, </span><span class="s1">base_type</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">,</span>
                                          <span class="s1">inner_arr_ty</span><span class="s3">, </span><span class="s1">is_inp</span><span class="s3">)</span>
            <span class="s1">arguments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">array_helper</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">scalar_helper </span><span class="s3">= </span><span class="s1">_ScalarHelper</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">)</span>
            <span class="s1">arguments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">scalar_helper</span><span class="s3">)</span>
    <span class="s1">kernel </span><span class="s3">= </span><span class="s1">kernel_class</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s1">layouts </span><span class="s3">= [</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">arguments</span>
               <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">_ArrayGUHelper</span><span class="s3">)]</span>
    <span class="s1">num_c_layout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">layouts </span><span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s4">'C'</span><span class="s3">])</span>
    <span class="s1">num_f_layout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">layouts </span><span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">])</span>

    <span class="s5"># Only choose F iteration order if more arrays are in F layout.</span>
    <span class="s5"># Default to C order otherwise.</span>
    <span class="s5"># This is a best effort for performance. NumPy has more fancy logic that</span>
    <span class="s5"># uses array iterators in non-trivial cases.</span>
    <span class="s2">if </span><span class="s1">num_f_layout </span><span class="s3">&gt; </span><span class="s1">num_c_layout</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s4">'F'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s4">'C'</span>

    <span class="s1">outputs </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">:]</span>
    <span class="s1">intpty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">indices </span><span class="s3">= [</span><span class="s1">inp</span><span class="s3">.</span><span class="s1">create_iter_indices</span><span class="s3">() </span><span class="s2">for </span><span class="s1">inp </span><span class="s2">in </span><span class="s1">arguments</span><span class="s3">]</span>
    <span class="s1">loopshape_ndim </span><span class="s3">= </span><span class="s1">outputs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">outputs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">inner_arr_ty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">loopshape </span><span class="s3">= </span><span class="s1">outputs</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">[ : </span><span class="s1">loopshape_ndim</span><span class="s3">]</span>

    <span class="s1">_sig </span><span class="s3">= </span><span class="s1">parse_signature</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">gufunc_builder</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">idx_a</span><span class="s3">, </span><span class="s1">sig_a</span><span class="s3">), (</span><span class="s1">idx_b</span><span class="s3">, </span><span class="s1">sig_b</span><span class="s3">) </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">combinations</span><span class="s3">(</span>
            <span class="s1">zip</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">)),</span>
            <span class="s1">_sig</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">_sig</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]),</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s3">):</span>
        <span class="s5"># For each pair of arguments, both inputs and outputs, must match their</span>
        <span class="s5"># inner dimensions if their signatures are the same.</span>
        <span class="s1">arg_a</span><span class="s3">, </span><span class="s1">arg_b </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">idx_a</span><span class="s3">], </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">idx_b</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">sig_a </span><span class="s3">== </span><span class="s1">sig_b </span><span class="s2">and </span><span class="s1">\</span>
                <span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">_ArrayGUHelper</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s1">arg_a</span><span class="s3">, </span><span class="s1">arg_b</span><span class="s3">)):</span>
            <span class="s1">arg_a</span><span class="s3">, </span><span class="s1">arg_b </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">idx_a</span><span class="s3">], </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">idx_b</span><span class="s3">]</span>
            <span class="s1">arg_a</span><span class="s3">.</span><span class="s1">guard_match_core_dims</span><span class="s3">(</span><span class="s1">arg_b</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sig_a</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">arguments</span><span class="s3">[:</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">_ArrayGUHelper</span><span class="s3">):</span>
            <span class="s1">arg</span><span class="s3">.</span><span class="s1">guard_shape</span><span class="s3">(</span><span class="s1">loopshape</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                           <span class="s1">loopshape</span><span class="s3">,</span>
                           <span class="s1">intp</span><span class="s3">=</span><span class="s1">intpty</span><span class="s3">,</span>
                           <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop_indices</span><span class="s3">:</span>
        <span class="s1">vals_in </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">index</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">)):</span>
            <span class="s1">index</span><span class="s3">.</span><span class="s1">update_indices</span><span class="s3">(</span><span class="s1">loop_indices</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">vals_in</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">load_data</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">as_values</span><span class="s3">()))</span>

        <span class="s1">kernel</span><span class="s3">.</span><span class="s1">generate</span><span class="s3">(*</span><span class="s1">vals_in</span><span class="s3">)</span>


<span class="s5"># Kernels are the code to be executed inside the multidimensional loop.</span>
<span class="s2">class </span><span class="s1">_Kernel</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">outer_sig </span><span class="s3">= </span><span class="s1">outer_sig</span>

    <span class="s2">def </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Numpy uses cast semantics that are different from standard Python 
        (for example, it does allow casting from complex to float). 
 
        This method acts as a patch to context.cast so that it allows 
        complex to real/int casts. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">toty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
            <span class="s5"># attempt conversion of the real part to the specified type.</span>
            <span class="s5"># note that NumPy issues a warning in this kind of conversions</span>
            <span class="s1">newty </span><span class="s3">= </span><span class="s1">fromty</span><span class="s3">.</span><span class="s1">underlying_float</span>
            <span class="s1">attr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_getattr</span><span class="s3">(</span><span class="s1">fromty</span><span class="s3">, </span><span class="s4">'real'</span><span class="s3">)</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s4">'real'</span><span class="s3">)</span>
            <span class="s1">fromty </span><span class="s3">= </span><span class="s1">newty</span>
            <span class="s5"># let the regular cast do the rest...</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">isig </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_sig</span>
        <span class="s1">osig </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outer_sig</span>
        <span class="s1">cast_args </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">inty</span><span class="s3">, </span><span class="s1">outty</span><span class="s3">)</span>
                     <span class="s2">for </span><span class="s1">val</span><span class="s3">, </span><span class="s1">inty</span><span class="s3">, </span><span class="s1">outty </span><span class="s2">in</span>
                     <span class="s1">zip</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">osig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cres</span><span class="s3">.</span><span class="s1">objectmode</span><span class="s3">:</span>
            <span class="s1">func_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">get_function_type</span><span class="s3">(</span>
                <span class="s1">types</span><span class="s3">.</span><span class="s1">pyobject</span><span class="s3">, [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">pyobject</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">isig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">func_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">get_function_type</span><span class="s3">(</span>
                <span class="s1">isig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">block</span><span class="s3">.</span><span class="s1">function</span><span class="s3">.</span><span class="s1">module</span>
        <span class="s1">entry_point </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span>
            <span class="s1">module</span><span class="s3">, </span><span class="s1">func_type</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">cres</span><span class="s3">.</span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">llvm_func_name</span><span class="s3">)</span>
        <span class="s1">entry_point</span><span class="s3">.</span><span class="s1">attributes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">&quot;alwaysinline&quot;</span><span class="s3">)</span>

        <span class="s1">_</span><span class="s3">, </span><span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">call_function</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">entry_point</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,</span>
            <span class="s1">cast_args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">osig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_ufunc_db_function</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Use the ufunc loop type information to select the code generation 
    function from the table provided by the dict_of_kernels. The dict 
    of kernels maps the loop identifier to a function with the 
    following signature: (context, builder, signature, args). 
 
    The loop type information has the form 'AB-&gt;C'. The letters to the 
    left of '-&gt;' are the input types (specified as NumPy letter 
    types).  The letters to the right of '-&gt;' are the output 
    types. There must be 'ufunc.nin' letters to the left of '-&gt;', and 
    'ufunc.nout' letters to the right. 
 
    For example, a binary float loop resulting in a float, will have 
    the following signature: 'ff-&gt;f'. 
 
    A given ufunc implements many loops. The list of loops implemented 
    for a given ufunc can be accessed using the 'types' attribute in 
    the ufunc object. The NumPy machinery selects the first loop that 
    fits a given calling signature (in our case, what we call the 
    outer_sig). This logic is mimicked by 'ufunc_find_matching_loop'. 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">_KernelImpl</span><span class="s3">(</span><span class="s1">_Kernel</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">):</span>
            <span class="s1">super</span><span class="s3">(</span><span class="s1">_KernelImpl</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">)</span>
            <span class="s1">loop </span><span class="s3">= </span><span class="s1">ufunc_find_matching_loop</span><span class="s3">(</span>
                <span class="s1">ufunc</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">.</span><span class="s1">args </span><span class="s3">+ </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">_unpack_output_types</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">outer_sig</span><span class="s3">)))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fn </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_ufunc_info</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">ufunc_sig</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">inner_sig </span><span class="s3">= </span><span class="s1">_ufunc_loop_sig</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fn </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Don't know how to lower ufunc '{0}' for loop '{1}'&quot;</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">isig </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inner_sig</span>
            <span class="s1">osig </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outer_sig</span>

            <span class="s1">cast_args </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">inty</span><span class="s3">, </span><span class="s1">outty</span><span class="s3">)</span>
                         <span class="s2">for </span><span class="s1">val</span><span class="s3">, </span><span class="s1">inty</span><span class="s3">, </span><span class="s1">outty </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">osig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,</span>
                                                     <span class="s1">isig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)]</span>
            <span class="s2">with </span><span class="s1">force_error_model</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s4">'numpy'</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">, </span><span class="s1">cast_args</span><span class="s3">)</span>
            <span class="s1">dmm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">dmm</span><span class="s3">[</span><span class="s1">isig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">].</span><span class="s1">from_return</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">isig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">osig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_KernelImpl</span>


<span class="s5">################################################################################</span>
<span class="s5"># Helper functions that register the ufuncs</span>

<span class="s2">def </span><span class="s1">register_ufunc_kernel</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">do_ufunc</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">)</span>

    <span class="s1">_any </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span>
    <span class="s1">in_args </span><span class="s3">= (</span><span class="s1">_any</span><span class="s3">,) * </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin</span>

    <span class="s5"># Add a lowering for each out argument that is missing.</span>
    <span class="s2">for </span><span class="s1">n_explicit_out </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nout </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s1">out_args </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,) * </span><span class="s1">n_explicit_out</span>
        <span class="s1">lower</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, *</span><span class="s1">in_args</span><span class="s3">, *</span><span class="s1">out_args</span><span class="s3">)(</span><span class="s1">do_ufunc</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">kernel</span>


<span class="s2">def </span><span class="s1">register_unary_operator_kernel</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">,</span>
                                   <span class="s1">inplace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">assert not </span><span class="s1">inplace  </span><span class="s5"># are there any inplace unary operators?</span>
    <span class="s2">def </span><span class="s1">lower_unary_operator</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">)</span>
    <span class="s1">_arr_kind </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span>
    <span class="s1">lower</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">_arr_kind</span><span class="s3">)(</span><span class="s1">lower_unary_operator</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">register_binary_operator_kernel</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">lower_binary_operator</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lower_inplace_operator</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s5"># The visible signature is (A, B) -&gt; A</span>
        <span class="s5"># The implementation's signature (with explicit output)</span>
        <span class="s5"># is (A, B, A) -&gt; A</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) + (</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args </span><span class="s3">+ (</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],))</span>
        <span class="s2">return </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">)</span>

    <span class="s1">_any </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span>
    <span class="s1">_arr_kind </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span>
    <span class="s1">formal_sigs </span><span class="s3">= [(</span><span class="s1">_arr_kind</span><span class="s3">, </span><span class="s1">_arr_kind</span><span class="s3">), (</span><span class="s1">_any</span><span class="s3">, </span><span class="s1">_arr_kind</span><span class="s3">), (</span><span class="s1">_arr_kind</span><span class="s3">, </span><span class="s1">_any</span><span class="s3">)]</span>
    <span class="s2">for </span><span class="s1">sig </span><span class="s2">in </span><span class="s1">formal_sigs</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s1">lower</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">)(</span><span class="s1">lower_binary_operator</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lower</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">)(</span><span class="s1">lower_inplace_operator</span><span class="s3">)</span>


<span class="s5">################################################################################</span>
<span class="s5"># Use the contents of ufunc_db to initialize the supported ufuncs</span>

<span class="s3">@</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_positive_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">'''Lowering function for +(array) expressions.  Defined here 
    (numba.targets.npyimpl) since the remaining array-operator 
    lowering functions are also registered in this module. 
    '''</span>
    <span class="s2">class </span><span class="s1">_UnaryPositiveKernel</span><span class="s3">(</span><span class="s1">_Kernel</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">[</span><span class="s1">val</span><span class="s3">] = </span><span class="s1">args</span>
            <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">return </span><span class="s1">numpy_ufunc_kernel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">positive</span><span class="s3">,</span>
                              <span class="s1">_UnaryPositiveKernel</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">register_ufuncs</span><span class="s3">(</span><span class="s1">ufuncs</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">):</span>
    <span class="s1">kernels </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">ufunc </span><span class="s2">in </span><span class="s1">ufuncs</span><span class="s3">:</span>
        <span class="s1">db_func </span><span class="s3">= </span><span class="s1">_ufunc_db_function</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">)</span>
        <span class="s1">kernels</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">] = </span><span class="s1">register_ufunc_kernel</span><span class="s3">(</span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">db_func</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">_op_map </span><span class="s2">in </span><span class="s3">(</span><span class="s1">npydecl</span><span class="s3">.</span><span class="s1">NumpyRulesUnaryArrayOperator</span><span class="s3">.</span><span class="s1">_op_map</span><span class="s3">,</span>
                    <span class="s1">npydecl</span><span class="s3">.</span><span class="s1">NumpyRulesArrayOperator</span><span class="s3">.</span><span class="s1">_op_map</span><span class="s3">,</span>
                    <span class="s3">):</span>
        <span class="s2">for </span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc_name </span><span class="s2">in </span><span class="s1">_op_map</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">ufunc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s1">ufunc_name</span><span class="s3">)</span>
            <span class="s1">kernel </span><span class="s3">= </span><span class="s1">kernels</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">register_unary_operator_kernel</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">register_binary_operator_kernel</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;There shouldn't be any non-unary or binary operators&quot;</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">_op_map </span><span class="s2">in </span><span class="s3">(</span><span class="s1">npydecl</span><span class="s3">.</span><span class="s1">NumpyRulesInplaceArrayOperator</span><span class="s3">.</span><span class="s1">_op_map</span><span class="s3">,</span>
                    <span class="s3">):</span>
        <span class="s2">for </span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc_name </span><span class="s2">in </span><span class="s1">_op_map</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">ufunc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s1">ufunc_name</span><span class="s3">)</span>
            <span class="s1">kernel </span><span class="s3">= </span><span class="s1">kernels</span><span class="s3">[</span><span class="s1">ufunc</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">register_unary_operator_kernel</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">,</span>
                                               <span class="s1">inplace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">register_binary_operator_kernel</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">, </span><span class="s1">ufunc</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">,</span>
                                                <span class="s1">inplace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;There shouldn't be any non-unary or binary operators&quot;</span><span class="s3">)</span>


<span class="s1">register_ufuncs</span><span class="s3">(</span><span class="s1">ufunc_db</span><span class="s3">.</span><span class="s1">get_ufuncs</span><span class="s3">(), </span><span class="s1">registry</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_make_dtype_object</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">desc</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Given a string or NumberClass description *desc*, returns the dtype object. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">from_nb_type</span><span class="s3">(</span><span class="s1">nb_type</span><span class="s3">):</span>
        <span class="s1">return_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">(</span><span class="s1">nb_type</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">return_type</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s5"># All dtype objects are dummy values in LLVM.</span>
            <span class="s5"># They only exist in the type level.</span>
            <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">):</span>
        <span class="s5"># Convert the str description into np.dtype then to numba type.</span>
        <span class="s1">nb_type </span><span class="s3">= </span><span class="s1">from_dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">from_nb_type</span><span class="s3">(</span><span class="s1">nb_type</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">functions</span><span class="s3">.</span><span class="s1">NumberClass</span><span class="s3">):</span>
        <span class="s1">thestr </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s5"># Convert the str description into np.dtype then to numba type.</span>
        <span class="s1">nb_type </span><span class="s3">= </span><span class="s1">from_dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">thestr</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">from_nb_type</span><span class="s3">(</span><span class="s1">nb_type</span><span class="s3">)</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_dtype</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Provide an implementation so that numpy.dtype function can be lowered. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">functions</span><span class="s3">.</span><span class="s1">NumberClass</span><span class="s3">)):</span>
        <span class="s2">def </span><span class="s1">imp</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_make_dtype_object</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">imp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s4">'unknown dtype descriptor: {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">desc</span><span class="s3">))</span>
</pre>
</body>
</html>