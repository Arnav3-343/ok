<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2010, 2011 Sebastian Thiel (byronimo@gmail.com) and contributors</span>
<span class="s0">#</span>
<span class="s0"># This module is part of GitDB and is released under</span>
<span class="s0"># the New BSD License: https://opensource.org/license/bsd-3-clause/</span>
<span class="s2">import </span><span class="s1">binascii</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">mmap</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">errno</span>

<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>

<span class="s2">from </span><span class="s1">smmap </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">StaticWindowMapManager</span><span class="s3">,</span>
    <span class="s1">SlidingWindowMapManager</span><span class="s3">,</span>
    <span class="s1">SlidingWindowMapBuffer</span>
<span class="s3">)</span>

<span class="s0"># initialize our global memory manager instance</span>
<span class="s0"># Use it to free cached (and unused) resources.</span>
<span class="s1">mman </span><span class="s3">= </span><span class="s1">SlidingWindowMapManager</span><span class="s3">()</span>
<span class="s0"># END handle mman</span>

<span class="s2">import </span><span class="s1">hashlib</span>

<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">struct </span><span class="s2">import </span><span class="s1">unpack_from</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">struct </span><span class="s2">import </span><span class="s1">unpack</span><span class="s3">, </span><span class="s1">calcsize</span>
    <span class="s1">__calcsize_cache </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">__calcsize_cache</span><span class="s3">[</span><span class="s1">fmt</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">)</span>
            <span class="s1">__calcsize_cache</span><span class="s3">[</span><span class="s1">fmt</span><span class="s3">] = </span><span class="s1">size</span>
        <span class="s0"># END exception handling</span>
        <span class="s2">return </span><span class="s1">unpack</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">: </span><span class="s1">offset </span><span class="s3">+ </span><span class="s1">size</span><span class="s3">])</span>
    <span class="s0"># END own unpack_from implementation</span>


<span class="s0">#{ Aliases</span>

<span class="s1">hex_to_bin </span><span class="s3">= </span><span class="s1">binascii</span><span class="s3">.</span><span class="s1">a2b_hex</span>
<span class="s1">bin_to_hex </span><span class="s3">= </span><span class="s1">binascii</span><span class="s3">.</span><span class="s1">b2a_hex</span>

<span class="s0"># errors</span>
<span class="s1">ENOENT </span><span class="s3">= </span><span class="s1">errno</span><span class="s3">.</span><span class="s1">ENOENT</span>

<span class="s0"># os shortcuts</span>
<span class="s1">exists </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span>
<span class="s1">mkdir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">mkdir</span>
<span class="s1">chmod </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">chmod</span>
<span class="s1">isdir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span>
<span class="s1">isfile </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span>
<span class="s1">rename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">rename</span>
<span class="s1">dirname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span>
<span class="s1">basename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span>
<span class="s1">join </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span>
<span class="s1">read </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">read</span>
<span class="s1">write </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">write</span>
<span class="s1">close </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">close</span>
<span class="s1">fsync </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">fsync</span>


<span class="s2">def </span><span class="s1">_retry</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s0"># Wrapper around functions, that are problematic on &quot;Windows&quot;. Sometimes</span>
    <span class="s0"># the OS or someone else has still a handle to the file</span>
    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s5">&quot;win32&quot;</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
                <span class="s1">time</span><span class="s3">.</span><span class="s1">sleep</span><span class="s3">(</span><span class="s4">0.1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">remove</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_retry</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s0"># Backwards compatibility imports</span>
<span class="s2">from </span><span class="s1">gitdb</span><span class="s3">.</span><span class="s1">const </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">NULL_BIN_SHA</span><span class="s3">,</span>
    <span class="s1">NULL_HEX_SHA</span>
<span class="s3">)</span>

<span class="s0">#} END Aliases</span>

<span class="s0">#{ compatibility stuff ...</span>


<span class="s2">class </span><span class="s1">_RandomAccessBytesIO</span><span class="s3">:</span>

    <span class="s6">&quot;&quot;&quot;Wrapper to provide required functionality in case memory maps cannot or may 
    not be used. This is only really required in python 2.4&quot;&quot;&quot;</span>
    <span class="s1">__slots__ </span><span class="s3">= </span><span class="s5">'_sio'</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">buf</span><span class="s3">=</span><span class="s5">''</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_sio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sio</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">()[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__getslice__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">()[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">byte_ord</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the integer representation of the byte string.  This supports Python 
    3 byte arrays as well as standard strings. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">b</span>

<span class="s0">#} END compatibility stuff ...</span>

<span class="s0">#{ Routines</span>


<span class="s2">def </span><span class="s1">make_sha</span><span class="s3">(</span><span class="s1">source</span><span class="s3">=</span><span class="s7">b''</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;A python2.4 workaround for the sha/hashlib module fiasco 
 
    **Note** From the dulwich project &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hashlib</span><span class="s3">.</span><span class="s1">sha1</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">NameError</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">sha</span>
        <span class="s1">sha1 </span><span class="s3">= </span><span class="s1">sha</span><span class="s3">.</span><span class="s1">sha</span><span class="s3">(</span><span class="s1">source</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sha1</span>


<span class="s2">def </span><span class="s1">allocate_memory</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;:return: a file-protocol accessible memory block of the given size&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_RandomAccessBytesIO</span><span class="s3">(</span><span class="s7">b''</span><span class="s3">)</span>
    <span class="s0"># END handle empty chunks gracefully</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">mmap</span><span class="s3">.</span><span class="s1">mmap</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)  </span><span class="s0"># read-write by default</span>
    <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
        <span class="s0"># setup real memory instead</span>
        <span class="s0"># this of course may fail if the amount of memory is not available in</span>
        <span class="s0"># one chunk - would only be the case in python 2.4, being more likely on</span>
        <span class="s0"># 32 bit systems.</span>
        <span class="s2">return </span><span class="s1">_RandomAccessBytesIO</span><span class="s3">(</span><span class="s7">b&quot;</span><span class="s2">\0</span><span class="s7">&quot; </span><span class="s3">* </span><span class="s1">size</span><span class="s3">)</span>
    <span class="s0"># END handle memory allocation</span>


<span class="s2">def </span><span class="s1">file_contents_ro</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">allow_mmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;:return: read-only contents of the file represented by the file descriptor fd 
 
    :param fd: file descriptor opened for reading 
    :param stream: if False, random access is provided, otherwise the stream interface 
        is provided. 
    :param allow_mmap: if True, its allowed to map the contents into memory, which 
        allows large files to be handled and accessed efficiently. The file-descriptor 
        will change its position if this is False&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">allow_mmap</span><span class="s3">:</span>
            <span class="s0"># supports stream and random access</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">mmap</span><span class="s3">.</span><span class="s1">mmap</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">access</span><span class="s3">=</span><span class="s1">mmap</span><span class="s3">.</span><span class="s1">ACCESS_READ</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
                <span class="s0"># python 2.4 issue, 0 wants to be the actual size</span>
                <span class="s2">return </span><span class="s1">mmap</span><span class="s3">.</span><span class="s1">mmap</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">fstat</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">).</span><span class="s1">st_size</span><span class="s3">, </span><span class="s1">access</span><span class="s3">=</span><span class="s1">mmap</span><span class="s3">.</span><span class="s1">ACCESS_READ</span><span class="s3">)</span>
            <span class="s0"># END handle python 2.4</span>
    <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
        <span class="s2">pass</span>
    <span class="s0"># END exception handling</span>

    <span class="s0"># read manually</span>
    <span class="s1">contents </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">fstat</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">).</span><span class="s1">st_size</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">stream</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_RandomAccessBytesIO</span><span class="s3">(</span><span class="s1">contents</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">contents</span>


<span class="s2">def </span><span class="s1">file_contents_ro_filepath</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">allow_mmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Get the file contents at filepath as fast as possible 
 
    :return: random access compatible memory of the given filepath 
    :param stream: see ``file_contents_ro`` 
    :param allow_mmap: see ``file_contents_ro`` 
    :param flags: additional flags to pass to os.open 
    :raise OSError: If the file could not be opened 
 
    **Note** for now we don't try to use O_NOATIME directly as the right value needs to be 
    shared per database in fact. It only makes a real difference for loose object 
    databases anyway, and they use it with the help of the ``flags`` parameter&quot;&quot;&quot;</span>
    <span class="s1">fd </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">O_RDONLY </span><span class="s3">| </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s5">'O_BINARY'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">) | </span><span class="s1">flags</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">file_contents_ro</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">allow_mmap</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">close</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">)</span>
    <span class="s0"># END assure file is closed</span>


<span class="s2">def </span><span class="s1">sliding_ro_buffer</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    :return: a buffer compatible object which uses our mapped memory manager internally 
        ready to read the whole given filepath&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">SlidingWindowMapBuffer</span><span class="s3">(</span><span class="s1">mman</span><span class="s3">.</span><span class="s1">make_cursor</span><span class="s3">(</span><span class="s1">filepath</span><span class="s3">), </span><span class="s1">flags</span><span class="s3">=</span><span class="s1">flags</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">to_hex_sha</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;:return: hexified version  of sha&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">) == </span><span class="s4">40</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">sha</span>
    <span class="s2">return </span><span class="s1">bin_to_hex</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">to_bin_sha</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">) == </span><span class="s4">20</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">sha</span>
    <span class="s2">return </span><span class="s1">hex_to_bin</span><span class="s3">(</span><span class="s1">sha</span><span class="s3">)</span>


<span class="s0">#} END routines</span>


<span class="s0">#{ Utilities</span>

<span class="s2">class </span><span class="s1">LazyMixin</span><span class="s3">:</span>

    <span class="s6">&quot;&quot;&quot; 
    Base class providing an interface to lazily retrieve attribute values upon 
    first access. If slots are used, memory will only be reserved once the attribute 
    is actually accessed and retrieved the first time. All future accesses will 
    return the cached value as stored in the Instance's dict or slot. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Whenever an attribute is requested that we do not know, we allow it 
        to be created and set. Next time the same attribute is requested, it is simply 
        returned from our dict/slots. &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_cache_</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s0"># will raise in case the cache was not created</span>
        <span class="s2">return </span><span class="s1">object</span><span class="s3">.</span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_cache_</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        This method should be overridden in the derived class. 
        It should check whether the attribute named by attr can be created 
        and cached. Do nothing if you do not know the attribute or call your subclass 
 
        The derived class may create as many additional attributes as it deems 
        necessary in case a git command returns more information than represented 
        in the single attribute.&quot;&quot;&quot;</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">LockedFD</span><span class="s3">:</span>

    <span class="s6">&quot;&quot;&quot; 
    This class facilitates a safe read and write operation to a file on disk. 
    If we write to 'file', we obtain a lock file at 'file.lock' and write to 
    that instead. If we succeed, the lock file will be renamed to overwrite 
    the original file. 
 
    When reading, we obtain a lock file, but to prevent other writers from 
    succeeding while we are reading the file. 
 
    This type handles error correctly in that it will assure a consistent state 
    on destruction. 
 
    **note** with this setup, parallel reading is not possible&quot;&quot;&quot;</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s5">&quot;_filepath&quot;</span><span class="s3">, </span><span class="s5">'_fd'</span><span class="s3">, </span><span class="s5">'_write'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filepath</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Initialize an instance with the givne filepath&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath </span><span class="s3">= </span><span class="s1">filepath</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write </span><span class="s3">= </span><span class="s2">None          </span><span class="s0"># if True, we write a file</span>

    <span class="s2">def </span><span class="s1">__del__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># will do nothing if the file descriptor is already closed</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">rollback</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_lockfilepath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">&quot;%s.lock&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span>

    <span class="s2">def </span><span class="s1">open</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">write</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Open the file descriptor for reading or writing, both in binary mode. 
 
        :param write: if True, the file descriptor will be opened for writing. Other 
            wise it will be opened read-only. 
        :param stream: if True, the file descriptor will be wrapped into a simple stream 
            object which supports only reading or writing 
        :return: fd to read from or write to. It is still maintained by this instance 
            and must not be closed directly 
        :raise IOError: if the lock could not be retrieved 
        :raise OSError: If the actual file could not be opened for reading 
 
        **note** must only be called once&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s5">&quot;Called %s multiple times&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">open</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_write </span><span class="s3">= </span><span class="s1">write</span>

        <span class="s0"># try to open the lock file</span>
        <span class="s1">binary </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s5">'O_BINARY'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">lockmode </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">O_WRONLY </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">O_CREAT </span><span class="s3">| </span><span class="s1">os</span><span class="s3">.</span><span class="s1">O_EXCL </span><span class="s3">| </span><span class="s1">binary</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">fd </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lockfilepath</span><span class="s3">(), </span><span class="s1">lockmode</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s5">&quot;600&quot;</span><span class="s3">, </span><span class="s4">8</span><span class="s3">))</span>
            <span class="s2">if not </span><span class="s1">write</span><span class="s3">:</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">close</span><span class="s3">(</span><span class="s1">fd</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s3">= </span><span class="s1">fd</span>
            <span class="s0"># END handle file descriptor</span>
        <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">OSError</span><span class="s3">(</span><span class="s5">&quot;Lock at %r could not be obtained&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lockfilepath</span><span class="s3">()) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s0"># END handle lock retrieval</span>

        <span class="s0"># open actual file if required</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># we could specify exclusive here, as we obtained the lock anyway</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">O_RDONLY </span><span class="s3">| </span><span class="s1">binary</span><span class="s3">)</span>
            <span class="s2">except</span><span class="s3">:</span>
                <span class="s0"># assure we release our lockfile</span>
                <span class="s1">remove</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lockfilepath</span><span class="s3">())</span>
                <span class="s2">raise</span>
            <span class="s0"># END handle lockfile</span>
        <span class="s0"># END open descriptor for reading</span>

        <span class="s2">if </span><span class="s1">stream</span><span class="s3">:</span>
            <span class="s0"># need delayed import</span>
            <span class="s2">from </span><span class="s1">gitdb</span><span class="s3">.</span><span class="s1">stream </span><span class="s2">import </span><span class="s1">FDStream</span>
            <span class="s2">return </span><span class="s1">FDStream</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd</span>
        <span class="s0"># END handle stream</span>

    <span class="s2">def </span><span class="s1">commit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;When done writing, call this function to commit your changes into the 
        actual file. 
        The file descriptor will be closed, and the lockfile handled. 
 
        **Note** can be called multiple times&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_end_writing</span><span class="s3">(</span><span class="s1">successful</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rollback</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Abort your operation without any changes. The file descriptor will be 
        closed, and the lock released. 
 
        **Note** can be called multiple times&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_end_writing</span><span class="s3">(</span><span class="s1">successful</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_end_writing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">successful</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Handle the lock according to the write mode &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s5">&quot;Cannot end operation if it wasn't started yet&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">os</span><span class="s3">.</span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fd</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fd </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">lockfile </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lockfilepath</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_write </span><span class="s2">and </span><span class="s1">successful</span><span class="s3">:</span>
            <span class="s0"># on windows, rename does not silently overwrite the existing one</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s5">&quot;win32&quot;</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span><span class="s3">):</span>
                    <span class="s1">remove</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span><span class="s3">)</span>
                <span class="s0"># END remove if exists</span>
            <span class="s0"># END win32 special handling</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">rename</span><span class="s3">(</span><span class="s1">lockfile</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span><span class="s3">)</span>

            <span class="s0"># assure others can at least read the file - the tmpfile left it at rw--</span>
            <span class="s0"># We may also write that file, on windows that boils down to a remove-</span>
            <span class="s0"># protection as well</span>
            <span class="s1">chmod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filepath</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s5">&quot;644&quot;</span><span class="s3">, </span><span class="s4">8</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># just delete the file so far, we failed</span>
            <span class="s1">remove</span><span class="s3">(</span><span class="s1">lockfile</span><span class="s3">)</span>
        <span class="s0"># END successful handling</span>

<span class="s0">#} END utilities</span>
</pre>
</body>
</html>