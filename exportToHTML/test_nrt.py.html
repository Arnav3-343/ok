<html>
<head>
<title>test_nrt.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_nrt.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">njit</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">runtime </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">rtsys</span><span class="s2">,</span>
    <span class="s1">nrtopt</span><span class="s2">,</span>
    <span class="s1">_nrt_python</span><span class="s2">,</span>
    <span class="s1">nrt</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">extending </span><span class="s0">import </span><span class="s1">intrinsic</span><span class="s2">, </span><span class="s1">include_path</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">imputils </span><span class="s0">import </span><span class="s1">impl_ret_untracked</span>
<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir</span>
<span class="s0">import </span><span class="s1">llvmlite</span><span class="s2">.</span><span class="s1">binding </span><span class="s0">as </span><span class="s1">llvm</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">unsafe</span><span class="s2">.</span><span class="s1">nrt </span><span class="s0">import </span><span class="s1">NRT_get_api</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">support </span><span class="s0">import </span><span class="s2">(</span><span class="s1">EnableNRTStatsMixin</span><span class="s2">, </span><span class="s1">TestCase</span><span class="s2">, </span><span class="s1">temp_directory</span><span class="s2">,</span>
                                 <span class="s1">import_dynamic</span><span class="s2">, </span><span class="s1">skip_if_32bit</span><span class="s2">,</span>
                                 <span class="s1">skip_unless_cffi</span><span class="s2">, </span><span class="s1">run_in_subprocess</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">registry </span><span class="s0">import </span><span class="s1">cpu_target</span>
<span class="s0">import </span><span class="s1">unittest</span>


<span class="s1">linux_only </span><span class="s2">= </span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">skipIf</span><span class="s2">(</span><span class="s0">not </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">'linux'</span><span class="s2">),</span>
                             <span class="s3">'linux only test'</span><span class="s2">)</span>
<span class="s1">x86_only </span><span class="s2">= </span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">skipIf</span><span class="s2">(</span><span class="s1">platform</span><span class="s2">.</span><span class="s1">machine</span><span class="s2">() </span><span class="s0">not in </span><span class="s2">(</span><span class="s3">'i386'</span><span class="s2">, </span><span class="s3">'x86_64'</span><span class="s2">),</span>
                           <span class="s3">'x86 only test'</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Dummy</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s1">alive </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">alive </span><span class="s2">+= </span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">__del__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">alive </span><span class="s2">-= </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestNrtMemInfoNotInitialized</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Unit test for checking the use of the NRT fails if the 
    initialization sequence has not been run. 
    &quot;&quot;&quot;</span>
    <span class="s1">_numba_parallel_test_ </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_init_fail</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">methods </span><span class="s2">= {</span><span class="s3">'library'</span><span class="s2">: (),</span>
                   <span class="s3">'meminfo_new'</span><span class="s2">: ((), ()),</span>
                   <span class="s3">'meminfo_alloc'</span><span class="s2">: ((),),</span>
                   <span class="s2">}</span>

        <span class="s0">for </span><span class="s1">meth</span><span class="s2">, </span><span class="s1">args </span><span class="s0">in </span><span class="s1">methods</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
                    <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">_init </span><span class="s2">= </span><span class="s0">False</span>
                    <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">rtsys</span><span class="s2">, </span><span class="s1">meth</span><span class="s2">)</span>
                    <span class="s1">fn</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

                <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Runtime must be initialized before use.&quot;</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>
            <span class="s0">finally</span><span class="s2">:</span>
                <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">_init </span><span class="s2">= </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">TestNrtMemInfo</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Unit test for core MemInfo functionality 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Reset the Dummy class</span>
        <span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s6"># initialize the NRT (in case the tests are run in isolation)</span>
        <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">initialize</span><span class="s2">(</span><span class="s1">cpu_target</span><span class="s2">.</span><span class="s1">target_context</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TestNrtMemInfo</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">setUp</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_meminfo_refct_1</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">Dummy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s4">0xdeadcafe  </span><span class="s6"># some made up location</span>

        <span class="s1">mi </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_new</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">d</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">mi</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">2</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">mi</span><span class="s2">.</span><span class="s1">release</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mi</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_meminfo_refct_2</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">Dummy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s4">0xdeadcafe  </span><span class="s6"># some made up location</span>

        <span class="s1">mi </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_new</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">d</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">ct </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">100</span><span class="s2">):</span>
            <span class="s1">mi</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1 </span><span class="s2">+ </span><span class="s4">100</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">100</span><span class="s2">):</span>
            <span class="s1">mi</span><span class="s2">.</span><span class="s1">release</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mi</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_fake_memoryview</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">Dummy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s4">0xdeadcafe  </span><span class="s6"># some made up location</span>

        <span class="s1">mi </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_new</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">mview </span><span class="s2">= </span><span class="s1">memoryview</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">, </span><span class="s1">mi</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">readonly</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIs</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">, </span><span class="s1">mview</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">d</span>
        <span class="s0">del </span><span class="s1">mi</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mview</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">.</span><span class="s1">alive</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_memoryview</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">ctypes </span><span class="s0">import </span><span class="s1">c_uint32</span><span class="s2">, </span><span class="s1">c_void_p</span><span class="s2">, </span><span class="s1">POINTER</span><span class="s2">, </span><span class="s1">cast</span>

        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
        <span class="s1">bytesize </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">* </span><span class="s4">10</span>
        <span class="s1">mi </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_alloc</span><span class="s2">(</span><span class="s1">bytesize</span><span class="s2">, </span><span class="s1">safe</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s1">mi</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">c_arr </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">c_void_p</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">data</span><span class="s2">), </span><span class="s1">POINTER</span><span class="s2">(</span><span class="s1">c_uint32 </span><span class="s2">* </span><span class="s4">10</span><span class="s2">))</span>
        <span class="s6"># Check 0xCB-filling</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s4">0xcbcbcbcb</span><span class="s2">)</span>

        <span class="s6"># Init array with ctypes</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">i </span><span class="s2">+ </span><span class="s4">1</span>
        <span class="s1">mview </span><span class="s2">= </span><span class="s1">memoryview</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">nbytes</span><span class="s2">, </span><span class="s1">bytesize</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">readonly</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIs</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">, </span><span class="s1">mview</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mi</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">mview</span><span class="s2">.</span><span class="s1">nbytes </span><span class="s2">// </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">,</span>
                         <span class="s1">buffer</span><span class="s2">=</span><span class="s1">mview</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mview</span>
        <span class="s6"># Modify array with NumPy</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">size</span><span class="s2">) + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">)</span>

        <span class="s1">arr </span><span class="s2">+= </span><span class="s4">1</span>

        <span class="s6"># Check value reflected in ctypes</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">i </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">addr</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">arr</span>
        <span class="s6"># At this point the memory is zero filled</span>
        <span class="s6"># We can't check this deterministically because the memory could be</span>
        <span class="s6"># consumed by another thread.</span>

    <span class="s0">def </span><span class="s1">test_buffer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">ctypes </span><span class="s0">import </span><span class="s1">c_uint32</span><span class="s2">, </span><span class="s1">c_void_p</span><span class="s2">, </span><span class="s1">POINTER</span><span class="s2">, </span><span class="s1">cast</span>

        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
        <span class="s1">bytesize </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">* </span><span class="s4">10</span>
        <span class="s1">mi </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_alloc</span><span class="s2">(</span><span class="s1">bytesize</span><span class="s2">, </span><span class="s1">safe</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s1">mi</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">c_arr </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">c_void_p</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">), </span><span class="s1">POINTER</span><span class="s2">(</span><span class="s1">c_uint32 </span><span class="s2">* </span><span class="s4">10</span><span class="s2">))</span>
        <span class="s6"># Check 0xCB-filling</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s4">0xcbcbcbcb</span><span class="s2">)</span>

        <span class="s6"># Init array with ctypes</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">i </span><span class="s2">+ </span><span class="s4">1</span>

        <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">bytesize </span><span class="s2">// </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">,</span>
                         <span class="s1">buffer</span><span class="s2">=</span><span class="s1">mi</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mi</span>
        <span class="s6"># Modify array with NumPy</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">size</span><span class="s2">) + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">)</span>

        <span class="s1">arr </span><span class="s2">+= </span><span class="s4">1</span>

        <span class="s6"># Check value reflected in ctypes</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">c_arr</span><span class="s2">.</span><span class="s1">contents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">i </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">addr</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">arr</span>
        <span class="s6"># At this point the memory is zero filled</span>
        <span class="s6"># We can't check this deterministically because the memory could be</span>
        <span class="s6"># consumed by another thread.</span>

    <span class="s2">@</span><span class="s1">skip_if_32bit</span>
    <span class="s0">def </span><span class="s1">test_allocate_invalid_size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that attempting to allocate too big a region fails gracefully.</span>
        <span class="s1">size </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">size_t</span><span class="s2">.</span><span class="s1">maxval </span><span class="s2">// </span><span class="s4">8 </span><span class="s2">// </span><span class="s4">2</span>
        <span class="s0">for </span><span class="s1">pred </span><span class="s0">in </span><span class="s2">(</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">MemoryError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
                <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_alloc</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">safe</span><span class="s2">=</span><span class="s1">pred</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s3">f&quot;Requested allocation of </span><span class="s0">{</span><span class="s1">size</span><span class="s0">} </span><span class="s3">bytes failed.&quot;</span><span class="s2">,</span>
                          <span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_allocate_negative_size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that attempting to allocate negative number of bytes fails</span>
        <span class="s6"># gracefully.</span>
        <span class="s1">size </span><span class="s2">= -</span><span class="s4">10</span>
        <span class="s0">for </span><span class="s1">pred </span><span class="s0">in </span><span class="s2">(</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
                <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">meminfo_alloc</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">safe</span><span class="s2">=</span><span class="s1">pred</span><span class="s2">)</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">f&quot;Cannot allocate a negative number of bytes: </span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s3">.&quot;</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">TestTracemalloc</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Test NRT-allocated memory can be tracked by tracemalloc. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">measure_memory_diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">tracemalloc</span>
        <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">skipTest</span><span class="s2">(</span><span class="s3">&quot;tracemalloc not available&quot;</span><span class="s2">)</span>
        <span class="s1">tracemalloc</span><span class="s2">.</span><span class="s1">start</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">before </span><span class="s2">= </span><span class="s1">tracemalloc</span><span class="s2">.</span><span class="s1">take_snapshot</span><span class="s2">()</span>
            <span class="s6"># Keep the result and only delete it after taking a snapshot</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">func</span><span class="s2">()</span>
            <span class="s1">after </span><span class="s2">= </span><span class="s1">tracemalloc</span><span class="s2">.</span><span class="s1">take_snapshot</span><span class="s2">()</span>
            <span class="s0">del </span><span class="s1">res</span>
            <span class="s0">return </span><span class="s1">after</span><span class="s2">.</span><span class="s1">compare_to</span><span class="s2">(</span><span class="s1">before</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">tracemalloc</span><span class="s2">.</span><span class="s1">stop</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_snapshot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s4">1000000</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">alloc_nrt_memory</span><span class="s2">():</span>
            <span class="s5">&quot;&quot;&quot; 
            Allocate and return a large array. 
            &quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">keep_memory</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s1">alloc_nrt_memory</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">release_memory</span><span class="s2">():</span>
            <span class="s1">alloc_nrt_memory</span><span class="s2">()</span>

        <span class="s1">alloc_lineno </span><span class="s2">= </span><span class="s1">keep_memory</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_firstlineno </span><span class="s2">+ </span><span class="s4">1</span>

        <span class="s6"># Warmup JIT</span>
        <span class="s1">alloc_nrt_memory</span><span class="s2">()</span>

        <span class="s6"># The large NRT-allocated array should appear topmost in the diff</span>
        <span class="s1">diff </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">measure_memory_diff</span><span class="s2">(</span><span class="s1">keep_memory</span><span class="s2">)</span>
        <span class="s1">stat </span><span class="s2">= </span><span class="s1">diff</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s6"># There is a slight overhead, so the allocated size won't exactly be N</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertGreaterEqual</span><span class="s2">(</span><span class="s1">stat</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLess</span><span class="s2">(</span><span class="s1">stat</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">N </span><span class="s2">* </span><span class="s4">1.015</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=(</span><span class="s3">&quot;Unexpected allocation overhead encountered. &quot;</span>
                             <span class="s3">&quot;May be due to difference in CPython &quot;</span>
                             <span class="s3">&quot;builds or running under coverage&quot;</span><span class="s2">))</span>
        <span class="s1">frame </span><span class="s2">= </span><span class="s1">stat</span><span class="s2">.</span><span class="s1">traceback</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">basename</span><span class="s2">(</span><span class="s1">frame</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">), </span><span class="s3">&quot;test_nrt.py&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">frame</span><span class="s2">.</span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">alloc_lineno</span><span class="s2">)</span>

        <span class="s6"># If NRT memory is released before taking a snapshot, it shouldn't</span>
        <span class="s6"># appear.</span>
        <span class="s1">diff </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">measure_memory_diff</span><span class="s2">(</span><span class="s1">release_memory</span><span class="s2">)</span>
        <span class="s1">stat </span><span class="s2">= </span><span class="s1">diff</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s6"># Something else appears, but nothing the magnitude of N</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLess</span><span class="s2">(</span><span class="s1">stat</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">N </span><span class="s2">* </span><span class="s4">0.01</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestNRTIssue</span><span class="s2">(</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_issue_with_refct_op_pruning</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        GitHub Issue #1244 https://github.com/numba/numba/issues/1244 
        &quot;&quot;&quot;</span>
        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">calculate_2D_vector_mag</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">vector</span>

            <span class="s0">return </span><span class="s1">math</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">x </span><span class="s2">** </span><span class="s4">2 </span><span class="s2">+ </span><span class="s1">y </span><span class="s2">** </span><span class="s4">2</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">normalize_2D_vector</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">):</span>
            <span class="s1">normalized_vector </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

            <span class="s1">mag </span><span class="s2">= </span><span class="s1">calculate_2D_vector_mag</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">vector</span>

            <span class="s1">normalized_vector</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s1">x </span><span class="s2">/ </span><span class="s1">mag</span>
            <span class="s1">normalized_vector</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] = </span><span class="s1">y </span><span class="s2">/ </span><span class="s1">mag</span>

            <span class="s0">return </span><span class="s1">normalized_vector</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">normalize_vectors</span><span class="s2">(</span><span class="s1">num_vectors</span><span class="s2">, </span><span class="s1">vectors</span><span class="s2">):</span>
            <span class="s1">normalized_vectors </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">num_vectors</span><span class="s2">, </span><span class="s4">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">num_vectors</span><span class="s2">):</span>
                <span class="s1">vector </span><span class="s2">= </span><span class="s1">vectors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

                <span class="s1">normalized_vector </span><span class="s2">= </span><span class="s1">normalize_2D_vector</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">)</span>

                <span class="s1">normalized_vectors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">, </span><span class="s4">0</span><span class="s2">] = </span><span class="s1">normalized_vector</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
                <span class="s1">normalized_vectors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] = </span><span class="s1">normalized_vector</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>

            <span class="s0">return </span><span class="s1">normalized_vectors</span>

        <span class="s1">num_vectors </span><span class="s2">= </span><span class="s4">10</span>
        <span class="s1">test_vectors </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">random</span><span class="s2">((</span><span class="s1">num_vectors</span><span class="s2">, </span><span class="s4">2</span><span class="s2">))</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">normalize_vectors</span><span class="s2">(</span><span class="s1">num_vectors</span><span class="s2">, </span><span class="s1">test_vectors</span><span class="s2">)</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">normalize_vectors</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">num_vectors</span><span class="s2">, </span><span class="s1">test_vectors</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_almost_equal</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_incref_after_cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Issue #1427: when casting a value before returning it, the</span>
        <span class="s6"># cast result should be incref'ed, not the original value.</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">)</span>

        <span class="s6"># Note the return type isn't the same as the tuple type above:</span>
        <span class="s6"># the first element is a complex rather than a float.</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">njit</span><span class="s2">((</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">((</span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">,</span>
                                   <span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">) )))())(</span><span class="s1">f</span><span class="s2">)</span>
        <span class="s1">z</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertPreciseEqual</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s4">0j</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertPreciseEqual</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_refct_pruning_issue_1511</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">[:]</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">f</span><span class="s2">()</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_refct_pruning_issue_1526</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">udt</span><span class="s2">(</span><span class="s1">image</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s1">next_loc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">image </span><span class="s2">== </span><span class="s4">1</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">next_loc</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]) == </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">y_offset </span><span class="s2">= </span><span class="s4">1</span>
                <span class="s1">x_offset </span><span class="s2">= </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">y_offset </span><span class="s2">= </span><span class="s1">next_loc</span><span class="s2">[</span><span class="s4">0</span><span class="s2">][</span><span class="s4">0</span><span class="s2">]</span>
                <span class="s1">x_offset </span><span class="s2">= </span><span class="s1">next_loc</span><span class="s2">[</span><span class="s4">1</span><span class="s2">][</span><span class="s4">0</span><span class="s2">]</span>

            <span class="s1">next_loc_x </span><span class="s2">= (</span><span class="s1">x </span><span class="s2">- </span><span class="s4">1</span><span class="s2">) + </span><span class="s1">x_offset</span>
            <span class="s1">next_loc_y </span><span class="s2">= (</span><span class="s1">y </span><span class="s2">- </span><span class="s4">1</span><span class="s2">) + </span><span class="s1">y_offset</span>

            <span class="s0">return </span><span class="s1">next_loc_x</span><span class="s2">, </span><span class="s1">next_loc_y</span>

        <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">]])</span>
        <span class="s1">expect </span><span class="s2">= </span><span class="s1">udt</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s2">)</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">udt</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">expect</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">TestCase</span><span class="s2">.</span><span class="s1">run_test_in_subprocess</span>
    <span class="s0">def </span><span class="s1">test_no_nrt_on_njit_decoration</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that the NRT is not initialized/compiled as a result of</span>
        <span class="s6"># decorating a function with `@njit`.</span>
        <span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">njit</span>

        <span class="s6"># check the NRT is not initialized.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">_init</span><span class="s2">)</span>

        <span class="s6"># decorate</span>
        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">foo</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s4">123</span>

        <span class="s6"># check the NRT is still not initialized</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">_init</span><span class="s2">)</span>

        <span class="s6"># execute</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">foo</span><span class="s2">(), </span><span class="s1">foo</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">())</span>

        <span class="s6"># check the NRT is still now initialized as execution has definitely</span>
        <span class="s6"># occurred.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">_init</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestRefCtPruning</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>

    <span class="s1">sample_llvm_ir </span><span class="s2">= </span><span class="s3">''' 
define i32 @&quot;MyFunction&quot;(i8** noalias nocapture %retptr, { i8*, i32 }** noalias nocapture %excinfo, i8* noalias nocapture readnone %env, double %arg.vt.0, double %arg.vt.1, double %arg.vt.2, double %arg.vt.3, double %arg.bounds.0, double %arg.bounds.1, double %arg.bounds.2, double %arg.bounds.3, i8* %arg.xs.0, i8* nocapture readnone %arg.xs.1, i64 %arg.xs.2, i64 %arg.xs.3, double* nocapture readonly %arg.xs.4, i64 %arg.xs.5.0, i64 %arg.xs.6.0, i8* %arg.ys.0, i8* nocapture readnone %arg.ys.1, i64 %arg.ys.2, i64 %arg.ys.3, double* nocapture readonly %arg.ys.4, i64 %arg.ys.5.0, i64 %arg.ys.6.0, i8* %arg.aggs_and_cols.0.0, i8* nocapture readnone %arg.aggs_and_cols.0.1, i64 %arg.aggs_and_cols.0.2, i64 %arg.aggs_and_cols.0.3, i32* nocapture %arg.aggs_and_cols.0.4, i64 %arg.aggs_and_cols.0.5.0, i64 %arg.aggs_and_cols.0.5.1, i64 %arg.aggs_and_cols.0.6.0, i64 %arg.aggs_and_cols.0.6.1) local_unnamed_addr { 
entry: 
tail call void @NRT_incref(i8* %arg.xs.0) 
tail call void @NRT_incref(i8* %arg.ys.0) 
tail call void @NRT_incref(i8* %arg.aggs_and_cols.0.0) 
%.251 = icmp sgt i64 %arg.xs.5.0, 0 
br i1 %.251, label %B42.preheader, label %B160 
 
B42.preheader:                                    ; preds = %entry 
%0 = add i64 %arg.xs.5.0, 1 
br label %B42 
 
B42:                                              ; preds = %B40.backedge, %B42.preheader 
%lsr.iv3 = phi i64 [ %lsr.iv.next, %B40.backedge ], [ %0, %B42.preheader ] 
%lsr.iv1 = phi double* [ %scevgep2, %B40.backedge ], [ %arg.xs.4, %B42.preheader ] 
%lsr.iv = phi double* [ %scevgep, %B40.backedge ], [ %arg.ys.4, %B42.preheader ] 
%.381 = load double, double* %lsr.iv1, align 8 
%.420 = load double, double* %lsr.iv, align 8 
%.458 = fcmp ole double %.381, %arg.bounds.1 
%not..432 = fcmp oge double %.381, %arg.bounds.0 
%&quot;$phi82.1.1&quot; = and i1 %.458, %not..432 
br i1 %&quot;$phi82.1.1&quot;, label %B84, label %B40.backedge 
 
B84:                                              ; preds = %B42 
%.513 = fcmp ole double %.420, %arg.bounds.3 
%not..487 = fcmp oge double %.420, %arg.bounds.2 
%&quot;$phi106.1.1&quot; = and i1 %.513, %not..487 
br i1 %&quot;$phi106.1.1&quot;, label %B108.endif.endif.endif, label %B40.backedge 
 
B160:                                             ; preds = %B40.backedge, %entry 
tail call void @NRT_decref(i8* %arg.ys.0) 
tail call void @NRT_decref(i8* %arg.xs.0) 
tail call void @NRT_decref(i8* %arg.aggs_and_cols.0.0) 
store i8* null, i8** %retptr, align 8 
ret i32 0 
 
B108.endif.endif.endif:                           ; preds = %B84 
%.575 = fmul double %.381, %arg.vt.0 
%.583 = fadd double %.575, %arg.vt.1 
%.590 = fptosi double %.583 to i64 
%.630 = fmul double %.420, %arg.vt.2 
%.638 = fadd double %.630, %arg.vt.3 
%.645 = fptosi double %.638 to i64 
tail call void @NRT_incref(i8* %arg.aggs_and_cols.0.0)              ; GONE 1 
tail call void @NRT_decref(i8* null)                                ; GONE 2 
tail call void @NRT_incref(i8* %arg.aggs_and_cols.0.0), !noalias !0 ; GONE 3 
%.62.i.i = icmp slt i64 %.645, 0 
%.63.i.i = select i1 %.62.i.i, i64 %arg.aggs_and_cols.0.5.0, i64 0 
%.64.i.i = add i64 %.63.i.i, %.645 
%.65.i.i = icmp slt i64 %.590, 0 
%.66.i.i = select i1 %.65.i.i, i64 %arg.aggs_and_cols.0.5.1, i64 0 
%.67.i.i = add i64 %.66.i.i, %.590 
%.84.i.i = mul i64 %.64.i.i, %arg.aggs_and_cols.0.5.1 
%.87.i.i = add i64 %.67.i.i, %.84.i.i 
%.88.i.i = getelementptr i32, i32* %arg.aggs_and_cols.0.4, i64 %.87.i.i 
%.89.i.i = load i32, i32* %.88.i.i, align 4, !noalias !3 
%.99.i.i = add i32 %.89.i.i, 1 
store i32 %.99.i.i, i32* %.88.i.i, align 4, !noalias !3 
tail call void @NRT_decref(i8* %arg.aggs_and_cols.0.0), !noalias !0 ; GONE 4 
tail call void @NRT_decref(i8* %arg.aggs_and_cols.0.0)              ; GONE 5 
br label %B40.backedge 
 
B40.backedge:                                     ; preds = %B108.endif.endif.endif, %B84, %B42 
%scevgep = getelementptr double, double* %lsr.iv, i64 1 
%scevgep2 = getelementptr double, double* %lsr.iv1, i64 1 
%lsr.iv.next = add i64 %lsr.iv3, -1 
%.294 = icmp sgt i64 %lsr.iv.next, 1 
br i1 %.294, label %B42, label %B160 
} 
    ''' </span><span class="s6"># noqa</span>

    <span class="s0">def </span><span class="s1">test_refct_pruning_op_recognize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">input_ir </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_llvm_ir</span>
        <span class="s1">input_lines </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">input_ir</span><span class="s2">.</span><span class="s1">splitlines</span><span class="s2">())</span>
        <span class="s1">before_increfs </span><span class="s2">= [</span><span class="s1">ln </span><span class="s0">for </span><span class="s1">ln </span><span class="s0">in </span><span class="s1">input_lines </span><span class="s0">if </span><span class="s3">'NRT_incref' </span><span class="s0">in </span><span class="s1">ln</span><span class="s2">]</span>
        <span class="s1">before_decrefs </span><span class="s2">= [</span><span class="s1">ln </span><span class="s0">for </span><span class="s1">ln </span><span class="s0">in </span><span class="s1">input_lines </span><span class="s0">if </span><span class="s3">'NRT_decref' </span><span class="s0">in </span><span class="s1">ln</span><span class="s2">]</span>

        <span class="s6"># prune</span>
        <span class="s1">output_ir </span><span class="s2">= </span><span class="s1">nrtopt</span><span class="s2">.</span><span class="s1">_remove_redundant_nrt_refct</span><span class="s2">(</span><span class="s1">input_ir</span><span class="s2">)</span>
        <span class="s1">output_lines </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">output_ir</span><span class="s2">.</span><span class="s1">splitlines</span><span class="s2">())</span>
        <span class="s1">after_increfs </span><span class="s2">= [</span><span class="s1">ln </span><span class="s0">for </span><span class="s1">ln </span><span class="s0">in </span><span class="s1">output_lines </span><span class="s0">if </span><span class="s3">'NRT_incref' </span><span class="s0">in </span><span class="s1">ln</span><span class="s2">]</span>
        <span class="s1">after_decrefs </span><span class="s2">= [</span><span class="s1">ln </span><span class="s0">for </span><span class="s1">ln </span><span class="s0">in </span><span class="s1">output_lines </span><span class="s0">if </span><span class="s3">'NRT_decref' </span><span class="s0">in </span><span class="s1">ln</span><span class="s2">]</span>

        <span class="s6"># check</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotEqual</span><span class="s2">(</span><span class="s1">before_increfs</span><span class="s2">, </span><span class="s1">after_increfs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotEqual</span><span class="s2">(</span><span class="s1">before_decrefs</span><span class="s2">, </span><span class="s1">after_decrefs</span><span class="s2">)</span>

        <span class="s1">pruned_increfs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">before_increfs</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">after_increfs</span><span class="s2">)</span>
        <span class="s1">pruned_decrefs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">before_decrefs</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">after_decrefs</span><span class="s2">)</span>

        <span class="s6"># the symm difference == or-combined</span>
        <span class="s1">combined </span><span class="s2">= </span><span class="s1">pruned_increfs </span><span class="s2">| </span><span class="s1">pruned_decrefs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">, </span><span class="s1">pruned_increfs </span><span class="s2">^ </span><span class="s1">pruned_decrefs</span><span class="s2">)</span>
        <span class="s1">pruned_lines </span><span class="s2">= </span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">)</span>

        <span class="s6"># all GONE lines are pruned</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">]:</span>
            <span class="s1">gone </span><span class="s2">= </span><span class="s3">'; GONE {}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">gone</span><span class="s2">, </span><span class="s1">pruned_lines</span><span class="s2">)</span>
        <span class="s6"># no other lines</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">pruned_lines</span><span class="s2">.</span><span class="s1">splitlines</span><span class="s2">())), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s3">&quot;Pass removed as it was buggy. Re-enable when fixed.&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_refct_pruning_with_branches</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">'''testcase from #2350'''</span>
        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">_append_non_na</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">agg</span><span class="s2">, </span><span class="s1">field</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">field</span><span class="s2">):</span>
                <span class="s1">agg</span><span class="s2">[</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">] += </span><span class="s4">1</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">_append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">agg</span><span class="s2">, </span><span class="s1">field</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">field</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">agg</span><span class="s2">[</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">]):</span>
                    <span class="s1">agg</span><span class="s2">[</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">] = </span><span class="s1">field</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">agg</span><span class="s2">[</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">] += </span><span class="s1">field</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">agg</span><span class="s2">, </span><span class="s1">field</span><span class="s2">):</span>
            <span class="s1">_append_non_na</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">agg</span><span class="s2">, </span><span class="s1">field</span><span class="s2">)</span>
            <span class="s1">_append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">agg</span><span class="s2">, </span><span class="s1">field</span><span class="s2">)</span>

        <span class="s6"># Disable python wrapper to avoid detecting necessary</span>
        <span class="s6"># refcount inside it</span>
        <span class="s2">@</span><span class="s1">njit</span><span class="s2">(</span><span class="s1">no_cpython_wrapper</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">extend</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">field</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]):</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]):</span>
                    <span class="s1">append</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">field</span><span class="s2">)</span>

        <span class="s6"># Compile</span>
        <span class="s1">extend</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s3">&quot;(f4[:,::1], f4)&quot;</span><span class="s2">)</span>

        <span class="s6"># Test there are no reference count operations</span>
        <span class="s1">llvmir </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">extend</span><span class="s2">.</span><span class="s1">inspect_llvm</span><span class="s2">(</span><span class="s1">extend</span><span class="s2">.</span><span class="s1">signatures</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]))</span>
        <span class="s1">refops </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">re</span><span class="s2">.</span><span class="s1">finditer</span><span class="s2">(</span><span class="s3">r'(NRT_incref|NRT_decref)\([^\)]+\)'</span><span class="s2">, </span><span class="s1">llvmir</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">refops</span><span class="s2">), </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">linux_only</span>
    <span class="s2">@</span><span class="s1">x86_only</span>
    <span class="s0">def </span><span class="s1">test_inline_asm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;The InlineAsm class from llvmlite.ir has no 'name' attr the refcount 
        pruning pass should be tolerant to this&quot;&quot;&quot;</span>
        <span class="s1">llvm</span><span class="s2">.</span><span class="s1">initialize</span><span class="s2">()</span>
        <span class="s1">llvm</span><span class="s2">.</span><span class="s1">initialize_native_target</span><span class="s2">()</span>
        <span class="s1">llvm</span><span class="s2">.</span><span class="s1">initialize_native_asmprinter</span><span class="s2">()</span>
        <span class="s1">llvm</span><span class="s2">.</span><span class="s1">initialize_native_asmparser</span><span class="s2">()</span>

        <span class="s2">@</span><span class="s1">intrinsic</span>
        <span class="s0">def </span><span class="s1">bar</span><span class="s2">(</span><span class="s1">tyctx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">codegen</span><span class="s2">(</span><span class="s1">cgctx</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s2">(</span><span class="s1">arg_0</span><span class="s2">, </span><span class="s1">arg_1</span><span class="s2">) = </span><span class="s1">args</span>
                <span class="s1">fty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s4">32</span><span class="s2">), [</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s4">32</span><span class="s2">),</span>
                                                       <span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s4">32</span><span class="s2">)])</span>
                <span class="s1">mul </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">asm</span><span class="s2">(</span><span class="s1">fty</span><span class="s2">, </span><span class="s3">&quot;mov $2, $0; imul $1, $0&quot;</span><span class="s2">, </span><span class="s3">&quot;=&amp;r,r,r&quot;</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">arg_0</span><span class="s2">, </span><span class="s1">arg_1</span><span class="s2">), </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;asm_mul&quot;</span><span class="s2">,</span>
                                  <span class="s1">side_effect</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">cgctx</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">mul</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">), </span><span class="s1">codegen</span>

        <span class="s2">@</span><span class="s1">njit</span><span class="s2">([</span><span class="s3">'int32(int32)'</span><span class="s2">])</span>
        <span class="s0">def </span><span class="s1">foo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s1">x </span><span class="s2">+= </span><span class="s4">1</span>
            <span class="s1">z </span><span class="s2">= </span><span class="s1">bar</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">z</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">foo</span><span class="s2">(</span><span class="s4">10</span><span class="s2">), </span><span class="s4">22</span><span class="s2">) </span><span class="s6"># expect (10 + 1) * 2 = 22</span>


<span class="s2">@</span><span class="s1">skip_unless_cffi</span>
<span class="s0">class </span><span class="s1">TestNrtExternalCFFI</span><span class="s2">(</span><span class="s1">EnableNRTStatsMixin</span><span class="s2">, </span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Testing the use of externally compiled C code that use NRT 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># initialize the NRT (in case the tests are run in isolation)</span>
        <span class="s1">cpu_target</span><span class="s2">.</span><span class="s1">target_context</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TestNrtExternalCFFI</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">setUp</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">compile_cffi_module</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">cdef</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">cffi </span><span class="s0">import </span><span class="s1">FFI</span>

        <span class="s1">ffi </span><span class="s2">= </span><span class="s1">FFI</span><span class="s2">()</span>
        <span class="s1">ffi</span><span class="s2">.</span><span class="s1">set_source</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">include_dirs</span><span class="s2">=[</span><span class="s1">include_path</span><span class="s2">()])</span>
        <span class="s1">ffi</span><span class="s2">.</span><span class="s1">cdef</span><span class="s2">(</span><span class="s1">cdef</span><span class="s2">)</span>
        <span class="s1">tmpdir </span><span class="s2">= </span><span class="s1">temp_directory</span><span class="s2">(</span><span class="s3">&quot;cffi_test_{}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>
        <span class="s1">ffi</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s1">tmpdir</span><span class="s2">)</span>
        <span class="s1">sys</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">tmpdir</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">mod </span><span class="s2">= </span><span class="s1">import_dynamic</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">tmpdir</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">ffi</span><span class="s2">, </span><span class="s1">mod</span>

    <span class="s0">def </span><span class="s1">get_nrt_api_table</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">cffi </span><span class="s0">import </span><span class="s1">FFI</span>

        <span class="s1">ffi </span><span class="s2">= </span><span class="s1">FFI</span><span class="s2">()</span>
        <span class="s1">nrt_get_api </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s3">&quot;void* (*)()&quot;</span><span class="s2">, </span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">c_helpers</span><span class="s2">[</span><span class="s3">'get_api'</span><span class="s2">])</span>
        <span class="s1">table </span><span class="s2">= </span><span class="s1">nrt_get_api</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">table</span>

    <span class="s0">def </span><span class="s1">test_manage_memory</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s3">&quot;{}_test_manage_memory&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">source </span><span class="s2">= </span><span class="s3">r&quot;&quot;&quot; 
#include &lt;stdio.h&gt; 
#include &quot;numba/core/runtime/nrt_external.h&quot; 
 
int status = 0; 
 
void my_dtor(void *ptr) { 
    free(ptr); 
    status = 0xdead; 
} 
 
NRT_MemInfo* test_nrt_api(NRT_api_functions *nrt) { 
    void * data = malloc(10); 
    NRT_MemInfo *mi = nrt-&gt;manage_memory(data, my_dtor); 
    nrt-&gt;acquire(mi); 
    nrt-&gt;release(mi); 
    status = 0xa110c; 
    return mi; 
} 
        &quot;&quot;&quot;</span>
        <span class="s1">cdef </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot; 
void* test_nrt_api(void *nrt); 
extern int status; 
        &quot;&quot;&quot;</span>

        <span class="s1">ffi</span><span class="s2">, </span><span class="s1">mod </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compile_cffi_module</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">cdef</span><span class="s2">)</span>
        <span class="s6"># Init status is 0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">status</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
        <span class="s1">table </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_nrt_api_table</span><span class="s2">()</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">mod</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">test_nrt_api</span><span class="s2">(</span><span class="s1">table</span><span class="s2">)</span>
        <span class="s6"># status is now 0xa110c</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">status</span><span class="s2">, </span><span class="s4">0xa110c</span><span class="s2">)</span>
        <span class="s1">mi_addr </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s3">&quot;size_t&quot;</span><span class="s2">, </span><span class="s1">out</span><span class="s2">))</span>
        <span class="s1">mi </span><span class="s2">= </span><span class="s1">nrt</span><span class="s2">.</span><span class="s1">MemInfo</span><span class="s2">(</span><span class="s1">mi_addr</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">mi   </span><span class="s6"># force deallocation on mi</span>
        <span class="s6"># status is now 0xdead</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">status</span><span class="s2">, </span><span class="s4">0xdead</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_allocate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s3">&quot;{}_test_allocate&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">source </span><span class="s2">= </span><span class="s3">r&quot;&quot;&quot; 
#include &lt;stdio.h&gt; 
#include &quot;numba/core/runtime/nrt_external.h&quot; 
 
NRT_MemInfo* test_nrt_api(NRT_api_functions *nrt, size_t n) { 
    size_t *data = NULL; 
    NRT_MemInfo *mi = nrt-&gt;allocate(n); 
    data = nrt-&gt;get_data(mi); 
    data[0] = 0xded; 
    data[1] = 0xabc; 
    data[2] = 0xdef; 
    return mi; 
} 
        &quot;&quot;&quot;</span>
        <span class="s1">cdef </span><span class="s2">= </span><span class="s3">&quot;void* test_nrt_api(void *nrt, size_t n);&quot;</span>
        <span class="s1">ffi</span><span class="s2">, </span><span class="s1">mod </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compile_cffi_module</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">cdef</span><span class="s2">)</span>

        <span class="s1">table </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_nrt_api_table</span><span class="s2">()</span>

        <span class="s1">numbytes </span><span class="s2">= </span><span class="s4">3 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">).</span><span class="s1">itemsize</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">mod</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">test_nrt_api</span><span class="s2">(</span><span class="s1">table</span><span class="s2">, </span><span class="s1">numbytes</span><span class="s2">)</span>

        <span class="s1">mi_addr </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s3">&quot;size_t&quot;</span><span class="s2">, </span><span class="s1">out</span><span class="s2">))</span>
        <span class="s1">mi </span><span class="s2">= </span><span class="s1">nrt</span><span class="s2">.</span><span class="s1">MemInfo</span><span class="s2">(</span><span class="s1">mi_addr</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">.</span><span class="s1">refcount</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>

        <span class="s1">buffer </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">buffer</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s3">&quot;char [{}]&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">numbytes</span><span class="s2">), </span><span class="s1">mi</span><span class="s2">.</span><span class="s1">data</span><span class="s2">))</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=(</span><span class="s4">3</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">buffer</span><span class="s2">=</span><span class="s1">buffer</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, [</span><span class="s4">0xded</span><span class="s2">, </span><span class="s4">0xabc</span><span class="s2">, </span><span class="s4">0xdef</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">test_get_api</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">cffi </span><span class="s0">import </span><span class="s1">FFI</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">test_nrt_api</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s1">NRT_get_api</span><span class="s2">()</span>

        <span class="s1">ffi </span><span class="s2">= </span><span class="s1">FFI</span><span class="s2">()</span>
        <span class="s1">expect </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s3">'size_t'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_nrt_api_table</span><span class="s2">()))</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">test_nrt_api</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">expect</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestNrtStatistics</span><span class="s2">(</span><span class="s1">TestCase</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Store the current stats state</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__stats_state </span><span class="s2">= </span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">tearDown</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Set stats state back to whatever it was before the test ran</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__stats_state</span><span class="s2">:</span>
            <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_enable_stats</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_disable_stats</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_stats_env_var_explicit_on</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that explicitly turning the stats on via the env var works.</span>
        <span class="s1">src </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot;if 1: 
        from numba import njit 
        import numpy as np 
        from numba.core.runtime import rtsys, _nrt_python 
        from numba.core.registry import cpu_target 
 
        @njit 
        def foo(): 
            return np.arange(10)[0] 
 
        # initialize the NRT before use 
        rtsys.initialize(cpu_target.target_context) 
        assert _nrt_python.memsys_stats_enabled() 
        orig_stats = rtsys.get_allocation_stats() 
        foo() 
        new_stats = rtsys.get_allocation_stats() 
        total_alloc = new_stats.alloc - orig_stats.alloc 
        total_free = new_stats.free - orig_stats.free 
        total_mi_alloc = new_stats.mi_alloc - orig_stats.mi_alloc 
        total_mi_free = new_stats.mi_free - orig_stats.mi_free 
 
        expected = 1 
        assert total_alloc == expected 
        assert total_free == expected 
        assert total_mi_alloc == expected 
        assert total_mi_free == expected 
        &quot;&quot;&quot;</span>
        <span class="s6"># Check env var explicitly being set works</span>
        <span class="s1">env </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">environ</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">env</span><span class="s2">[</span><span class="s3">'NUMBA_NRT_STATS'</span><span class="s2">] = </span><span class="s3">&quot;1&quot;</span>
        <span class="s1">run_in_subprocess</span><span class="s2">(</span><span class="s1">src</span><span class="s2">, </span><span class="s1">env</span><span class="s2">=</span><span class="s1">env</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_env_var_off</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">):</span>

        <span class="s1">src </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot;if 1: 
        from numba import njit 
        import numpy as np 
        from numba.core.runtime import rtsys, _nrt_python 
 
        @njit 
        def foo(): 
            return np.arange(10)[0] 
 
        assert _nrt_python.memsys_stats_enabled() == False 
        try: 
            rtsys.get_allocation_stats() 
        except RuntimeError as e: 
            assert &quot;NRT stats are disabled.&quot; in str(e) 
        &quot;&quot;&quot;</span>
        <span class="s1">run_in_subprocess</span><span class="s2">(</span><span class="s1">src</span><span class="s2">, </span><span class="s1">env</span><span class="s2">=</span><span class="s1">env</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_stats_env_var_explicit_off</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that explicitly turning the stats off via the env var works.</span>
        <span class="s1">env </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">environ</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">env</span><span class="s2">[</span><span class="s3">'NUMBA_NRT_STATS'</span><span class="s2">] = </span><span class="s3">&quot;0&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_env_var_off</span><span class="s2">(</span><span class="s1">env</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_stats_env_var_default_off</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that the env var not being set is the same as &quot;off&quot;, i.e.</span>
        <span class="s6"># default for Numba is off.</span>
        <span class="s1">env </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">environ</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">env</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'NUMBA_NRT_STATS'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_env_var_off</span><span class="s2">(</span><span class="s1">env</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_stats_status_toggle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">foo</span><span class="s2">():</span>
            <span class="s1">tmp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">3</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">5 </span><span class="s2">* </span><span class="s1">tmp</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])</span>

        <span class="s6"># Switch on stats</span>
        <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_enable_stats</span><span class="s2">()</span>
        <span class="s6"># check the stats are on</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">())</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">2</span><span class="s2">):</span>
            <span class="s6"># capture the stats state</span>
            <span class="s1">stats_1 </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">get_allocation_stats</span><span class="s2">()</span>
            <span class="s6"># Switch off stats</span>
            <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_disable_stats</span><span class="s2">()</span>
            <span class="s6"># check the stats are off</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">())</span>
            <span class="s6"># run something that would move the counters were they enabled</span>
            <span class="s1">foo</span><span class="s2">()</span>
            <span class="s6"># Switch on stats</span>
            <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_enable_stats</span><span class="s2">()</span>
            <span class="s6"># check the stats are on</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">())</span>
            <span class="s6"># capture the stats state (should not have changed)</span>
            <span class="s1">stats_2 </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">get_allocation_stats</span><span class="s2">()</span>
            <span class="s6"># run something that will move the counters</span>
            <span class="s1">foo</span><span class="s2">()</span>
            <span class="s6"># capture the stats state (should have changed)</span>
            <span class="s1">stats_3 </span><span class="s2">= </span><span class="s1">rtsys</span><span class="s2">.</span><span class="s1">get_allocation_stats</span><span class="s2">()</span>
            <span class="s6"># check stats_1 == stats_2</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">stats_1</span><span class="s2">, </span><span class="s1">stats_2</span><span class="s2">)</span>
            <span class="s6"># check stats_2 &lt; stats_3</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLess</span><span class="s2">(</span><span class="s1">stats_2</span><span class="s2">, </span><span class="s1">stats_3</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_rtsys_stats_query_raises_exception_when_disabled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks that the standard rtsys.get_allocation_stats() query raises</span>
        <span class="s6"># when stats counters are turned off.</span>

        <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_disable_stats</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">())</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">rtsys</span><span class="s2">.</span><span class="s1">get_allocation_stats</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s3">&quot;NRT stats are disabled.&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_nrt_explicit_stats_query_raises_exception_when_disabled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># Checks the various memsys_get_stats functions raise if queried when</span>
        <span class="s6"># the stats counters are disabled.</span>
        <span class="s1">method_variations </span><span class="s2">= (</span><span class="s3">'alloc'</span><span class="s2">, </span><span class="s3">'free'</span><span class="s2">, </span><span class="s3">'mi_alloc'</span><span class="s2">, </span><span class="s3">'mi_free'</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">meth </span><span class="s0">in </span><span class="s1">method_variations</span><span class="s2">:</span>
            <span class="s1">stats_func </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">, </span><span class="s3">f'memsys_get_stats_</span><span class="s0">{</span><span class="s1">meth</span><span class="s0">}</span><span class="s3">'</span><span class="s2">)</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">subTest</span><span class="s2">(</span><span class="s1">stats_func</span><span class="s2">=</span><span class="s1">stats_func</span><span class="s2">):</span>
                <span class="s6"># Turn stats off</span>
                <span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_disable_stats</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertFalse</span><span class="s2">(</span><span class="s1">_nrt_python</span><span class="s2">.</span><span class="s1">memsys_stats_enabled</span><span class="s2">())</span>
                <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
                    <span class="s1">stats_func</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s3">&quot;NRT stats are disabled.&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>


<span class="s0">if </span><span class="s1">__name__ </span><span class="s2">== </span><span class="s3">'__main__'</span><span class="s2">:</span>
    <span class="s1">unittest</span><span class="s2">.</span><span class="s1">main</span><span class="s2">()</span>
</pre>
</body>
</html>