<html>
<head>
<title>deviceufunc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
deviceufunc.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implements custom ufunc dispatch mechanism for non-CPU devices. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">ABCMeta</span><span class="s3">, </span><span class="s1">abstractmethod</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">ufuncbuilder </span><span class="s2">import </span><span class="s1">_BaseUFuncBuilder</span><span class="s3">, </span><span class="s1">parse_identity</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">sigutils</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ufunc</span><span class="s3">.</span><span class="s1">sigparse </span><span class="s2">import </span><span class="s1">parse_signature</span>


<span class="s2">def </span><span class="s1">_broadcast_axis</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises 
    ------ 
    ValueError if broadcast fails 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">a </span><span class="s3">== </span><span class="s1">b</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">a</span>
    <span class="s2">elif </span><span class="s1">a </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">b</span>
    <span class="s2">elif </span><span class="s1">b </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">a</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;failed to broadcast {0} and {1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_pairwise_broadcast</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">, </span><span class="s1">shape2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises 
    ------ 
    ValueError if broadcast fails 
    &quot;&quot;&quot;</span>
    <span class="s1">shape1</span><span class="s3">, </span><span class="s1">shape2 </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">, [</span><span class="s1">shape1</span><span class="s3">, </span><span class="s1">shape2</span><span class="s3">])</span>

    <span class="s2">while </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape2</span><span class="s3">):</span>
        <span class="s1">shape1 </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">,) + </span><span class="s1">shape1</span>

    <span class="s2">while </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">) &gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape2</span><span class="s3">):</span>
        <span class="s1">shape2 </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">,) + </span><span class="s1">shape2</span>

    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">_broadcast_axis</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">, </span><span class="s1">shape2</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_multi_broadcast</span><span class="s3">(*</span><span class="s1">shapelist</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raises 
    ------ 
    ValueError if broadcast fails 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">shapelist</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">shapelist</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">others </span><span class="s3">= </span><span class="s1">shapelist</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">each </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">others</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s4">1</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">_pairwise_broadcast</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">each</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;failed to broadcast argument #{0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">i</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">UFuncMechanism</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Prepare ufunc arguments for vectorize. 
    &quot;&quot;&quot;</span>
    <span class="s1">DEFAULT_STREAM </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">SUPPORT_DEVICE_SLICING </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Never used directly by user. Invoke by UFuncMechanism.call(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typemap </span><span class="s3">= </span><span class="s1">typemap</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">nargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">nargs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">scalarpos </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">arrays </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">nargs</span>

    <span class="s2">def </span><span class="s1">_fill_arrays</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get all arguments in array form 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">as_device_array</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">)):</span>
                <span class="s6"># Is scalar</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">scalarpos</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fill_argtypes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get dtypes 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ary </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">ary </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">dtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">).</span><span class="s1">dtype</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dtype</span>

    <span class="s2">def </span><span class="s1">_resolve_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Resolve signature. 
        May have ambiguous case. 
        &quot;&quot;&quot;</span>
        <span class="s1">matches </span><span class="s3">= []</span>
        <span class="s6"># Resolve scalar args exact match first</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scalarpos</span><span class="s3">:</span>
            <span class="s6"># Try resolve scalar arguments</span>
            <span class="s2">for </span><span class="s1">formaltys </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">:</span>
                <span class="s1">match_map </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">formal</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">formaltys</span><span class="s3">,</span>
                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">)):</span>
                    <span class="s2">if </span><span class="s1">actual </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s1">actual </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]).</span><span class="s1">dtype</span>

                    <span class="s1">match_map</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">actual </span><span class="s3">== </span><span class="s1">formal</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">match_map</span><span class="s3">):</span>
                    <span class="s1">matches</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">formaltys</span><span class="s3">)</span>

        <span class="s6"># No matching with exact match; try coercing the scalar arguments</span>
        <span class="s2">if not </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s1">matches </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">formaltys </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">:</span>
                <span class="s1">all_matches </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span><span class="s1">actual </span><span class="s2">is None or </span><span class="s1">formal </span><span class="s3">== </span><span class="s1">actual</span>
                                  <span class="s2">for </span><span class="s1">formal</span><span class="s3">, </span><span class="s1">actual </span><span class="s2">in</span>
                                  <span class="s1">zip</span><span class="s3">(</span><span class="s1">formaltys</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">))</span>
                <span class="s2">if </span><span class="s1">all_matches</span><span class="s3">:</span>
                    <span class="s1">matches</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">formaltys</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">matches</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;No matching version.  GPU ufunc requires array &quot;</span>
                            <span class="s5">&quot;arguments to have the exact types.  This behaves &quot;</span>
                            <span class="s5">&quot;like regular ufunc with casting='no'.&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">matches</span><span class="s3">) &gt; </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;Failed to resolve ufunc due to ambiguous &quot;</span>
                            <span class="s5">&quot;signature. Too many untyped scalars. &quot;</span>
                            <span class="s5">&quot;Use numpy dtype object to type tag.&quot;</span><span class="s3">)</span>

        <span class="s6"># Try scalar arguments</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes </span><span class="s3">= </span><span class="s1">matches</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_actual_args</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return the actual arguments 
        Casts scalar arguments to np.array. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scalarpos</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span>

    <span class="s2">def </span><span class="s1">_broadcast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arys</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Perform numpy ufunc broadcasting 
        &quot;&quot;&quot;</span>
        <span class="s1">shapelist </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arys</span><span class="s3">]</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">_multi_broadcast</span><span class="s3">(*</span><span class="s1">shapelist</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ary </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">arys</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">pass</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
                    <span class="s1">arys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">broadcast_device</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">ax_differs </span><span class="s3">= [</span><span class="s1">ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">))</span>
                                  <span class="s2">if </span><span class="s1">ax </span><span class="s3">&gt;= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim</span>
                                  <span class="s2">or </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] != </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">]]</span>

                    <span class="s1">missingdim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
                    <span class="s1">strides </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">missingdim </span><span class="s3">+ </span><span class="s1">list</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>

                    <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">ax_differs</span><span class="s3">:</span>
                        <span class="s1">strides</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] = </span><span class="s4">0</span>

                    <span class="s1">strided </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">stride_tricks</span><span class="s3">.</span><span class="s1">as_strided</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">,</span>
                                                              <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">,</span>
                                                              <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">)</span>

                    <span class="s1">arys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">force_array_layout</span><span class="s3">(</span><span class="s1">strided</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">arys</span>

    <span class="s2">def </span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Prepare and return the arguments for the ufunc. 
        Does not call to_device(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fill_arrays</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fill_argtypes</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_resolve_signature</span><span class="s3">()</span>
        <span class="s1">arys </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_actual_args</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_broadcast</span><span class="s3">(</span><span class="s1">arys</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns (result_dtype, function) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Is the `obj` a device array? 
        Override in subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">as_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Convert the `obj` to a device array 
        Override in subclass 
 
        Default implementation is an identity function 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">broadcast_device</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Handles ondevice broadcasting 
 
        Override in subclass to add support. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">&quot;broadcasting on device is not supported&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">force_array_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Ensures array layout met device requirement. 
 
        Override in sublcass 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ary</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">call</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Perform the entire ufunc call mechanism. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Handle keywords</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">kws</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'stream'</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">DEFAULT_STREAM</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">kws</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'out'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">kws</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;unrecognized keywords: %s&quot; </span><span class="s3">% </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">kws</span><span class="s3">))</span>

        <span class="s6"># Begin call resolution</span>
        <span class="s1">cr </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">get_arguments</span><span class="s3">()</span>
        <span class="s1">resty</span><span class="s3">, </span><span class="s1">func </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">()</span>

        <span class="s1">outshape </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">shape</span>

        <span class="s6"># Adjust output value</span>
        <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None and </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">as_device_array</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">attempt_ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">SUPPORT_DEVICE_SLICING</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError</span>

            <span class="s2">try</span><span class="s3">:</span>
                <span class="s6"># Call the `.ravel()` method</span>
                <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
                <span class="s6"># If it is not a device array</span>
                <span class="s2">if not </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                    <span class="s2">raise</span>
                <span class="s6"># For device array, retry ravel on the host by first</span>
                <span class="s6"># copying it back.</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">hostary </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">to_host</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>
                    <span class="s2">return </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">hostary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s1">args </span><span class="s3">= [</span><span class="s1">attempt_ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>

        <span class="s6"># Prepare argument on the device</span>
        <span class="s1">devarys </span><span class="s3">= []</span>
        <span class="s1">any_device </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">devarys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s1">any_device </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">dev_a </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>
                <span class="s1">devarys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dev_a</span><span class="s3">)</span>

        <span class="s6"># Launch</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">out </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s6"># No output is provided</span>
            <span class="s1">devout </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">allocate_device_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>

            <span class="s1">devarys</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">devout</span><span class="s3">])</span>
            <span class="s1">cr</span><span class="s3">.</span><span class="s1">launch</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">devarys</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">any_device</span><span class="s3">:</span>
                <span class="s6"># If any of the arguments are on device,</span>
                <span class="s6"># Keep output on the device</span>
                <span class="s2">return </span><span class="s1">devout</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">outshape</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># Otherwise, transfer output back to host</span>
                <span class="s2">return </span><span class="s1">devout</span><span class="s3">.</span><span class="s1">copy_to_host</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">outshape</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
            <span class="s6"># If output is provided and it is a device array,</span>
            <span class="s6"># Return device array</span>
            <span class="s2">if </span><span class="s1">out</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">attempt_ravel</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
            <span class="s1">devout </span><span class="s3">= </span><span class="s1">out</span>
            <span class="s1">devarys</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">devout</span><span class="s3">])</span>
            <span class="s1">cr</span><span class="s3">.</span><span class="s1">launch</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">devarys</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">devout</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">outshape</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># If output is provided and it is a host array,</span>
            <span class="s6"># Return host array</span>
            <span class="s2">assert </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">shape</span>
            <span class="s2">assert </span><span class="s1">out</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">resty</span>
            <span class="s1">devout </span><span class="s3">= </span><span class="s1">cr</span><span class="s3">.</span><span class="s1">allocate_device_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>
            <span class="s1">devarys</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s1">devout</span><span class="s3">])</span>
            <span class="s1">cr</span><span class="s3">.</span><span class="s1">launch</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">devarys</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">devout</span><span class="s3">.</span><span class="s1">copy_to_host</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">outshape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">hostary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Implement to device transfer 
        Override in subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">to_host</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">devary</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Implement to host transfer 
        Override in subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">allocate_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Implements device allocation 
        Override in subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">launch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Implements device function invocation 
        Override in subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">def </span><span class="s1">to_dtype</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">EnumMember</span><span class="s3">):</span>
        <span class="s1">ty </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">DeviceVectorize</span><span class="s3">(</span><span class="s1">_BaseUFuncBuilder</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">targetoptions</span><span class="s3">={}):</span>
        <span class="s2">if </span><span class="s1">cache</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;caching is not supported&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">targetoptions</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">opt </span><span class="s3">== </span><span class="s5">'nopython'</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;nopython kwarg for cuda target is redundant&quot;</span><span class="s3">,</span>
                              <span class="s1">RuntimeWarning</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;Unrecognized options. &quot;</span>
                <span class="s1">fmt </span><span class="s3">+= </span><span class="s5">&quot;cuda vectorize target does not support option: '%s'&quot;</span>
                <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s1">fmt </span><span class="s3">% </span><span class="s1">opt</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">py_func </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">identity </span><span class="s3">= </span><span class="s1">parse_identity</span><span class="s3">(</span><span class="s1">identity</span><span class="s3">)</span>
        <span class="s6"># { arg_dtype: (return_dtype), cudakernel }</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap </span><span class="s3">= </span><span class="s1">OrderedDict</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">pyfunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">py_func</span>

    <span class="s2">def </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6"># compile core as device function</span>
        <span class="s1">args</span><span class="s3">, </span><span class="s1">return_type </span><span class="s3">= </span><span class="s1">sigutils</span><span class="s3">.</span><span class="s1">normalize_signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">)</span>
        <span class="s1">devfnsig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

        <span class="s1">funcname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pyfunc</span><span class="s3">.</span><span class="s1">__name__</span>
        <span class="s1">kernelsource </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_kernel_source</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_kernel_template</span><span class="s3">,</span>
                                               <span class="s1">devfnsig</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">corefn</span><span class="s3">, </span><span class="s1">return_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_core</span><span class="s3">(</span><span class="s1">devfnsig</span><span class="s3">)</span>
        <span class="s1">glbl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_globals</span><span class="s3">(</span><span class="s1">corefn</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">void</span><span class="s3">, *([</span><span class="s1">a</span><span class="s3">[:] </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">] + [</span><span class="s1">return_type</span><span class="s3">[:]]))</span>
        <span class="s1">exec</span><span class="s3">(</span><span class="s1">kernelsource</span><span class="s3">, </span><span class="s1">glbl</span><span class="s3">)</span>

        <span class="s1">stager </span><span class="s3">= </span><span class="s1">glbl</span><span class="s3">[</span><span class="s5">'__vectorized_%s' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">]</span>
        <span class="s1">kernel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_kernel</span><span class="s3">(</span><span class="s1">stager</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s1">argdtypes </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">to_dtype</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">devfnsig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">resdtype </span><span class="s3">= </span><span class="s1">to_dtype</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">argdtypes</span><span class="s3">)] = </span><span class="s1">resdtype</span><span class="s3">, </span><span class="s1">kernel</span>

    <span class="s2">def </span><span class="s1">build_ufunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_kernel_source</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">template</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= [</span><span class="s5">'a%d' </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">))]</span>
        <span class="s1">fmts </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">funcname</span><span class="s3">,</span>
                    <span class="s1">args</span><span class="s3">=</span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">args</span><span class="s3">),</span>
                    <span class="s1">argitems</span><span class="s3">=</span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s5">'%s[__tid__]' </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">args</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">template</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(**</span><span class="s1">fmts</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_compile_core</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_globals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">corefn</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_compile_kernel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fnobj</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">DeviceGUFuncVectorize</span><span class="s3">(</span><span class="s1">_BaseUFuncBuilder</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">targetoptions</span><span class="s3">={},</span>
                 <span class="s1">writable_args</span><span class="s3">=()):</span>
        <span class="s2">if </span><span class="s1">cache</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;caching is not supported&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">writable_args</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;writable_args are not supported&quot;</span><span class="s3">)</span>

        <span class="s6"># Allow nopython flag to be set.</span>
        <span class="s2">if not </span><span class="s1">targetoptions</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'nopython'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;nopython flag must be True&quot;</span><span class="s3">)</span>
        <span class="s6"># Are there any more target options?</span>
        <span class="s2">if </span><span class="s1">targetoptions</span><span class="s3">:</span>
            <span class="s1">opts </span><span class="s3">= </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">targetoptions</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()])</span>
            <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;The following target options are not supported: {0}&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">opts</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">py_func </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">identity </span><span class="s3">= </span><span class="s1">parse_identity</span><span class="s3">(</span><span class="s1">identity</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">sig</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">inputsig</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outputsig </span><span class="s3">= </span><span class="s1">parse_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">)</span>

        <span class="s6"># Maps from a tuple of input_dtypes to (output_dtypes, kernel)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap </span><span class="s3">= </span><span class="s1">OrderedDict</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">pyfunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">py_func</span>

    <span class="s2">def </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">indims </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inputsig</span><span class="s3">]</span>
        <span class="s1">outdims </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outputsig</span><span class="s3">]</span>
        <span class="s1">args</span><span class="s3">, </span><span class="s1">return_type </span><span class="s3">= </span><span class="s1">sigutils</span><span class="s3">.</span><span class="s1">normalize_signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s6"># It is only valid to specify types.none as a return type, or to not</span>
        <span class="s6"># specify the return type (where the &quot;Python None&quot; is the return type)</span>
        <span class="s1">valid_return_type </span><span class="s3">= </span><span class="s1">return_type </span><span class="s2">in </span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">valid_return_type</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">'guvectorized functions cannot return values: '</span>
                            <span class="s5">f'signature </span><span class="s2">{</span><span class="s1">sig</span><span class="s2">} </span><span class="s5">specifies </span><span class="s2">{</span><span class="s1">return_type</span><span class="s2">} </span><span class="s5">return '</span>
                           <span class="s5">'type'</span><span class="s3">)</span>

        <span class="s1">funcname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">.</span><span class="s1">__name__</span>
        <span class="s1">src </span><span class="s3">= </span><span class="s1">expand_gufunc_template</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_kernel_template</span><span class="s3">, </span><span class="s1">indims</span><span class="s3">,</span>
                                     <span class="s1">outdims</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

        <span class="s1">glbls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_globals</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s1">exec</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">glbls</span><span class="s3">)</span>
        <span class="s1">fnobj </span><span class="s3">= </span><span class="s1">glbls</span><span class="s3">[</span><span class="s5">'__gufunc_{name}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">funcname</span><span class="s3">)]</span>

        <span class="s1">outertys </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_determine_gufunc_outer_types</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">indims </span><span class="s3">+ </span><span class="s1">outdims</span><span class="s3">))</span>
        <span class="s1">kernel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_kernel</span><span class="s3">(</span><span class="s1">fnobj</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">=</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">outertys</span><span class="s3">))</span>

        <span class="s1">nout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">outdims</span><span class="s3">)</span>
        <span class="s1">dtypes </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">outertys</span><span class="s3">]</span>
        <span class="s1">indtypes </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">dtypes</span><span class="s3">[:-</span><span class="s1">nout</span><span class="s3">])</span>
        <span class="s1">outdtypes </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">dtypes</span><span class="s3">[-</span><span class="s1">nout</span><span class="s3">:])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap</span><span class="s3">[</span><span class="s1">indtypes</span><span class="s3">] = </span><span class="s1">outdtypes</span><span class="s3">, </span><span class="s1">kernel</span>

    <span class="s2">def </span><span class="s1">_compile_kernel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fnobj</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_globals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">def </span><span class="s1">_determine_gufunc_outer_types</span><span class="s3">(</span><span class="s1">argtys</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">at</span><span class="s3">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">argtys</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">at</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">at</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">nd </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">nd </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;gufunc signature mismatch: ndim&gt;0 for scalar&quot;</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">at</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s5">'A'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">expand_gufunc_template</span><span class="s3">(</span><span class="s1">template</span><span class="s3">, </span><span class="s1">indims</span><span class="s3">, </span><span class="s1">outdims</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Expand gufunc source template 
    &quot;&quot;&quot;</span>
    <span class="s1">argdims </span><span class="s3">= </span><span class="s1">indims </span><span class="s3">+ </span><span class="s1">outdims</span>
    <span class="s1">argnames </span><span class="s3">= [</span><span class="s5">&quot;arg{0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">argdims</span><span class="s3">))]</span>
    <span class="s1">checkedarg </span><span class="s3">= </span><span class="s5">&quot;min({0})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">&quot;{0}.shape[0]&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                                              <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">argnames</span><span class="s3">]))</span>
    <span class="s1">inputs </span><span class="s3">= [</span><span class="s1">_gen_src_for_indexing</span><span class="s3">(</span><span class="s1">aref</span><span class="s3">, </span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">)</span>
              <span class="s2">for </span><span class="s1">aref</span><span class="s3">, </span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">argnames</span><span class="s3">, </span><span class="s1">indims</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">)]</span>
    <span class="s1">outputs </span><span class="s3">= [</span><span class="s1">_gen_src_for_indexing</span><span class="s3">(</span><span class="s1">aref</span><span class="s3">, </span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">)</span>
               <span class="s2">for </span><span class="s1">aref</span><span class="s3">, </span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">argnames</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">indims</span><span class="s3">):], </span><span class="s1">outdims</span><span class="s3">,</span>
                                             <span class="s1">argtypes</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">indims</span><span class="s3">):])]</span>
    <span class="s1">argitems </span><span class="s3">= </span><span class="s1">inputs </span><span class="s3">+ </span><span class="s1">outputs</span>
    <span class="s1">src </span><span class="s3">= </span><span class="s1">template</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">funcname</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">argnames</span><span class="s3">),</span>
                          <span class="s1">checkedarg</span><span class="s3">=</span><span class="s1">checkedarg</span><span class="s3">,</span>
                          <span class="s1">argitems</span><span class="s3">=</span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">argitems</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">src</span>


<span class="s2">def </span><span class="s1">_gen_src_for_indexing</span><span class="s3">(</span><span class="s1">aref</span><span class="s3">, </span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s5">&quot;{aref}[{sliced}]&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">aref</span><span class="s3">=</span><span class="s1">aref</span><span class="s3">,</span>
                                     <span class="s1">sliced</span><span class="s3">=</span><span class="s1">_gen_src_index</span><span class="s3">(</span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_gen_src_index</span><span class="s3">(</span><span class="s1">adims</span><span class="s3">, </span><span class="s1">atype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">adims </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">','</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">'__tid__'</span><span class="s3">] + [</span><span class="s5">':'</span><span class="s3">] * </span><span class="s1">adims</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">atype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">atype</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">== </span><span class="s1">adims</span><span class="s3">:</span>
        <span class="s6"># Special case for 0-nd in shape-signature but</span>
        <span class="s6"># 1d array in type signature.</span>
        <span class="s6"># Slice it so that the result has the same dimension.</span>
        <span class="s2">return </span><span class="s5">'__tid__:(__tid__ + 1)'</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">'__tid__'</span>


<span class="s2">class </span><span class="s1">GUFuncEngine</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">'''Determine how to broadcast and execute a gufunc 
    base on input shape and signature 
    '''</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_signature</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">cls</span><span class="s3">(*</span><span class="s1">parse_signature</span><span class="s3">(</span><span class="s1">signature</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inputsig</span><span class="s3">, </span><span class="s1">outputsig</span><span class="s3">):</span>
        <span class="s6"># signatures</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sin </span><span class="s3">= </span><span class="s1">inputsig</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sout </span><span class="s3">= </span><span class="s1">outputsig</span>
        <span class="s6"># argument count</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nin </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nout </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sout</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">schedule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ishapes</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ishapes</span><span class="s3">) != </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">'invalid number of input argument'</span><span class="s3">)</span>

        <span class="s6"># associate symbol values for input signature</span>
        <span class="s1">symbolmap </span><span class="s3">= {}</span>
        <span class="s1">outer_shapes </span><span class="s3">= []</span>
        <span class="s1">inner_shapes </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">argn</span><span class="s3">, (</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">symbols</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">ishapes</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">)):</span>
            <span class="s1">argn </span><span class="s3">+= </span><span class="s4">1  </span><span class="s6"># start from 1 for human</span>
            <span class="s1">inner_ndim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">symbols</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) &lt; </span><span class="s1">inner_ndim</span><span class="s3">:</span>
                <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;arg #%d: insufficient inner dimension&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">fmt </span><span class="s3">% (</span><span class="s1">argn</span><span class="s3">,))</span>
            <span class="s2">if </span><span class="s1">inner_ndim</span><span class="s3">:</span>
                <span class="s1">inner_shape </span><span class="s3">= </span><span class="s1">shape</span><span class="s3">[-</span><span class="s1">inner_ndim</span><span class="s3">:]</span>
                <span class="s1">outer_shape </span><span class="s3">= </span><span class="s1">shape</span><span class="s3">[:-</span><span class="s1">inner_ndim</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">inner_shape </span><span class="s3">= ()</span>
                <span class="s1">outer_shape </span><span class="s3">= </span><span class="s1">shape</span>

            <span class="s2">for </span><span class="s1">axis</span><span class="s3">, (</span><span class="s1">dim</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">inner_shape</span><span class="s3">, </span><span class="s1">symbols</span><span class="s3">)):</span>
                <span class="s1">axis </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">outer_shape</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">symbolmap</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">symbolmap</span><span class="s3">[</span><span class="s1">sym</span><span class="s3">] != </span><span class="s1">dim</span><span class="s3">:</span>
                        <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;arg #%d: shape[%d] mismatch argument&quot;</span>
                        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">fmt </span><span class="s3">% (</span><span class="s1">argn</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">))</span>
                <span class="s1">symbolmap</span><span class="s3">[</span><span class="s1">sym</span><span class="s3">] = </span><span class="s1">dim</span>

            <span class="s1">outer_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">outer_shape</span><span class="s3">)</span>
            <span class="s1">inner_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inner_shape</span><span class="s3">)</span>

        <span class="s6"># solve output shape</span>
        <span class="s1">oshapes </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">outsig </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sout</span><span class="s3">:</span>
            <span class="s1">oshape </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">outsig</span><span class="s3">:</span>
                <span class="s1">oshape</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">symbolmap</span><span class="s3">[</span><span class="s1">sym</span><span class="s3">])</span>
            <span class="s1">oshapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">oshape</span><span class="s3">))</span>

        <span class="s6"># find the biggest outershape as looping dimension</span>
        <span class="s1">sizes </span><span class="s3">= [</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s4">1</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">outer_shapes</span><span class="s3">]</span>
        <span class="s1">largest_i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">)</span>
        <span class="s1">loopdims </span><span class="s3">= </span><span class="s1">outer_shapes</span><span class="s3">[</span><span class="s1">largest_i</span><span class="s3">]</span>

        <span class="s1">pinned </span><span class="s3">= [</span><span class="s2">False</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nin  </span><span class="s6"># same argument for each iteration</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">outer_shapes</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">d </span><span class="s3">!= </span><span class="s1">loopdims</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">d </span><span class="s3">== (</span><span class="s4">1</span><span class="s3">,) </span><span class="s2">or </span><span class="s1">d </span><span class="s3">== ():</span>
                    <span class="s1">pinned</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;arg #%d: outer dimension mismatch&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">fmt </span><span class="s3">% (</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">,))</span>

        <span class="s2">return </span><span class="s1">GUFuncSchedule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inner_shapes</span><span class="s3">, </span><span class="s1">oshapes</span><span class="s3">, </span><span class="s1">loopdims</span><span class="s3">, </span><span class="s1">pinned</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">GUFuncSchedule</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">ishapes</span><span class="s3">, </span><span class="s1">oshapes</span><span class="s3">, </span><span class="s1">loopdims</span><span class="s3">, </span><span class="s1">pinned</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">parent </span><span class="s3">= </span><span class="s1">parent</span>
        <span class="s6"># core shapes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ishapes </span><span class="s3">= </span><span class="s1">ishapes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">oshapes </span><span class="s3">= </span><span class="s1">oshapes</span>
        <span class="s6"># looping dimension</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loopdims </span><span class="s3">= </span><span class="s1">loopdims</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loopn </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">loopdims</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s6"># flags</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pinned </span><span class="s3">= </span><span class="s1">pinned</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">output_shapes </span><span class="s3">= [</span><span class="s1">loopdims </span><span class="s3">+ </span><span class="s1">s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">oshapes</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">import </span><span class="s1">pprint</span>

        <span class="s1">attrs </span><span class="s3">= </span><span class="s5">'ishapes'</span><span class="s3">, </span><span class="s5">'oshapes'</span><span class="s3">, </span><span class="s5">'loopdims'</span><span class="s3">, </span><span class="s5">'loopn'</span><span class="s3">, </span><span class="s5">'pinned'</span>
        <span class="s1">values </span><span class="s3">= [(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">pprint</span><span class="s3">.</span><span class="s1">pformat</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">values</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">GeneralizedUFunc</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kernelmap</span><span class="s3">, </span><span class="s1">engine</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap </span><span class="s3">= </span><span class="s1">kernelmap</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">engine </span><span class="s3">= </span><span class="s1">engine</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">max_blocksize </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">** </span><span class="s4">30</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
        <span class="s1">callsteps </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_steps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">nin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">nout</span><span class="s3">,</span>
                                     <span class="s1">args</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">)</span>
        <span class="s1">indtypes</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">outdtypes</span><span class="s3">, </span><span class="s1">kernel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_schedule</span><span class="s3">(</span>
            <span class="s1">callsteps</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">callsteps</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">)</span>
        <span class="s1">callsteps</span><span class="s3">.</span><span class="s1">adjust_input_types</span><span class="s3">(</span><span class="s1">indtypes</span><span class="s3">)</span>

        <span class="s1">outputs </span><span class="s3">= </span><span class="s1">callsteps</span><span class="s3">.</span><span class="s1">prepare_outputs</span><span class="s3">(</span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">outdtypes</span><span class="s3">)</span>
        <span class="s1">inputs </span><span class="s3">= </span><span class="s1">callsteps</span><span class="s3">.</span><span class="s1">prepare_inputs</span><span class="s3">()</span>
        <span class="s1">parameters </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_broadcast</span><span class="s3">(</span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">)</span>

        <span class="s1">callsteps</span><span class="s3">.</span><span class="s1">launch_kernel</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">loopn</span><span class="s3">, </span><span class="s1">parameters</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">callsteps</span><span class="s3">.</span><span class="s1">post_process_outputs</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_schedule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">outs</span><span class="s3">):</span>
        <span class="s1">input_shapes </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">]</span>
        <span class="s1">schedule </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">schedule</span><span class="s3">(</span><span class="s1">input_shapes</span><span class="s3">)</span>

        <span class="s6"># find kernel</span>
        <span class="s1">indtypes </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">i</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">outdtypes</span><span class="s3">, </span><span class="s1">kernel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap</span><span class="s3">[</span><span class="s1">indtypes</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s6"># No exact match, then use the first compatible.</span>
            <span class="s6"># This does not match the numpy dispatching exactly.</span>
            <span class="s6"># Later, we may just jit a new version for the missing signature.</span>
            <span class="s1">indtypes </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_search_matching_signature</span><span class="s3">(</span><span class="s1">indtypes</span><span class="s3">)</span>
            <span class="s6"># Select kernel</span>
            <span class="s1">outdtypes</span><span class="s3">, </span><span class="s1">kernel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap</span><span class="s3">[</span><span class="s1">indtypes</span><span class="s3">]</span>

        <span class="s6"># check output</span>
        <span class="s2">for </span><span class="s1">sched_shape</span><span class="s3">, </span><span class="s1">out </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">output_shapes</span><span class="s3">, </span><span class="s1">outs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None and </span><span class="s1">sched_shape </span><span class="s3">!= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'output shape mismatch'</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">indtypes</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">outdtypes</span><span class="s3">, </span><span class="s1">kernel</span>

    <span class="s2">def </span><span class="s1">_search_matching_signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">idtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given the input types in `idtypes`, return a compatible sequence of 
        types that is defined in `kernelmap`. 
 
        Note: Ordering is guaranteed by `kernelmap` being a OrderedDict 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">sig </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kernelmap</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">, </span><span class="s1">desired</span><span class="s3">)</span>
                   <span class="s2">for </span><span class="s1">actual</span><span class="s3">, </span><span class="s1">desired </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">, </span><span class="s1">idtypes</span><span class="s3">)):</span>
                <span class="s2">return </span><span class="s1">sig</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;no matching signature&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_broadcast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">retvals</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">loopn </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">, </span><span class="s5">&quot;zero looping dimension&quot;</span>

        <span class="s1">odim </span><span class="s3">= </span><span class="s4">1 </span><span class="s2">if not </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">loopdims </span><span class="s2">else </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">loopn</span>
        <span class="s1">newparams </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">p</span><span class="s3">, </span><span class="s1">cs </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">params</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">ishapes</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">cs </span><span class="s2">and </span><span class="s1">p</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s6"># Broadcast scalar input</span>
                <span class="s1">devary </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_broadcast_scalar_input</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">odim</span><span class="s3">)</span>
                <span class="s1">newparams</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">devary</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># Broadcast vector input</span>
                <span class="s1">newparams</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_broadcast_array</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">odim</span><span class="s3">, </span><span class="s1">cs</span><span class="s3">))</span>

        <span class="s1">newretvals </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">retval</span><span class="s3">, </span><span class="s1">oshape </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">retvals</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">oshapes</span><span class="s3">):</span>
            <span class="s1">newretvals</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">odim</span><span class="s3">, *</span><span class="s1">oshape</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">newparams</span><span class="s3">) + </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">newretvals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_broadcast_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">newdim</span><span class="s3">, </span><span class="s1">innerdim</span><span class="s3">):</span>
        <span class="s1">newshape </span><span class="s3">= (</span><span class="s1">newdim</span><span class="s3">,) + </span><span class="s1">innerdim</span>
        <span class="s6"># No change in shape</span>
        <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">newshape</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">ary</span>

        <span class="s6"># Creating new dimension</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">newshape</span><span class="s3">[-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):] == </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">\</span>
               <span class="s5">&quot;cannot add dim and reshape at the same time&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_broadcast_add_axis</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">)</span>

        <span class="s6"># Collapsing dimension</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(*</span><span class="s1">newshape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_broadcast_add_axis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s5">&quot;cannot add new axis&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_broadcast_scalar_input</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">GUFuncCallSteps</span><span class="s3">(</span><span class="s1">metaclass</span><span class="s3">=</span><span class="s1">ABCMeta</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Implements memory management and kernel launch operations for GUFunc calls. 
 
    One instance of this class is instantiated for each call, and the instance 
    is specific to the arguments given to the GUFunc call. 
 
    The base class implements the overall logic; subclasses provide 
    target-specific implementations of individual functions. 
    &quot;&quot;&quot;</span>

    <span class="s6"># The base class uses these slots; subclasses may provide additional slots.</span>
    <span class="s1">__slots__ </span><span class="s3">= [</span>
        <span class="s5">'outputs'</span><span class="s3">,</span>
        <span class="s5">'inputs'</span><span class="s3">,</span>
        <span class="s5">'_copy_result_to_host'</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s3">@</span><span class="s1">abstractmethod</span>
    <span class="s2">def </span><span class="s1">launch_kernel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">nelem</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Implement the kernel launch&quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">abstractmethod</span>
    <span class="s2">def </span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if `obj` is a device array for this target, False 
        otherwise. 
        &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">abstractmethod</span>
    <span class="s2">def </span><span class="s1">as_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return `obj` as a device array on this target. 
 
        May return `obj` directly if it is already on the target. 
        &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">abstractmethod</span>
    <span class="s2">def </span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">hostary</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy `hostary` to the device and return the device array. 
        &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">abstractmethod</span>
    <span class="s2">def </span><span class="s1">allocate_device_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Allocate a new uninitialized device array with the given shape and 
        dtype. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nin</span><span class="s3">, </span><span class="s1">nout</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">outputs </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'out'</span><span class="s3">)</span>

        <span class="s6"># Ensure the user has passed a correct number of arguments</span>
        <span class="s2">if </span><span class="s1">outputs </span><span class="s2">is None and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">nin</span><span class="s3">, (</span><span class="s1">nin </span><span class="s3">+ </span><span class="s1">nout</span><span class="s3">)):</span>
            <span class="s2">def </span><span class="s1">pos_argn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s5">f'</span><span class="s2">{</span><span class="s1">n</span><span class="s2">} </span><span class="s5">positional argument</span><span class="s2">{</span><span class="s5">&quot;s&quot; </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">!= </span><span class="s4">1</span><span class="s3">)</span><span class="s2">}</span><span class="s5">'</span>

            <span class="s1">msg </span><span class="s3">= (</span><span class="s5">f'This gufunc accepts </span><span class="s2">{</span><span class="s1">pos_argn</span><span class="s3">(</span><span class="s1">nin</span><span class="s3">)</span><span class="s2">} </span><span class="s5">(when providing '</span>
                   <span class="s5">f'input only) or </span><span class="s2">{</span><span class="s1">pos_argn</span><span class="s3">(</span><span class="s1">nin </span><span class="s3">+ </span><span class="s1">nout</span><span class="s3">)</span><span class="s2">} </span><span class="s5">(when providing '</span>
                   <span class="s5">f'input and output). Got </span><span class="s2">{</span><span class="s1">pos_argn</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span><span class="s2">}</span><span class="s5">.'</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">outputs </span><span class="s2">is not None and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) &gt; </span><span class="s1">nin</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;cannot specify argument 'out' as both positional &quot;</span>
                             <span class="s5">&quot;and keyword&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># If the user did not pass outputs either in the out kwarg or as</span>
            <span class="s6"># positional arguments, then we need to generate an initial list of</span>
            <span class="s6"># &quot;placeholder&quot; outputs using None as a sentry value</span>
            <span class="s1">outputs </span><span class="s3">= [</span><span class="s1">outputs</span><span class="s3">] * </span><span class="s1">nout</span>

        <span class="s6"># Ensure all output device arrays are Numba device arrays - for</span>
        <span class="s6"># example, any output passed in that supports the CUDA Array Interface</span>
        <span class="s6"># is converted to a Numba CUDA device array; others are left untouched.</span>
        <span class="s1">all_user_outputs_are_host </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">outputs </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">output </span><span class="s2">in </span><span class="s1">outputs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">output</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">as_device_array</span><span class="s3">(</span><span class="s1">output</span><span class="s3">))</span>
                <span class="s1">all_user_outputs_are_host </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">output</span><span class="s3">)</span>

        <span class="s1">all_host_arrays </span><span class="s3">= </span><span class="s2">not </span><span class="s1">any</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>

        <span class="s6"># - If any of the arguments are device arrays, we leave the output on</span>
        <span class="s6">#   the device.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_copy_result_to_host </span><span class="s3">= (</span><span class="s1">all_host_arrays </span><span class="s2">and</span>
                                     <span class="s1">all_user_outputs_are_host</span><span class="s3">)</span>

        <span class="s6"># Normalize arguments - ensure they are either device- or host-side</span>
        <span class="s6"># arrays (as opposed to lists, tuples, etc).</span>
        <span class="s2">def </span><span class="s1">normalize_arg</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">convert </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">as_device_array</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">convert </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span>

            <span class="s2">return </span><span class="s1">convert</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">normalized_args </span><span class="s3">= [</span><span class="s1">normalize_arg</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">inputs </span><span class="s3">= </span><span class="s1">normalized_args</span><span class="s3">[:</span><span class="s1">nin</span><span class="s3">]</span>

        <span class="s6"># Check if there are extra arguments for outputs.</span>
        <span class="s1">unused_inputs </span><span class="s3">= </span><span class="s1">normalized_args</span><span class="s3">[</span><span class="s1">nin</span><span class="s3">:]</span>
        <span class="s2">if </span><span class="s1">unused_inputs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">outputs </span><span class="s3">= </span><span class="s1">unused_inputs</span>

    <span class="s2">def </span><span class="s1">adjust_input_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Attempt to cast the inputs to the required types if necessary 
        and if they are not device arrays. 
 
        Side effect: Only affects the elements of `inputs` that require 
        a type cast. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">ity</span><span class="s3">, </span><span class="s1">val</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indtypes</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">ity </span><span class="s3">!= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">'astype'</span><span class="s3">):</span>
                    <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;compatible signature is possible by casting but &quot;</span>
                           <span class="s5">&quot;{0} does not support .astype()&quot;</span><span class="s3">).</span><span class="s1">format</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">val</span><span class="s3">))</span>
                    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
                <span class="s6"># Cast types</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">val</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">ity</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare_outputs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">, </span><span class="s1">outdtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of output parameters that all reside on the target device. 
 
        Outputs that were passed-in to the GUFunc are used if they reside on the 
        device; other outputs are allocated as necessary. 
        &quot;&quot;&quot;</span>
        <span class="s1">outputs </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">output </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">schedule</span><span class="s3">.</span><span class="s1">output_shapes</span><span class="s3">, </span><span class="s1">outdtypes</span><span class="s3">,</span>
                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">output </span><span class="s2">is None or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_copy_result_to_host</span><span class="s3">:</span>
                <span class="s1">output </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">allocate_device_array</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">outputs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">output</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">outputs</span>

    <span class="s2">def </span><span class="s1">prepare_inputs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of input parameters that all reside on the target device. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">ensure_device</span><span class="s3">(</span><span class="s1">parameter</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_device_array</span><span class="s3">(</span><span class="s1">parameter</span><span class="s3">):</span>
                <span class="s1">convert </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">as_device_array</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">convert </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_device</span>

            <span class="s2">return </span><span class="s1">convert</span><span class="s3">(</span><span class="s1">parameter</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s3">[</span><span class="s1">ensure_device</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">post_process_outputs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Moves the given output(s) to the host if necessary. 
 
        Returns a single value (e.g. an array) if there was one output, or a 
        tuple of arrays if there were multiple. Although this feels a little 
        jarring, it is consistent with the behavior of GUFuncs in general. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_copy_result_to_host</span><span class="s3">:</span>
            <span class="s1">outputs </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_host</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">self_output</span><span class="s3">)</span>
                       <span class="s2">for </span><span class="s1">output</span><span class="s3">, </span><span class="s1">self_output </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">)]</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">outputs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">outputs</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">outputs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">outputs</span><span class="s3">)</span>
</pre>
</body>
</html>