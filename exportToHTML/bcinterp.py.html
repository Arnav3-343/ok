<html>
<head>
<title>bcinterp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bcinterp.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains logic to convert RVSDG into Numba IR. 
 
Key APIs: 
- function `run_frontend()` 
- function `rvsdg_to_ir()` 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">dis</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">import </span><span class="s1">builtins</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterator</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ir</span><span class="s3">,</span>
    <span class="s1">bytecode</span><span class="s3">,</span>
    <span class="s1">ir_utils</span><span class="s3">,</span>
    <span class="s1">utils</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">BINOPS_TO_OPERATORS</span><span class="s3">,</span>
    <span class="s1">INPLACE_BINOPS_TO_OPERATORS</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">rvsdg</span><span class="s3">.</span><span class="s1">bc2rvsdg </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">build_rvsdg</span><span class="s3">,</span>
    <span class="s1">SCFG</span><span class="s3">,</span>
    <span class="s1">BasicBlock</span><span class="s3">,</span>
    <span class="s1">RegionBlock</span><span class="s3">,</span>
    <span class="s1">DDGBlock</span><span class="s3">,</span>
    <span class="s1">DDGControlVariable</span><span class="s3">,</span>
    <span class="s1">DDGBranch</span><span class="s3">,</span>
    <span class="s1">DDGRegion</span><span class="s3">,</span>
    <span class="s1">Op</span><span class="s3">,</span>
    <span class="s1">ValueState</span><span class="s3">,</span>
    <span class="s1">DEBUG_GRAPH</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">rvsdg</span><span class="s3">.</span><span class="s1">regionpasses </span><span class="s2">import </span><span class="s1">RegionVisitor</span>


<span class="s2">def </span><span class="s1">run_frontend</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">pySignature</span><span class="s3">.</span><span class="s1">from_callable</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
    <span class="s1">argnames </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">)</span>
    <span class="s1">rvsdg </span><span class="s3">= </span><span class="s1">build_rvsdg</span><span class="s3">(</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">, </span><span class="s1">argnames</span><span class="s3">)</span>

    <span class="s1">func_id </span><span class="s3">= </span><span class="s1">bytecode</span><span class="s3">.</span><span class="s1">FunctionIdentity</span><span class="s3">.</span><span class="s1">from_function</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
    <span class="s1">func_ir </span><span class="s3">= </span><span class="s1">rvsdg_to_ir</span><span class="s3">(</span><span class="s1">func_id</span><span class="s3">, </span><span class="s1">rvsdg</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">func_ir</span>


<span class="s2">def </span><span class="s1">_get_first_bytecode</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Op</span><span class="s3">]) </span><span class="s1">-&gt; dis</span><span class="s3">.</span><span class="s1">Instruction </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s2">for </span><span class="s1">bc </span><span class="s2">in </span><span class="s3">(</span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst </span><span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops </span><span class="s2">if </span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">bc</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_innermost_exiting</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">: </span><span class="s1">RegionBlock</span><span class="s3">) </span><span class="s1">-&gt; BasicBlock</span><span class="s3">:</span>
    <span class="s4"># This will iterate through the RegionBlocks until it finds an exiting</span>
    <span class="s4"># attribute that is not a RegionBlock.</span>
    <span class="s2">while </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">, </span><span class="s1">RegionBlock</span><span class="s3">):</span>
        <span class="s1">blk </span><span class="s3">= </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">subregion</span><span class="s3">.</span><span class="s1">graph</span><span class="s3">[</span><span class="s1">blk</span><span class="s3">.</span><span class="s1">exiting</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">blk</span>


<span class="s1">_noop </span><span class="s3">= {</span><span class="s5">&quot;var.incoming&quot;</span><span class="s3">, </span><span class="s5">&quot;start&quot;</span><span class="s3">}</span>


<span class="s1">_Data </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">RVSDG2IR</span><span class="s3">(</span><span class="s1">RegionVisitor</span><span class="s3">[</span><span class="s1">_Data</span><span class="s3">]):</span>
    <span class="s1">blocks</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">]</span>
    <span class="s1">func_id</span><span class="s3">: </span><span class="s1">bytecode</span><span class="s3">.</span><span class="s1">FunctionIdentity</span>
    <span class="s1">local_scope</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Scope</span>
    <span class="s1">global_scope</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Scope</span>
    <span class="s1">vsmap</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">ValueState</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">]</span>
    <span class="s1">_current_block</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">last_block_label</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">branch_predicate</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">_label_map</span><span class="s3">: </span><span class="s1">dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]</span>
    <span class="s1">_emit_debug_print </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func_id</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func_id </span><span class="s3">= </span><span class="s1">func_id</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">first_loc </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Loc</span><span class="s3">.</span><span class="s1">from_function_id</span><span class="s3">(</span><span class="s1">func_id</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">global_scope </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Scope</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Scope</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">global_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_current_block </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map </span><span class="s3">= {}</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">current_block</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_current_block</span>
        <span class="s2">assert </span><span class="s1">out </span><span class="s2">is not None</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">last_block</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label </span><span class="s2">is not None  </span><span class="s4"># for typing</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_phi_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">varname</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">label</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s1">suffix </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">label</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s5">f&quot;$phi.</span><span class="s2">{</span><span class="s1">varname</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">suffix</span><span class="s2">}</span><span class="s5">&quot;</span>

    <span class="s2">def </span><span class="s1">_get_cp_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cpname</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s5">f&quot;$.cp.</span><span class="s2">{</span><span class="s1">cpname</span><span class="s2">}</span><span class="s5">&quot;</span>

    <span class="s2">def </span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">label</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s5">f&quot;block.</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">num</span>

    <span class="s2">def </span><span class="s1">_get_temp_label</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">num </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_label_map</span><span class="s3">[</span><span class="s5">f&quot;annoy.</span><span class="s2">{</span><span class="s1">num</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">] = </span><span class="s1">num</span>
        <span class="s2">return </span><span class="s1">num</span>

    <span class="s2">def </span><span class="s1">initialize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _Data</span><span class="s3">:</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_temp_label</span><span class="s3">()</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">,</span>
                                            <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)):</span>
            <span class="s1">data</span><span class="s3">: </span><span class="s1">_Data </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">):  </span><span class="s4"># type: ignore</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">(</span><span class="s1">index</span><span class="s3">=</span><span class="s1">i</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s5">f&quot;var.</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">k</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">finalize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">last_block </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">is_terminated</span><span class="s3">:</span>
                <span class="s1">last_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">ir</span><span class="s3">.</span><span class="s1">StaticRaise</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">, (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_block</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">block</span><span class="s3">: </span><span class="s1">BasicBlock</span><span class="s3">, </span><span class="s1">data</span><span class="s3">: </span><span class="s1">_Data</span><span class="s3">) </span><span class="s1">-&gt; _Data</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">DDGBlock</span><span class="s3">):</span>
            <span class="s4"># Prepare incoming variables</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">in_vars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">vs</span><span class="s3">] = </span><span class="s1">data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

            <span class="s4"># Emit instruction body</span>
            <span class="s1">ops </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">get_toposorted_ops</span><span class="s3">()</span>
            <span class="s1">firstbc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s1">_get_first_bytecode</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">firstbc </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">firstbc</span><span class="s3">.</span><span class="s1">positions </span><span class="s2">is not None</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">with_lineno</span><span class="s3">(</span>
                    <span class="s1">firstbc</span><span class="s3">.</span><span class="s1">positions</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">,</span>
                    <span class="s1">firstbc</span><span class="s3">.</span><span class="s1">positions</span><span class="s3">.</span><span class="s1">col_offset</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
                <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
            <span class="s3">):</span>
                <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">op</span><span class="s3">.</span><span class="s1">opname </span><span class="s2">in </span><span class="s1">_noop</span><span class="s3">:</span>
                        <span class="s2">pass</span>
                    <span class="s2">elif </span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">interpret_bytecode</span><span class="s3">(</span><span class="s1">op</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">op</span><span class="s3">.</span><span class="s1">opname </span><span class="s2">in </span><span class="s3">{</span><span class="s5">&quot;stack.export&quot;</span><span class="s3">, </span><span class="s5">&quot;stack.incoming&quot;</span><span class="s3">}:</span>
                        <span class="s3">[</span><span class="s1">arg</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
                        <span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">arg</span><span class="s3">], </span><span class="s5">f&quot;$</span><span class="s2">{</span><span class="s1">res</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">&quot;</span>
                        <span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">op</span><span class="s3">.</span><span class="s1">opname</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">_jump_targets</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s2">is not None</span>
                    <span class="s1">truebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">_jump_targets</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
                    <span class="s1">falsebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">_jump_targets</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
                    <span class="s1">br </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span>
                        <span class="s1">cond</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate</span><span class="s3">,</span>
                        <span class="s1">truebr</span><span class="s3">=</span><span class="s1">truebr</span><span class="s3">,</span>
                        <span class="s1">falsebr</span><span class="s3">=</span><span class="s1">falsebr</span><span class="s3">,</span>
                        <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">br</span><span class="s3">)</span>
            <span class="s4"># Prepare outgoing variables</span>
            <span class="s1">data </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">vs</span><span class="s3">] </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">out_vars</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">DDGControlVariable</span><span class="s3">):</span>
            <span class="s4"># Emit body</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
                <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
            <span class="s3">):</span>
                <span class="s2">for </span><span class="s1">cp</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">variable_assignment</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">const </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">use_literal_type</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">const</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_cp_name</span><span class="s3">(</span><span class="s1">cp</span><span class="s3">), </span><span class="s1">redefine</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">DDGBranch</span><span class="s3">):</span>
            <span class="s4"># Emit body</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">branch_value_table</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_two_way_switch</span><span class="s3">(</span><span class="s1">block</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_n_way_switch</span><span class="s3">(</span><span class="s1">block</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_emit_two_way_switch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s4"># Handle simple two-way branch</span>
            <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">branch_value_table</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) == {</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">}</span>
            <span class="s1">cp </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">variable</span>
            <span class="s1">cpvar </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_cp_name</span><span class="s3">(</span><span class="s1">cp</span><span class="s3">))</span>
            <span class="s1">truebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">branch_value_table</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
            <span class="s1">falsebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">branch_value_table</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
            <span class="s1">br </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span>
                <span class="s1">cond</span><span class="s3">=</span><span class="s1">cpvar</span><span class="s3">,</span>
                <span class="s1">truebr</span><span class="s3">=</span><span class="s1">truebr</span><span class="s3">,</span>
                <span class="s1">falsebr</span><span class="s3">=</span><span class="s1">falsebr</span><span class="s3">,</span>
                <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">br</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_emit_n_way_switch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This handles emitting a switch block with N cases. It does the 
        following: 
 
        - The branch value table in the block provides information about the 
          case index and the case label in this switch. 
        - Emit a block that unconditionally jumps to the first case block. 
        - In each case block: 
            - Compare the control variable to the expected case index for 
              that case. 
            - Branch to the target label on true, or the next case on false. 
        - There is no default case. The control variable must match a case index 
 
        ┌───────────────────────┐ 
        │  current block        │ 
        └───────────┬───────────┘ 
                    │ 
                    └─────────┐ 
                              ▼ 
                    ┌───────────────────┐ 
                    │   case 0          │ 
                    └─────────┬─────────┘ 
                              │ 
                              │ 
                              ▼ 
                    ┌───────────────────┐ 
                    │  case 1           │ 
                    └─────────┬─────────┘ 
                              │ 
                              │ 
                              ▼ 
                    ┌───────────────────┐ 
                    │  case N-1         │ 
                    └─────────┬─────────┘ 
                              │ 
                    ┌─────────┘ 
                    │ 
                    ▼ 
        ┌───────────────────────┐ 
        │ subsequent blocks     │ 
        └───────────────────────┘ 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># with self.set_block(</span>
        <span class="s4">#         self._get_label(block.name),</span>
        <span class="s4">#         ir.Block(scope=self.local_scope, loc=self.loc)):</span>
        <span class="s4">#     # Handle simple two-way branch</span>
        <span class="s4">#     # assert set(block.branch_value_table.keys()) == {0, 1}</span>
        <span class="s4">#     cp = block.variable</span>
        <span class="s4">#     cpvar = self.local_scope.get_exact(f&quot;$.cp.{cp}&quot;)</span>

        <span class="s4">#     falsebr = self._get_label(block.branch_value_table[1])</span>
        <span class="s4">#     truebr = self._get_label(block.branch_value_table[0])</span>

        <span class="s4">#     const = self.store(ir.Const(0, loc=self.loc), &quot;$.const&quot;)</span>
        <span class="s4">#     cmp = ir.Expr.binop(operator.eq, const, cpvar,</span>
        <span class="s4">#                         loc=self.loc)</span>
        <span class="s4">#     pred = self.store(cmp, &quot;$.pred&quot;)</span>
        <span class="s4">#     br = ir.Branch(</span>
        <span class="s4">#         cond=pred,</span>
        <span class="s4">#         truebr=truebr,</span>
        <span class="s4">#         falsebr=falsebr,</span>
        <span class="s4">#         loc=self.loc,</span>
        <span class="s4">#     )</span>
        <span class="s4">#     self.current_block.append(br)</span>
        <span class="s1">bvt </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">branch_value_table</span>
        <span class="s4"># The control variable</span>
        <span class="s1">cp </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">variable</span>
        <span class="s1">cpvar </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_cp_name</span><span class="s3">(</span><span class="s1">cp</span><span class="s3">))</span>
        <span class="s1">labels </span><span class="s3">= [(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">bvt</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()]</span>

        <span class="s1">blocks </span><span class="s3">= []</span>
        <span class="s4"># For all but last labels</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s1">blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_temp_label</span><span class="s3">(),</span>
                    <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
                <span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s4"># Jump into the first block</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s4"># Handle jump tree</span>
        <span class="s2">while </span><span class="s1">blocks</span><span class="s3">:</span>
            <span class="s1">cp_expect</span><span class="s3">, </span><span class="s1">cp_label </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
            <span class="s1">cur_label</span><span class="s3">, </span><span class="s1">cur_block </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span><span class="s1">cur_label</span><span class="s3">, </span><span class="s1">cur_block</span><span class="s3">):</span>
                <span class="s1">const </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">cp_expect</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">), </span><span class="s5">&quot;$.const&quot;</span><span class="s3">)</span>
                <span class="s1">cmp </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">, </span><span class="s1">const</span><span class="s3">, </span><span class="s1">cpvar</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s1">pred </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">, </span><span class="s5">&quot;$.cmp&quot;</span><span class="s3">)</span>

                <span class="s2">if not </span><span class="s1">blocks</span><span class="s3">:</span>
                    <span class="s1">_</span><span class="s3">, </span><span class="s1">falsebr </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">falsebr</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">blocks</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
                <span class="s1">br </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span>
                    <span class="s1">cond</span><span class="s3">=</span><span class="s1">pred</span><span class="s3">,</span>
                    <span class="s1">truebr</span><span class="s3">=</span><span class="s1">cp_label</span><span class="s3">,</span>
                    <span class="s1">falsebr</span><span class="s3">=</span><span class="s1">falsebr</span><span class="s3">,</span>
                    <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">br</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">visit_loop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">region</span><span class="s3">: </span><span class="s1">RegionBlock</span><span class="s3">, </span><span class="s1">data</span><span class="s3">: </span><span class="s1">_Data</span><span class="s3">) </span><span class="s1">-&gt; _Data</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">region</span><span class="s3">, </span><span class="s1">DDGRegion</span><span class="s3">)</span>
        <span class="s4"># Prepare incoming states</span>
        <span class="s1">inner_data</span><span class="s3">: </span><span class="s1">_Data </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">region</span><span class="s3">.</span><span class="s1">incoming_states</span><span class="s3">:</span>
            <span class="s1">inner_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">],</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_phi_name</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">region</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
                <span class="s1">redefine</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">block</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">,</span>
            <span class="s3">)</span>

        <span class="s4"># Emit loop body</span>
        <span class="s1">out_data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">region</span><span class="s3">, </span><span class="s1">inner_data</span><span class="s3">)</span>

        <span class="s4"># Prepare outgoing states</span>
        <span class="s1">exit_data </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">region</span><span class="s3">.</span><span class="s1">outgoing_states</span><span class="s3">:</span>
            <span class="s1">exit_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                <span class="s1">out_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">],</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_phi_name</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">region</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
                <span class="s1">redefine</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">block</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">,</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">exit_data</span>

    <span class="s2">def </span><span class="s1">visit_switch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">region</span><span class="s3">: </span><span class="s1">RegionBlock</span><span class="s3">, </span><span class="s1">data</span><span class="s3">: </span><span class="s1">_Data</span><span class="s3">) </span><span class="s1">-&gt; _Data</span><span class="s3">:</span>
        <span class="s4"># Emit header</span>
        <span class="s1">header </span><span class="s3">= </span><span class="s1">region</span><span class="s3">.</span><span class="s1">header</span>
        <span class="s1">header_block </span><span class="s3">= </span><span class="s1">region</span><span class="s3">.</span><span class="s1">subregion</span><span class="s3">[</span><span class="s1">header</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">header_block</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s5">&quot;head&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">data_at_head </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">header_block</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
        <span class="s4"># NOTE: This check is needed due to the mess that the responsibility of</span>
        <span class="s4">#       terminating the block is unclear. Some rvsdg block is</span>
        <span class="s4">#       fallthrough but some have jumps.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">is_terminated</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s2">is not None  </span><span class="s4"># for typing</span>

            <span class="s4"># Jump-target 1 is when a the jump is taken.</span>
            <span class="s4"># Jump-target 0 is when the jump fallthrough</span>
            <span class="s1">truebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">header_block</span><span class="s3">.</span><span class="s1">jump_targets</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
            <span class="s1">falsebr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">header_block</span><span class="s3">.</span><span class="s1">jump_targets</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
            <span class="s1">br </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate</span><span class="s3">, </span><span class="s1">truebr</span><span class="s3">, </span><span class="s1">falsebr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">br</span><span class="s3">)</span>

        <span class="s4"># Emit branches</span>
        <span class="s1">data_for_branches </span><span class="s3">= []</span>
        <span class="s1">branch_blocks </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">region</span><span class="s3">.</span><span class="s1">subregion</span><span class="s3">.</span><span class="s1">graph</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s5">&quot;branch&quot;</span><span class="s3">:</span>
                <span class="s1">branch_blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_innermost_exiting</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">))</span>
                <span class="s1">data_for_branches</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">, </span><span class="s1">data_at_head</span><span class="s3">))</span>
                <span class="s4"># Add jump to tail</span>
                <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">is_terminated</span><span class="s3">:</span>
                    <span class="s3">[</span><span class="s1">target</span><span class="s3">] = </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">jump_targets</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                        <span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">target</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                    <span class="s3">)</span>

        <span class="s4"># handle outgoing values from the branches</span>
        <span class="s1">names</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s1">reduce</span><span class="s3">(</span>
            <span class="s1">operator</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">, </span><span class="s1">map</span><span class="s3">(</span><span class="s1">set</span><span class="s3">, </span><span class="s1">data_for_branches</span><span class="s3">))  </span><span class="s4"># type: ignore</span>
        <span class="s2">for </span><span class="s1">blk</span><span class="s3">, </span><span class="s1">branch_data </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span>
            <span class="s1">branch_blocks</span><span class="s3">, </span><span class="s1">data_for_branches</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span>
        <span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">names</span><span class="s3">:</span>
                <span class="s4"># Set undefined variable to None</span>
                <span class="s4"># (It should be a &quot;zeroinitializer&quot; but ir.Expr.null doesn't</span>
                <span class="s4">#  work)</span>
                <span class="s1">rhs </span><span class="s3">= </span><span class="s1">branch_data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
                <span class="s4"># Insert stores to export</span>
                <span class="s1">phiname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_phi_name</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">region</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                    <span class="s1">rhs</span><span class="s3">,</span>
                    <span class="s1">phiname</span><span class="s3">,</span>
                    <span class="s1">redefine</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s1">block</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)],</span>
                <span class="s3">)</span>
        <span class="s4"># Emit tail</span>
        <span class="s1">data_after_branches </span><span class="s3">= {</span>
            <span class="s1">k</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">.</span><span class="s1">get_exact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_phi_name</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">region</span><span class="s3">.</span><span class="s1">name</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">names</span>
        <span class="s3">}</span>

        <span class="s1">exiting </span><span class="s3">= </span><span class="s1">region</span><span class="s3">.</span><span class="s1">exiting</span>
        <span class="s1">exiting_block </span><span class="s3">= </span><span class="s1">region</span><span class="s3">.</span><span class="s1">subregion</span><span class="s3">[</span><span class="s1">exiting</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">exiting_block</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s5">&quot;tail&quot;</span>
        <span class="s1">data_at_tail </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">exiting_block</span><span class="s3">, </span><span class="s1">data_after_branches</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">data_at_tail</span>

    <span class="s2">def </span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">region</span><span class="s3">: </span><span class="s1">RegionBlock</span><span class="s3">, </span><span class="s1">data</span><span class="s3">: </span><span class="s1">_Data</span><span class="s3">) </span><span class="s1">-&gt; _Data</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">set_block</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_label</span><span class="s3">(</span><span class="s1">region</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s4"># Ensures there's a block for all regions</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">visit_linear</span><span class="s3">(</span><span class="s1">region</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">set_block</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">label</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">block</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">[</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;A context manager that set the current block for other IR building 
        methods. 
 
        In addition, 
 
        - It closes any existing block in ``last_block_label`` by jumping to the 
          new block. 
        - If there is a existing block, it will be restored as the current block 
          after the context manager. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">last_block </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">last_block</span><span class="s3">.</span><span class="s1">is_terminated</span><span class="s3">:</span>
                <span class="s1">last_block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_debug_print</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;begin dump last blk&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
                <span class="s1">last_block</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">()</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;end dump last blk&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;=&quot;</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">block</span>
        <span class="s1">old </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_current_block</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_current_block </span><span class="s3">= </span><span class="s1">block</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">block</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">last_block_label </span><span class="s3">= </span><span class="s1">label</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_current_block </span><span class="s3">= </span><span class="s1">old</span>
            <span class="s4"># dump</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_debug_print</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s5">f&quot;begin dump blk: </span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;-&quot;</span><span class="s3">))</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">()</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;end dump blk&quot;</span><span class="s3">.</span><span class="s1">center</span><span class="s3">(</span><span class="s6">80</span><span class="s3">, </span><span class="s5">&quot;=&quot;</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, *, </span><span class="s1">redefine</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">block</span><span class="s3">=</span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">:</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span>
        <span class="s2">if </span><span class="s1">redefine</span><span class="s3">:</span>
            <span class="s1">target </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">target </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">local_scope</span><span class="s3">.</span><span class="s1">get_or_define</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">stmt </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">, </span><span class="s1">target</span><span class="s3">=</span><span class="s1">target</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">block</span><span class="s3">=</span><span class="s1">block</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">target</span>

    <span class="s2">def </span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">vs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">vs</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s5">f&quot;$</span><span class="s2">{</span><span class="s1">vs</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Stmt</span><span class="s3">, </span><span class="s1">block</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">block </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">block </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span>
        <span class="s2">if </span><span class="s1">block</span><span class="s3">.</span><span class="s1">is_terminated</span><span class="s3">:</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">insert_before_terminator</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_global_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;THIS IS COPIED from interpreter.py 
 
        Get a global value from the func_global (first) or 
        as a builtins (second).  If both failed, return a ir.UNDEFINED. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">builtins</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">UNDEFINED</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_closure_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get a value from the cell contained in this function's closure. 
        If not set, return a ir.UNDEFINED. 
        &quot;&quot;&quot;</span>
        <span class="s1">cell </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__closure__</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cell</span><span class="s3">.</span><span class="s1">cell_contents</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">UNDEFINED</span>

    <span class="s2">def </span><span class="s1">debug_print</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">msg_const </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">), </span><span class="s5">&quot;$.debug.msg&quot;</span><span class="s3">)</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">print</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">), </span><span class="s5">&quot;$.debug.print&quot;</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, (</span><span class="s1">msg_const</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">), (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s5">&quot;$.debug.res&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">interpret_bytecode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Interpret a single Op containing bytecode instructions. 
 
        Internally, it dispatches to methods with names following the pattern 
        `op_&lt;opname&gt;`. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst </span><span class="s2">is not None</span>
        <span class="s1">pos </span><span class="s3">= </span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">positions</span>
        <span class="s2">assert </span><span class="s1">pos </span><span class="s2">is not None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">with_lineno</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">.</span><span class="s1">col_offset</span><span class="s3">)</span>
        <span class="s4"># debug print</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_debug_print</span><span class="s3">:</span>
            <span class="s1">where </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">offset</span><span class="s2">:</span><span class="s5">3</span><span class="s2">}</span><span class="s5">:(</span><span class="s2">{</span><span class="s1">pos</span><span class="s3">.</span><span class="s1">lineno</span><span class="s2">:</span><span class="s5">3</span><span class="s2">}</span><span class="s5">:</span><span class="s2">{</span><span class="s1">pos</span><span class="s3">.</span><span class="s1">col_offset</span><span class="s2">:</span><span class="s5">3</span><span class="s2">}</span><span class="s5">)&quot;</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">f&quot;[</span><span class="s2">{</span><span class="s1">where</span><span class="s2">}</span><span class="s5">] </span><span class="s2">{</span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">opname</span><span class="s2">}</span><span class="s5">(</span><span class="s2">{</span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">argrepr</span><span class="s2">}</span><span class="s5">) &quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">op</span><span class="s3">.</span><span class="s1">input_ports</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">vs</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s5">f&quot;   in </span><span class="s2">{</span><span class="s1">k</span><span class="s2">:</span><span class="s5">&gt;6</span><span class="s2">}</span><span class="s5">: &lt;undef&gt;&quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s5">f&quot;   in </span><span class="s2">{</span><span class="s1">k</span><span class="s2">:</span><span class="s5">&gt;6</span><span class="s2">}</span><span class="s5">:&quot;</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

        <span class="s4"># dispatch</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">f&quot;op_</span><span class="s2">{</span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">opname</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">fn</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">)</span>

        <span class="s4"># debug print</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_emit_debug_print</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">op</span><span class="s3">.</span><span class="s1">output_ports</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">vs</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s5">f&quot;  out </span><span class="s2">{</span><span class="s1">k</span><span class="s2">:</span><span class="s5">&gt;6</span><span class="s2">}</span><span class="s5">: &lt;undef&gt;&quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s5">f&quot;  out </span><span class="s2">{</span><span class="s1">k</span><span class="s2">:</span><span class="s5">&gt;6</span><span class="s2">}</span><span class="s5">:&quot;</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_PUSH_NULL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">op_LOAD_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s2">assert not </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">vs</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s4"># TODO: handle non scalar</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">vs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_LOAD_GLOBAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s4"># intentionally ignoring the nil</span>
        <span class="s3">[</span><span class="s1">_nil</span><span class="s3">, </span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_global_value</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">)</span>
        <span class="s4"># TODO: handle non scalar</span>
        <span class="s1">const </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">const</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_LOAD_ATTR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s3">[</span><span class="s1">item</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s1">getattr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">item</span><span class="s3">], </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_LOAD_METHOD</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_nil</span><span class="s3">, </span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s3">[</span><span class="s1">item</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s1">getattr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">item</span><span class="s3">], </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_LOAD_DEREF</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">code  </span><span class="s4"># type: ignore</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">code</span><span class="s3">.</span><span class="s1">co_cellvars</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>
            <span class="s1">gl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">code</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">:</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">code</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_closure_value</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)</span>
            <span class="s1">gl </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">gl</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_STORE_FAST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">incvar</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">incvar</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_KW_NAMES</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s2">pass  </span><span class="s4"># do nothing</span>

    <span class="s2">def </span><span class="s1">op_CALL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">callee_or_null</span><span class="s3">, </span><span class="s1">arg0_or_callee</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s2">if </span><span class="s1">callee_or_null</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s5">&quot;null&quot;</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>
        <span class="s1">callee </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">arg0_or_callee</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">op</span><span class="s3">.</span><span class="s1">opname </span><span class="s3">== </span><span class="s5">&quot;call.kw&quot;</span><span class="s3">:</span>
            <span class="s4"># If this is a keyword call, the last value-state in `args` has</span>
            <span class="s4"># the names of the keyword arguments. This corresponds to the</span>
            <span class="s4"># `kw_names` special state in the CPython interpreter.</span>
            <span class="s1">kw_names_op </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">parent</span>
            <span class="s2">assert </span><span class="s1">kw_names_op </span><span class="s2">is not None  </span><span class="s4"># for typing</span>
            <span class="s2">assert </span><span class="s1">kw_names_op</span><span class="s3">.</span><span class="s1">bc_inst </span><span class="s2">is not None  </span><span class="s4"># for typing</span>
            <span class="s2">assert </span><span class="s1">kw_names_op</span><span class="s3">.</span><span class="s1">opname </span><span class="s3">== </span><span class="s5">&quot;kw_names&quot;</span>
            <span class="s4"># Now that we handled the `kw_names`, remove it from the list of</span>
            <span class="s4"># actual arguments. The last `len(kw_names)` values in it will go</span>
            <span class="s4"># in the `kwargs`. All values before that is the positional args.</span>
            <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">co </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">code  </span><span class="s4"># type: ignore</span>
            <span class="s1">names </span><span class="s3">= </span><span class="s1">co</span><span class="s3">.</span><span class="s1">co_consts</span><span class="s3">[</span><span class="s1">kw_names_op</span><span class="s3">.</span><span class="s1">bc_inst</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">]</span>
            <span class="s1">argvars </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">vs</span><span class="s3">] </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
            <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">names</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">names</span><span class="s3">) :]))</span>
            <span class="s1">argvars </span><span class="s3">= </span><span class="s1">argvars</span><span class="s3">[: -</span><span class="s1">len</span><span class="s3">(</span><span class="s1">names</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">op</span><span class="s3">.</span><span class="s1">opname </span><span class="s3">== </span><span class="s5">&quot;call&quot;</span>
            <span class="s1">argvars </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">vs</span><span class="s3">] </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
            <span class="s1">kwargs </span><span class="s3">= ()</span>

        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">argvars</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_COMPARE_OP</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">operator </span><span class="s3">= </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argrepr</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">BINOPS_TO_OPERATORS</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]  </span><span class="s4"># type: ignore</span>
        <span class="s1">lhs_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
        <span class="s1">rhs_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">]</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">lhs_var</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">=</span><span class="s1">rhs_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">, </span><span class="s1">op</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>

        <span class="s2">if </span><span class="s5">&quot;=&quot; </span><span class="s2">in </span><span class="s1">operator</span><span class="s3">:</span>
            <span class="s1">immuop </span><span class="s3">= </span><span class="s1">BINOPS_TO_OPERATORS</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]]</span>
            <span class="s1">op </span><span class="s3">= </span><span class="s1">INPLACE_BINOPS_TO_OPERATORS</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]</span>
            <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">inplace_binop</span><span class="s3">(</span>
                <span class="s1">op</span><span class="s3">,</span>
                <span class="s1">immuop</span><span class="s3">,</span>
                <span class="s1">lhs</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">],</span>
                <span class="s1">rhs</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">],</span>
                <span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">op </span><span class="s3">= </span><span class="s1">BINOPS_TO_OPERATORS</span><span class="s3">[</span><span class="s1">operator</span><span class="s3">]</span>
            <span class="s1">lhs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">]</span>
            <span class="s1">rhs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">rhs</span><span class="s3">]</span>
            <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">=</span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_BINARY_OP</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argrepr</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_IS_OP</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s1">opname </span><span class="s3">= </span><span class="s5">'is not' </span><span class="s2">if </span><span class="s1">bc</span><span class="s3">.</span><span class="s1">argval </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">else </span><span class="s5">'is'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">opname</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_UNARY_NOT</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">val</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">unary</span><span class="s3">(</span><span class="s5">&quot;not&quot;</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">val</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_BINARY_SUBSCR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">target</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">index_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">target_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">target</span><span class="s3">]</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">(</span><span class="s1">target_var</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_STORE_SUBSCR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">value</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s1">index_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">target_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">target</span><span class="s3">]</span>
        <span class="s1">value_var </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">value</span><span class="s3">]</span>
        <span class="s1">stmt </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">(</span>
            <span class="s1">target</span><span class="s3">=</span><span class="s1">target_var</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_BUILD_TUPLE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">build_tuple</span><span class="s3">(</span>
            <span class="s1">items</span><span class="s3">=[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">it</span><span class="s3">] </span><span class="s2">for </span><span class="s1">it </span><span class="s2">in </span><span class="s1">items</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_BUILD_SLICE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">v</span><span class="s3">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span><span class="s3">])</span>
        <span class="s3">[</span><span class="s1">out</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) </span><span class="s2">in </span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">), </span><span class="s5">&quot;expected (start, stop, [step])&quot;</span>
        <span class="s1">slicegv </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s5">&quot;slice&quot;</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">slicevar </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">slicegv</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;$slicevar&quot;</span><span class="s3">, </span><span class="s1">redefine</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">sliceinst </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">slicevar</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">sliceinst</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_GET_ITER</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">arg</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getiter</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">arg</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_vsmap</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_FOR_ITER</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">iterator</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>

        <span class="s4"># Emit code</span>
        <span class="s1">pairval </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">iternext</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">iterator</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">pair </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">pairval</span><span class="s3">, </span><span class="s5">&quot;$foriter&quot;</span><span class="s3">)</span>

        <span class="s1">iternext </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">pair_first</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">pair</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">indval </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">iternext</span><span class="s3">, </span><span class="s5">&quot;$foriter.indval&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">res</span><span class="s3">] = </span><span class="s1">indval</span>

        <span class="s1">isvalid </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">pair_second</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">pair</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">pred </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">isvalid</span><span class="s3">, </span><span class="s5">&quot;$foriter.isvalid&quot;</span><span class="s3">)</span>

        <span class="s1">not_fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">not_fn</span><span class="s3">, </span><span class="s5">&quot;$not&quot;</span><span class="s3">), (</span><span class="s1">pred</span><span class="s3">,), (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s5">&quot;$for_iter&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_jump_if_not</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Emit code for jump if predicate is false.&quot;&quot;&quot;</span>
        <span class="s1">not_fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">not_fn</span><span class="s3">, </span><span class="s5">&quot;$not&quot;</span><span class="s3">), (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">pred</span><span class="s3">],), (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s5">&quot;$jump_if&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_jump_if</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Emit code for jump if predicate is true.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">pred</span><span class="s3">], </span><span class="s5">&quot;$jump_if&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_JUMP_IF_FALSE_OR_POP</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_jump_if_not</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_JUMP_IF_TRUE_OR_POP</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_jump_if</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_POP_JUMP_FORWARD_IF_FALSE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_jump_if_not</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_POP_JUMP_FORWARD_IF_TRUE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_jump_if</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_test_none_and_jump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">):</span>
        <span class="s1">test </span><span class="s3">= </span><span class="s5">&quot;is not&quot; </span><span class="s2">if </span><span class="s1">invert </span><span class="s2">else </span><span class="s5">&quot;is&quot;</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">BINOPS_TO_OPERATORS</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]  </span><span class="s4"># type: ignore</span>
        <span class="s1">none </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
            <span class="s1">value</span><span class="s3">=</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">name</span><span class="s3">=</span><span class="s5">f&quot;$constNone</span><span class="s2">{</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">offset</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s3">)</span>
        <span class="s1">isnone </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">pred</span><span class="s3">], </span><span class="s1">rhs</span><span class="s3">=</span><span class="s1">none</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">branch_predicate </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">isnone</span><span class="s3">, </span><span class="s5">&quot;$jump_if&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_POP_JUMP_FORWARD_IF_NONE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_test_none_and_jump</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">op_POP_JUMP_FORWARD_IF_NOT_NONE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_test_none_and_jump</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">op_POP_JUMP_BACKWARD_IF_TRUE </span><span class="s3">= </span><span class="s1">op_POP_JUMP_FORWARD_IF_TRUE</span>

    <span class="s2">def </span><span class="s1">op_RETURN_VALUE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">retval</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">is_terminated</span>

    <span class="s2">def </span><span class="s1">op_RAISE_VARARGS</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">: </span><span class="s1">Op</span><span class="s3">, </span><span class="s1">bc</span><span class="s3">: </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Instruction</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">_env</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">] = </span><span class="s1">op</span><span class="s3">.</span><span class="s1">inputs</span>
        <span class="s4"># XXX: temporary implementation</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Raise</span><span class="s3">(</span><span class="s1">exception</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">vsmap</span><span class="s3">[</span><span class="s1">exc</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">current_block</span><span class="s3">.</span><span class="s1">is_terminated</span>


<span class="s2">def </span><span class="s1">rvsdg_to_ir</span><span class="s3">(</span>
    <span class="s1">func_id</span><span class="s3">: </span><span class="s1">bytecode</span><span class="s3">.</span><span class="s1">FunctionIdentity</span><span class="s3">, </span><span class="s1">rvsdg</span><span class="s3">: </span><span class="s1">SCFG</span>
<span class="s3">) </span><span class="s1">-&gt; ir</span><span class="s3">.</span><span class="s1">FunctionIR</span><span class="s3">:</span>
    <span class="s1">rvsdg2ir </span><span class="s3">= </span><span class="s1">RVSDG2IR</span><span class="s3">(</span><span class="s1">func_id</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">initialize</span><span class="s3">()</span>
    <span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">visit_graph</span><span class="s3">(</span><span class="s1">rvsdg</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
    <span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">finalize</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">blk</span><span class="s3">.</span><span class="s1">verify</span><span class="s3">()</span>

    <span class="s1">defs </span><span class="s3">= </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>

    <span class="s1">fir </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionIR</span><span class="s3">(</span>
        <span class="s1">blocks</span><span class="s3">=</span><span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">,</span>
        <span class="s1">is_generator</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">func_id</span><span class="s3">=</span><span class="s1">func_id</span><span class="s3">,</span>
        <span class="s1">loc</span><span class="s3">=</span><span class="s1">rvsdg2ir</span><span class="s3">.</span><span class="s1">first_loc</span><span class="s3">,</span>
        <span class="s1">definitions</span><span class="s3">=</span><span class="s1">defs</span><span class="s3">,</span>
        <span class="s1">arg_count</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">),  </span><span class="s4"># type: ignore</span>
        <span class="s1">arg_names</span><span class="s3">=</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">arg_names</span><span class="s3">,  </span><span class="s4"># type: ignore</span>
    <span class="s3">)</span>
    <span class="s4"># fir.dump()</span>
    <span class="s2">if </span><span class="s1">DEBUG_GRAPH</span><span class="s3">:</span>
        <span class="s1">fir</span><span class="s3">.</span><span class="s1">render_dot</span><span class="s3">().</span><span class="s1">view</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">fir</span>
</pre>
</body>
</html>