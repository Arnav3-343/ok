<html>
<head>
<title>arraymath.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arraymath.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of math operations on Array objects. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">llvmlite</span><span class="s3">.</span><span class="s1">ir</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">cgutils</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">overload</span><span class="s3">, </span><span class="s1">overload_method</span><span class="s3">, </span><span class="s1">register_jitable</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">, </span><span class="s1">type_can_asarray</span><span class="s3">, </span><span class="s1">type_is_scalar</span><span class="s3">,</span>
                                    <span class="s1">numpy_version</span><span class="s3">, </span><span class="s1">is_nonelike</span><span class="s3">,</span>
                                    <span class="s1">check_is_integer</span><span class="s3">, </span><span class="s1">lt_floats</span><span class="s3">, </span><span class="s1">lt_complex</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">imputils </span><span class="s2">import </span><span class="s3">(</span><span class="s1">lower_builtin</span><span class="s3">, </span><span class="s1">impl_ret_borrowed</span><span class="s3">,</span>
                                 <span class="s1">impl_ret_new_ref</span><span class="s3">, </span><span class="s1">impl_ret_untracked</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arrayobj </span><span class="s2">import </span><span class="s3">(</span><span class="s1">make_array</span><span class="s3">, </span><span class="s1">load_item</span><span class="s3">, </span><span class="s1">store_item</span><span class="s3">,</span>
                               <span class="s1">_empty_nd_impl</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s1">ensure_blas</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">intrinsic</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s3">(</span><span class="s1">RequireLiteralValue</span><span class="s3">, </span><span class="s1">TypingError</span><span class="s3">,</span>
                               <span class="s1">NumbaValueError</span><span class="s3">, </span><span class="s1">NumbaNotImplementedError</span><span class="s3">,</span>
                               <span class="s1">NumbaTypeError</span><span class="s3">, </span><span class="s1">NumbaDeprecationWarning</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">cpython</span><span class="s3">.</span><span class="s1">unsafe</span><span class="s3">.</span><span class="s1">tuple </span><span class="s2">import </span><span class="s1">tuple_setitem</span>


<span class="s2">def </span><span class="s1">_check_blas</span><span class="s3">():</span>
    <span class="s4"># Checks if a BLAS is available so e.g. dot will work</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">ensure_blas</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s2">return True</span>


<span class="s1">_HAVE_BLAS </span><span class="s3">= </span><span class="s1">_check_blas</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_create_tuple_result_shape</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">shape_list</span><span class="s3">, </span><span class="s1">shape_tuple</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    This routine converts shape list where the axis dimension has already 
    been popped to a tuple for indexing of the same size.  The original shape 
    tuple is also required because it contains a length field at compile time 
    whereas the shape list does not. 
    &quot;&quot;&quot;</span>

    <span class="s4"># The new tuple's size is one less than the original tuple since axis</span>
    <span class="s4"># dimension removed.</span>
    <span class="s1">nd </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape_tuple</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s4"># The return type of this intrinsic is an int tuple of length nd.</span>
    <span class="s1">tupty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">nd</span><span class="s3">)</span>
    <span class="s4"># The function signature for this intrinsic.</span>
    <span class="s1">function_sig </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">(</span><span class="s1">shape_list</span><span class="s3">, </span><span class="s1">shape_tuple</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">lltupty </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">tupty</span><span class="s3">)</span>
        <span class="s4"># Create an empty int tuple.</span>
        <span class="s1">tup </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">lltupty</span><span class="s3">)</span>

        <span class="s4"># Get the shape list from the args and we don't need shape tuple.</span>
        <span class="s3">[</span><span class="s1">in_shape</span><span class="s3">, </span><span class="s1">_</span><span class="s3">] = </span><span class="s1">args</span>

        <span class="s2">def </span><span class="s1">array_indexer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s4"># loop to fill the tuple</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nd</span><span class="s3">):</span>
            <span class="s1">dataidx </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s4"># compile and call array_indexer</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_indexer</span><span class="s3">,</span>
                                          <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">(</span><span class="s1">shape_list</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">),</span>
                                          <span class="s3">[</span><span class="s1">in_shape</span><span class="s3">, </span><span class="s1">dataidx</span><span class="s3">])</span>
            <span class="s1">tup </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tup</span>

    <span class="s2">return </span><span class="s1">function_sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">shape_tuple</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generates a tuple that can be used to index a specific slice from an 
    array for sum with axis.  shape_tuple is the size of the dimensions of 
    the input array.  'value' is the value to put in the indexing tuple 
    in the axis dimension and 'axis' is that dimension.  For this to work, 
    axis has to be a const. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RequireLiteralValue</span><span class="s3">(</span><span class="s6">'axis argument must be a constant'</span><span class="s3">)</span>
    <span class="s4"># Get the value of the axis constant.</span>
    <span class="s1">axis_value </span><span class="s3">= </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">literal_value</span>
    <span class="s4"># The length of the indexing tuple to be output.</span>
    <span class="s1">nd </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape_tuple</span><span class="s3">)</span>

    <span class="s4"># If the axis value is impossible for the given size array then</span>
    <span class="s4"># just fake it like it was for axis 0.  This will stop compile errors</span>
    <span class="s4"># when it looks like it could be called from array_sum_axis but really</span>
    <span class="s4"># can't because that routine checks the axis mismatch and raise an</span>
    <span class="s4"># exception.</span>
    <span class="s2">if </span><span class="s1">axis_value </span><span class="s3">&gt;= </span><span class="s1">nd</span><span class="s3">:</span>
        <span class="s1">axis_value </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s4"># Calculate the type of the indexing tuple.  All the non-axis</span>
    <span class="s4"># dimensions have slice2 type and the axis dimension has int type.</span>
    <span class="s1">before </span><span class="s3">= </span><span class="s1">axis_value</span>
    <span class="s1">after </span><span class="s3">= </span><span class="s1">nd </span><span class="s3">- </span><span class="s1">before </span><span class="s3">- </span><span class="s5">1</span>

    <span class="s1">types_list </span><span class="s3">= []</span>
    <span class="s1">types_list </span><span class="s3">+= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">slice2_type</span><span class="s3">] * </span><span class="s1">before</span>
    <span class="s1">types_list </span><span class="s3">+= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">]</span>
    <span class="s1">types_list </span><span class="s3">+= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">slice2_type</span><span class="s3">] * </span><span class="s1">after</span>

    <span class="s4"># Creates the output type of the function.</span>
    <span class="s1">tupty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">(</span><span class="s1">types_list</span><span class="s3">)</span>
    <span class="s4"># Defines the signature of the intrinsic.</span>
    <span class="s1">function_sig </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">(</span><span class="s1">shape_tuple</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">lltupty </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">tupty</span><span class="s3">)</span>
        <span class="s4"># Create an empty indexing tuple.</span>
        <span class="s1">tup </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">lltupty</span><span class="s3">)</span>

        <span class="s4"># We only need value of the axis dimension here.</span>
        <span class="s4"># The rest are constants defined above.</span>
        <span class="s3">[</span><span class="s1">_</span><span class="s3">, </span><span class="s1">value_arg</span><span class="s3">, </span><span class="s1">_</span><span class="s3">] = </span><span class="s1">args</span>

        <span class="s2">def </span><span class="s1">create_full_slice</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s4"># loop to fill the tuple with slice(None,None) before</span>
        <span class="s4"># the axis dimension.</span>

        <span class="s4"># compile and call create_full_slice</span>
        <span class="s1">slice_data </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">create_full_slice</span><span class="s3">,</span>
                                            <span class="s1">types</span><span class="s3">.</span><span class="s1">slice2_type</span><span class="s3">(),</span>
                                            <span class="s3">[])</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis_value</span><span class="s3">):</span>
            <span class="s1">tup </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">slice_data</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>

        <span class="s4"># Add the axis dimension 'value'.</span>
        <span class="s1">tup </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">value_arg</span><span class="s3">, </span><span class="s1">axis_value</span><span class="s3">)</span>

        <span class="s4"># loop to fill the tuple with slice(None,None) after</span>
        <span class="s4"># the axis dimension.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">axis_value </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">nd</span><span class="s3">):</span>
            <span class="s1">tup </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">slice_data</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tup</span>

    <span class="s2">return </span><span class="s1">function_sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Basic stats and aggregates</span>

<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_sum</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">array_sum_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_sum_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                                   <span class="s1">locals</span><span class="s3">=</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">c</span><span class="s3">=</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_array_sum_axis_nop</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">gen_sum_axis_impl</span><span class="s3">(</span><span class="s1">is_axis_const</span><span class="s3">, </span><span class="s1">const_axis_val</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        function that performs sums over one specific axis 
 
        The third parameter to gen_index_tuple that generates the indexing 
        tuples has to be a const so we can't just pass &quot;axis&quot; through since 
        that isn't const.  We can check for specific values and have 
        different instances that do take consts.  Supporting axis summation 
        only up to the fourth dimension for now. 
 
        typing/arraydecl.py:sum_expand defines the return type for sum with 
        axis. It is one dimension less than the input array. 
        &quot;&quot;&quot;</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span>

        <span class="s2">if not </span><span class="s1">is_axis_const</span><span class="s3">:</span>
            <span class="s4"># Catch where axis is negative or greater than 3.</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">&gt; </span><span class="s5">3</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Numba does not support sum with axis &quot;</span>
                                 <span class="s6">&quot;parameter outside the range 0 to 3.&quot;</span><span class="s3">)</span>

        <span class="s4"># Catch the case where the user misspecifies the axis to be</span>
        <span class="s4"># more than the number of the array's dimensions.</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&gt;= </span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;axis is out of bounds for array&quot;</span><span class="s3">)</span>

        <span class="s4"># Convert the shape of the input array to a list.</span>
        <span class="s1">ashape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s4"># Get the length of the axis dimension.</span>
        <span class="s1">axis_len </span><span class="s3">= </span><span class="s1">ashape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s4"># Remove the axis dimension from the list of dimensional lengths.</span>
        <span class="s1">ashape</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s4"># Convert this shape list back to a tuple using above intrinsic.</span>
        <span class="s1">ashape_without_axis </span><span class="s3">= </span><span class="s1">_create_tuple_result_shape</span><span class="s3">(</span><span class="s1">ashape</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s4"># Tuple needed here to create output array with correct size.</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">ashape_without_axis</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">))</span>

        <span class="s4"># Iterate through the axis dimension.</span>
        <span class="s2">for </span><span class="s1">axis_index </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">axis_len</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">is_axis_const</span><span class="s3">:</span>
                <span class="s4"># constant specialized version works for any valid axis value</span>
                <span class="s1">index_tuple_generic </span><span class="s3">= </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">axis_index</span><span class="s3">,</span>
                                                       <span class="s1">const_axis_val</span><span class="s3">)</span>
                <span class="s1">result </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">index_tuple_generic</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># Generate a tuple used to index the input array.</span>
                <span class="s4"># The tuple is &quot;:&quot; in all dimensions except the axis</span>
                <span class="s4"># dimension where it is &quot;axis_index&quot;.</span>
                <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">index_tuple1 </span><span class="s3">= </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">axis_index</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                    <span class="s1">result </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">index_tuple1</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">axis </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">index_tuple2 </span><span class="s3">= </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">axis_index</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
                    <span class="s1">result </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">index_tuple2</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">axis </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
                    <span class="s1">index_tuple3 </span><span class="s3">= </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">axis_index</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
                    <span class="s1">result </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">index_tuple3</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">axis </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:</span>
                    <span class="s1">index_tuple4 </span><span class="s3">= </span><span class="s1">_gen_index_tuple</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">axis_index</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)</span>
                    <span class="s1">result </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">index_tuple4</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">op</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">inner</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_sum_axis_dtype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s4"># if the return is scalar in type then &quot;take&quot; the 0th element of the</span>
    <span class="s4"># 0d array accumulator as the return value</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s6">'ndim'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">_array_sum_axis_nop</span>
    <span class="s3">[</span><span class="s1">ty_array</span><span class="s3">, </span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">is_axis_const </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">):</span>
        <span class="s4"># this special-cases for constant axis</span>
        <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s1">ty_axis</span><span class="s3">.</span><span class="s1">literal_value</span>
        <span class="s4"># fix negative axis</span>
        <span class="s2">if </span><span class="s1">const_axis_val </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s1">ty_array</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">const_axis_val</span>
        <span class="s2">if </span><span class="s1">const_axis_val </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">const_axis_val </span><span class="s3">&gt; </span><span class="s1">ty_array</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'axis' entry is out of bounds&quot;</span><span class="s3">)</span>

        <span class="s1">ty_axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">typing_context</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">const_axis_val</span><span class="s3">)</span>
        <span class="s1">axis_val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">const_axis_val</span><span class="s3">)</span>
        <span class="s4"># rewrite arguments</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">axis_val</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s4"># rewrite sig</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">args</span><span class="s3">=[</span><span class="s1">ty_array</span><span class="s3">, </span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">])</span>
        <span class="s1">is_axis_const </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">gen_impl </span><span class="s3">= </span><span class="s1">gen_sum_axis_impl</span><span class="s3">(</span><span class="s1">is_axis_const</span><span class="s3">, </span><span class="s1">const_axis_val</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">compiled </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">gen_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">array_sum_impl_axis</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">compiled</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_sum_impl_axis</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,  </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_sum_dtype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">array_sum_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_sum_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                                   <span class="s1">locals</span><span class="s3">=</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">c</span><span class="s3">=</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.sum&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_sum_axis</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s4"># if the return is scalar in type then &quot;take&quot; the 0th element of the</span>
    <span class="s4"># 0d array accumulator as the return value</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s6">'ndim'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">op </span><span class="s3">= </span><span class="s1">_array_sum_axis_nop</span>
    <span class="s3">[</span><span class="s1">ty_array</span><span class="s3">, </span><span class="s1">ty_axis</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">is_axis_const </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Literal</span><span class="s3">):</span>
        <span class="s4"># this special-cases for constant axis</span>
        <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s1">ty_axis</span><span class="s3">.</span><span class="s1">literal_value</span>
        <span class="s4"># fix negative axis</span>
        <span class="s2">if </span><span class="s1">const_axis_val </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">const_axis_val </span><span class="s3">= </span><span class="s1">ty_array</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">const_axis_val</span>
        <span class="s2">if </span><span class="s1">const_axis_val </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">const_axis_val </span><span class="s3">&gt; </span><span class="s1">ty_array</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">f&quot;'axis' entry (</span><span class="s2">{</span><span class="s1">const_axis_val</span><span class="s2">}</span><span class="s6">) is out of bounds&quot;</span>
            <span class="s2">raise </span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">ty_axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">typing_context</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">const_axis_val</span><span class="s3">)</span>
        <span class="s1">axis_val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">ty_axis</span><span class="s3">, </span><span class="s1">const_axis_val</span><span class="s3">)</span>
        <span class="s4"># rewrite arguments</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">axis_val</span>
        <span class="s4"># rewrite sig</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">args</span><span class="s3">=[</span><span class="s1">ty_array</span><span class="s3">, </span><span class="s1">ty_axis</span><span class="s3">])</span>
        <span class="s1">is_axis_const </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">gen_impl </span><span class="s3">= </span><span class="s1">gen_sum_axis_impl</span><span class="s3">(</span><span class="s1">is_axis_const</span><span class="s3">, </span><span class="s1">const_axis_val</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">compiled </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">gen_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">array_sum_impl_axis</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">compiled</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_sum_impl_axis</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_accumulator</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">timedelta64</span><span class="s3">:</span>
        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">(</span><span class="s1">value</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">acc_init</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;prod&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_prod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">get_accumulator</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">array_prod_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">acc_init</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">*= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s2">return </span><span class="s1">array_prod_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;cumsum&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_cumsum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">is_integer </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">signed_domain</span>
        <span class="s1">is_bool </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">types</span><span class="s3">.</span><span class="s1">bool_</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">is_integer </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">bitwidth </span><span class="s3">&lt; </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">.</span><span class="s1">bitwidth</span><span class="s3">)</span><span class="s1">\</span>
                <span class="s2">or </span><span class="s1">is_bool</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">get_accumulator</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">array_cumsum_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">acc_init</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">array_cumsum_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;cumprod&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_cumprod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">is_integer </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">signed_domain</span>
        <span class="s1">is_bool </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">types</span><span class="s3">.</span><span class="s1">bool_</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">is_integer </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">bitwidth </span><span class="s3">&lt; </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">.</span><span class="s1">bitwidth</span><span class="s3">)</span><span class="s1">\</span>
                <span class="s2">or </span><span class="s1">is_bool</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">get_accumulator</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">array_cumprod_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">acc_init</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">*= </span><span class="s1">v</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">array_cumprod_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;mean&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_mean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">is_number </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">integer_domain </span><span class="s3">| </span><span class="s1">frozenset</span><span class="s3">([</span><span class="s1">types</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">is_number</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">acc_init </span><span class="s3">= </span><span class="s1">get_accumulator</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">array_mean_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s4"># Can't use the naive `arr.sum() / arr.size`, as it would return</span>
            <span class="s4"># a wrong result on integer sum overflow.</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">acc_init</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">c </span><span class="s3">/ </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span>

        <span class="s2">return </span><span class="s1">array_mean_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">var</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;var&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_var</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">array_var_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s4"># Compute the mean</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>

            <span class="s4"># Compute the sum of square diffs</span>
            <span class="s1">ssd </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">val </span><span class="s3">= (</span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">() - </span><span class="s1">m</span><span class="s3">)</span>
                <span class="s1">ssd </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">val </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(</span><span class="s1">val</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">ssd </span><span class="s3">/ </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span>

        <span class="s2">return </span><span class="s1">array_var_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">std</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;std&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_std</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">array_std_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">var</span><span class="s3">() ** </span><span class="s5">0.5</span>

        <span class="s2">return </span><span class="s1">array_std_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">min_comparator</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min_val</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">min_val</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">max_comparator</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min_val</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s1">min_val</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">return_false</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">return False</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">amin</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;min&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">npy_min</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">min_comparator</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">return_false</span>

        <span class="s2">def </span><span class="s1">comp_func</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min_val</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&lt; </span><span class="s1">min_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                <span class="s2">return True</span>
            <span class="s2">elif </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s1">min_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt; </span><span class="s1">min_val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">:</span>
                    <span class="s2">return True</span>
            <span class="s2">return False</span>

        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">comp_func</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">min_comparator</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">return_false</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">min_comparator</span>

    <span class="s2">def </span><span class="s1">impl_min</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;zero-size array to reduction operation &quot;</span>
                             <span class="s6">&quot;minimum which has no identity&quot;</span><span class="s3">)</span>

        <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">pre_return_func</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">min_value</span>

        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">pre_return_func</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">v</span>
            <span class="s2">if </span><span class="s1">comparator</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">min_value</span><span class="s3">):</span>
                <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s2">return </span><span class="s1">min_value</span>

    <span class="s2">return </span><span class="s1">impl_min</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">amax</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;max&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">npy_max</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">max_comparator</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">return_false</span>

        <span class="s2">def </span><span class="s1">comp_func</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">max_val</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&gt; </span><span class="s1">max_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                <span class="s2">return True</span>
            <span class="s2">elif </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s1">max_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt; </span><span class="s1">max_val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">:</span>
                    <span class="s2">return True</span>
            <span class="s2">return False</span>

        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">comp_func</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">max_comparator</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">pre_return_func </span><span class="s3">= </span><span class="s1">return_false</span>
        <span class="s1">comparator </span><span class="s3">= </span><span class="s1">max_comparator</span>

    <span class="s2">def </span><span class="s1">impl_max</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;zero-size array to reduction operation &quot;</span>
                             <span class="s6">&quot;maximum which has no identity&quot;</span><span class="s3">)</span>

        <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">pre_return_func</span><span class="s3">(</span><span class="s1">max_value</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">max_value</span>

        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">pre_return_func</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">v</span>
            <span class="s2">if </span><span class="s1">comparator</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">max_value</span><span class="s3">):</span>
                <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s2">return </span><span class="s1">max_value</span>

    <span class="s2">return </span><span class="s1">impl_max</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmin_impl_datetime</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">)</span>
    <span class="s1">min_value </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">min_idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">min_idx</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">idx</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s1">min_value</span><span class="s3">:</span>
            <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">min_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">min_idx</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmin_impl_float</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s1">min_idx </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">min_value</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">min_idx</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">idx</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s1">min_value</span><span class="s3">:</span>
            <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">min_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">min_idx</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmin_impl_generic</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s1">min_idx </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">break</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s6">'unreachable'</span><span class="s3">)</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s1">min_value</span><span class="s3">:</span>
            <span class="s1">min_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">min_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">min_idx</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;argmin&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_argmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)):</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmin_impl_datetime</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmin_impl_float</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmin_impl_generic</span>

    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">array_argmin_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">flatten_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">array_argmin_impl </span><span class="s3">= </span><span class="s1">build_argmax_or_argmin_with_axis_impl</span><span class="s3">(</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">flatten_impl</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">array_argmin_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmax_impl_datetime</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">)</span>
    <span class="s1">max_value </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">max_idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">max_value</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">max_idx</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">idx</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&gt; </span><span class="s1">max_value</span><span class="s3">:</span>
            <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">max_idx</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmax_impl_float</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s1">max_idx </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">max_value</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">max_idx</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">idx</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&gt; </span><span class="s1">max_value</span><span class="s3">:</span>
            <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">max_idx</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">array_argmax_impl_generic</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
        <span class="s1">max_idx </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">break</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">arry</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s3">&gt; </span><span class="s1">max_value</span><span class="s3">:</span>
            <span class="s1">max_value </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">idx </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">max_idx</span>


<span class="s2">def </span><span class="s1">build_argmax_or_argmin_with_axis_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">flatten_impl</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a function that implements the logic for handling a flattened 
    array, return the implementation function. 
    &quot;&quot;&quot;</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s6">&quot;axis&quot;</span><span class="s3">)</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>

    <span class="s1">tuple_buffer </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">axis</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">&gt;= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;axis is out of bounds&quot;</span><span class="s3">)</span>

        <span class="s4"># Short circuit 1-dimensional arrays:</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">flatten_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s4"># Make chosen axis the last axis:</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">tuple_buffer</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">transpose_index </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">transposed_arr </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">transpose_index</span><span class="s3">)</span>

        <span class="s4"># Flatten along that axis; since we've transposed, we can just get</span>
        <span class="s4"># batches off the overall flattened array.</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">transposed_arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">raveled </span><span class="s3">= </span><span class="s1">transposed_arr</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s2">assert </span><span class="s1">raveled</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span>
        <span class="s2">assert </span><span class="s1">transposed_arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">% </span><span class="s1">m </span><span class="s3">== </span><span class="s5">0</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">transposed_arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">// </span><span class="s1">m</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">flatten_impl</span><span class="s3">(</span><span class="s1">raveled</span><span class="s3">[</span><span class="s1">i </span><span class="s3">* </span><span class="s1">m</span><span class="s3">:(</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">m</span><span class="s3">])</span>

        <span class="s4"># Reshape based on axis we didn't flatten over:</span>
        <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">transposed_arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;argmax&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_argmax</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)):</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmax_impl_datetime</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmax_impl_float</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">flatten_impl </span><span class="s3">= </span><span class="s1">array_argmax_impl_generic</span>

    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">array_argmax_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">flatten_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">array_argmax_impl </span><span class="s3">= </span><span class="s1">build_argmax_or_argmin_with_axis_impl</span><span class="s3">(</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">flatten_impl</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">array_argmax_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;all&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">flat_all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">():</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">return </span><span class="s1">flat_all</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_allclose_scalars</span><span class="s3">(</span><span class="s1">a_v</span><span class="s3">, </span><span class="s1">b_v</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">a_v_isnan </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a_v</span><span class="s3">)</span>
    <span class="s1">b_v_isnan </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b_v</span><span class="s3">)</span>

    <span class="s4"># only one of the values is NaN and the</span>
    <span class="s4"># other is not.</span>
    <span class="s2">if </span><span class="s3">( (</span><span class="s2">not </span><span class="s1">a_v_isnan </span><span class="s2">and </span><span class="s1">b_v_isnan</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s3">(</span><span class="s1">a_v_isnan </span><span class="s2">and not </span><span class="s1">b_v_isnan</span><span class="s3">) ):</span>
        <span class="s2">return False</span>

    <span class="s4"># either both of the values are NaN</span>
    <span class="s4"># or both are numbers</span>
    <span class="s2">if </span><span class="s1">a_v_isnan </span><span class="s2">and </span><span class="s1">b_v_isnan</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">equal_nan</span><span class="s3">:</span>
            <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">a_v</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">b_v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a_v </span><span class="s3">== </span><span class="s1">b_v</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">a_v </span><span class="s3">- </span><span class="s1">b_v</span><span class="s3">) &gt; </span><span class="s1">atol </span><span class="s3">+ </span><span class="s1">rtol </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">b_v </span><span class="s3">* </span><span class="s5">1.0</span><span class="s3">):</span>
            <span class="s2">return False</span>

    <span class="s2">return True</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;allclose&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_allclose</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The first argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The second argument &quot;b&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rtol</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The third argument &quot;rtol&quot; must be a '</span>
                          <span class="s6">'floating point'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">atol</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The fourth argument &quot;atol&quot; must be a '</span>
                          <span class="s6">'floating point'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">equal_nan</span><span class="s3">, (</span><span class="s1">bool</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The fifth argument &quot;equal_nan&quot; must be a '</span>
                          <span class="s6">'boolean'</span><span class="s3">)</span>

    <span class="s1">is_a_scalar </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>
    <span class="s1">is_b_scalar </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_a_scalar </span><span class="s2">and </span><span class="s1">is_b_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_allclose_impl_scalar_scalar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">,</span>
                                           <span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_allclose_scalars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">,</span>
                                     <span class="s1">equal_nan</span><span class="s3">=</span><span class="s1">equal_nan</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np_allclose_impl_scalar_scalar</span>
    <span class="s2">elif </span><span class="s1">is_a_scalar </span><span class="s2">and not </span><span class="s1">is_b_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_allclose_impl_scalar_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">,</span>
                                          <span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">bv </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s1">_allclose_scalars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bv</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">,</span>
                                         <span class="s1">equal_nan</span><span class="s3">=</span><span class="s1">equal_nan</span><span class="s3">):</span>
                    <span class="s2">return False</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">np_allclose_impl_scalar_array</span>
    <span class="s2">elif not </span><span class="s1">is_a_scalar </span><span class="s2">and </span><span class="s1">is_b_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_allclose_impl_array_scalar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">,</span>
                                          <span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">av </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s1">_allclose_scalars</span><span class="s3">(</span><span class="s1">av</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">,</span>
                                         <span class="s1">equal_nan</span><span class="s3">=</span><span class="s1">equal_nan</span><span class="s3">):</span>
                    <span class="s2">return False</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">np_allclose_impl_array_scalar</span>
    <span class="s2">elif not </span><span class="s1">is_a_scalar </span><span class="s2">and not </span><span class="s1">is_b_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_allclose_impl_array_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">,</span>
                                         <span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
            <span class="s1">a_a</span><span class="s3">, </span><span class="s1">b_b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">av</span><span class="s3">, </span><span class="s1">bv </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">((</span><span class="s1">a_a</span><span class="s3">, </span><span class="s1">b_b</span><span class="s3">)):</span>
                <span class="s2">if not </span><span class="s1">_allclose_scalars</span><span class="s3">(</span><span class="s1">av</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">bv</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">,</span>
                                         <span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s1">equal_nan</span><span class="s3">):</span>
                    <span class="s2">return False</span>

            <span class="s2">return True</span>

        <span class="s2">return </span><span class="s1">np_allclose_impl_array_array</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">&quot;any&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_any</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">flat_any</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">():</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">return </span><span class="s1">flat_any</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">average</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_average</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">np_average_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">np_average_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                            <span class="s6">&quot;Numba does not support average when shapes of &quot;</span>
                            <span class="s6">&quot;a and weights differ.&quot;</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                            <span class="s6">&quot;1D weights expected when shapes of &quot;</span>
                            <span class="s6">&quot;a and weights differ.&quot;</span><span class="s3">)</span>

                <span class="s1">scl </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">scl </span><span class="s3">== </span><span class="s5">0.0</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ZeroDivisionError</span><span class="s3">(</span>
                        <span class="s6">&quot;Weights sum to zero, can't be normalized.&quot;</span><span class="s3">)</span>

                <span class="s1">avg </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">)) / </span><span class="s1">scl</span>
                <span class="s2">return </span><span class="s1">avg</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_average_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;Numba does not support average with axis.&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_average_impl</span>


<span class="s2">def </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A generic isnan() function 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">_trivial_isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">_trivial_isnan</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplex</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_iscomplex</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># NumPy uses asanyarray here!</span>
        <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">imag </span><span class="s3">!= </span><span class="s5">0</span>
    <span class="s2">return None</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_isreal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># NumPy uses asanyarray here!</span>
        <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">imag </span><span class="s3">== </span><span class="s5">0</span>
    <span class="s2">return None</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s4"># Implementation based on NumPy</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/d9b1e32cb8ef90d6b4a47853241db2a28146a57d/numpy/lib/type_check.py#L282-L320</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
    <span class="s1">iscmplx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return False</span>
            <span class="s2">return </span><span class="s1">iscmplx</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">iscmplx</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isrealobj</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">isrealobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s4"># Return True if x is not a complex type.</span>
    <span class="s4"># Implementation based on NumPy</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/ccfbcc1cd9a4035a467f2e982a565ab27de25b6b/numpy/lib/type_check.py#L290-L322</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_isscalar</span><span class="s3">(</span><span class="s1">element</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">type_is_scalar</span><span class="s3">(</span><span class="s1">element</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">element</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">is_np_inf_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">):</span>

    <span class="s4"># if/else branch should be unified after PR #5606 is merged</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_and</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">signbit</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_and</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">signbit</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)), </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isneginf</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">isneginf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">is_np_inf_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isposinf</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">isposinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: ~</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">is_np_inf_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">less_than</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">greater_than</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s1">b</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">check_array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'zero-size array to reduction operation not possible'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">nan_min_max_factory</span><span class="s3">(</span><span class="s1">comparison_op</span><span class="s3">, </span><span class="s1">is_complex_dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">is_complex_dtype</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">check_array</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">return_val </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
                <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">return_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
                    <span class="s1">return_val </span><span class="s3">= </span><span class="s1">v</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">comparison_op</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">return_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
                        <span class="s1">return_val </span><span class="s3">= </span><span class="s1">v</span>
                    <span class="s2">elif </span><span class="s1">v</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s1">return_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">comparison_op</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">return_val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                            <span class="s1">return_val </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s2">return </span><span class="s1">return_val</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">check_array</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">return_val </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
                <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                    <span class="s2">if not </span><span class="s1">comparison_op</span><span class="s3">(</span><span class="s1">return_val</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
                        <span class="s1">return_val </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s2">return </span><span class="s1">return_val</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s1">real_nanmin </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span>
    <span class="s1">nan_min_max_factory</span><span class="s3">(</span><span class="s1">less_than</span><span class="s3">, </span><span class="s1">is_complex_dtype</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s1">real_nanmax </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span>
    <span class="s1">nan_min_max_factory</span><span class="s3">(</span><span class="s1">greater_than</span><span class="s3">, </span><span class="s1">is_complex_dtype</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s1">complex_nanmin </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span>
    <span class="s1">nan_min_max_factory</span><span class="s3">(</span><span class="s1">less_than</span><span class="s3">, </span><span class="s1">is_complex_dtype</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s1">complex_nanmax </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span>
    <span class="s1">nan_min_max_factory</span><span class="s3">(</span><span class="s1">greater_than</span><span class="s3">, </span><span class="s1">is_complex_dtype</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_isclose_item</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">equal_nan</span>
    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">x </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) == (</span><span class="s1">y </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x </span><span class="s3">- </span><span class="s1">y</span><span class="s3">) &lt;= </span><span class="s1">atol </span><span class="s3">+ </span><span class="s1">rtol </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isclose</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The first argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The second argument &quot;b&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rtol</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The third argument &quot;rtol&quot; must be a '</span>
                          <span class="s6">'floating point'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">atol</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The fourth argument &quot;atol&quot; must be a '</span>
                          <span class="s6">'floating point'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">equal_nan</span><span class="s3">, (</span><span class="s1">bool</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The fifth argument &quot;equal_nan&quot; must be a '</span>
                          <span class="s6">'boolean'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">isclose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">b</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">_isclose_item</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">isclose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">_isclose_item</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">isclose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">a_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">b_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a_</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">av</span><span class="s3">, </span><span class="s1">bv</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">((</span><span class="s1">a_</span><span class="s3">, </span><span class="s1">b_</span><span class="s3">))):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">_isclose_item</span><span class="s3">(</span><span class="s1">av</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">bv</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">,</span>
                                       <span class="s1">equal_nan</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">isclose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_isclose_item</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">isclose_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmin</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">complex_nanmin</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">real_nanmin</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmax</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanmax</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">complex_nanmax</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">real_nanmax</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmean</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanmean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s1">isnan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanmean_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                <span class="s1">count </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s4"># np.divide() doesn't raise ZeroDivisionError</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">nanmean_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanvar</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanvar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s1">isnan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanvar_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s4"># Compute the mean</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s4"># Compute the sum of square diffs</span>
        <span class="s1">ssd </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s1">val </span><span class="s3">= (</span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">() - </span><span class="s1">m</span><span class="s3">)</span>
                <span class="s1">ssd </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">val </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(</span><span class="s1">val</span><span class="s3">))</span>
                <span class="s1">count </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s4"># np.divide() doesn't raise ZeroDivisionError</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">ssd</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">nanvar_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanstd</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanstd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">nanstd_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanvar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) ** </span><span class="s5">0.5</span>

    <span class="s2">return </span><span class="s1">nanstd_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nansum</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nansum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">isnan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nansum_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s2">return </span><span class="s1">nansum_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanprod</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanprod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">isnan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanprod_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">one</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">*= </span><span class="s1">v</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s2">return </span><span class="s1">nanprod_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nancumprod</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nancumprod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s4"># dtype cannot possibly contain NaN</span>
        <span class="s2">return lambda </span><span class="s1">a</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s1">is_nan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s1">one </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">nancumprod_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">one</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s3">~</span><span class="s1">is_nan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                    <span class="s1">c </span><span class="s3">*= </span><span class="s1">v</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">nancumprod_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nancumsum</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nancumsum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s4"># dtype cannot possibly contain NaN</span>
        <span class="s2">return lambda </span><span class="s1">a</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s1">is_nan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s1">zero </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">nancumsum_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">zero</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s3">~</span><span class="s1">is_nan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                    <span class="s1">c </span><span class="s3">+= </span><span class="s1">v</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">nancumsum_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">prepare_ptp_input</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'zero-size array reduction not possible'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">_compute_current_val_impl_gen</span><span class="s3">(</span><span class="s1">op</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s4"># The sort order for complex numbers is lexicographic. If both the</span>
        <span class="s4"># real and imaginary parts are non-nan then the order is determined</span>
        <span class="s4"># by the real parts except when they are equal, in which case the</span>
        <span class="s4"># order is determined by the imaginary parts.</span>
        <span class="s4"># https://github.com/numpy/numpy/blob/577a86e/numpy/core/fromnumeric.py#L874-L877    # noqa: E501</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">op</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">val</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s1">current_val</span><span class="s3">.</span><span class="s1">real</span>
                    <span class="s2">and </span><span class="s1">op</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)):</span>
                <span class="s2">return </span><span class="s1">val</span>
            <span class="s2">return </span><span class="s1">current_val</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">op</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">) </span><span class="s2">else </span><span class="s1">current_val</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_compute_a_max</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_compute_a_min</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_compute_a_max</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_compute_a_max_impl</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_compute_current_val_impl_gen</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">gt</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_compute_a_min</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_compute_a_min_impl</span><span class="s3">(</span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_compute_current_val_impl_gen</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">lt</span><span class="s3">, </span><span class="s1">current_val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_early_return</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_early_return</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_early_return_impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">UNUSED </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                    <span class="s2">return True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan </span><span class="s3">* </span><span class="s5">1j</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan </span><span class="s3">+ </span><span class="s5">0j</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return False</span><span class="s3">, </span><span class="s1">UNUSED</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
                <span class="s2">return True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return False</span><span class="s3">, </span><span class="s1">UNUSED</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
            <span class="s2">return False</span><span class="s3">, </span><span class="s1">UNUSED</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ptp</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_ptp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;Boolean dtype is unsupported (as per NumPy)&quot;</span><span class="s3">)</span>
            <span class="s4"># Numpy raises a TypeError</span>

    <span class="s2">def </span><span class="s1">np_ptp_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">prepare_ptp_input</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">a_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s1">a_min </span><span class="s3">= </span><span class="s1">a_flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">a_max </span><span class="s3">= </span><span class="s1">a_flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">a_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">take_branch</span><span class="s3">, </span><span class="s1">retval </span><span class="s3">= </span><span class="s1">_early_return</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">take_branch</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">retval</span>
            <span class="s1">a_max </span><span class="s3">= </span><span class="s1">_compute_a_max</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
            <span class="s1">a_min </span><span class="s3">= </span><span class="s1">_compute_a_min</span><span class="s3">(</span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">a_max </span><span class="s3">- </span><span class="s1">a_min</span>

    <span class="s2">return </span><span class="s1">np_ptp_impl</span>


<span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s6">'ptp'</span><span class="s3">)(</span><span class="s1">np_ptp</span><span class="s3">)</span>

<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Median and partitioning</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">nan_aware_less_than</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span>


<span class="s2">def </span><span class="s1">_partition_factory</span><span class="s3">(</span><span class="s1">pivotimpl</span><span class="s3">, </span><span class="s1">argpartition</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">_partition</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">I</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">mid </span><span class="s3">= (</span><span class="s1">low </span><span class="s3">+ </span><span class="s1">high</span><span class="s3">) &gt;&gt; </span><span class="s5">1</span>
        <span class="s4"># NOTE: the pattern of swaps below for the pivot choice and the</span>
        <span class="s4"># partitioning gives good results (i.e. regular O(n log n))</span>
        <span class="s4"># on sorted, reverse-sorted, and uniform arrays.  Subtle changes</span>
        <span class="s4"># risk breaking this property.</span>

        <span class="s4"># Use median of three {low, middle, high} as the pivot</span>
        <span class="s2">if </span><span class="s1">pivotimpl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]):</span>
            <span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
                <span class="s1">I</span><span class="s3">[</span><span class="s1">low</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">pivotimpl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">]):</span>
            <span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
                <span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">pivotimpl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]):</span>
            <span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
                <span class="s1">I</span><span class="s3">[</span><span class="s1">low</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">low</span><span class="s3">]</span>
        <span class="s1">pivot </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">]</span>

        <span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
            <span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">]</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">low</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s1">high </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">high </span><span class="s2">and </span><span class="s1">pivotimpl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">pivot</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">while </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s1">low </span><span class="s2">and </span><span class="s1">pivotimpl</span><span class="s3">(</span><span class="s1">pivot</span><span class="s3">, </span><span class="s1">A</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]):</span>
                <span class="s1">j </span><span class="s3">-= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s1">j</span><span class="s3">:</span>
                <span class="s2">break</span>
            <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
                <span class="s1">I</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">j </span><span class="s3">-= </span><span class="s5">1</span>
        <span class="s4"># Put the pivot back in its final place (all items before `i`</span>
        <span class="s4"># are smaller than the pivot, all items at/after `i` are larger)</span>
        <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">] = </span><span class="s1">A</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">argpartition</span><span class="s3">:</span>
            <span class="s1">I</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">] = </span><span class="s1">I</span><span class="s3">[</span><span class="s1">high</span><span class="s3">], </span><span class="s1">I</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">i</span>
    <span class="s2">return </span><span class="s1">_partition</span>


<span class="s1">_partition </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_partition_factory</span><span class="s3">(</span><span class="s1">less_than</span><span class="s3">))</span>
<span class="s1">_partition_w_nan </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_partition_factory</span><span class="s3">(</span><span class="s1">nan_aware_less_than</span><span class="s3">))</span>
<span class="s1">_argpartition_w_nan </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_partition_factory</span><span class="s3">(</span>
    <span class="s1">nan_aware_less_than</span><span class="s3">,</span>
    <span class="s1">argpartition</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
<span class="s3">)</span>


<span class="s2">def </span><span class="s1">_select_factory</span><span class="s3">(</span><span class="s1">partitionimpl</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select the k'th smallest element in array[low:high + 1]. 
        &quot;&quot;&quot;</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">partitionimpl</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">)</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">!= </span><span class="s1">k</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">k</span><span class="s3">:</span>
                <span class="s1">low </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">partitionimpl</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">high </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">partitionimpl</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">arry</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">_select</span>


<span class="s1">_select </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_select_factory</span><span class="s3">(</span><span class="s1">_partition</span><span class="s3">))</span>
<span class="s1">_select_w_nan </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_select_factory</span><span class="s3">(</span><span class="s1">_partition_w_nan</span><span class="s3">))</span>
<span class="s1">_arg_select_w_nan </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_select_factory</span><span class="s3">(</span><span class="s1">_argpartition_w_nan</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_select_two</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Select the k'th and k+1'th smallest elements in array[low:high + 1]. 
 
    This is significantly faster than doing two independent selections 
    for k and k+1. 
    &quot;&quot;&quot;</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">high </span><span class="s3">&gt; </span><span class="s1">low  </span><span class="s4"># by construction</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">_partition</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">k</span><span class="s3">:</span>
            <span class="s1">low </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">high </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">i </span><span class="s3">== </span><span class="s1">k</span><span class="s3">:</span>
            <span class="s1">_select</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s4"># i == k + 1</span>
            <span class="s1">_select</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">arry</span><span class="s3">[</span><span class="s1">k</span><span class="s3">], </span><span class="s1">arry</span><span class="s3">[</span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_median_inner</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The main logic of the median() call.  *temp_arry* must be disposable, 
    as this function will mutate it. 
    &quot;&quot;&quot;</span>
    <span class="s1">low </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">high </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span>
    <span class="s1">half </span><span class="s3">= </span><span class="s1">n </span><span class="s3">&gt;&gt; </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">&amp; </span><span class="s5">1 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">_select_two</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">half </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">) / </span><span class="s5">2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">half</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">median</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_median</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">median_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s4"># np.median() works on the flattened array, and we need a temporary</span>
        <span class="s4"># workspace anyway</span>
        <span class="s1">temp_arry </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">()</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">temp_arry</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">_median_inner</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">median_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_collect_percentiles_inner</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s4">#TODO: This needs rewriting to be closer to NumPy, particularly the nan/inf</span>
    <span class="s4"># handling which is generally subject to algorithmic changes.</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s4"># single element array; output same for all percentiles</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">q</span><span class="s3">), </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">q</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)):</span>
            <span class="s1">percentile </span><span class="s3">= </span><span class="s1">q</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s4"># bypass pivoting where requested percentile is 100</span>
            <span class="s2">if </span><span class="s1">percentile </span><span class="s3">== </span><span class="s5">100</span><span class="s3">:</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s4"># heuristics to handle infinite values a la NumPy</span>
                <span class="s2">if </span><span class="s3">~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                    <span class="s2">if </span><span class="s3">~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

            <span class="s4"># bypass pivoting where requested percentile is 0</span>
            <span class="s2">elif </span><span class="s1">percentile </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s4"># convoluted heuristics to handle infinite values a la NumPy</span>
                <span class="s2">if </span><span class="s3">~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                    <span class="s1">num_pos_inf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">a </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
                    <span class="s1">num_neg_inf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">a </span><span class="s3">== -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
                    <span class="s1">num_finite </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- (</span><span class="s1">num_neg_inf </span><span class="s3">+ </span><span class="s1">num_pos_inf</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">num_finite </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
                    <span class="s2">if </span><span class="s1">num_pos_inf </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">n </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
                    <span class="s2">if </span><span class="s1">num_neg_inf </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
                    <span class="s2">if </span><span class="s1">num_finite </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">num_pos_inf </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">num_neg_inf </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
                                <span class="s1">val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># linear interp between closest ranks</span>
                <span class="s1">rank </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">+ (</span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">true_divide</span><span class="s3">(</span><span class="s1">percentile</span><span class="s3">, </span><span class="s5">100.0</span><span class="s3">)</span>
                <span class="s1">f </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">)</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">rank </span><span class="s3">- </span><span class="s1">f</span>
                <span class="s1">lower</span><span class="s3">, </span><span class="s1">upper </span><span class="s3">= </span><span class="s1">_select_two</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">int</span><span class="s3">(</span><span class="s1">f </span><span class="s3">- </span><span class="s5">1</span><span class="s3">), </span><span class="s1">low</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=(</span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>
                <span class="s1">val </span><span class="s3">= </span><span class="s1">lower </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">m</span><span class="s3">) + </span><span class="s1">upper </span><span class="s3">* </span><span class="s1">m</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">val</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_can_collect_percentiles</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">nan_mask</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">skip_nan</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[~</span><span class="s1">nan_mask</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return False  </span><span class="s4"># told to skip nan, but no elements remain</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">nan_mask</span><span class="s3">):</span>
            <span class="s2">return False  </span><span class="s4"># told *not* to skip nan, but nan encountered</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:  </span><span class="s4"># single element array</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)  </span><span class="s4"># can collect percentiles if element is finite</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return True</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">check_valid</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">q_upper_bound</span><span class="s3">):</span>
    <span class="s1">valid </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s4"># avoid expensive reductions where possible</span>
    <span class="s2">if </span><span class="s1">q</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">q</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">10</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">q</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">q</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt; </span><span class="s5">0.0 </span><span class="s2">or </span><span class="s1">q</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">q_upper_bound </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">q</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]):</span>
                <span class="s1">valid </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s2">break</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt; </span><span class="s5">0.0</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">q </span><span class="s3">&gt; </span><span class="s1">q_upper_bound</span><span class="s3">):</span>
            <span class="s1">valid </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">return </span><span class="s1">valid</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">percentile_is_valid</span><span class="s3">(</span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">check_valid</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">q_upper_bound</span><span class="s3">=</span><span class="s5">100.0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Percentiles must be in the range [0, 100]'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">quantile_is_valid</span><span class="s3">(</span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">check_valid</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">q_upper_bound</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Quantiles must be in the range [0, 1]'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_collect_percentiles</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">):</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s1">check_q</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">q </span><span class="s3">* </span><span class="s1">factor</span>

    <span class="s1">temp_arry </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s1">nan_mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">_can_collect_percentiles</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">nan_mask</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">):</span>
        <span class="s1">temp_arry </span><span class="s3">= </span><span class="s1">temp_arry</span><span class="s3">[~</span><span class="s1">nan_mask</span><span class="s3">]</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">_collect_percentiles_inner</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">q</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">q</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_percentile_quantile_inner</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The underlying algorithm to find percentiles and quantiles 
    is the same, hence we converge onto the same code paths 
    in this inner function implementation 
    &quot;&quot;&quot;</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'Not supported for complex dtype'</span><span class="s3">)</span>
        <span class="s4"># this could be supported, but would require a</span>
        <span class="s4"># lexicographic comparison</span>

    <span class="s2">def </span><span class="s1">np_percentile_q_scalar_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_collect_percentiles</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">np_percentile_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_collect_percentiles</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">np_percentile_q_scalar_impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">q</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_percentile_q_scalar_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_percentile_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">percentile</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_percentile</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_percentile_quantile_inner</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">=</span><span class="s1">percentile_is_valid</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanpercentile</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanpercentile</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_percentile_quantile_inner</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">=</span><span class="s1">percentile_is_valid</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">quantile</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_quantile</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_percentile_quantile_inner</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">=</span><span class="s5">100.0</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">=</span><span class="s1">quantile_is_valid</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanquantile</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanquantile</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_percentile_quantile_inner</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">skip_nan</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">=</span><span class="s5">100.0</span><span class="s3">, </span><span class="s1">check_q</span><span class="s3">=</span><span class="s1">quantile_is_valid</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmedian</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_nanmedian</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s1">isnan </span><span class="s3">= </span><span class="s1">get_isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nanmedian_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s4"># Create a temporary workspace with only non-NaN values</span>
        <span class="s1">temp_arry </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
                <span class="s1">temp_arry</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">v</span>
                <span class="s1">n </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s4"># all NaNs</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

        <span class="s2">return </span><span class="s1">_median_inner</span><span class="s3">(</span><span class="s1">temp_arry</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">nanmedian_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_partition_impl_inner</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth_array</span><span class="s3">):</span>

    <span class="s4"># allocate and fill empty array rather than copy a and mutate in place</span>
    <span class="s4"># as the latter approach fails to preserve strides</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])  </span><span class="s4"># Numpy default partition axis is -1</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">idx</span><span class="s3">:</span>
        <span class="s1">arry </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">s</span><span class="s3">].</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">low </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">high </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">) - </span><span class="s5">1</span>

        <span class="s2">for </span><span class="s1">kth </span><span class="s2">in </span><span class="s1">kth_array</span><span class="s3">:</span>
            <span class="s1">_select_w_nan</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
            <span class="s1">low </span><span class="s3">= </span><span class="s1">kth  </span><span class="s4"># narrow span of subsequent partition</span>

        <span class="s1">out</span><span class="s3">[</span><span class="s1">s</span><span class="s3">] = </span><span class="s1">arry</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_argpartition_impl_inner</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth_array</span><span class="s3">):</span>

    <span class="s4"># allocate and fill empty array rather than copy a and mutate in place</span>
    <span class="s4"># as the latter approach fails to preserve strides</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])  </span><span class="s4"># Numpy default partition axis is -1</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">idx</span><span class="s3">:</span>
        <span class="s1">arry </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">s</span><span class="s3">].</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">idx_arry </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">))</span>
        <span class="s1">low </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">high </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">) - </span><span class="s5">1</span>

        <span class="s2">for </span><span class="s1">kth </span><span class="s2">in </span><span class="s1">kth_array</span><span class="s3">:</span>
            <span class="s1">_arg_select_w_nan</span><span class="s3">(</span><span class="s1">arry</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">idx_arry</span><span class="s3">)</span>
            <span class="s1">low </span><span class="s3">= </span><span class="s1">kth  </span><span class="s4"># narrow span of subsequent partition</span>

        <span class="s1">out</span><span class="s3">[</span><span class="s1">s</span><span class="s3">] = </span><span class="s1">idx_arry</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">valid_kths</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a sorted, unique array of kth values which serve 
    as indexers for partitioning the input array, a. 
 
    If the absolute value of any of the provided values 
    is greater than a.shape[-1] an exception is raised since 
    we are partitioning along the last axis (per Numpy default 
    behaviour). 
 
    Values less than 0 are transformed to equivalent positive 
    index values. 
    &quot;&quot;&quot;</span>
    <span class="s4"># cast boolean to int, where relevant</span>
    <span class="s1">kth_array </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">kth</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">kth_array</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'kth must be scalar or 1-D'</span><span class="s3">)</span>
        <span class="s4"># numpy raises ValueError: object too deep for desired array</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">kth_array</span><span class="s3">) &gt;= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;kth out of bounds&quot;</span><span class="s3">)</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">kth_array</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">(</span><span class="s1">kth_array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">val </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]  </span><span class="s4"># equivalent positive index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">val</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">partition</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_partition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'The first argument must be an array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'The first argument must be at least 1-D (found 0-D)'</span><span class="s3">)</span>

    <span class="s1">kthdt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">kth</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kthdt</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s4"># bool gets cast to int subsequently</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'Partition index must be integer'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_partition_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">):</span>
        <span class="s1">a_tmp </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a_tmp</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a_tmp</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">kth_array </span><span class="s3">= </span><span class="s1">valid_kths</span><span class="s3">(</span><span class="s1">a_tmp</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np_partition_impl_inner</span><span class="s3">(</span><span class="s1">a_tmp</span><span class="s3">, </span><span class="s1">kth_array</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_partition_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argpartition</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_argpartition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'The first argument must be an array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'The first argument must be at least 1-D (found 0-D)'</span><span class="s3">)</span>

    <span class="s1">kthdt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">kth</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kthdt</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s4"># bool gets cast to int subsequently</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">'Partition index must be integer'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_argpartition_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">):</span>
        <span class="s1">a_tmp </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a_tmp</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a_tmp</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s6">'intp'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">kth_array </span><span class="s3">= </span><span class="s1">valid_kths</span><span class="s3">(</span><span class="s1">a_tmp</span><span class="s3">, </span><span class="s1">kth</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np_argpartition_impl_inner</span><span class="s3">(</span><span class="s1">a_tmp</span><span class="s3">, </span><span class="s1">kth_array</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_argpartition_impl</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Building matrices</span>

<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_tri_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">N</span><span class="s3">), </span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)  </span><span class="s4"># numpy floors each dimension at 0</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)  </span><span class="s4"># numpy default dtype</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
        <span class="s1">m_max </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, :</span><span class="s1">m_max</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">m_max</span><span class="s3">:] = </span><span class="s5">0</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_tri</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

    <span class="s4"># we require k to be integer, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">tri_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">M </span><span class="s3">= </span><span class="s1">N</span>
        <span class="s2">return </span><span class="s1">_tri_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">tri_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_make_square</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Takes a 1d array and tiles it to form a square matrix 
    - i.e. a facsimile of np.tile(m, (len(m), 1)) 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span>

    <span class="s1">len_m </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len_m</span><span class="s3">, </span><span class="s1">len_m</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len_m</span><span class="s3">):</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">m</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_tril_impl_2d</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">], </span><span class="s1">M</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">tril</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">my_tril</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

    <span class="s4"># we require k to be integer, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_tril_impl_1d</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">m_2d </span><span class="s3">= </span><span class="s1">_make_square</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np_tril_impl_2d</span><span class="s3">(</span><span class="s1">m_2d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_tril_impl_multi</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">], </span><span class="s1">M</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">])</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">zero_opt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">sel </span><span class="s2">in </span><span class="s1">idx</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">[</span><span class="s1">sel</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">m</span><span class="s3">[</span><span class="s1">sel</span><span class="s3">], </span><span class="s1">zero_opt</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">z</span>

    <span class="s2">if </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_tril_impl_1d</span>
    <span class="s2">elif </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_tril_impl_2d</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_tril_impl_multi</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">tril_indices</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_tril_indices</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s4"># we require integer arguments, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s6">'n'</span><span class="s3">)</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s6">'m'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_tril_indices_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">np_tril_indices_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">tril_indices_from</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_tril_indices_from</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

    <span class="s4"># we require k to be integer, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;input array must be 2-d&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_tril_indices_from_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tril_indices</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">np_tril_indices_from_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_triu_impl_2d</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">], </span><span class="s1">M</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k </span><span class="s3">- </span><span class="s5">1</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">m</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">triu</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">my_triu</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s4"># we require k to be integer, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_triu_impl_1d</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">m_2d </span><span class="s3">= </span><span class="s1">_make_square</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np_triu_impl_2d</span><span class="s3">(</span><span class="s1">m_2d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_triu_impl_multi</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">], </span><span class="s1">M</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k </span><span class="s3">- </span><span class="s5">1</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">])</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">zero_opt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">m</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">sel </span><span class="s2">in </span><span class="s1">idx</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">[</span><span class="s1">sel</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">zero_opt</span><span class="s3">, </span><span class="s1">m</span><span class="s3">[</span><span class="s1">sel</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">z</span>

    <span class="s2">if </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_triu_impl_1d</span>
    <span class="s2">elif </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_triu_impl_2d</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_triu_impl_multi</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">triu_indices</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_triu_indices</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s4"># we require integer arguments, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s6">'n'</span><span class="s3">)</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s6">'m'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_triu_indices_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tri</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">np_triu_indices_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">triu_indices_from</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_triu_indices_from</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

    <span class="s4"># we require k to be integer, unlike numpy</span>
    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s6">'k'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;input array must be 2-d&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_triu_indices_from_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">triu_indices</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">m</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">np_triu_indices_from_impl</span>


<span class="s2">def </span><span class="s1">_prepare_array</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_prepare_array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_prepare_array_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">arr </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s2">return lambda </span><span class="s1">arr</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(())</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return lambda </span><span class="s1">arr</span><span class="s3">: </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">_dtype_of_compound</span><span class="s3">(</span><span class="s1">inobj</span><span class="s3">):</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">inobj</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s1">l </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s6">'__len__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">l </span><span class="s2">is not None and </span><span class="s1">l</span><span class="s3">() == </span><span class="s5">0</span><span class="s3">: </span><span class="s4"># empty tuple or similar</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dt </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;type has no dtype attr&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ediff1d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_ediff1d</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">to_end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">to_begin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">&quot;Boolean dtype is unsupported (as per NumPy)&quot;</span><span class="s3">)</span>
            <span class="s4"># Numpy tries to do this: return ary[1:] - ary[:-1] which</span>
            <span class="s4"># results in a TypeError exception being raised</span>

    <span class="s4"># Check that to_end and to_begin are compatible with ary</span>
    <span class="s1">ary_dt </span><span class="s3">= </span><span class="s1">_dtype_of_compound</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">to_begin_dt </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">to_begin</span><span class="s3">)):</span>
        <span class="s1">to_begin_dt </span><span class="s3">= </span><span class="s1">_dtype_of_compound</span><span class="s3">(</span><span class="s1">to_begin</span><span class="s3">)</span>
    <span class="s1">to_end_dt </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">to_end</span><span class="s3">)):</span>
        <span class="s1">to_end_dt </span><span class="s3">= </span><span class="s1">_dtype_of_compound</span><span class="s3">(</span><span class="s1">to_end</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">to_begin_dt </span><span class="s2">is not None and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">to_begin_dt</span><span class="s3">, </span><span class="s1">ary_dt</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;dtype of to_begin must be compatible with input ary&quot;</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">to_end_dt </span><span class="s2">is not None and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">to_end_dt</span><span class="s3">, </span><span class="s1">ary_dt</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;dtype of to_end must be compatible with input ary&quot;</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_ediff1d_impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">to_end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">to_begin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s4"># transform each input into an equivalent 1d array</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">_prepare_array</span><span class="s3">(</span><span class="s1">to_begin</span><span class="s3">)</span>
        <span class="s1">mid </span><span class="s3">= </span><span class="s1">_prepare_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">)</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">_prepare_array</span><span class="s3">(</span><span class="s1">to_end</span><span class="s3">)</span>

        <span class="s1">out_dtype </span><span class="s3">= </span><span class="s1">mid</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s4"># output array dtype determined by ary dtype, per NumPy</span>
        <span class="s4"># (for the most part); an exception to the rule is a zero length</span>
        <span class="s4"># array-like, where NumPy falls back to np.float64; this behaviour</span>
        <span class="s4"># is *not* replicated</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">mid</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">start</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">mid</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">end</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">),</span>
                           <span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
            <span class="s1">start_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">mid_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">start</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">mid</span><span class="s3">) - </span><span class="s5">1</span>
            <span class="s1">out</span><span class="s3">[:</span><span class="s1">start_idx</span><span class="s3">] = </span><span class="s1">start</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">start_idx</span><span class="s3">:</span><span class="s1">mid_idx</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">mid</span><span class="s3">)</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">mid_idx</span><span class="s3">:] = </span><span class="s1">end</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">start</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">end</span><span class="s3">)), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
            <span class="s1">start_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">out</span><span class="s3">[:</span><span class="s1">start_idx</span><span class="s3">] = </span><span class="s1">start</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">start_idx</span><span class="s3">:] = </span><span class="s1">end</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">return </span><span class="s1">np_ediff1d_impl</span>


<span class="s2">def </span><span class="s1">_select_element</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_select_element</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_select_element_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s1">zerod </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s6">'ndim'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) == </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">zerod</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((</span><span class="s5">1</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">x</span><span class="s3">[:] = </span><span class="s1">arr</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">arr</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_get_d</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_get_d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">get_d_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">trapz</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_trapz</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'y cannot be a scalar'</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'y cannot be 0D'</span><span class="s3">)</span>
        <span class="s4"># NumPy raises IndexError: list assignment index out of range</span>

    <span class="s4"># inspired by:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/7ee52003/numpy/lib/function_base.py#L4040-L4065    # noqa: E501</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
        <span class="s1">yarr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">_get_d</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">)</span>
        <span class="s1">y_ave </span><span class="s3">= (</span><span class="s1">yarr</span><span class="s3">[..., </span><span class="s1">slice</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)] + </span><span class="s1">yarr</span><span class="s3">[..., </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)]) / </span><span class="s5">2.0</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">d </span><span class="s3">* </span><span class="s1">y_ave</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">processed </span><span class="s3">= </span><span class="s1">_select_element</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">processed</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_np_vander</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate an N-column Vandermonde matrix from a supplied 1-dimensional 
    array, x. Store results in an output matrix, out, which is assumed to 
    be of the required dtype. 
 
    Values are accumulated using np.multiply to match the floating point 
    precision behaviour of numpy.vander. 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">assert </span><span class="s1">m </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">n </span><span class="s3">== </span><span class="s1">N</span>

    <span class="s2">if </span><span class="s1">increasing</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">out</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">out</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">[:, (</span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s1">N </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">out</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">out</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">[:, (</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)])</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_check_vander_params</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'x must be a one-dimensional array or sequence.'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Negative dimensions are not allowed'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vander</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_vander</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s2">not in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'Second argument N must be None or an integer'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_vander_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">_check_vander_params</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>

        <span class="s4"># allocate output matrix using dtype determined in closure</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">_np_vander</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">np_vander_seq_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">x_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">_check_vander_params</span><span class="s3">(</span><span class="s1">x_arr</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>

        <span class="s4"># allocate output matrix using dtype inferred when x_arr was created</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">x_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">_np_vander</span><span class="s3">(</span><span class="s1">x_arr</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">x_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s4"># replicate numpy behaviour w.r.t.type promotion</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">x_dt</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np_vander_impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">np_vander_seq_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">roll</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_roll</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shift</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'shift must be an integer'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_roll_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s4"># empty_like might result in different contiguity vs NumPy</span>

        <span class="s1">arr_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">idx </span><span class="s3">= (</span><span class="s1">i </span><span class="s3">+ </span><span class="s1">shift</span><span class="s3">) % </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s1">out</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">arr_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">return lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_roll_impl</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Mathematical functions</span>

<span class="s1">LIKELY_IN_CACHE_SIZE </span><span class="s3">= </span><span class="s5">8</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">binary_search_with_guess</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">guess</span><span class="s3">):</span>
    <span class="s4"># NOTE: Do not refactor... see note in np_interp function impl below</span>
    <span class="s4"># this is a facsimile of binary_search_with_guess prior to 1.15:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.15.x/numpy/core/src/multiarray/compiled_base.c    # noqa: E501</span>
    <span class="s4"># Permanent reference:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/3430d78c01a3b9a19adad75f1acb5ae18286da73/numpy/core/src/multiarray/compiled_base.c#L447    # noqa: E501</span>
    <span class="s1">imin </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">imax </span><span class="s3">= </span><span class="s1">length</span>

    <span class="s4"># Handle keys outside of the arr range first</span>
    <span class="s2">if </span><span class="s1">key </span><span class="s3">&gt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">length</span>
    <span class="s2">elif </span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s5">1</span>

    <span class="s4"># If len &lt;= 4 use linear search.</span>
    <span class="s4"># From above we know key &gt;= arr[0] when we start.</span>
    <span class="s2">if </span><span class="s1">length </span><span class="s3">&lt;= </span><span class="s5">4</span><span class="s3">:</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length </span><span class="s2">and </span><span class="s1">key </span><span class="s3">&gt;= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span>

    <span class="s2">if </span><span class="s1">guess </span><span class="s3">&gt; </span><span class="s1">length </span><span class="s3">- </span><span class="s5">3</span><span class="s3">:</span>
        <span class="s1">guess </span><span class="s3">= </span><span class="s1">length </span><span class="s3">- </span><span class="s5">3</span>

    <span class="s2">if </span><span class="s1">guess </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">guess </span><span class="s3">= </span><span class="s5">1</span>

    <span class="s4"># check most likely values: guess - 1, guess, guess + 1</span>
    <span class="s2">if </span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess </span><span class="s3">- </span><span class="s5">1</span><span class="s3">]:</span>
            <span class="s1">imax </span><span class="s3">= </span><span class="s1">guess </span><span class="s3">- </span><span class="s5">1</span>

            <span class="s4"># last attempt to restrict search to items in cache</span>
            <span class="s2">if </span><span class="s1">guess </span><span class="s3">&gt; </span><span class="s1">LIKELY_IN_CACHE_SIZE </span><span class="s2">and </span><span class="s1">\</span>
                    <span class="s1">key </span><span class="s3">&gt;= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess </span><span class="s3">- </span><span class="s1">LIKELY_IN_CACHE_SIZE</span><span class="s3">]:</span>
                <span class="s1">imin </span><span class="s3">= </span><span class="s1">guess </span><span class="s3">- </span><span class="s1">LIKELY_IN_CACHE_SIZE</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># key &gt;= arr[guess - 1]</span>
            <span class="s2">return </span><span class="s1">guess </span><span class="s3">- </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># key &gt;= arr[guess]</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]:</span>
            <span class="s2">return </span><span class="s1">guess</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># key &gt;= arr[guess + 1]</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">]:</span>
                <span class="s2">return </span><span class="s1">guess </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># key &gt;= arr[guess + 2]</span>
                <span class="s1">imin </span><span class="s3">= </span><span class="s1">guess </span><span class="s3">+ </span><span class="s5">2</span>
                <span class="s4"># last attempt to restrict search to items in cache</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">guess </span><span class="s3">&lt; (</span><span class="s1">length </span><span class="s3">- </span><span class="s1">LIKELY_IN_CACHE_SIZE </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)) </span><span class="s2">and </span><span class="s1">\</span>
                        <span class="s3">(</span><span class="s1">key </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">guess </span><span class="s3">+ </span><span class="s1">LIKELY_IN_CACHE_SIZE</span><span class="s3">]):</span>
                    <span class="s1">imax </span><span class="s3">= </span><span class="s1">guess </span><span class="s3">+ </span><span class="s1">LIKELY_IN_CACHE_SIZE</span>

    <span class="s4"># finally, find index by bisection</span>
    <span class="s2">while </span><span class="s1">imin </span><span class="s3">&lt; </span><span class="s1">imax</span><span class="s3">:</span>
        <span class="s1">imid </span><span class="s3">= </span><span class="s1">imin </span><span class="s3">+ ((</span><span class="s1">imax </span><span class="s3">- </span><span class="s1">imin</span><span class="s3">) &gt;&gt; </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s3">&gt;= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">imid</span><span class="s3">]:</span>
            <span class="s1">imin </span><span class="s3">= </span><span class="s1">imid </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">imax </span><span class="s3">= </span><span class="s1">imid</span>

    <span class="s2">return </span><span class="s1">imin </span><span class="s3">- </span><span class="s5">1</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_interp_impl_complex_inner</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s4"># NOTE: Do not refactor... see note in np_interp function impl below</span>
    <span class="s4"># this is a facsimile of arr_interp_complex post 1.16 with added</span>
    <span class="s4"># branching to support np1.17 style NaN handling.</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.16.x/numpy/core/src/multiarray/compiled_base.c    # noqa: E501</span>
    <span class="s4"># Permanent reference:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/971e2e89d08deeae0139d3011d15646fdac13c92/numpy/core/src/multiarray/compiled_base.c#L628    # noqa: E501</span>
    <span class="s1">dz </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">dx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s1">dy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'array of sample points is empty'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dy</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'fp and xp are not of the same size.'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">dx</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">dz</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">dres </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">dz</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">lenx </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">size</span>
    <span class="s1">lenxp </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">)</span>
    <span class="s1">lval </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">rval </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">lenxp </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">xp_val </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">fp_val </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">lenx</span><span class="s3">):</span>
            <span class="s1">x_val </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">x_val </span><span class="s3">&lt; </span><span class="s1">xp_val</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">lval</span>
            <span class="s2">elif </span><span class="s1">x_val </span><span class="s3">&gt; </span><span class="s1">xp_val</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">rval</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">fp_val</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s4"># only pre-calculate slopes if there are relatively few of them.</span>
        <span class="s2">if </span><span class="s1">lenxp </span><span class="s3">&lt;= </span><span class="s1">lenx</span><span class="s3">:</span>
            <span class="s1">slopes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">slopes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">slopes</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s1">inv_dx </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">/ (</span><span class="s1">dx</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
                <span class="s1">real </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">real </span><span class="s3">- </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">real</span><span class="s3">) * </span><span class="s1">inv_dx</span>
                <span class="s1">imag </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">imag </span><span class="s3">- </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">imag</span><span class="s3">) * </span><span class="s1">inv_dx</span>
                <span class="s1">slopes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">imag</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">lenx</span><span class="s3">):</span>
            <span class="s1">x_val </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x_val</span><span class="s3">):</span>
                <span class="s1">real </span><span class="s3">= </span><span class="s1">x_val</span>
                <span class="s1">imag </span><span class="s3">= </span><span class="s5">0.0</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">imag</span>
                <span class="s2">continue</span>

            <span class="s1">j </span><span class="s3">= </span><span class="s1">binary_search_with_guess</span><span class="s3">(</span><span class="s1">x_val</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">lenxp</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">j </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">lval</span>
            <span class="s2">elif </span><span class="s1">j </span><span class="s3">== </span><span class="s1">lenxp</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">rval</span>
            <span class="s2">elif </span><span class="s1">j </span><span class="s3">== </span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] == </span><span class="s1">x_val</span><span class="s3">:</span>
                <span class="s4"># Avoid potential non-finite interpolation</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">slopes</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                    <span class="s1">slope </span><span class="s3">= </span><span class="s1">slopes</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">inv_dx </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">/ (</span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">])</span>
                    <span class="s1">real </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">real </span><span class="s3">- </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">real</span><span class="s3">) * </span><span class="s1">inv_dx</span>
                    <span class="s1">imag </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">imag </span><span class="s3">- </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">imag</span><span class="s3">) * </span><span class="s1">inv_dx</span>
                    <span class="s1">slope </span><span class="s3">= </span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">imag</span>

                <span class="s4"># NumPy 1.17 handles NaN correctly - this is a copy of</span>
                <span class="s4"># innermost part of arr_interp_complex post 1.17:</span>
                <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.17.x/numpy/core/src/multiarray/compiled_base.c    # noqa: E501</span>
                <span class="s4"># Permanent reference:</span>
                <span class="s4"># https://github.com/numpy/numpy/blob/91fbe4dde246559fa5b085ebf4bc268e2b89eea8/numpy/core/src/multiarray/compiled_base.c#L798-L812    # noqa: E501</span>

                <span class="s4"># If we get NaN in one direction, try the other</span>
                <span class="s1">real </span><span class="s3">= </span><span class="s1">slope</span><span class="s3">.</span><span class="s1">real </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">real</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">real</span><span class="s3">):</span>
                    <span class="s1">real </span><span class="s3">= </span><span class="s1">slope</span><span class="s3">.</span><span class="s1">real </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">real</span>
                    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">real</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">real </span><span class="s3">== </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">real</span><span class="s3">:</span>
                        <span class="s1">real </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">real</span>

                <span class="s1">imag </span><span class="s3">= </span><span class="s1">slope</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">imag</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">imag</span><span class="s3">):</span>
                    <span class="s1">imag </span><span class="s3">= </span><span class="s1">slope</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">imag</span>
                    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">imag</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">imag </span><span class="s3">== </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">].</span><span class="s1">imag</span><span class="s3">:</span>
                        <span class="s1">imag </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">].</span><span class="s1">imag</span>

                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">imag</span>

    <span class="s2">return </span><span class="s1">dres</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_interp_impl_inner</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s4"># NOTE: Do not refactor... see note in np_interp function impl below</span>
    <span class="s4"># this is a facsimile of arr_interp post 1.16:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.16.x/numpy/core/src/multiarray/compiled_base.c    # noqa: E501</span>
    <span class="s4"># Permanent reference:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/971e2e89d08deeae0139d3011d15646fdac13c92/numpy/core/src/multiarray/compiled_base.c#L473     # noqa: E501</span>
    <span class="s1">dz </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">dx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">dy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'array of sample points is empty'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dy</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'fp and xp are not of the same size.'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">dx</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">dz</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">dres </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">dz</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">lenx </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">size</span>
    <span class="s1">lenxp </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dx</span><span class="s3">)</span>
    <span class="s1">lval </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">rval </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">lenxp </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">xp_val </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">fp_val </span><span class="s3">= </span><span class="s1">dy</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">lenx</span><span class="s3">):</span>
            <span class="s1">x_val </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">x_val </span><span class="s3">&lt; </span><span class="s1">xp_val</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">lval</span>
            <span class="s2">elif </span><span class="s1">x_val </span><span class="s3">&gt; </span><span class="s1">xp_val</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">rval</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">fp_val</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s4"># only pre-calculate slopes if there are relatively few of them.</span>
        <span class="s2">if </span><span class="s1">lenxp </span><span class="s3">&lt;= </span><span class="s1">lenx</span><span class="s3">:</span>
            <span class="s1">slopes </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s1">dy</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]) / (</span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s1">dx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">slopes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">lenx</span><span class="s3">):</span>
            <span class="s1">x_val </span><span class="s3">= </span><span class="s1">dz</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x_val</span><span class="s3">):</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">x_val</span>
                <span class="s2">continue</span>

            <span class="s1">j </span><span class="s3">= </span><span class="s1">binary_search_with_guess</span><span class="s3">(</span><span class="s1">x_val</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">lenxp</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">j </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">lval</span>
            <span class="s2">elif </span><span class="s1">j </span><span class="s3">== </span><span class="s1">lenxp</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">rval</span>
            <span class="s2">elif </span><span class="s1">j </span><span class="s3">== </span><span class="s1">lenxp </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] == </span><span class="s1">x_val</span><span class="s3">:</span>
                <span class="s4"># Avoid potential non-finite interpolation</span>
                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">slopes</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                    <span class="s1">slope </span><span class="s3">= </span><span class="s1">slopes</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">slope </span><span class="s3">= (</span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]) / (</span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">])</span>

                <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">slope </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>

                <span class="s4"># NOTE: this is in np1.17</span>
                <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.17.x/numpy/core/src/multiarray/compiled_base.c    # noqa: E501</span>
                <span class="s4"># Permanent reference:</span>
                <span class="s4"># https://github.com/numpy/numpy/blob/91fbe4dde246559fa5b085ebf4bc268e2b89eea8/numpy/core/src/multiarray/compiled_base.c#L610-L616    # noqa: E501</span>
                <span class="s4">#</span>
                <span class="s4"># If we get nan in one direction, try the other</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]):</span>
                    <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">slope </span><span class="s3">* (</span><span class="s1">x_val </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]) + </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]    </span><span class="s4"># noqa: E501</span>
                    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">and </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] == </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]:</span>
                        <span class="s1">dres</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">dy</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">dres</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">interp</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_interp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">):</span>
    <span class="s4"># Replicating basic interp is relatively simple, but matching the behaviour</span>
    <span class="s4"># of NumPy for edge cases is really quite hard. After a couple of attempts</span>
    <span class="s4"># to avoid translation of the C source it was deemed necessary.</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s6">'ndim'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'xp must be 1D'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s6">'ndim'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">fp</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'fp must be 1D'</span><span class="s3">)</span>

    <span class="s1">complex_dtype_msg </span><span class="s3">= (</span>
        <span class="s6">&quot;Cannot cast array data from complex dtype to float64 dtype&quot;</span>
    <span class="s3">)</span>

    <span class="s1">xp_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">xp_dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">complex_dtype_msg</span><span class="s3">)</span>

    <span class="s1">fp_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">fp_dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s1">inner </span><span class="s3">= </span><span class="s1">np_interp_impl_complex_inner</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">inner </span><span class="s3">= </span><span class="s1">np_interp_impl_inner</span>

    <span class="s2">def </span><span class="s1">np_interp_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_interp_scalar_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">complex_dtype_msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np_interp_scalar_impl</span>

    <span class="s2">return </span><span class="s1">np_interp_impl</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Statistics</span>

<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">row_wise_average</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, :]) / </span><span class="s1">n</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_cov_impl_inner</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">):</span>

    <span class="s4"># determine degrees of freedom</span>
    <span class="s2">if </span><span class="s1">ddof </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">bias</span><span class="s3">:</span>
            <span class="s1">ddof </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ddof </span><span class="s3">= </span><span class="s5">1</span>

    <span class="s4"># determine the normalization factor</span>
    <span class="s1">fact </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">ddof</span>

    <span class="s4"># numpy warns if less than 0 and floors at 0</span>
    <span class="s1">fact </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">fact</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">)</span>

    <span class="s4"># de-mean</span>
    <span class="s1">X </span><span class="s3">-= </span><span class="s1">row_wise_average</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s4"># calculate result - requires blas</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">))</span>
    <span class="s1">c </span><span class="s3">*= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">true_divide</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fact</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">_prepare_cov_input_inner</span><span class="s3">():</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_prepare_cov_input_inner</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_prepare_cov_input_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">y </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">_prepare_cov_input_inner</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">m_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">))</span>

            <span class="s2">if not </span><span class="s1">rowvar</span><span class="s3">:</span>
                <span class="s1">m_arr </span><span class="s3">= </span><span class="s1">m_arr</span><span class="s3">.</span><span class="s1">T</span>

            <span class="s2">return </span><span class="s1">m_arr</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">_prepare_cov_input_inner</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">m_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">))</span>
            <span class="s1">y_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>

            <span class="s4"># transpose if asked to and not a (1, n) vector - this looks</span>
            <span class="s4"># wrong as you might end up transposing one and not the other,</span>
            <span class="s4"># but it's what numpy does</span>
            <span class="s2">if not </span><span class="s1">rowvar</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">m_arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">m_arr </span><span class="s3">= </span><span class="s1">m_arr</span><span class="s3">.</span><span class="s1">T</span>
                <span class="s2">if </span><span class="s1">y_arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">y_arr </span><span class="s3">= </span><span class="s1">y_arr</span><span class="s3">.</span><span class="s1">T</span>

            <span class="s1">m_rows</span><span class="s3">, </span><span class="s1">m_cols </span><span class="s3">= </span><span class="s1">m_arr</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">y_rows</span><span class="s3">, </span><span class="s1">y_cols </span><span class="s3">= </span><span class="s1">y_arr</span><span class="s3">.</span><span class="s1">shape</span>

            <span class="s2">if </span><span class="s1">m_cols </span><span class="s3">!= </span><span class="s1">y_cols</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;m and y have incompatible dimensions&quot;</span><span class="s3">)</span>

            <span class="s4"># allocate and fill output array</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m_rows </span><span class="s3">+ </span><span class="s1">y_rows</span><span class="s3">, </span><span class="s1">m_cols</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">out</span><span class="s3">[:</span><span class="s1">m_rows</span><span class="s3">, :] = </span><span class="s1">m_arr</span>
            <span class="s1">out</span><span class="s3">[-</span><span class="s1">y_rows</span><span class="s3">:, :] = </span><span class="s1">y_arr</span>

            <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">return </span><span class="s1">_prepare_cov_input_inner</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_handle_m_dim_change</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">m</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s6">&quot;2D array containing a single row is unsupported due to &quot;</span>
               <span class="s6">&quot;ambiguity in type inference. To use numpy.cov in this case &quot;</span>
               <span class="s6">&quot;simply pass the row as a 1D array, i.e. m[0].&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s1">_handle_m_dim_nop </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">):</span>
    <span class="s1">array_like_dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">array_like_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s1">array_like_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s1">coltypes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">array_like</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s6">'count'</span><span class="s3">):</span>
                <span class="s3">[</span><span class="s1">coltypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">val</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">coltypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coltypes</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">array_like_dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(*[</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">) </span><span class="s2">for </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">coltypes</span><span class="s3">])</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coltypes</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">array_like_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">coltypes</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">())</span>

    <span class="s2">return </span><span class="s1">array_like_dt</span>


<span class="s2">def </span><span class="s1">check_dimensions</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">array_like</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;{0} has more than 2 dimensions&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">.</span><span class="s1">key</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_like</span><span class="s3">.</span><span class="s1">key</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">key</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;{0} has more than 2 dimensions&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_handle_ddof</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Cannot convert non-finite ddof to integer'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ddof </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'ddof must be integral value'</span><span class="s3">)</span>


<span class="s1">_handle_ddof_nop </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_prepare_cov_input</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">_DDOF_HANDLER</span><span class="s3">,</span>
                       <span class="s1">_M_DIM_HANDLER</span><span class="s3">):</span>
    <span class="s1">_M_DIM_HANDLER</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">_DDOF_HANDLER</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_prepare_cov_input_inner</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">scalar_result_expected</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">, </span><span class="s1">optional_input</span><span class="s3">):</span>
    <span class="s1">opt_is_none </span><span class="s3">= </span><span class="s1">optional_input </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">mandatory_input</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">opt_is_none</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">))</span>
               <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">mandatory_input</span><span class="s3">.</span><span class="s1">types</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">opt_is_none</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">.</span><span class="s1">types</span><span class="s3">) == </span><span class="s5">1 </span><span class="s2">and</span>
                    <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">.</span><span class="s1">types</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)):</span>
                <span class="s2">return </span><span class="s1">opt_is_none</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">return </span><span class="s1">opt_is_none</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mandatory_input</span><span class="s3">.</span><span class="s1">key</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">) </span><span class="s2">and</span>
                <span class="s1">opt_is_none</span><span class="s3">):</span>
            <span class="s2">return True</span>

    <span class="s2">return False</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_clip_corr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">fabs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_clip_complex</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s1">real </span><span class="s3">= </span><span class="s1">_clip_corr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>
    <span class="s1">imag </span><span class="s3">= </span><span class="s1">_clip_corr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">imag</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cov</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_cov</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s4"># reject problem if m and / or y are more than 2D</span>
    <span class="s1">check_dimensions</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s6">'m'</span><span class="s3">)</span>
    <span class="s1">check_dimensions</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s6">'y'</span><span class="s3">)</span>

    <span class="s4"># reject problem if ddof invalid (either upfront if type is</span>
    <span class="s4"># obviously invalid, or later if value found to be non-integral)</span>
    <span class="s2">if </span><span class="s1">ddof </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s1">_DDOF_HANDLER </span><span class="s3">= </span><span class="s1">_handle_ddof_nop</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
            <span class="s1">_DDOF_HANDLER </span><span class="s3">= </span><span class="s1">_handle_ddof_nop</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
            <span class="s1">_DDOF_HANDLER </span><span class="s3">= </span><span class="s1">_handle_ddof</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'ddof must be a real numerical scalar type'</span><span class="s3">)</span>

    <span class="s4"># special case for 2D array input with 1 row of data - select</span>
    <span class="s4"># handler function which we'll call later when we have access</span>
    <span class="s4"># to the shape of the input array</span>
    <span class="s1">_M_DIM_HANDLER </span><span class="s3">= </span><span class="s1">_handle_m_dim_nop</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">_M_DIM_HANDLER </span><span class="s3">= </span><span class="s1">_handle_m_dim_change</span>

    <span class="s4"># infer result dtype</span>
    <span class="s1">m_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">y_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">m_dt</span><span class="s3">, </span><span class="s1">y_dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_cov_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">_prepare_cov_input</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">_DDOF_HANDLER</span><span class="s3">,</span>
                               <span class="s1">_M_DIM_HANDLER</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">((</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">,</span>
                           <span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np_cov_impl_inner</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_cov_impl_single_variable</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                    <span class="s1">ddof</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">_prepare_cov_input</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">_DDOF_HANDLER</span><span class="s3">,</span>
                               <span class="s1">_M_DIM_HANDLER</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">variance </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">variance </span><span class="s3">= </span><span class="s1">np_cov_impl_inner</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">).</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">variance</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">scalar_result_expected</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np_cov_impl_single_variable</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_cov_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">corrcoef</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_corrcoef</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>

    <span class="s1">x_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">y_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">x_dt</span><span class="s3">, </span><span class="s1">y_dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">:</span>
        <span class="s1">clip_fn </span><span class="s3">= </span><span class="s1">_clip_complex</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">clip_fn </span><span class="s3">= </span><span class="s1">_clip_corr</span>

    <span class="s2">def </span><span class="s1">np_corrcoef_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cov</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">)</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
        <span class="s1">stddev </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, :] /= </span><span class="s1">stddev</span>
            <span class="s1">c</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] /= </span><span class="s1">stddev</span>

        <span class="s2">return </span><span class="s1">clip_fn</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_corrcoef_impl_single_variable</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cov</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">c </span><span class="s3">/ </span><span class="s1">c</span>

    <span class="s2">if </span><span class="s1">scalar_result_expected</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np_corrcoef_impl_single_variable</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_corrcoef_impl</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Element-wise computations</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argwhere</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_argwhere</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s4"># needs to be much more array-like for the array impl to work, Numba bug</span>
    <span class="s4"># in one of the underlying function calls?</span>

    <span class="s1">use_scalar </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">use_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">falseish </span><span class="s3">= (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">trueish </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">is not None and </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">trueish</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">falseish</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_flatnonzero</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">))[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">is not None and </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">data </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)]</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_fill_diagonal_params</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">step </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">n</span>
        <span class="s2">if </span><span class="s1">wrap</span><span class="s3">:</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">m</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;All dimensions of input must be of equal length&quot;</span><span class="s3">)</span>

        <span class="s1">step </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">+ (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])).</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">shape</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">end</span><span class="s3">, </span><span class="s1">step</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_fill_diagonal_scalar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">):</span>
    <span class="s1">end</span><span class="s3">, </span><span class="s1">step </span><span class="s3">= </span><span class="s1">_fill_diagonal_params</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">step</span><span class="s3">):</span>
        <span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">val</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_fill_diagonal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">):</span>
    <span class="s1">end</span><span class="s3">, </span><span class="s1">step </span><span class="s3">= </span><span class="s1">_fill_diagonal_params</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">)</span>
    <span class="s1">ctr </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">v_len </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">step</span><span class="s3">):</span>
        <span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">val</span><span class="s3">[</span><span class="s1">ctr</span><span class="s3">]</span>
        <span class="s1">ctr </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s1">ctr </span><span class="s3">= </span><span class="s1">ctr </span><span class="s3">% </span><span class="s1">v_len</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_check_val_int</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">iinfo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">v_min </span><span class="s3">= </span><span class="s1">iinfo</span><span class="s3">.</span><span class="s1">min</span>
    <span class="s1">v_max </span><span class="s3">= </span><span class="s1">iinfo</span><span class="s3">.</span><span class="s1">max</span>

    <span class="s4"># check finite values are within bounds</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">val </span><span class="s3">&lt; </span><span class="s1">v_min</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">val </span><span class="s3">&gt; </span><span class="s1">v_max</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Unable to safely conform val to a.dtype'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_check_val_float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">finfo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">v_min </span><span class="s3">= </span><span class="s1">finfo</span><span class="s3">.</span><span class="s1">min</span>
    <span class="s1">v_max </span><span class="s3">= </span><span class="s1">finfo</span><span class="s3">.</span><span class="s1">max</span>

    <span class="s4"># check finite values are within bounds</span>
    <span class="s1">finite_vals </span><span class="s3">= </span><span class="s1">val</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)]</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">finite_vals </span><span class="s3">&lt; </span><span class="s1">v_min</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">finite_vals </span><span class="s3">&gt; </span><span class="s1">v_max</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Unable to safely conform val to a.dtype'</span><span class="s3">)</span>


<span class="s4"># no check performed, needed for pathway where no check is required</span>
<span class="s1">_check_nop </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_asarray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_asarray_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s1">ty </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">x</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ty</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">fill_diagonal</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_fill_diagonal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s4"># the following can be simplified after #3088; until then, employ</span>
        <span class="s4"># a basic mechanism for catching cases where val is of a type/value</span>
        <span class="s4"># which cannot safely be cast to a.dtype</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s1">checker </span><span class="s3">= </span><span class="s1">_check_val_int</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
            <span class="s1">checker </span><span class="s3">= </span><span class="s1">_check_val_float</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">checker </span><span class="s3">= </span><span class="s1">_check_nop</span>

        <span class="s2">def </span><span class="s1">scalar_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">tmpval </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">val</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
            <span class="s1">checker</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tmpval</span><span class="s3">)</span>
            <span class="s1">_fill_diagonal_scalar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">non_scalar_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">tmpval </span><span class="s3">= </span><span class="s1">_asarray</span><span class="s3">(</span><span class="s1">val</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
            <span class="s1">checker</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tmpval</span><span class="s3">)</span>
            <span class="s1">_fill_diagonal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tmpval</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">scalar_impl</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">non_scalar_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;The first argument must be at least 2-D (found %s-D)&quot; </span><span class="s3">% </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_np_round_intrinsic</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">):</span>
    <span class="s4"># np.round() always rounds half to even</span>
    <span class="s2">return </span><span class="s6">&quot;llvm.rint.f%d&quot; </span><span class="s3">% (</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">bitwidth</span><span class="s3">,)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">val</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">val</span><span class="s3">] = </span><span class="s1">args</span>
        <span class="s1">tp </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">llty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">llvmlite</span><span class="s3">.</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">llty</span><span class="s3">, [</span><span class="s1">llty</span><span class="s3">])</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">,</span>
                                            <span class="s1">_np_round_intrinsic</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">))</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, (</span><span class="s1">val</span><span class="s3">,))</span>
        <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">round_ndigits</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ndigits</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">or </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s4"># NOTE: this is CPython's algorithm, but perhaps this is overkill</span>
    <span class="s4"># when emulating Numpy's behaviour.</span>
    <span class="s2">if </span><span class="s1">ndigits </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">ndigits </span><span class="s3">&gt; </span><span class="s5">22</span><span class="s3">:</span>
            <span class="s4"># pow1 and pow2 are each safe from overflow, but</span>
            <span class="s4"># pow1*pow2 ~= pow(10.0, ndigits) might overflow.</span>
            <span class="s1">pow1 </span><span class="s3">= </span><span class="s5">10.0 </span><span class="s3">** (</span><span class="s1">ndigits </span><span class="s3">- </span><span class="s5">22</span><span class="s3">)</span>
            <span class="s1">pow2 </span><span class="s3">= </span><span class="s5">1e22</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">pow1 </span><span class="s3">= </span><span class="s5">10.0 </span><span class="s3">** </span><span class="s1">ndigits</span>
            <span class="s1">pow2 </span><span class="s3">= </span><span class="s5">1.0</span>
        <span class="s1">y </span><span class="s3">= (</span><span class="s1">x </span><span class="s3">* </span><span class="s1">pow1</span><span class="s3">) * </span><span class="s1">pow2</span>
        <span class="s2">if </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) / </span><span class="s1">pow2</span><span class="s3">) / </span><span class="s1">pow1</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">pow1 </span><span class="s3">= </span><span class="s5">10.0 </span><span class="s3">** (-</span><span class="s1">ndigits</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">x </span><span class="s3">/ </span><span class="s1">pow1</span>
        <span class="s2">return </span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) * </span><span class="s1">pow1</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">around</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_round</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'The argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;out&quot; must be an array if it is provided'</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
                <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">decimals </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">round_ndigits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">impl</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
                <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">decimals </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">a</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">round_ndigits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">))</span>
                <span class="s2">return </span><span class="s1">impl</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
                <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">decimals </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                        <span class="s1">real </span><span class="s3">= </span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>
                        <span class="s1">imag </span><span class="s3">= </span><span class="s1">_np_round_float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">real </span><span class="s3">= </span><span class="s1">round_ndigits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">)</span>
                        <span class="s1">imag </span><span class="s3">= </span><span class="s1">round_ndigits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">complex</span><span class="s3">(</span><span class="s1">real</span><span class="s3">, </span><span class="s1">imag</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">impl</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">out</span>
            <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">impl</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;invalid output shape&quot;</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                    <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">out</span>
            <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">round_</span><span class="s3">)(</span><span class="s1">impl_np_round</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_sinc</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s5">0.e0</span><span class="s3">: </span><span class="s4"># to match np impl</span>
                <span class="s1">x </span><span class="s3">= </span><span class="s5">1e-20</span>
            <span class="s1">x </span><span class="s3">*= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s4"># np sinc is the normalised variant</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) / </span><span class="s1">x</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'Argument &quot;x&quot; must be a Number or array-like.'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ov_np_angle</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">deg_mult </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s5">180 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">)</span>

    <span class="s4"># non-complex scalar values are accepted as well</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">deg</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arctan2</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real</span><span class="s3">) * </span><span class="s1">deg_mult</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arctan2</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
            <span class="s1">ret_dtype </span><span class="s3">= </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">underlying_float</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
            <span class="s1">ret_dtype </span><span class="s3">= </span><span class="s1">dtype</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ret_dtype</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'Argument &quot;z&quot; must be a complex '</span>
                             <span class="s6">f'or Array[complex]. Got </span><span class="s2">{</span><span class="s1">z</span><span class="s2">}</span><span class="s6">'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s6">&quot;array.nonzero&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_nonzero</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s4"># Return type is a N-tuple of 1D C-contiguous arrays</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">outaryty </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">nouts </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">count</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout</span>

    <span class="s4"># First count the number of non-zero elements</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                                        <span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
        <span class="s1">nz </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">is_true</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">nz</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">count</span><span class="s3">), </span><span class="s1">one</span><span class="s3">), </span><span class="s1">count</span><span class="s3">)</span>

    <span class="s4"># Then allocate output arrays of the right size</span>
    <span class="s1">out_shape </span><span class="s3">= (</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">count</span><span class="s3">),)</span>
    <span class="s1">outs </span><span class="s3">= [</span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outaryty</span><span class="s3">, </span><span class="s1">out_shape</span><span class="s3">).</span><span class="s1">_getvalue</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nouts</span><span class="s3">)]</span>
    <span class="s1">outarys </span><span class="s3">= [</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">outaryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out</span><span class="s3">) </span><span class="s2">for </span><span class="s1">out </span><span class="s2">in </span><span class="s1">outs</span><span class="s3">]</span>
    <span class="s1">out_datas </span><span class="s3">= [</span><span class="s1">out</span><span class="s3">.</span><span class="s1">data </span><span class="s2">for </span><span class="s1">out </span><span class="s2">in </span><span class="s1">outarys</span><span class="s3">]</span>

    <span class="s4"># And fill them up</span>
    <span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                                        <span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
        <span class="s1">nz </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">is_true</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">nz</span><span class="s3">):</span>
            <span class="s4"># Store element indices in output arrays</span>
            <span class="s2">if not </span><span class="s1">indices</span><span class="s3">:</span>
                <span class="s4"># For a 0-d array, store 0 in the unique output array</span>
                <span class="s1">indices </span><span class="s3">= (</span><span class="s1">zero</span><span class="s3">,)</span>
            <span class="s1">cur </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nouts</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_datas</span><span class="s3">[</span><span class="s1">i</span><span class="s3">],</span>
                                                <span class="s1">out_shape</span><span class="s3">, (),</span>
                                                <span class="s6">'C'</span><span class="s3">, [</span><span class="s1">cur</span><span class="s3">])</span>
                <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">outaryty</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">ptr</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">cur</span><span class="s3">, </span><span class="s1">one</span><span class="s3">), </span><span class="s1">index</span><span class="s3">)</span>

    <span class="s1">tup </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">outs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_where_zero_size_array_impl</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s1">x_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">x_ </span><span class="s2">if </span><span class="s1">condition </span><span class="s2">else </span><span class="s1">y_</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_where_generic_inner_impl</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">res</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">):</span>
        <span class="s1">res</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">x</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] </span><span class="s2">if </span><span class="s1">c </span><span class="s2">else </span><span class="s1">y</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_where_fast_inner_impl</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">res</span><span class="s3">):</span>
    <span class="s1">cf </span><span class="s3">= </span><span class="s1">cond</span><span class="s3">.</span><span class="s1">flat</span>
    <span class="s1">xf </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">flat</span>
    <span class="s1">yf </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">flat</span>
    <span class="s1">rf </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">flat</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
        <span class="s1">rf</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">xf</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">if </span><span class="s1">cf</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">else </span><span class="s1">yf</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_where_generic_impl</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">):</span>
    <span class="s1">use_faster_impl </span><span class="s3">= </span><span class="s1">layout </span><span class="s2">in </span><span class="s3">[{</span><span class="s6">'C'</span><span class="s3">}, {</span><span class="s6">'F'</span><span class="s3">}]</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s1">cond1</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">y1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">cond1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">cond_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">cond1</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">x_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">y1</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'F'</span><span class="s3">:</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">T</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">use_faster_impl</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_where_fast_inner_impl</span><span class="s3">(</span><span class="s1">cond_</span><span class="s3">, </span><span class="s1">x_</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_where_generic_inner_impl</span><span class="s3">(</span><span class="s1">cond_</span><span class="s3">, </span><span class="s1">x_</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ov_np_where</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;condition&quot; must be array-like'</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">where_cond_none_none</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">).</span><span class="s1">nonzero</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">where_cond_none_none</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ov_np_where_x_y</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;condition&quot; must be array-like'</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s4"># corner case: None is a valid value for np.where:</span>
    <span class="s4"># &gt;&gt;&gt; np.where([0, 1], None, 2)</span>
    <span class="s4"># array([None, 2])</span>
    <span class="s4">#</span>
    <span class="s4"># &gt;&gt;&gt; np.where([0, 1], 2, None)</span>
    <span class="s4"># array([2, None])</span>
    <span class="s4">#</span>
    <span class="s4"># &gt;&gt;&gt; np.where([0, 1], None, None)</span>
    <span class="s4"># array([None, None])</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
        <span class="s4"># skip it for now as np.asarray(None) is not supported</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'Argument &quot;x&quot; or &quot;y&quot; cannot be None'</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">((</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">), (</span><span class="s6">'x'</span><span class="s3">, </span><span class="s6">'y'</span><span class="s3">)):</span>
        <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;{}&quot; must be array-like if provided'</span>
            <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

    <span class="s1">cond_arr </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s1">x_arr </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s1">y_arr </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">cond_arr</span><span class="s3">:</span>
        <span class="s1">x_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">y_dt </span><span class="s3">= </span><span class="s1">determine_dtype</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">x_dt</span><span class="s3">, </span><span class="s1">y_dt</span><span class="s3">)</span>

        <span class="s4"># corner case - 0 dim values</span>
        <span class="s2">def </span><span class="s1">check_0_dim</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span>
                <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">special_0_case </span><span class="s3">= </span><span class="s1">all</span><span class="s3">([</span><span class="s1">check_0_dim</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)])</span>
        <span class="s2">if </span><span class="s1">special_0_case</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_where_zero_size_array_impl</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">layout </span><span class="s3">= </span><span class="s1">condition</span><span class="s3">.</span><span class="s1">layout</span>
        <span class="s2">if </span><span class="s1">x_arr </span><span class="s2">and </span><span class="s1">y_arr</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">condition</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">:</span>
                <span class="s1">layout </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">layout </span><span class="s3">= </span><span class="s6">'A'</span>
        <span class="s2">return </span><span class="s1">_where_generic_impl</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_real</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">np_real_impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">val</span><span class="s3">.</span><span class="s1">real</span>

    <span class="s2">return </span><span class="s1">np_real_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_imag</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">np_imag_impl</span><span class="s3">(</span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">val</span><span class="s3">.</span><span class="s1">imag</span>

    <span class="s2">return </span><span class="s1">np_imag_impl</span>


<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Misc functions</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">contains</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_contains</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">np_contains_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s1">key</span><span class="s3">:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">return </span><span class="s1">np_contains_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">count_nonzero</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_count_nonzero</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;The argument to np.count_nonzero must be array-like&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">arr2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">arr2 </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">arr2 </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">arr2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s1">np_delete_handler_isslice </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x </span><span class="s3">: </span><span class="s1">x</span><span class="s3">)</span>
<span class="s1">np_delete_handler_isarray </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x </span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_delete</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s4"># Implementation based on numpy</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/af66e487a57bfd4850f4306e3b85d1dac3c70412/numpy/lib/function_base.py#L4065-L4267    # noqa: E501</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;arr must be either an Array or a Sequence&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">SliceType</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">SliceType</span><span class="s3">)):</span>
            <span class="s1">handler </span><span class="s3">= </span><span class="s1">np_delete_handler_isslice</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'obj should be of Integer dtype'</span><span class="s3">)</span>
            <span class="s1">handler </span><span class="s3">= </span><span class="s1">np_delete_handler_isarray</span>

        <span class="s2">def </span><span class="s1">np_delete_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">))</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span>

            <span class="s1">keep </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">handler</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
            <span class="s1">keep</span><span class="s3">[</span><span class="s1">obj</span><span class="s3">] = </span><span class="s2">False</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">np_delete_impl</span>

    <span class="s2">else</span><span class="s3">: </span><span class="s4"># scalar value</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'obj should be of Integer dtype'</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">np_delete_scalar_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">))</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s1">pos </span><span class="s3">= </span><span class="s1">obj</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">pos </span><span class="s3">&lt; -</span><span class="s1">N </span><span class="s2">or </span><span class="s1">pos </span><span class="s3">&gt;= </span><span class="s1">N</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">IndexError</span><span class="s3">(</span><span class="s6">'obj must be less than the len(arr)'</span><span class="s3">)</span>
                <span class="s4"># NumPy raises IndexError: index 'i' is out of</span>
                <span class="s4"># bounds for axis 'x' with size 'n'</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">pos </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
                <span class="s1">pos </span><span class="s3">+= </span><span class="s1">N</span>

            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">arr</span><span class="s3">[:</span><span class="s1">pos</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">:]))</span>
        <span class="s2">return </span><span class="s1">np_delete_scalar_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_diff_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">diff_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;diff(): order must be non-negative&quot;</span><span class="s3">)</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + (</span><span class="s1">max</span><span class="s3">(</span><span class="s1">size </span><span class="s3">- </span><span class="s1">n</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">out</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s4"># np.diff() works on each last dimension subarray independently.</span>
        <span class="s4"># To make things easier, normalize input and output into 2d arrays</span>
        <span class="s1">a2 </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">size</span><span class="s3">))</span>
        <span class="s1">out2 </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]))</span>
        <span class="s4"># A scratchpad for subarrays</span>
        <span class="s1">work </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">major </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s4"># First iteration: diff a2 into work</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s1">work</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">a2</span><span class="s3">[</span><span class="s1">major</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">a2</span><span class="s3">[</span><span class="s1">major</span><span class="s3">, </span><span class="s1">i</span><span class="s3">]</span>
            <span class="s4"># Other iterations: diff work into itself</span>
            <span class="s2">for </span><span class="s1">niter </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size </span><span class="s3">- </span><span class="s1">niter </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
                    <span class="s1">work</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">work</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s4"># Copy final diff into out2</span>
            <span class="s1">out2</span><span class="s3">[</span><span class="s1">major</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">[:</span><span class="s1">size </span><span class="s3">- </span><span class="s1">n</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">return </span><span class="s1">diff_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array_equal</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_array_equal</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s3">(</span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">) </span><span class="s2">and </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'Both arguments to &quot;array_equals&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s1">accepted </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">accepted</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">, </span><span class="s1">accepted</span><span class="s3">):</span>
        <span class="s4"># special case</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a1 </span><span class="s3">== </span><span class="s1">a2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">a </span><span class="s3">== </span><span class="s1">b</span><span class="s3">)</span>
            <span class="s2">return False</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">jit_np_intersect1d</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">):</span>
    <span class="s4"># Not implemented to support assume_unique or return_indices</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/v1.19.0/numpy/lib</span>
    <span class="s4"># /arraysetops.py#L347-L441</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">ar2</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'intersect1d: first two args must be array-like'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_intersects1d_impl</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">):</span>
        <span class="s1">ar1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">)</span>
        <span class="s1">ar2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ar2</span><span class="s3">)</span>

        <span class="s1">ar1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">)</span>
        <span class="s1">ar2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">ar2</span><span class="s3">)</span>

        <span class="s1">aux </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">))</span>
        <span class="s1">aux</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">aux</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] == </span><span class="s1">aux</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">int1d </span><span class="s3">= </span><span class="s1">aux</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">][</span><span class="s1">mask</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">int1d</span>
    <span class="s2">return </span><span class="s1">np_intersects1d_impl</span>


<span class="s2">def </span><span class="s1">validate_1d_array_like</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">seq</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;{0}(): input should have dimension 1&quot;</span>
                            <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">))</span>
    <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;{0}(): input should be an array or sequence&quot;</span>
                        <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_bincount</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">validate_1d_array_like</span><span class="s3">(</span><span class="s6">&quot;bincount&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">minlength</span><span class="s3">, </span><span class="s6">'minlength'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">weights </span><span class="s2">not in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s1">validate_1d_array_like</span><span class="s3">(</span><span class="s6">&quot;bincount&quot;</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">)</span>
        <span class="s4"># weights is promoted to double in C impl</span>
        <span class="s4"># https://github.com/numpy/numpy/blob/maintenance/1.16.x/numpy/core/src/multiarray/compiled_base.c#L93-L95    # noqa: E501</span>
        <span class="s1">out_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">validate_inputs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;bincount(): weights and list don't have &quot;</span>
                                 <span class="s6">&quot;the same length&quot;</span><span class="s3">)</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">count_item</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">val</span><span class="s3">] += </span><span class="s1">weights</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">out_dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">validate_inputs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">count_item</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">val</span><span class="s3">] += </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">bincount_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">validate_inputs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">minlength </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'minlength' must not be negative&quot;</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">a_max </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s3">-</span><span class="s5">1</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;bincount(): first argument must be &quot;</span>
                                 <span class="s6">&quot;non-negative&quot;</span><span class="s3">)</span>
            <span class="s1">a_max </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

        <span class="s1">out_length </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">a_max </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">out_length</span><span class="s3">, </span><span class="s1">out_dtype</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">count_item</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">weights</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">return </span><span class="s1">bincount_impl</span>


<span class="s1">less_than_float </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">lt_floats</span><span class="s3">)</span>
<span class="s1">less_than_complex </span><span class="s3">= </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">lt_complex</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">less_than_or_equal_complex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                    <span class="s2">return True</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt;= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return False</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span><span class="s3">):</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&lt;= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return False</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">):</span>
                    <span class="s2">return True</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&lt; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                        <span class="s2">return True</span>
                    <span class="s2">elif </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt;= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">imag</span>
                    <span class="s2">return False</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_less_than_or_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">less_than_or_equal_complex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return True</span>

    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt;= </span><span class="s1">b</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_less_than</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">less_than_complex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">less_than_float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_less_then_datetime64</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s4"># Original numpy code is at:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/3dad50936a8dc534a81a545365f69ee9ab162ffe/numpy/_core/src/npysort/npysort_common.h#L334-L346</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">0</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnat</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">1</span>

    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_less_then_or_equal_datetime64</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">return not </span><span class="s1">_less_then_datetime64</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_searchsorted</span><span class="s3">(</span><span class="s1">cmp</span><span class="s3">):</span>
    <span class="s4"># a facsimile of:</span>
    <span class="s4"># https://github.com/numpy/numpy/blob/4f84d719657eb455a35fcdf9e75b83eb1f97024a/numpy/core/src/npysort/binsearch.cpp#L61  # noqa: E501</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">key_val</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">):</span>
        <span class="s2">while </span><span class="s1">min_idx </span><span class="s3">&lt; </span><span class="s1">max_idx</span><span class="s3">:</span>
            <span class="s4"># to avoid overflow</span>
            <span class="s1">mid_idx </span><span class="s3">= </span><span class="s1">min_idx </span><span class="s3">+ ((</span><span class="s1">max_idx </span><span class="s3">- </span><span class="s1">min_idx</span><span class="s3">) &gt;&gt; </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">mid_val </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">mid_idx</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">mid_val</span><span class="s3">, </span><span class="s1">key_val</span><span class="s3">):</span>
                <span class="s1">min_idx </span><span class="s3">= </span><span class="s1">mid_idx </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">mid_idx</span>
        <span class="s2">return </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_idx</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s1">VALID_SEARCHSORTED_SIDES </span><span class="s3">= </span><span class="s1">frozenset</span><span class="s3">({</span><span class="s6">'left'</span><span class="s3">, </span><span class="s6">'right'</span><span class="s3">})</span>


<span class="s2">def </span><span class="s1">make_searchsorted_implementation</span><span class="s3">(</span><span class="s1">np_dtype</span><span class="s3">, </span><span class="s1">side</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">side </span><span class="s2">in </span><span class="s1">VALID_SEARCHSORTED_SIDES</span>

    <span class="s2">if </span><span class="s1">np_dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">in </span><span class="s6">'mM'</span><span class="s3">:</span>
        <span class="s4"># is datetime</span>
        <span class="s1">lt </span><span class="s3">= </span><span class="s1">_less_then_datetime64</span>
        <span class="s1">le </span><span class="s3">= </span><span class="s1">_less_then_or_equal_datetime64</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">lt </span><span class="s3">= </span><span class="s1">_less_than</span>
        <span class="s1">le </span><span class="s3">= </span><span class="s1">_less_than_or_equal</span>

    <span class="s2">if </span><span class="s1">side </span><span class="s3">== </span><span class="s6">'left'</span><span class="s3">:</span>
        <span class="s1">_impl </span><span class="s3">= </span><span class="s1">_searchsorted</span><span class="s3">(</span><span class="s1">lt</span><span class="s3">)</span>
        <span class="s1">_cmp </span><span class="s3">= </span><span class="s1">lt</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">np_dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">) </span><span class="s2">and </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">23</span><span class="s3">):</span>
            <span class="s4"># change in behaviour for inexact types</span>
            <span class="s4"># introduced by:</span>
            <span class="s4"># https://github.com/numpy/numpy/pull/21867</span>
            <span class="s1">_impl </span><span class="s3">= </span><span class="s1">_searchsorted</span><span class="s3">(</span><span class="s1">le</span><span class="s3">)</span>
            <span class="s1">_cmp </span><span class="s3">= </span><span class="s1">lt</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">_impl </span><span class="s3">= </span><span class="s1">_searchsorted</span><span class="s3">(</span><span class="s1">le</span><span class="s3">)</span>
            <span class="s1">_cmp </span><span class="s3">= </span><span class="s1">le</span>

    <span class="s2">return </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_impl</span><span class="s3">), </span><span class="s1">register_jitable</span><span class="s3">(</span><span class="s1">_cmp</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">):</span>
    <span class="s1">side_val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">side</span><span class="s3">, </span><span class="s6">'literal_value'</span><span class="s3">, </span><span class="s1">side</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">side_val </span><span class="s2">not in </span><span class="s1">VALID_SEARCHSORTED_SIDES</span><span class="s3">:</span>
        <span class="s4"># could change this so that side doesn't need to be</span>
        <span class="s4"># a compile-time constant</span>
        <span class="s2">raise </span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s6">f&quot;Invalid value given for 'side': </span><span class="s2">{</span><span class="s1">side_val</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">)):</span>
        <span class="s1">v_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">v_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

    <span class="s1">np_dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">v_dt</span><span class="s3">)</span>
    <span class="s1">_impl</span><span class="s3">, </span><span class="s1">_cmp </span><span class="s3">= </span><span class="s1">make_searchsorted_implementation</span><span class="s3">(</span><span class="s1">np_dt</span><span class="s3">, </span><span class="s1">side_val</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">last_key_val </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">min_idx </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">key_val </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">_cmp</span><span class="s3">(</span><span class="s1">last_key_val</span><span class="s3">, </span><span class="s1">key_val</span><span class="s3">):</span>
                    <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">min_idx </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s2">if </span><span class="s1">max_idx </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                        <span class="s1">max_idx </span><span class="s3">+= </span><span class="s5">1</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">max_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

                <span class="s1">last_key_val </span><span class="s3">= </span><span class="s1">key_val</span>
                <span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_idx </span><span class="s3">= </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">key_val</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">)</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">min_idx</span>

            <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">):</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s1">side</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s4"># presumably `v` is scalar</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">):</span>
            <span class="s1">r</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">r</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">digitize</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_digitize</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">right</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'x may not be complex'</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">register_jitable</span>
    <span class="s2">def </span><span class="s1">_monotonicity</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">):</span>

        <span class="s4"># all bin edges hold the same value</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s5">1</span>

        <span class="s4"># Skip repeated values at the beginning of the array</span>
        <span class="s1">last_value </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">) </span><span class="s2">and </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] == </span><span class="s1">last_value</span><span class="s3">:</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s4"># all bin edges hold the same value</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s5">1</span>

        <span class="s1">next_value </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">last_value </span><span class="s3">&lt; </span><span class="s1">next_value</span><span class="s3">:</span>
            <span class="s4"># Possibly monotonic increasing</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">)):</span>
                <span class="s1">last_value </span><span class="s3">= </span><span class="s1">next_value</span>
                <span class="s1">next_value </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">last_value </span><span class="s3">&gt; </span><span class="s1">next_value</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s5">0</span>
            <span class="s2">return </span><span class="s5">1</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># last &gt; next, possibly monotonic decreasing</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">)):</span>
                <span class="s1">last_value </span><span class="s3">= </span><span class="s1">next_value</span>
                <span class="s1">next_value </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">last_value </span><span class="s3">&lt; </span><span class="s1">next_value</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s5">0</span>
            <span class="s2">return </span><span class="s3">-</span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">digitize_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">right</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>

        <span class="s1">mono </span><span class="s3">= </span><span class="s1">_monotonicity</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">mono </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s6">&quot;bins must be monotonically increasing or decreasing&quot;</span>
            <span class="s3">)</span>

        <span class="s4"># this is backwards because the arguments below are swapped</span>
        <span class="s2">if </span><span class="s1">right</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">mono </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
                <span class="s4"># reverse the bins, and invert the results</span>
                <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'left'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">mono </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
                <span class="s4"># reverse the bins, and invert the results</span>
                <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'right'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s6">'right'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">digitize_impl</span>


<span class="s1">_range </span><span class="s3">= </span><span class="s1">range</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">histogram</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_histogram</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">range</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s4"># With a uniform distribution of bins, use a fast algorithm</span>
        <span class="s4"># independent of the number of bins</span>

        <span class="s2">if </span><span class="s1">range </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
            <span class="s1">inf </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s6">'inf'</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">histogram_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">range</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">bin_min </span><span class="s3">= </span><span class="s1">inf</span>
                <span class="s1">bin_max </span><span class="s3">= -</span><span class="s1">inf</span>
                <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                    <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                    <span class="s2">if </span><span class="s1">bin_min </span><span class="s3">&gt; </span><span class="s1">v</span><span class="s3">:</span>
                        <span class="s1">bin_min </span><span class="s3">= </span><span class="s1">v</span>
                    <span class="s2">if </span><span class="s1">bin_max </span><span class="s3">&lt; </span><span class="s1">v</span><span class="s3">:</span>
                        <span class="s1">bin_max </span><span class="s3">= </span><span class="s1">v</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">histogram</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, (</span><span class="s1">bin_min</span><span class="s3">, </span><span class="s1">bin_max</span><span class="s3">))</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">histogram_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">range</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">bins </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;histogram(): `bins` should be a &quot;</span>
                                     <span class="s6">&quot;positive integer&quot;</span><span class="s3">)</span>
                <span class="s1">bin_min</span><span class="s3">, </span><span class="s1">bin_max </span><span class="s3">= </span><span class="s1">range</span>
                <span class="s2">if not </span><span class="s1">bin_min </span><span class="s3">&lt;= </span><span class="s1">bin_max</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;histogram(): max must be larger than &quot;</span>
                                     <span class="s6">&quot;min in range parameter&quot;</span><span class="s3">)</span>

                <span class="s1">hist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">bin_max </span><span class="s3">&gt; </span><span class="s1">bin_min</span><span class="s3">:</span>
                    <span class="s1">bin_ratio </span><span class="s3">= </span><span class="s1">bins </span><span class="s3">/ (</span><span class="s1">bin_max </span><span class="s3">- </span><span class="s1">bin_min</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                        <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                        <span class="s1">b </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">((</span><span class="s1">v </span><span class="s3">- </span><span class="s1">bin_min</span><span class="s3">) * </span><span class="s1">bin_ratio</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s5">0 </span><span class="s3">&lt;= </span><span class="s1">b </span><span class="s3">&lt; </span><span class="s1">bins</span><span class="s3">:</span>
                            <span class="s1">hist</span><span class="s3">[</span><span class="s1">int</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)] += </span><span class="s5">1</span>
                        <span class="s2">elif </span><span class="s1">v </span><span class="s3">== </span><span class="s1">bin_max</span><span class="s3">:</span>
                            <span class="s1">hist</span><span class="s3">[</span><span class="s1">bins </span><span class="s3">- </span><span class="s5">1</span><span class="s3">] += </span><span class="s5">1</span>

                <span class="s1">bins_array </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">bin_min</span><span class="s3">, </span><span class="s1">bin_max</span><span class="s3">, </span><span class="s1">bins </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">hist</span><span class="s3">, </span><span class="s1">bins_array</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># With a custom bins array, use a bisection search</span>

        <span class="s2">def </span><span class="s1">histogram_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">range</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">nbins </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bins</span><span class="s3">) - </span><span class="s5">1</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">_range</span><span class="s3">(</span><span class="s1">nbins</span><span class="s3">):</span>
                <span class="s4"># Note this also catches NaNs</span>
                <span class="s2">if not </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt;= </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;histogram(): bins must increase &quot;</span>
                                     <span class="s6">&quot;monotonically&quot;</span><span class="s3">)</span>

            <span class="s1">bin_min </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">bin_max </span><span class="s3">= </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">nbins</span><span class="s3">]</span>
            <span class="s1">hist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">nbins</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">nbins </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">view </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                    <span class="s1">v </span><span class="s3">= </span><span class="s1">view</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
                    <span class="s2">if not </span><span class="s1">bin_min </span><span class="s3">&lt;= </span><span class="s1">v </span><span class="s3">&lt;= </span><span class="s1">bin_max</span><span class="s3">:</span>
                        <span class="s4"># Value is out of bounds, ignore (also catches NaNs)</span>
                        <span class="s2">continue</span>
                    <span class="s4"># Bisect in bins[:-1]</span>
                    <span class="s1">lo </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s1">hi </span><span class="s3">= </span><span class="s1">nbins </span><span class="s3">- </span><span class="s5">1</span>
                    <span class="s2">while </span><span class="s1">lo </span><span class="s3">&lt; </span><span class="s1">hi</span><span class="s3">:</span>
                        <span class="s4"># Note the `+ 1` is necessary to avoid an infinite</span>
                        <span class="s4"># loop where mid = lo =&gt; lo = mid</span>
                        <span class="s1">mid </span><span class="s3">= (</span><span class="s1">lo </span><span class="s3">+ </span><span class="s1">hi </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) &gt;&gt; </span><span class="s5">1</span>
                        <span class="s2">if </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s1">bins</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">]:</span>
                            <span class="s1">hi </span><span class="s3">= </span><span class="s1">mid </span><span class="s3">- </span><span class="s5">1</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">lo </span><span class="s3">= </span><span class="s1">mid</span>
                    <span class="s1">hist</span><span class="s3">[</span><span class="s1">lo</span><span class="s3">] += </span><span class="s5">1</span>

            <span class="s2">return </span><span class="s1">hist</span><span class="s3">, </span><span class="s1">bins</span>

    <span class="s2">return </span><span class="s1">histogram_impl</span>


<span class="s4"># Create np.finfo, np.iinfo and np.MachAr</span>
<span class="s4"># machar</span>
<span class="s1">_mach_ar_supported </span><span class="s3">= (</span><span class="s6">'ibeta'</span><span class="s3">, </span><span class="s6">'it'</span><span class="s3">, </span><span class="s6">'machep'</span><span class="s3">, </span><span class="s6">'eps'</span><span class="s3">, </span><span class="s6">'negep'</span><span class="s3">, </span><span class="s6">'epsneg'</span><span class="s3">,</span>
                      <span class="s6">'iexp'</span><span class="s3">, </span><span class="s6">'minexp'</span><span class="s3">, </span><span class="s6">'xmin'</span><span class="s3">, </span><span class="s6">'maxexp'</span><span class="s3">, </span><span class="s6">'xmax'</span><span class="s3">, </span><span class="s6">'irnd'</span><span class="s3">,</span>
                      <span class="s6">'ngrd'</span><span class="s3">, </span><span class="s6">'epsilon'</span><span class="s3">, </span><span class="s6">'tiny'</span><span class="s3">, </span><span class="s6">'huge'</span><span class="s3">, </span><span class="s6">'precision'</span><span class="s3">,</span>
                      <span class="s6">'resolution'</span><span class="s3">,)</span>
<span class="s1">MachAr </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s6">'MachAr'</span><span class="s3">, </span><span class="s1">_mach_ar_supported</span><span class="s3">)</span>

<span class="s4"># Do not support MachAr field</span>
<span class="s4"># finfo</span>
<span class="s1">_finfo_supported </span><span class="s3">= (</span><span class="s6">'eps'</span><span class="s3">, </span><span class="s6">'epsneg'</span><span class="s3">, </span><span class="s6">'iexp'</span><span class="s3">, </span><span class="s6">'machep'</span><span class="s3">, </span><span class="s6">'max'</span><span class="s3">, </span><span class="s6">'maxexp'</span><span class="s3">, </span><span class="s6">'min'</span><span class="s3">,</span>
                    <span class="s6">'minexp'</span><span class="s3">, </span><span class="s6">'negep'</span><span class="s3">, </span><span class="s6">'nexp'</span><span class="s3">, </span><span class="s6">'nmant'</span><span class="s3">, </span><span class="s6">'precision'</span><span class="s3">,</span>
                    <span class="s6">'resolution'</span><span class="s3">, </span><span class="s6">'tiny'</span><span class="s3">, </span><span class="s6">'bits'</span><span class="s3">,)</span>


<span class="s1">finfo </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s6">'finfo'</span><span class="s3">, </span><span class="s1">_finfo_supported</span><span class="s3">)</span>

<span class="s4"># iinfo</span>
<span class="s1">_iinfo_supported </span><span class="s3">= (</span><span class="s6">'min'</span><span class="s3">, </span><span class="s6">'max'</span><span class="s3">, </span><span class="s6">'bits'</span><span class="s3">,)</span>

<span class="s1">iinfo </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s6">'iinfo'</span><span class="s3">, </span><span class="s1">_iinfo_supported</span><span class="s3">)</span>


<span class="s4"># This module is imported under the compiler lock which should deal with the</span>
<span class="s4"># lack of thread safety in the warning filter.</span>
<span class="s2">def </span><span class="s1">_gen_np_machar</span><span class="s3">():</span>
    <span class="s4"># NumPy 1.24 removed np.MachAr</span>
    <span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&gt;= (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">24</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">w</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">r'`np.MachAr` is deprecated \(NumPy 1.22\)'</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s6">&quot;always&quot;</span><span class="s3">, </span><span class="s1">message</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">,</span>
                                <span class="s1">category</span><span class="s3">=</span><span class="s1">DeprecationWarning</span><span class="s3">,</span>
                                <span class="s1">module</span><span class="s3">=</span><span class="s6">r'.*numba.*arraymath'</span><span class="s3">)</span>
        <span class="s1">np_MachAr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">MachAr</span>

    <span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np_MachAr</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">MachAr_impl</span><span class="s3">():</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">np_MachAr</span><span class="s3">()</span>
        <span class="s1">_mach_ar_data </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">_mach_ar_supported</span><span class="s3">])</span>

        <span class="s2">if </span><span class="s1">w</span><span class="s3">:</span>
            <span class="s1">wmsg </span><span class="s3">= </span><span class="s1">w</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn_explicit</span><span class="s3">(</span><span class="s1">wmsg</span><span class="s3">.</span><span class="s1">message</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">],</span>
                                   <span class="s1">NumbaDeprecationWarning</span><span class="s3">,</span>
                                   <span class="s1">wmsg</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">,</span>
                                   <span class="s1">wmsg</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">MachAr</span><span class="s3">(*</span><span class="s1">_mach_ar_data</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s1">_gen_np_machar</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">generate_xinfo_body</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">np_func</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s1">nbty </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
    <span class="s1">np_dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">nbty</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">np_func</span><span class="s3">(</span><span class="s1">np_dtype</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">: </span><span class="s4"># This exception instance comes from NumPy</span>
        <span class="s4"># The np function might not support the dtype</span>
        <span class="s2">return None</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">attr</span><span class="s3">])</span>

    <span class="s3">@</span><span class="s1">register_jitable</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">container</span><span class="s3">(*</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_finfo</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">generate_xinfo_body</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">, </span><span class="s1">finfo</span><span class="s3">, </span><span class="s1">_finfo_supported</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_iinfo</span><span class="s3">(</span><span class="s1">int_type</span><span class="s3">):</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">generate_xinfo_body</span><span class="s3">(</span><span class="s1">int_type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">, </span><span class="s1">iinfo</span><span class="s3">, </span><span class="s1">_iinfo_supported</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">int_type</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">int_type</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_get_inner_prod</span><span class="s3">(</span><span class="s1">dta</span><span class="s3">, </span><span class="s1">dtb</span><span class="s3">):</span>
    <span class="s4"># gets an inner product implementation, if both types are float then</span>
    <span class="s4"># BLAS is used else a local function</span>

    <span class="s3">@</span><span class="s1">register_jitable</span>
    <span class="s2">def </span><span class="s1">_innerprod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">acc </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s1">acc </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">acc</span>

    <span class="s4"># no BLAS... use local function regardless</span>
    <span class="s2">if not </span><span class="s1">_HAVE_BLAS</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_innerprod</span>

    <span class="s1">flty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">real_domain </span><span class="s3">| </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span>
    <span class="s1">floats </span><span class="s3">= </span><span class="s1">dta </span><span class="s2">in </span><span class="s1">flty </span><span class="s2">and </span><span class="s1">dtb </span><span class="s2">in </span><span class="s1">flty</span>
    <span class="s2">if not </span><span class="s1">floats</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_innerprod</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">a_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dta</span><span class="s3">)</span>
        <span class="s1">b_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dtb</span><span class="s3">)</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">a_dt</span><span class="s3">, </span><span class="s1">b_dt</span><span class="s3">)</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">_dot_wrap</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">), </span><span class="s1">b</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">_dot_wrap</span>


<span class="s2">def </span><span class="s1">_assert_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;%s() only supported on 1D arrays &quot; </span><span class="s3">% </span><span class="s1">func_name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_np_correlate_core</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">, </span><span class="s1">ap2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">direction</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_np_correlate_core</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_np_correlate_core_impl</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">, </span><span class="s1">ap2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">direction</span><span class="s3">):</span>
    <span class="s1">a_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">b_dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">ap2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">a_dt</span><span class="s3">, </span><span class="s1">b_dt</span><span class="s3">)</span>
    <span class="s1">innerprod </span><span class="s3">= </span><span class="s1">_get_inner_prod</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ap2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">, </span><span class="s1">ap2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">direction</span><span class="s3">):</span>
        <span class="s4"># Implementation loosely based on `_pyarray_correlate` from</span>
        <span class="s4"># https://github.com/numpy/numpy/blob/3bce2be74f228684ca2895ad02b63953f37e2a9d/numpy/core/src/multiarray/multiarraymodule.c#L1191    # noqa: E501</span>
        <span class="s4"># For &quot;mode&quot;:</span>
        <span class="s4"># Convolve uses 'full' by default.</span>
        <span class="s4"># Correlate uses 'valid' by default.</span>
        <span class="s4"># For &quot;direction&quot;, +1 to write the return values out in order 0-&gt;N</span>
        <span class="s4"># -1 to write them out N-&gt;0.</span>

        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">)</span>
        <span class="s1">n2 </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ap2</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n1 </span><span class="s3">&lt; </span><span class="s1">n2</span><span class="s3">:</span>
            <span class="s4"># This should never occur when called by np.convolve because</span>
            <span class="s4"># _np_correlate.impl swaps arguments based on length.</span>
            <span class="s4"># The same applies for np.correlate.</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'len(ap1)' must greater than 'len(ap2)'&quot;</span><span class="s3">)</span>

        <span class="s1">length </span><span class="s3">= </span><span class="s1">n1</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">n2</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s6">&quot;valid&quot;</span><span class="s3">:</span>
            <span class="s1">length </span><span class="s3">= </span><span class="s1">length </span><span class="s3">- </span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s1">n_left </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">n_right </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s6">&quot;full&quot;</span><span class="s3">:</span>
            <span class="s1">n_right </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span>
            <span class="s1">n_left </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span>
            <span class="s1">length </span><span class="s3">= </span><span class="s1">length </span><span class="s3">+ </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s6">&quot;same&quot;</span><span class="s3">:</span>
            <span class="s1">n_left </span><span class="s3">= </span><span class="s1">n </span><span class="s3">// </span><span class="s5">2</span>
            <span class="s1">n_right </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">n_left </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s6">&quot;Invalid 'mode', &quot;</span>
                <span class="s6">&quot;valid are 'full', 'same', 'valid'&quot;</span>
            <span class="s3">)</span>

        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">length</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">direction </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">inc </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">direction </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span>
            <span class="s1">inc </span><span class="s3">= -</span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Invalid direction&quot;</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_left</span><span class="s3">):</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">n </span><span class="s3">- </span><span class="s1">n_left</span>
            <span class="s1">ret</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">innerprod</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">], </span><span class="s1">ap2</span><span class="s3">[-</span><span class="s1">k</span><span class="s3">:])</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">inc</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n1 </span><span class="s3">- </span><span class="s1">n2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">ret</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">innerprod</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">[</span><span class="s1">i </span><span class="s3">: </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">n2</span><span class="s3">], </span><span class="s1">ap2</span><span class="s3">)</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">inc</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_right</span><span class="s3">):</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s5">1</span>
            <span class="s1">ret</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">innerprod</span><span class="s3">(</span><span class="s1">ap1</span><span class="s3">[-</span><span class="s1">k</span><span class="s3">:], </span><span class="s1">ap2</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">])</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">inc</span>

        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">correlate</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_np_correlate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s6">&quot;valid&quot;</span><span class="s3">):</span>
    <span class="s1">_assert_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">'np.correlate'</span><span class="s3">)</span>
    <span class="s1">_assert_1d</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s6">'np.correlate'</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">register_jitable</span>
    <span class="s2">def </span><span class="s1">op_conj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">register_jitable</span>
    <span class="s2">def </span><span class="s1">op_nop</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
            <span class="s1">a_op </span><span class="s3">= </span><span class="s1">op_nop</span>
            <span class="s1">b_op </span><span class="s3">= </span><span class="s1">op_conj</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">a_op </span><span class="s3">= </span><span class="s1">op_nop</span>
            <span class="s1">b_op </span><span class="s3">= </span><span class="s1">op_nop</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
            <span class="s1">a_op </span><span class="s3">= </span><span class="s1">op_nop</span>
            <span class="s1">b_op </span><span class="s3">= </span><span class="s1">op_conj</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">a_op </span><span class="s3">= </span><span class="s1">op_conj</span>
            <span class="s1">b_op </span><span class="s3">= </span><span class="s1">op_nop</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s6">&quot;valid&quot;</span><span class="s3">):</span>
        <span class="s1">la </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">lv </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">la </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'a' cannot be empty&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">lv </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'v' cannot be empty&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">la </span><span class="s3">&lt; </span><span class="s1">lv</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_np_correlate_core</span><span class="s3">(</span><span class="s1">b_op</span><span class="s3">(</span><span class="s1">v</span><span class="s3">), </span><span class="s1">a_op</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">mode</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_np_correlate_core</span><span class="s3">(</span><span class="s1">a_op</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">b_op</span><span class="s3">(</span><span class="s1">v</span><span class="s3">), </span><span class="s1">mode</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">convolve</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_convolve</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s6">&quot;full&quot;</span><span class="s3">):</span>
    <span class="s1">_assert_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">'np.convolve'</span><span class="s3">)</span>
    <span class="s1">_assert_1d</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s6">'np.convolve'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s6">&quot;full&quot;</span><span class="s3">):</span>
        <span class="s1">la </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">lv </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">la </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'a' cannot be empty&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">lv </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;'v' cannot be empty&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">la </span><span class="s3">&lt; </span><span class="s1">lv</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_np_correlate_core</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">a</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">mode</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_np_correlate_core</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">mode</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s4"># developer note... keep this function (type_can_asarray) in sync with the</span>
    <span class="s4"># accepted types implementations below!</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">a</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s4"># Nested lists cannot be unpacked, therefore only single lists are</span>
        <span class="s4"># permitted and these conform to Sequence and can be unpacked along on</span>
        <span class="s4"># the same path as Tuple.</span>
        <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s1">dt_conv </span><span class="s3">= </span><span class="s1">a </span><span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">else </span><span class="s1">dtype</span>
        <span class="s1">ty </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dt_conv</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">ListType</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span>
                <span class="s6">&quot;asarray support for List is limited &quot;</span>
                <span class="s6">&quot;to Boolean and Number types&quot;</span><span class="s3">)</span>

        <span class="s1">target_dtype </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">else </span><span class="s1">dtype</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">l </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">target_dtype</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span>
            <span class="s2">return </span><span class="s1">ret</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">impl </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfarray</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">np_asfarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">):</span>
        <span class="s4"># convert numba dtype types into NumPy dtype</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Type</span><span class="s3">):</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">):</span>
            <span class="s1">dx </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dx </span><span class="s3">= </span><span class="s1">dtype</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_extract</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">np_extract_impl</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s1">cond </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'Cannot extract from an empty array'</span><span class="s3">)</span>

        <span class="s4"># the following looks odd but replicates NumPy...</span>
        <span class="s4"># https://github.com/numpy/numpy/issues/12859</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:]) </span><span class="s2">and </span><span class="s1">cond</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">'condition shape inconsistent with arr shape'</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s4"># NumPy raises IndexError: index 'm' is out of</span>
            <span class="s4"># bounds for size 'n'</span>

        <span class="s1">max_len </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] </span><span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">max_len</span><span class="s3">) </span><span class="s2">if </span><span class="s1">cond</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]]</span>

        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_extract_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">select</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_select</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">, </span><span class="s1">choicelist</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">np_select_arr_impl</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">, </span><span class="s1">choicelist</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">choicelist</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'list of cases must be same length as list '</span>
                             <span class="s6">'of conditions'</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">default </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">choicelist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">choicelist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s4"># should use reversed+zip, but reversed is not available</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">cond </span><span class="s3">= </span><span class="s1">condlist</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">choice </span><span class="s3">= </span><span class="s1">choicelist</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">choice</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s4"># first we check the types of the input parameters</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'condlist must be a List or a Tuple'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">choicelist</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'choicelist must be a List or a Tuple'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">default</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'default must be a scalar (number or boolean)'</span><span class="s3">)</span>
    <span class="s4"># the types of the parameters have been checked, now we test the types</span>
    <span class="s4"># of the content of the parameters</span>
    <span class="s4"># implementation note: if in the future numba's np.where accepts tuples</span>
    <span class="s4"># as elements of condlist, then the check below should be extended to</span>
    <span class="s4"># accept tuples</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'items of condlist must be arrays'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">choicelist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'items of choicelist must be arrays'</span><span class="s3">)</span>
    <span class="s4"># the types of the parameters and their contents have been checked,</span>
    <span class="s4"># now we test the dtypes of the content of parameters</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'condlist arrays must contain booleans'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'condlist tuples must only contain booleans'</span><span class="s3">)</span>
    <span class="s4"># the input types are correct, now we perform checks on the dimensions</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">choicelist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'condlist and choicelist elements must have the '</span>
                             <span class="s6">'same number of dimensions'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">condlist</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'condlist arrays must be of at least dimension 1'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_select_arr_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">union1d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_union1d</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">ar2</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;The arguments to np.union1d must be array-like&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">((</span><span class="s6">'unichr' </span><span class="s2">in </span><span class="s1">ar1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name </span><span class="s2">or </span><span class="s6">'unichr' </span><span class="s2">in </span><span class="s1">ar2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span><span class="s3">) </span><span class="s2">and</span>
       <span class="s1">ar1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s1">ar2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;For Unicode arrays, arrays must have same dtype&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">union_impl</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ar1</span><span class="s3">))</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ar2</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)))</span>

    <span class="s2">return </span><span class="s1">union_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray_chkfinite</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_asarray_chkfinite</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;The argument to np.asarray_chkfinite must be array-like&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">NumbaNotImplementedError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'dtype must be a valid Numpy dtype'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">i</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;array must not contain infs or NaNs&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">a</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unwrap</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_unwrap</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">discont</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">period</span><span class="s3">=</span><span class="s5">6.283185307179586</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;axis&quot; must be an integer'</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;p&quot; must be array-like'</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">discont</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">))</span>
            <span class="s2">and not </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">discont</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;discont&quot; must be a scalar'</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">period</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">'The argument &quot;period&quot; must be a scalar'</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">slice1 </span><span class="s3">= (</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">period</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">period</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">integer_input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">discont</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">period</span><span class="s3">=</span><span class="s5">6.283185307179586</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">!= -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">'Value for argument &quot;axis&quot; is not supported'</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s4"># Flatten to a 2D array, keeping axis -1</span>
        <span class="s1">p_init </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">init_shape </span><span class="s3">= </span><span class="s1">p_init</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">last_axis </span><span class="s3">= </span><span class="s1">init_shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">p_new </span><span class="s3">= </span><span class="s1">p_init</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">p_init</span><span class="s3">.</span><span class="s1">size </span><span class="s3">// </span><span class="s1">last_axis</span><span class="s3">, </span><span class="s1">last_axis</span><span class="s3">))</span>
        <span class="s4"># Manipulate discont and period</span>
        <span class="s2">if </span><span class="s1">discont </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">discont </span><span class="s3">= </span><span class="s1">period </span><span class="s3">/ </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">integer_input</span><span class="s3">:</span>
            <span class="s1">interval_high</span><span class="s3">, </span><span class="s1">rem </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">period</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
            <span class="s1">boundary_ambiguous </span><span class="s3">= </span><span class="s1">rem </span><span class="s3">== </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">interval_high </span><span class="s3">= </span><span class="s1">period </span><span class="s3">/ </span><span class="s5">2</span>
            <span class="s1">boundary_ambiguous </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">interval_low </span><span class="s3">= -</span><span class="s1">interval_high</span>

        <span class="s4"># Work on each row separately</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">p_init</span><span class="s3">.</span><span class="s1">size </span><span class="s3">// </span><span class="s1">last_axis</span><span class="s3">):</span>
            <span class="s1">row </span><span class="s3">= </span><span class="s1">p_new</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">dd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>
            <span class="s1">ddmod </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mod</span><span class="s3">(</span><span class="s1">dd </span><span class="s3">- </span><span class="s1">interval_low</span><span class="s3">, </span><span class="s1">period</span><span class="s3">) + </span><span class="s1">interval_low</span>
            <span class="s2">if </span><span class="s1">boundary_ambiguous</span><span class="s3">:</span>
                <span class="s1">ddmod </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">((</span><span class="s1">ddmod </span><span class="s3">== </span><span class="s1">interval_low</span><span class="s3">) &amp; (</span><span class="s1">dd </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">),</span>
                                 <span class="s1">interval_high</span><span class="s3">, </span><span class="s1">ddmod</span><span class="s3">)</span>
            <span class="s1">ph_correct </span><span class="s3">= </span><span class="s1">ddmod </span><span class="s3">- </span><span class="s1">dd</span>

            <span class="s1">ph_correct </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dd</span><span class="s3">]) &lt; </span><span class="s1">discont</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
                                  <span class="s1">ph_correct</span><span class="s3">)</span>
            <span class="s1">ph_ravel </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dd</span><span class="s3">]) &lt; </span><span class="s1">discont</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
                                <span class="s1">ph_correct</span><span class="s3">)</span>
            <span class="s1">ph_correct </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">ph_ravel</span><span class="s3">, </span><span class="s1">ph_correct</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">up </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>
            <span class="s1">up</span><span class="s3">[</span><span class="s1">slice1</span><span class="s3">] = </span><span class="s1">row</span><span class="s3">[</span><span class="s1">slice1</span><span class="s3">] + </span><span class="s1">ph_correct</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">()</span>
            <span class="s1">p_new</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">up</span>

        <span class="s2">return </span><span class="s1">p_new</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">init_shape</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>

<span class="s4">#----------------------------------------------------------------------------</span>
<span class="s4"># Windowing functions</span>
<span class="s4">#   - translated from the numpy implementations found in:</span>
<span class="s4">#   https://github.com/numpy/numpy/blob/v1.16.1/numpy/lib/function_base.py#L2543-L3233    # noqa: E501</span>
<span class="s4">#   at commit: f1c4c758e1c24881560dd8ab1e64ae750</span>
<span class="s4">#   - and also, for NumPy &gt;= 1.20, translated from implementations in</span>
<span class="s4">#   https://github.com/numpy/numpy/blob/156cd054e007b05d4ac4829e10a369d19dd2b0b1/numpy/lib/function_base.py#L2655-L3065  # noqa: E501</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_bartlett_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1. </span><span class="s3">- </span><span class="s1">M</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">less_equal</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">), </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_blackman_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1. </span><span class="s3">- </span><span class="s1">M</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s5">0.42 </span><span class="s3">+ </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)) +</span>
            <span class="s5">0.08 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_hamming_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">M</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">0.54 </span><span class="s3">+ </span><span class="s5">0.46 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_hanning_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">M</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">0.5 </span><span class="s3">+ </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">window_generator</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">window_overload</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'M must be an integer'</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">window_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>

            <span class="s2">if </span><span class="s1">M </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">M </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">window_impl</span>
    <span class="s2">return </span><span class="s1">window_overload</span>


<span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bartlett</span><span class="s3">)(</span><span class="s1">window_generator</span><span class="s3">(</span><span class="s1">np_bartlett_impl</span><span class="s3">))</span>
<span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">blackman</span><span class="s3">)(</span><span class="s1">window_generator</span><span class="s3">(</span><span class="s1">np_blackman_impl</span><span class="s3">))</span>
<span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">hamming</span><span class="s3">)(</span><span class="s1">window_generator</span><span class="s3">(</span><span class="s1">np_hamming_impl</span><span class="s3">))</span>
<span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">hanning</span><span class="s3">)(</span><span class="s1">window_generator</span><span class="s3">(</span><span class="s1">np_hanning_impl</span><span class="s3">))</span>


<span class="s1">_i0A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span>
    <span class="s3">-</span><span class="s5">4.41534164647933937950E-18</span><span class="s3">,</span>
    <span class="s5">3.33079451882223809783E-17</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">2.43127984654795469359E-16</span><span class="s3">,</span>
    <span class="s5">1.71539128555513303061E-15</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">1.16853328779934516808E-14</span><span class="s3">,</span>
    <span class="s5">7.67618549860493561688E-14</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">4.85644678311192946090E-13</span><span class="s3">,</span>
    <span class="s5">2.95505266312963983461E-12</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">1.72682629144155570723E-11</span><span class="s3">,</span>
    <span class="s5">9.67580903537323691224E-11</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">5.18979560163526290666E-10</span><span class="s3">,</span>
    <span class="s5">2.65982372468238665035E-9</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">1.30002500998624804212E-8</span><span class="s3">,</span>
    <span class="s5">6.04699502254191894932E-8</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">2.67079385394061173391E-7</span><span class="s3">,</span>
    <span class="s5">1.11738753912010371815E-6</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">4.41673835845875056359E-6</span><span class="s3">,</span>
    <span class="s5">1.64484480707288970893E-5</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">5.75419501008210370398E-5</span><span class="s3">,</span>
    <span class="s5">1.88502885095841655729E-4</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">5.76375574538582365885E-4</span><span class="s3">,</span>
    <span class="s5">1.63947561694133579842E-3</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">4.32430999505057594430E-3</span><span class="s3">,</span>
    <span class="s5">1.05464603945949983183E-2</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">2.37374148058994688156E-2</span><span class="s3">,</span>
    <span class="s5">4.93052842396707084878E-2</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">9.49010970480476444210E-2</span><span class="s3">,</span>
    <span class="s5">1.71620901522208775349E-1</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">3.04682672343198398683E-1</span><span class="s3">,</span>
    <span class="s5">6.76795274409476084995E-1</span><span class="s3">,</span>
<span class="s3">])</span>

<span class="s1">_i0B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span>
    <span class="s3">-</span><span class="s5">7.23318048787475395456E-18</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">4.83050448594418207126E-18</span><span class="s3">,</span>
    <span class="s5">4.46562142029675999901E-17</span><span class="s3">,</span>
    <span class="s5">3.46122286769746109310E-17</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">2.82762398051658348494E-16</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">3.42548561967721913462E-16</span><span class="s3">,</span>
    <span class="s5">1.77256013305652638360E-15</span><span class="s3">,</span>
    <span class="s5">3.81168066935262242075E-15</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">9.55484669882830764870E-15</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">4.15056934728722208663E-14</span><span class="s3">,</span>
    <span class="s5">1.54008621752140982691E-14</span><span class="s3">,</span>
    <span class="s5">3.85277838274214270114E-13</span><span class="s3">,</span>
    <span class="s5">7.18012445138366623367E-13</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">1.79417853150680611778E-12</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">1.32158118404477131188E-11</span><span class="s3">,</span>
    <span class="s3">-</span><span class="s5">3.14991652796324136454E-11</span><span class="s3">,</span>
    <span class="s5">1.18891471078464383424E-11</span><span class="s3">,</span>
    <span class="s5">4.94060238822496958910E-10</span><span class="s3">,</span>
    <span class="s5">3.39623202570838634515E-9</span><span class="s3">,</span>
    <span class="s5">2.26666899049817806459E-8</span><span class="s3">,</span>
    <span class="s5">2.04891858946906374183E-7</span><span class="s3">,</span>
    <span class="s5">2.89137052083475648297E-6</span><span class="s3">,</span>
    <span class="s5">6.88975834691682398426E-5</span><span class="s3">,</span>
    <span class="s5">3.36911647825569408990E-3</span><span class="s3">,</span>
    <span class="s5">8.04490411014108831608E-1</span><span class="s3">,</span>
<span class="s3">])</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_chbevl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">):</span>
    <span class="s1">b0 </span><span class="s3">= </span><span class="s1">vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">b1 </span><span class="s3">= </span><span class="s5">0.0</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">)):</span>
        <span class="s1">b2 </span><span class="s3">= </span><span class="s1">b1</span>
        <span class="s1">b1 </span><span class="s3">= </span><span class="s1">b0</span>
        <span class="s1">b0 </span><span class="s3">= </span><span class="s1">x </span><span class="s3">* </span><span class="s1">b1 </span><span class="s3">- </span><span class="s1">b2 </span><span class="s3">+ </span><span class="s1">vals</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s5">0.5 </span><span class="s3">* (</span><span class="s1">b0 </span><span class="s3">- </span><span class="s1">b2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_i0</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= -</span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s5">8.0</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= (</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">x</span><span class="s3">) - </span><span class="s5">2.0</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">_chbevl</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">_i0A</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">_chbevl</span><span class="s3">(</span><span class="s5">32.0 </span><span class="s3">/ </span><span class="s1">x </span><span class="s3">- </span><span class="s5">2.0</span><span class="s3">, </span><span class="s1">_i0B</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_i0n</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">):</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">_i0</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">(</span><span class="s1">beta</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)):</span>
        <span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">_i0</span><span class="s3">(</span><span class="s1">beta </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- ((</span><span class="s1">n</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">alpha</span><span class="s3">) / </span><span class="s1">alpha</span><span class="s3">)**</span><span class="s5">2.0</span><span class="s3">)) / </span><span class="s1">t</span>

    <span class="s2">return </span><span class="s1">y</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">kaiser</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_kaiser</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'M must be an integer'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">beta</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">'beta must be an integer or float'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_kaiser_impl</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
        <span class="s1">alpha </span><span class="s3">= (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2.0</span>

        <span class="s2">return </span><span class="s1">_i0n</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_kaiser_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_cross_operation</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s1">x0 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[..., </span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s5">3</span><span class="s3">:</span>
            <span class="s1">x2 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[..., </span><span class="s5">2</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">x2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">x0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span>

    <span class="s1">a0</span><span class="s3">, </span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2 </span><span class="s3">= </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">b0</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">, </span><span class="s1">b2 </span><span class="s3">= </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

    <span class="s1">cp0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">b2</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">)</span>
    <span class="s1">cp1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">, </span><span class="s1">b0</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a0</span><span class="s3">, </span><span class="s1">b2</span><span class="s3">)</span>
    <span class="s1">cp2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a0</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">b0</span><span class="s3">)</span>

    <span class="s1">out</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">cp0</span>
    <span class="s1">out</span><span class="s3">[..., </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">cp1</span>
    <span class="s1">out</span><span class="s3">[..., </span><span class="s5">2</span><span class="s3">] = </span><span class="s1">cp2</span>


<span class="s2">def </span><span class="s1">_cross</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_cross</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_cross_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">promote_types</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">cp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">3</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">_cross_operation</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">cp</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">cp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">], </span><span class="s1">b</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">]).</span><span class="s1">shape</span>
            <span class="s1">cp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape </span><span class="s3">+ (</span><span class="s5">3</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">_cross_operation</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">cp</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">cp</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cross</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_cross</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;Inputs must be array-like.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">a_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">b_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] </span><span class="s2">not in </span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">) </span><span class="s2">or </span><span class="s1">b_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] </span><span class="s2">not in </span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span>
                <span class="s6">&quot;Incompatible dimensions for cross product</span><span class="s2">\n</span><span class="s6">&quot;</span>
                <span class="s6">&quot;(dimension must be 2 or 3)&quot;</span>
            <span class="s3">))</span>

        <span class="s2">if </span><span class="s1">a_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s5">3 </span><span class="s2">or </span><span class="s1">b_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s5">3</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_cross</span><span class="s3">(</span><span class="s1">a_</span><span class="s3">, </span><span class="s1">b_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span>
                <span class="s6">&quot;Dimensions for both inputs is 2.</span><span class="s2">\n</span><span class="s6">&quot;</span>
                <span class="s6">&quot;Please replace your numpy.cross(a, b) call with &quot;</span>
                <span class="s6">&quot;a call to `cross2d(a, b)` from `numba.np.extensions`.&quot;</span>
            <span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_cross2d_operation</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s1">x0 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[..., </span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span>

    <span class="s1">a0</span><span class="s3">, </span><span class="s1">a1 </span><span class="s3">= </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">b0</span><span class="s3">, </span><span class="s1">b1 </span><span class="s3">= </span><span class="s1">_cross_preprocessing</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

    <span class="s1">cp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a0</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a1</span><span class="s3">, </span><span class="s1">b0</span><span class="s3">)</span>
    <span class="s4"># If ndim of a and b is 1, cp is a scalar.</span>
    <span class="s4"># In this case np.cross returns a 0-D array, containing the scalar.</span>
    <span class="s4"># np.asarray is used to reconcile this case, without introducing</span>
    <span class="s4"># overhead in the case where cp is an actual N-D array.</span>
    <span class="s4"># (recall that np.asarray does not copy existing arrays)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">cp</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">cross2d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">cross2d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">cross2d_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;Inputs must be array-like.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">a_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">b_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">b_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span>
                <span class="s6">&quot;Incompatible dimensions for 2D cross product</span><span class="s2">\n</span><span class="s6">&quot;</span>
                <span class="s6">&quot;(dimension must be 2 for both inputs)&quot;</span>
            <span class="s3">))</span>
        <span class="s2">return </span><span class="s1">_cross2d_operation</span><span class="s3">(</span><span class="s1">a_</span><span class="s3">, </span><span class="s1">b_</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_trim_zeros</span><span class="s3">(</span><span class="s1">filt</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">=</span><span class="s6">'fb'</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">filt</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'The first argument must be an array'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">filt</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'array must be 1D'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">trim</span><span class="s3">, (</span><span class="s1">str</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UnicodeType</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">'The second argument must be a string'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">filt</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">=</span><span class="s6">'fb'</span><span class="s3">):</span>
        <span class="s1">a_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">filt</span><span class="s3">)</span>
        <span class="s1">first </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">trim </span><span class="s3">= </span><span class="s1">trim</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s6">'f' </span><span class="s2">in </span><span class="s1">trim</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">a_</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">first </span><span class="s3">= </span><span class="s1">first </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s1">last </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">filt</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s6">'b' </span><span class="s2">in </span><span class="s1">trim</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">a_</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]:</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">last </span><span class="s3">= </span><span class="s1">last </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">a_</span><span class="s3">[</span><span class="s1">first</span><span class="s3">:</span><span class="s1">last</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">impl</span>
</pre>
</body>
</html>