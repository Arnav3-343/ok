<html>
<head>
<title>clock.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
clock.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Clock object 
============ 
 
The :class:`Clock` object allows you to schedule a function call in the 
future; once or repeatedly at specified intervals. You can get the time 
elapsed between the scheduling and the calling of the callback via the 
`dt` argument:: 
 
    # dt means delta-time 
    def my_callback(dt): 
        pass 
 
    # call my_callback every 0.5 seconds 
    Clock.schedule_interval(my_callback, 0.5) 
 
    # call my_callback in 5 seconds 
    Clock.schedule_once(my_callback, 5) 
 
    # call my_callback as soon as possible (usually next frame.) 
    Clock.schedule_once(my_callback) 
 
.. note:: 
 
    If the callback returns False, the schedule will be canceled and won't 
    repeat. 
 
If you want to schedule a function to call with default arguments, you can use 
the `functools.partial 
&lt;http://docs.python.org/library/functools.html#functools.partial&gt;`_ python 
module:: 
 
    from functools import partial 
 
    def my_callback(value, key, *largs): 
        pass 
 
    Clock.schedule_interval(partial(my_callback, 'my value', 'my key'), 0.5) 
 
Conversely, if you want to schedule a function that doesn't accept the dt 
argument, you can use a `lambda 
&lt;http://docs.python.org/2/reference/expressions.html#lambda&gt;`_ expression 
to write a short function that does accept dt. For Example:: 
 
    def no_args_func(): 
        print(&quot;I accept no arguments, so don't schedule me in the clock&quot;) 
 
    Clock.schedule_once(lambda dt: no_args_func(), 0.5) 
 
.. note:: 
 
    You cannot unschedule an anonymous function unless you keep a 
    reference to it. It's better to add \\*args to your function 
    definition so that it can be called with an arbitrary number of 
    parameters. 
 
.. important:: 
 
    The class method callback is weak-referenced: you are responsible for 
    keeping a reference to your original object/callback. If you don't keep a 
    reference, the ClockBase will never execute your callback. For 
    example:: 
 
        class Foo(object): 
            def start(self): 
                Clock.schedule_interval(self.callback, 0.5) 
 
            def callback(self, dt): 
                print('In callback') 
 
        # A Foo object is created and the method start is called. 
        # Because no reference is kept to the instance returned from Foo(), 
        # the object will be collected by the Python Garbage Collector and 
        # your callback will be never called. 
        Foo().start() 
 
        # So you should do the following and keep a reference to the instance 
        # of foo until you don't need it anymore! 
        foo = Foo() 
        foo.start() 
 
 
.. _schedule-before-frame: 
 
Schedule before frame 
--------------------- 
 
.. versionadded:: 1.0.5 
 
Sometimes you need to schedule a callback BEFORE the next frame. Starting 
from 1.0.5, you can use a timeout of -1:: 
 
    Clock.schedule_once(my_callback, 0) # call after the next frame 
    Clock.schedule_once(my_callback, -1) # call before the next frame 
 
The Clock will execute all the callbacks with a timeout of -1 before the 
next frame even if you add a new callback with -1 from a running 
callback. However, :class:`Clock` has an iteration limit for these 
callbacks: it defaults to 10. 
 
If you schedule a callback that schedules a callback that schedules a ... etc 
more than 10 times, it will leave the loop and send a warning to the console, 
then continue after the next frame. This is implemented to prevent bugs from 
hanging or crashing the application. 
 
If you need to increase the limit, set the :attr:`max_iteration` property:: 
 
    from kivy.clock import Clock 
    Clock.max_iteration = 20 
 
.. _triggered-events: 
 
Triggered Events 
---------------- 
 
.. versionadded:: 1.0.5 
 
:meth:`CyClockBase.create_trigger` is an advanced method way to defer a 
callback. It functions exactly like :meth:`CyClockBase.schedule_once` and 
:meth:`CyClockBase.schedule_interval` except that it doesn't immediately 
schedule the callback. Instead, one schedules the callback using the 
:class:`ClockEvent` returned by it. This ensures that you can call the event 
multiple times but it won't be scheduled more than once. This is not the case 
with :meth:`CyClockBase.schedule_once`:: 
 
    # will run the callback twice before the next frame 
    Clock.schedule_once(my_callback) 
    Clock.schedule_once(my_callback) 
 
    # will run the callback once before the next frame 
    event = Clock.create_trigger(my_callback) 
    event() 
    event() 
 
    # will also run the callback only once before the next frame 
    event = Clock.schedule_once(my_callback)  # now it's already scheduled 
    event()  # won't be scheduled again 
    event() 
 
In addition, it is more convenient to create and bind to 
the triggered event than using :meth:`CyClockBase.schedule_once` in a 
function:: 
 
    from kivy.clock import Clock 
    from kivy.uix.widget import Widget 
 
    class Sample(Widget): 
        def __init__(self, **kwargs): 
            self._trigger = Clock.create_trigger(self.cb) 
            super(Sample, self).__init__(**kwargs) 
            self.bind(x=self._trigger, y=self._trigger) 
 
        def cb(self, *largs): 
            pass 
 
Even if x and y changes within one frame, the callback is only run once. 
 
Unscheduling 
------------- 
 
An event scheduled with :meth:`CyClockBase.schedule_once`, 
:meth:`CyClockBase.schedule_interval`, or with 
:meth:`CyClockBase.create_trigger` and then triggered can be unscheduled in 
multiple ways. E.g:: 
 
    def my_callback(dt): 
        pass 
 
    # call my_callback every 0.5 seconds 
    event = Clock.schedule_interval(my_callback, 0.5) 
 
    # call my_callback in 5 seconds 
    event2 = Clock.schedule_once(my_callback, 5) 
 
    event_trig = Clock.create_trigger(my_callback, 5) 
    event_trig() 
 
    # unschedule using cancel 
    event.cancel() 
 
    # unschedule using Clock.unschedule 
    Clock.unschedule(event2) 
 
    # unschedule using Clock.unschedule with the callback 
    # NOT RECOMMENDED 
    Clock.unschedule(my_callback) 
 
The best way to unschedule a callback is with :meth:`ClockEvent.cancel`. 
:meth:`CyClockBase.unschedule` is mainly an alias for that for that function. 
However, if the original callback itself is passed to 
:meth:`CyClockBase.unschedule`, it'll unschedule all instances of that 
callback (provided ``all`` is True, the default, otherwise only the first match 
is removed). 
 
Calling :meth:`CyClockBase.unschedule` on the original callback is highly 
discouraged because it's significantly slower than when using the event. 
 
Clock Lifecycle 
--------------- 
 
Kivy's clock has a lifecycle. By default, scheduling a callback after the Clock 
has ended will not raise an error, even though the callback may never be 
called. That's because most callbacks are like services, e.g. responding to a 
user button press - if the app is running the callbacks need to service the app 
and respond to the input, but once the app has stopped or is stopping, we can 
safely not process these events. 
 
Other events always need to be processed. E.g. another thread may request a 
callback in kivy's thread and then process some result. If the event is not 
processed in Kivy's thread because the app stopped, the second thread may 
block forever hanging the application as it exits. 
 
Consequently, we provide a API 
(:meth:`CyClockBase.create_lifecycle_aware_trigger`) for scheduling callbacks 
that raise a :class:`ClockNotRunningError` if the clock has stopped. If the 
scheduling succeeded it guarantees that one of its callbacks will be called. 
I.e. the new :meth:`CyClockBase.create_lifecycle_aware_trigger` accepts an 
additional ``clock_ended_callback`` parameter. Normally, ``callback`` will be 
called when the event is processed. But, if the clock is stopped before it can 
be processed, if the application exited normally (and the app was started) and 
the event wasn't canceled, and the callbacks are not garbage collected, then 
``clock_ended_callback`` will be called instead when the clock is stopped. 
 
That is, given these conditions, if :class:`ClockNotRunningError` was not 
raised when the event was scheduled, then one of these callbacks will be 
called - either ``callback`` if the event executed normally, or 
``clock_ended_callback`` if the clock is stopped while the event is scheduled. 
 
By default, events can be scheduled before the clock is started because it is 
assumed the clock will eventually be started when the app starts. I.e. 
calling :meth:`CyClockBase.create_lifecycle_aware_trigger` before the clock 
and application starts will succeed. But if the app never actually starts, then 
neither of the callbacks may be executed. 
 
.. versionadded:: 2.0.0 
    The lifecycle was added in 2.0.0 
 
Exception Handling 
------------------ 
 
Kivy provides a exception handling manager, 
:attr:`~kivy.base.ExceptionManager`, to handle its internal exceptions 
including exceptions raised by clock callbacks, without crashing the 
application. By default when an exception is raised, the app will crash. 
But, if a handler is registered with the exception manager and the handler 
handles the exception, the app will not crash and will continue as normal.:: 
 
    from kivy.base import ExceptionHandler, ExceptionManager 
    class MyHandler(ExceptionHandler): 
        def handle_exception(self, inst): 
            if isinstance(inst, ValueError): 
                Logger.exception('ValueError caught by MyHandler') 
                return ExceptionManager.PASS 
            return ExceptionManager.RAISE 
 
    ExceptionManager.add_handler(MyHandler()) 
 
Then, all ValueError exceptions will be logged to the console and ignored. 
Similarly, if a scheduled clock callback raises a ValueError, other clock 
events will still be processed normally. 
 
If an event's callback raises an exception, before the exception handler is 
executed, the callback is immediately canceled. 
 
It still is possible for the app to be corrupted if kivy itself is the source 
of the exception. I.e. even with a handler that ignores exceptions and doesn't 
crash, the app may be in a corrupted state if the error originates from within 
Kivy itself. However, the exception handler can help protect the app from 
crashing and can help protect against user callbacks crashing the app. 
 
.. versionchanged:: 2.0.0 
    Prior to Kivy 2.0.0, an exception raised in a event's callback would 
    cause the clock to crash and subsequent events may or may not be executed. 
    Even if the exception was handled by an 
    :class:`~kivy.base.ExceptionHandler`, there was no guarantee that some 
    scheduled events would not be skipped. 
 
    From 2.0.0 onward, if a event's exception is handled by an 
    :class:`~kivy.base.ExceptionHandler`, other events will be shielded from 
    the exception and will execute normally. 
 
Scheduling from ``__del__`` 
--------------------------- 
 
It is not safe to schedule Clock events from a object's ``__del__`` or 
``__dealloc__`` method. If you must schedule a Clock call from this method, use 
:meth:`CyClockBase.schedule_del_safe` or 
:meth:`CyClockBase.schedule_lifecycle_aware_del_safe` instead. 
 
Threading and Callback Order 
----------------------------- 
 
Beginning with 1.10.0, all the events scheduled for the same frame, e.g. 
all the events scheduled in the same frame with a ``timeout`` of ``0``, 
well be executed in the order they were scheduled. 
 
Also, all the scheduling and canceling methods are fully thread safe and 
can be safely used from external threads. 
 
As a consequence, calling :meth:`CyClockBase.unschedule` with the original 
callback is now significantly slower and highly discouraged. Instead, the 
returned events should be used to cancel. As a tradeoff, all the other methods 
are now significantly faster than before. 
 
Advanced Clock Details 
----------------------- 
 
The following section goes into the internal kivy clock details as well 
as the various clock options. It is meant only for advanced users. 
 
Fundamentally, the Kivy clock attempts to execute any scheduled callback 
rhythmically as determined by the specified fps (frame per second, see 
``maxfps`` in :mod:`~kivy.config`). That is, ideally, given e.g. a desired fps 
of 30, the clock will execute the callbacks at intervals of 1 / 30 seconds, or 
every 33.33 ms. All the callbacks in a frame are given the same timestamp, 
i.e. the ``dt`` passed to the callback are all the same and it's the difference 
in time between the start of this and the previous frame. 
 
Because of inherent indeterminism, the frames do not actually occur exactly 
at intervals of the fps and ``dt`` may be under or over the desired fps. 
Also, once the timeout is &quot;close enough&quot; to the desired timeout, as determined 
internally, Kivy will execute the callback in the current frame even when the 
&quot;actual time&quot; has not elapsed the ``timeout`` amount. 
 
Kivy offers now, since ``1.10.0``, multiple clocks with different behaviors. 
 
Default Clock 
^^^^^^^^^^^^^^ 
 
The default clock (``default``) behaves as described above. When a callback 
with a timeout of zero or non-zero is scheduled, they are executed at the frame 
that is near the timeout, which is a function of the fps. So a timeout of zero 
would still result in a delay of one frame or about 1 / fps, typically a bit 
less but sometimes more depending on the CPU usage of the other events 
scheduled for that frame. 
 
In a test using a fps of 30, a callback with a timeout of 0, 0.001, and 0.05, 
resulted in a mean callback delay of 0.02487, 0.02488, and 0.05011 seconds, 
respectively. When tested with a fps of 600 the delay for 0.05 was similar, 
except the standard deviation was reduced resulting in overall better accuracy. 
 
Interruptible Clock 
^^^^^^^^^^^^^^^^^^^^ 
 
The default clock suffers from the quantization problem, as frames occur only 
on intervals and any scheduled timeouts will not be able to occur during an 
interval. For example, with the timeout of 0.05, while the mean was 0.05011, 
its values ranged between 0.02548 - 0.07348 and a standard deviation of 0.002. 
Also, there's the minimum timeout of about 0.02487. 
 
The interruptible clock (``interrupt``) will execute timeouts even during a 
frame. So a timeout of zero will execute as quickly as possible and similarly 
a non-zero timeout will be executed even during the interval. 
 
This clock, and all the clocks described after this have an option, 
:attr:`ClockBaseInterruptBehavior.interupt_next_only`. When True, any of the 
behavior new behavior will only apply to the callbacks with a timeout of 
zero. Non-zero timeouts will behave like in the default clock. E.g. for this 
clock when True, only zero timeouts will execute during the interval. 
 
In a test using a fps of 30, a callback with a timeout of 0, 0.001, and 0.05, 
resulted in a mean callback delay of 0.00013, 0.00013, and 0.04120 seconds, 
respectively when :attr:`ClockBaseInterruptBehavior.interupt_next_only` was 
False. Also, compared to the default clock the standard deviation was reduced. 
When :attr:`ClockBaseInterruptBehavior.interupt_next_only` was True, the values 
were 0.00010, 0.02414, and 0.05034, respectively. 
 
Free Clock 
^^^^^^^^^^^ 
 
The interruptible clock may not be ideal for all cases because all the events 
are executed during the intervals and events are not executed anymore 
rhythmically as multiples of the fps. For example, there may not be any benefit 
for the graphics to update in a sub-interval, so the additional accuracy 
wastes CPU. 
 
The Free clock (``free_all``) solves this by having ``Clock.xxx_free`` versions 
of all the Clock scheduling methods. By free, we mean the event is free from 
the fps because it's not fps limited. E.g. 
:meth:`CyClockBaseFree.create_trigger_free` corresponds to 
:meth:`CyClockBase.create_trigger`. Only when an event scheduled using the 
``Clock.xxx_free`` methods is present will the clock interrupt and execute 
the events during the interval. So, if no ``free`` event is present the clock 
behaves like the ``default`` clock, otherwise it behaves like the ``interrupt`` 
clock. 
 
In a test using a fps of 30, a callback with a timeout of 0s, 0.001s, and 
0.05s, resulted in a mean callback delay of 0.00012s, 0.00017s, and 0.04121s 
seconds, respectively when it was a free event and 0.02403s, 0.02405s, and 
0.04829s, respectively when it wasn't. 
 
Free Only Clock 
^^^^^^^^^^^^^^^^^ 
 
The Free clock executes all events when a free event was scheduled. This 
results in normal events also being execute in the middle of the interval 
when a free event is scheduled. For example, above, when a free event was 
absent, a normal event with a 0.001s timeout was delayed for 0.02405s. However, 
if a free event happened to be also scheduled, the normal event was only 
delayed 0.00014s, which may be undesirable. 
 
The Free only clock (``free_only``) solves it by only executing free events 
during the interval and normal events are always executed like with the 
default clock. For example, in the presence of a free event, a normal event 
with a timeout of 0.001s still had a delay of 0.02406. So this clock, 
treats free and normal events independently, with normal events always being 
fps limited, but never the free events. 
 
Summary 
^^^^^^^^ 
 
The kivy clock type to use can be set with the ``kivy_clock`` option the 
:mod:`~kivy.config`. If ``KIVY_CLOCK`` is present in the environment it 
overwrites the config selection. Its possible values are as follows: 
 
* When ``kivy_clock`` is ``default``, the normal clock, :class:`ClockBase`, 
  which limits callbacks to the maxfps quantization - is used. 
* When ``kivy_clock`` is ``interrupt``, a interruptible clock, 
  :class:`ClockBaseInterrupt`, which doesn't limit any callbacks to the 
  maxfps - is used. Callbacks will be executed at any time. 
* When ``kivy_clock`` is ``free_all``, a interruptible clock, 
  :class:`ClockBaseFreeInterruptAll`, which doesn't limit any callbacks to the 
  maxfps in the presence of free events, but in their absence it limits events 
  to the fps quantization interval - is used. 
* When ``kivy_clock`` is ``free_only``, a interruptible clock, 
  :class:`ClockBaseFreeInterruptAll`, which treats free and normal events 
  independently; normal events are fps limited while free events are not - is 
  used. 
 
Async clock support 
------------------- 
 
.. versionadded:: 2.0.0 
 
Experimental async support has been added in 2.0.0. The Clock now has a 
:meth:`ClockBaseBehavior.async_tick` and :meth:`ClockBaseBehavior.async_idle` 
coroutine method which is used by the kivy EventLoop when the kivy EventLoop is 
executed in a asynchronous manner. When used, the kivy clock does not 
block while idling. 
 
The async library to use is selected with the `KIVY_EVENTLOOP` environmental 
variable or by  calling :meth:`~kivy.clock.ClockBaseBehavior.init_async_lib` 
directly. The library can be one of `&quot;asyncio&quot;` when the standard library 
`asyncio` should be used, or `&quot;trio&quot;` if the trio library 
should be used. If not set it defaults to `&quot;asyncio&quot;`. 
 
See :mod:`~kivy.app` for example usage. 
'''</span>

<span class="s1">__all__ </span><span class="s2">= (</span>
    <span class="s3">'Clock'</span><span class="s2">, </span><span class="s3">'ClockNotRunningError'</span><span class="s2">, </span><span class="s3">'ClockEvent'</span><span class="s2">, </span><span class="s3">'FreeClockEvent'</span><span class="s2">,</span>
    <span class="s3">'CyClockBase'</span><span class="s2">, </span><span class="s3">'CyClockBaseFree'</span><span class="s2">, </span><span class="s3">'triggered'</span><span class="s2">,</span>
    <span class="s3">'ClockBaseBehavior'</span><span class="s2">, </span><span class="s3">'ClockBaseInterruptBehavior'</span><span class="s2">,</span>
    <span class="s3">'ClockBaseInterruptFreeBehavior'</span><span class="s2">, </span><span class="s3">'ClockBase'</span><span class="s2">, </span><span class="s3">'ClockBaseInterrupt'</span><span class="s2">,</span>
    <span class="s3">'ClockBaseFreeInterruptAll'</span><span class="s2">, </span><span class="s3">'ClockBaseFreeInterruptOnly'</span><span class="s2">, </span><span class="s3">'mainthread'</span><span class="s2">)</span>

<span class="s4">from </span><span class="s1">sys </span><span class="s4">import </span><span class="s1">platform</span>
<span class="s4">from </span><span class="s1">os </span><span class="s4">import </span><span class="s1">environ</span>
<span class="s4">from </span><span class="s1">functools </span><span class="s4">import </span><span class="s1">wraps</span><span class="s2">, </span><span class="s1">partial</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">context </span><span class="s4">import </span><span class="s1">register_context</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">config </span><span class="s4">import </span><span class="s1">Config</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">logger </span><span class="s4">import </span><span class="s1">Logger</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">compat </span><span class="s4">import </span><span class="s1">clock </span><span class="s4">as </span><span class="s1">_default_time</span>
<span class="s4">import </span><span class="s1">time</span>
<span class="s4">try</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">_clock </span><span class="s4">import </span><span class="s1">CyClockBase</span><span class="s2">, </span><span class="s1">ClockEvent</span><span class="s2">, </span><span class="s1">FreeClockEvent</span><span class="s2">, </span><span class="s1">\</span>
        <span class="s1">CyClockBaseFree</span><span class="s2">, </span><span class="s1">ClockNotRunningError</span>
<span class="s4">except </span><span class="s1">ImportError</span><span class="s2">:</span>
    <span class="s1">Logger</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span>
        <span class="s3">'Clock: Unable to import kivy._clock. Have you perhaps forgotten to '</span>
        <span class="s3">'compile kivy? Kivy contains Cython code which needs to be compiled. '</span>
        <span class="s3">'A missing kivy._clock often indicates the Cython code has not been '</span>
        <span class="s3">'compiled. Please follow the installation instructions and make sure '</span>
        <span class="s3">'to compile Kivy'</span><span class="s2">)</span>
    <span class="s4">raise</span>

<span class="s4">from </span><span class="s1">threading </span><span class="s4">import </span><span class="s1">Event </span><span class="s4">as </span><span class="s1">ThreadingEvent</span>

<span class="s5"># some reading: http://gameprogrammingpatterns.com/game-loop.html</span>


<span class="s4">def </span><span class="s1">_get_sleep_obj</span><span class="s2">():</span>
    <span class="s4">pass</span>


<span class="s4">try</span><span class="s2">:</span>
    <span class="s4">import </span><span class="s1">ctypes</span>
    <span class="s4">if </span><span class="s1">platform </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'win32'</span><span class="s2">, </span><span class="s3">'cygwin'</span><span class="s2">):</span>
        <span class="s5"># Win32 Sleep function is only 10-millisecond resolution, so</span>
        <span class="s5"># instead use a waitable timer object, which has up to</span>
        <span class="s5"># 100-nanosecond resolution (hardware and implementation</span>
        <span class="s5"># dependent, of course).</span>

        <span class="s1">_kernel32 </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">windll</span><span class="s2">.</span><span class="s1">kernel32</span>

        <span class="s4">def </span><span class="s1">_get_sleep_obj</span><span class="s2">():  </span><span class="s5"># noqa: F811</span>
            <span class="s4">return </span><span class="s1">_kernel32</span><span class="s2">.</span><span class="s1">CreateWaitableTimerA</span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">_usleep</span><span class="s2">(</span><span class="s1">microseconds</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">delay </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_longlong</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(-</span><span class="s1">microseconds </span><span class="s2">* </span><span class="s6">10</span><span class="s2">))</span>
            <span class="s1">_kernel32</span><span class="s2">.</span><span class="s1">SetWaitableTimer</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">byref</span><span class="s2">(</span><span class="s1">delay</span><span class="s2">), </span><span class="s6">0</span><span class="s2">,</span>
                <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">(), </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">(), </span><span class="s4">False</span><span class="s2">)</span>
            <span class="s1">_kernel32</span><span class="s2">.</span><span class="s1">WaitForSingleObject</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s6">0xffffffff</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'darwin'</span><span class="s2">:</span>
            <span class="s1">_libc </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">CDLL</span><span class="s2">(</span><span class="s3">'libc.dylib'</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">from </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s1">find_library</span>
            <span class="s1">_libc </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">CDLL</span><span class="s2">(</span><span class="s1">find_library</span><span class="s2">(</span><span class="s3">'c'</span><span class="s2">), </span><span class="s1">use_errno</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

            <span class="s4">def </span><span class="s1">_libc_clock_gettime_wrapper</span><span class="s2">():</span>
                <span class="s4">from </span><span class="s1">os </span><span class="s4">import </span><span class="s1">strerror</span>

                <span class="s4">class </span><span class="s1">struct_tv</span><span class="s2">(</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">Structure</span><span class="s2">):</span>
                    <span class="s1">_fields_ </span><span class="s2">= [(</span><span class="s3">'tv_sec'</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_long</span><span class="s2">),</span>
                                <span class="s2">(</span><span class="s3">'tv_usec'</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_long</span><span class="s2">)]</span>

                <span class="s1">_clock_gettime </span><span class="s2">= </span><span class="s1">_libc</span><span class="s2">.</span><span class="s1">clock_gettime</span>
                <span class="s1">_clock_gettime</span><span class="s2">.</span><span class="s1">argtypes </span><span class="s2">= [</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_long</span><span class="s2">,</span>
                                           <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">POINTER</span><span class="s2">(</span><span class="s1">struct_tv</span><span class="s2">)]</span>

                <span class="s4">if </span><span class="s3">'linux' </span><span class="s4">in </span><span class="s1">platform</span><span class="s2">:</span>
                    <span class="s1">_clockid </span><span class="s2">= </span><span class="s6">4  </span><span class="s5"># CLOCK_MONOTONIC_RAW (Linux specific)</span>
                <span class="s4">elif </span><span class="s3">'freebsd' </span><span class="s4">in </span><span class="s1">platform</span><span class="s2">:</span>
                    <span class="s5"># clockid constants from sys/time.h</span>
                    <span class="s5"># _clockid = 4 # CLOCK_MONOTONIC (FreeBSD specific)</span>
                    <span class="s5"># 11: CLOCK_MONOTONIC_PRECISE (FreeBSD known OK for 10.2)</span>
                    <span class="s1">_clockid </span><span class="s2">= </span><span class="s6">11</span>
                    <span class="s5"># _clockid = 12</span>
                    <span class="s5"># 12: CLOCK_MONOTONIC_FAST (FreeBSD specific)</span>
                    <span class="s1">Logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'clock.py: {{{:s}}} clock ID {:d}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                        <span class="s1">platform</span><span class="s2">, </span><span class="s1">_clockid</span><span class="s2">))</span>
                <span class="s4">elif </span><span class="s3">'openbsd' </span><span class="s4">in </span><span class="s1">platform</span><span class="s2">:</span>
                    <span class="s1">_clockid </span><span class="s2">= </span><span class="s6">3  </span><span class="s5"># CLOCK_MONOTONIC</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">_clockid </span><span class="s2">= </span><span class="s6">1  </span><span class="s5"># CLOCK_MONOTONIC</span>

                <span class="s1">tv </span><span class="s2">= </span><span class="s1">struct_tv</span><span class="s2">()</span>

                <span class="s4">def </span><span class="s1">_time</span><span class="s2">():</span>
                    <span class="s4">if </span><span class="s1">_clock_gettime</span><span class="s2">(</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_long</span><span class="s2">(</span><span class="s1">_clockid</span><span class="s2">),</span>
                                      <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">pointer</span><span class="s2">(</span><span class="s1">tv</span><span class="s2">)) != </span><span class="s6">0</span><span class="s2">:</span>
                        <span class="s1">_ernno </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">get_errno</span><span class="s2">()</span>
                        <span class="s4">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s1">_ernno</span><span class="s2">, </span><span class="s1">strerror</span><span class="s2">(</span><span class="s1">_ernno</span><span class="s2">))</span>
                    <span class="s4">return </span><span class="s1">tv</span><span class="s2">.</span><span class="s1">tv_sec </span><span class="s2">+ (</span><span class="s1">tv</span><span class="s2">.</span><span class="s1">tv_usec </span><span class="s2">* </span><span class="s6">0.000000001</span><span class="s2">)</span>

                <span class="s4">return </span><span class="s1">_time</span>

            <span class="s1">_default_time </span><span class="s2">= </span><span class="s1">_libc_clock_gettime_wrapper</span><span class="s2">()  </span><span class="s5"># noqa: F811</span>

        <span class="s1">_libc</span><span class="s2">.</span><span class="s1">usleep</span><span class="s2">.</span><span class="s1">argtypes </span><span class="s2">= [</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_ulong</span><span class="s2">]</span>
        <span class="s1">_libc_usleep </span><span class="s2">= </span><span class="s1">_libc</span><span class="s2">.</span><span class="s1">usleep</span>

        <span class="s4">def </span><span class="s1">_usleep</span><span class="s2">(</span><span class="s1">microseconds</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">_libc_usleep</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s1">microseconds</span><span class="s2">))</span>

<span class="s4">except </span><span class="s2">(</span><span class="s1">OSError</span><span class="s2">, </span><span class="s1">ImportError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">):</span>
    <span class="s5"># ImportError: ctypes is not available on python-for-android.</span>
    <span class="s5"># AttributeError: ctypes is now available on python-for-android, but</span>
    <span class="s5">#   &quot;undefined symbol: clock_gettime&quot;. CF #3797</span>
    <span class="s5"># OSError: if the libc cannot be read (like with buildbot: invalid ELF</span>
    <span class="s5"># header)</span>

    <span class="s4">def </span><span class="s1">_usleep</span><span class="s2">(</span><span class="s1">microseconds</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">time</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">microseconds </span><span class="s2">/ </span><span class="s6">1000000.</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">ClockBaseBehavior</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">'''The base of the kivy clock. 
 
    :parameters: 
 
        `async_lib`: string 
            The async library to use when the clock is run asynchronously. 
            Can be one of, `&quot;asyncio&quot;` when the standard library asyncio 
            should be used, or `&quot;trio&quot;` if the trio library should be used. 
 
            It defaults to `'asyncio'` or the value in the environmental 
            variable `KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also 
            be called directly to set the library. 
    '''</span>

    <span class="s1">_dt </span><span class="s2">= </span><span class="s6">0.0001</span>
    <span class="s1">_last_fps_tick </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">_start_tick </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_fps </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_rfps </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_fps_counter </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_rfps_counter </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_frames </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_frames_displayed </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_events_duration </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s3">'''The measured time that it takes to process all the events etc, excepting 
    any sleep or waiting time. It is the average and is updated every 5 
    seconds. 
    '''</span>

    <span class="s1">_duration_count </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_sleep_time </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">_duration_ts0 </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s1">MIN_SLEEP </span><span class="s2">= </span><span class="s6">0.005</span>
    <span class="s3">'''The minimum time to sleep. If the remaining time is less than this, 
    the event loop will continue. 
    '''</span>
    <span class="s1">SLEEP_UNDERSHOOT </span><span class="s2">= </span><span class="s1">MIN_SLEEP </span><span class="s2">- </span><span class="s6">0.001</span>

    <span class="s1">_async_lib </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s1">_async_wait_for </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">async_lib</span><span class="s2">=</span><span class="s3">'asyncio'</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">init_async_lib</span><span class="s2">(</span><span class="s1">async_lib</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBaseBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_ts0 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_start_tick </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">Config</span><span class="s2">.</span><span class="s1">getint</span><span class="s2">(</span><span class="s3">'graphics'</span><span class="s2">, </span><span class="s3">'maxfps'</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">init_async_lib</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lib</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Manually sets the async library to use internally, when running in 
        a asynchronous manner. 
 
        This can be called anytime before the kivy event loop has started, 
        but not once the kivy App is running. 
 
        :parameters: 
 
            `lib`: string 
                The async library to use when the clock is run asynchronously. 
                Can be one of, `&quot;asyncio&quot;` when the standard library asyncio 
                should be used, or `&quot;trio&quot;` if the trio library should be used. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">lib </span><span class="s2">== </span><span class="s3">'trio'</span><span class="s2">:</span>
            <span class="s4">import </span><span class="s1">trio</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib </span><span class="s2">= </span><span class="s1">trio</span>

            <span class="s4">async def </span><span class="s1">wait_for</span><span class="s2">(</span><span class="s1">coro</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
                <span class="s4">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">move_on_after</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
                    <span class="s4">await </span><span class="s1">coro</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_wait_for </span><span class="s2">= </span><span class="s1">wait_for</span>
        <span class="s4">elif </span><span class="s1">lib </span><span class="s2">== </span><span class="s3">'asyncio'</span><span class="s2">:</span>
            <span class="s4">import </span><span class="s1">asyncio</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib </span><span class="s2">= </span><span class="s1">asyncio</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_wait_for </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">wait_for</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'async library {} not recognized'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">frametime</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Time spent between the last frame and the current frame 
        (in seconds). 
 
        .. versionadded:: 1.8.0 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dt</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">frames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Number of internal frames (not necessarily drawn) from the start of 
        the clock. 
 
        .. versionadded:: 1.8.0 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frames</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">frames_displayed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Number of displayed frames from the start of the clock. 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_frames_displayed</span>

    <span class="s4">def </span><span class="s1">usleep</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">microseconds</span><span class="s2">):</span>
        <span class="s0">'''Sleeps for the number of microseconds. 
        '''</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''(internal) waits here until the next frame. 
        '''</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">min_sleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
            <span class="s1">undershoot </span><span class="s2">= </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">min_sleep</span>
            <span class="s1">usleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">usleep</span>
            <span class="s1">ready </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ready</span>

            <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">ready</span><span class="s2">(</span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">)</span>
            <span class="s4">while not </span><span class="s1">done</span><span class="s2">:</span>
                <span class="s1">usleep</span><span class="s2">(</span><span class="s6">1000000 </span><span class="s2">* </span><span class="s1">sleeptime</span><span class="s2">)</span>
                <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">ready</span><span class="s2">(</span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">)</span>

        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s4">return </span><span class="s1">current</span>

    <span class="s4">async def </span><span class="s1">async_idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''(internal) async version of :meth:`idle`. 
        '''</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">min_sleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
            <span class="s1">undershoot </span><span class="s2">= </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">min_sleep</span>
            <span class="s1">ready </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ready</span>

            <span class="s1">slept </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">ready</span><span class="s2">(</span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">)</span>
            <span class="s4">while not </span><span class="s1">done</span><span class="s2">:</span>
                <span class="s1">slept </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">sleeptime</span><span class="s2">)</span>
                <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">ready</span><span class="s2">(</span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">)</span>

            <span class="s4">if not </span><span class="s1">slept</span><span class="s2">:</span>
                <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s4">return </span><span class="s1">current</span>

    <span class="s4">def </span><span class="s1">_check_ready</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">):</span>
        <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">() - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&lt;= </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot</span>

    <span class="s4">def </span><span class="s1">tick</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Advance the clock to the next step. Must be called every frame. 
        The default clock has a tick() function called by the core Kivy 
        framework.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_idle</span><span class="s2">()</span>
        <span class="s1">ts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">post_idle</span><span class="s2">(</span><span class="s1">ts</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">idle</span><span class="s2">())</span>

    <span class="s4">async def </span><span class="s1">async_tick</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''async version of :meth:`tick`. '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pre_idle</span><span class="s2">()</span>
        <span class="s1">ts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">current </span><span class="s2">= </span><span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">async_idle</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">post_idle</span><span class="s2">(</span><span class="s1">ts</span><span class="s2">, </span><span class="s1">current</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">pre_idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Called before :meth:`idle` by :meth:`tick`. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_release_references</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">post_idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">current</span><span class="s2">):</span>
        <span class="s0">'''Called after :meth:`idle` by :meth:`tick`. 
        '''</span>
        <span class="s5"># tick the current time</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_frames </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_fps_counter </span><span class="s2">+= </span><span class="s6">1</span>

        <span class="s5"># compute how long the event processing takes</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_count </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_sleep_time </span><span class="s2">+= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">ts</span>
        <span class="s1">t_tot </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_ts0</span>
        <span class="s4">if </span><span class="s1">t_tot </span><span class="s2">&gt;= </span><span class="s6">1.</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_events_duration </span><span class="s2">= </span><span class="s1">\</span>
                <span class="s2">(</span><span class="s1">t_tot </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sleep_time</span><span class="s2">) / </span><span class="s1">float</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_count</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_ts0 </span><span class="s2">= </span><span class="s1">current</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_sleep_time </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_duration_count </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s5"># calculate fps things</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_fps_tick </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_fps_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s4">elif </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_fps_tick </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_fps_tick</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fps_counter </span><span class="s2">/ </span><span class="s1">d</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rfps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_rfps_counter</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_fps_tick </span><span class="s2">= </span><span class="s1">current</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_fps_counter </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rfps_counter </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s5"># process event</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_process_events</span><span class="s2">()</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dt</span>

    <span class="s4">def </span><span class="s1">tick_draw</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Tick the drawing counter. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_process_events_before_frame</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_rfps_counter </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_frames_displayed </span><span class="s2">+= </span><span class="s6">1</span>

    <span class="s4">def </span><span class="s1">get_fps</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Get the current average FPS calculated by the clock. 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fps</span>

    <span class="s4">def </span><span class="s1">get_rfps</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Get the current &quot;real&quot; FPS calculated by the clock. 
        This counter reflects the real framerate displayed on the screen. 
 
        In contrast to get_fps(), this function returns a counter of the 
        number of frames, not the average of frames per second. 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_rfps</span>

    <span class="s4">def </span><span class="s1">get_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Get the last tick made by the clock.'''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>

    <span class="s4">def </span><span class="s1">get_boottime</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Get the time in seconds from the application start.'''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_start_tick</span>

    <span class="s1">time </span><span class="s2">= </span><span class="s1">staticmethod</span><span class="s2">(</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">_default_time</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">handle_exception</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">e</span><span class="s2">):</span>
        <span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">base </span><span class="s4">import </span><span class="s1">ExceptionManager</span>

        <span class="s4">if </span><span class="s1">ExceptionManager</span><span class="s2">.</span><span class="s1">handle_exception</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) == </span><span class="s1">ExceptionManager</span><span class="s2">.</span><span class="s1">RAISE</span><span class="s2">:</span>
            <span class="s4">raise</span>


<span class="s1">ClockBaseBehavior</span><span class="s2">.</span><span class="s1">time</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">\</span>
    <span class="s3">'''Proxy method for :func:`~kivy.compat.clock`. '''</span>


<span class="s4">class </span><span class="s1">ClockBaseInterruptBehavior</span><span class="s2">(</span><span class="s1">ClockBaseBehavior</span><span class="s2">):</span>
    <span class="s0">'''A kivy clock which can be interrupted during a frame to execute events. 
    '''</span>

    <span class="s1">interupt_next_only </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s1">_event </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">_async_event </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">_get_min_timeout_func </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">interupt_next_only</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBaseInterruptBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_event </span><span class="s2">= </span><span class="s1">ThreadingEvent</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">interupt_next_only </span><span class="s2">= </span><span class="s1">interupt_next_only</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_min_timeout_func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_min_timeout</span>

    <span class="s4">def </span><span class="s1">init_async_lib</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lib</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBaseInterruptBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">init_async_lib</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">lib </span><span class="s2">== </span><span class="s3">'trio'</span><span class="s2">:</span>
            <span class="s4">import </span><span class="s1">trio</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
            <span class="s5"># we don't know if this is called after things have already been</span>
            <span class="s5"># scheduled, so don't delay for a full frame before processing</span>
            <span class="s5"># events</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
        <span class="s4">elif </span><span class="s1">lib </span><span class="s2">== </span><span class="s3">'asyncio'</span><span class="s2">:</span>
            <span class="s4">import </span><span class="s1">asyncio</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">usleep</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">microseconds</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(</span><span class="s1">microseconds </span><span class="s2">/ </span><span class="s6">1000000.</span><span class="s2">)</span>

    <span class="s4">async def </span><span class="s1">async_usleep</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">microseconds</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_wait_for</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(), </span><span class="s1">microseconds </span><span class="s2">/ </span><span class="s6">1000000.</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">on_schedule</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s4">if not </span><span class="s1">fps</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">event</span><span class="s2">.</span><span class="s1">timeout </span><span class="s4">or </span><span class="s2">(</span>
                <span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interupt_next_only </span><span class="s4">and </span><span class="s1">event</span><span class="s2">.</span><span class="s1">timeout </span><span class="s2">&lt;=</span>
                <span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">-  </span><span class="s5"># remaining time</span>
                <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">() - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">) +  </span><span class="s5"># elapsed time</span>
                <span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()):  </span><span class="s5"># resolution fudge factor</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ready</span><span class="s2">(</span>
                <span class="s1">fps</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">event</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">done</span><span class="s2">:</span>
                <span class="s1">event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(</span><span class="s1">sleeptime</span><span class="s2">)</span>

        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s5"># anything scheduled from now on, if scheduled for the upcoming frame</span>
        <span class="s5"># will cause a timeout of the event on the next idle due to on_schedule</span>
        <span class="s5"># `self._last_tick = current` must happen before clear, otherwise the</span>
        <span class="s5"># on_schedule computation is wrong when exec between the clear and</span>
        <span class="s5"># the `self._last_tick = current` bytecode.</span>
        <span class="s4">return </span><span class="s1">current</span>

    <span class="s4">async def </span><span class="s1">async_idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">done</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ready</span><span class="s2">(</span>
                <span class="s1">fps</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">event</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">done</span><span class="s2">:</span>
                <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_wait_for</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(), </span><span class="s1">sleeptime</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s5"># anything scheduled from now on, if scheduled for the upcoming frame</span>
        <span class="s5"># will cause a timeout of the event on the next idle due to on_schedule</span>
        <span class="s5"># `self._last_tick = current` must happen before clear, otherwise the</span>
        <span class="s5"># on_schedule computation is wrong when exec between the clear and</span>
        <span class="s5"># the `self._last_tick = current` bytecode.</span>
        <span class="s4">return </span><span class="s1">current</span>

    <span class="s4">def </span><span class="s1">_check_ready</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fps</span><span class="s2">, </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">undershoot</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">event</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">():</span>
            <span class="s4">return True</span><span class="s2">, </span><span class="s6">0</span>

        <span class="s1">t </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_min_timeout_func</span><span class="s2">()</span>
        <span class="s4">if not </span><span class="s1">t</span><span class="s2">:</span>
            <span class="s4">return True</span><span class="s2">, </span><span class="s6">0</span>

        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interupt_next_only</span><span class="s2">:</span>
            <span class="s1">curr_t </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
            <span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">curr_t </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">), </span><span class="s1">t </span><span class="s2">- </span><span class="s1">curr_t</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">() - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&lt;= </span><span class="s1">min_sleep</span><span class="s2">, </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot</span>


<span class="s4">class </span><span class="s1">ClockBaseInterruptFreeBehavior</span><span class="s2">(</span><span class="s1">ClockBaseInterruptBehavior</span><span class="s2">):</span>
    <span class="s0">'''A base class for the clock that interrupts the sleep interval for 
    free events. 
    '''</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBaseInterruptFreeBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_min_timeout_func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_min_free_timeout</span>

    <span class="s4">def </span><span class="s1">on_schedule</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">event</span><span class="s2">.</span><span class="s1">free</span><span class="s2">:  </span><span class="s5"># only wake up for free events</span>
            <span class="s4">return</span>
        <span class="s5"># free events should use real time not frame time</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">_last_dt </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s4">return </span><span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBaseInterruptFreeBehavior</span><span class="s2">,</span>
                     <span class="s1">self</span><span class="s2">).</span><span class="s1">on_schedule</span><span class="s2">(</span><span class="s1">event</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">ClockBase</span><span class="s2">(</span><span class="s1">ClockBaseBehavior</span><span class="s2">, </span><span class="s1">CyClockBase</span><span class="s2">):</span>
    <span class="s0">'''The ``default`` kivy clock. See module for details. 
    '''</span>

    <span class="s1">_sleep_obj </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">ClockBase</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_sleep_obj </span><span class="s2">= </span><span class="s1">_get_sleep_obj</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">usleep</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">microseconds</span><span class="s2">):</span>
        <span class="s1">_usleep</span><span class="s2">(</span><span class="s1">microseconds</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sleep_obj</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">ClockBaseInterrupt</span><span class="s2">(</span><span class="s1">ClockBaseInterruptBehavior</span><span class="s2">, </span><span class="s1">CyClockBase</span><span class="s2">):</span>
    <span class="s0">'''The ``interrupt`` kivy clock. See module for details. 
    '''</span>

    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">ClockBaseFreeInterruptAll</span><span class="s2">(</span>
        <span class="s1">ClockBaseInterruptFreeBehavior</span><span class="s2">, </span><span class="s1">CyClockBaseFree</span><span class="s2">):</span>
    <span class="s0">'''The ``free_all`` kivy clock. See module for details. 
    '''</span>

    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">ClockBaseFreeInterruptOnly</span><span class="s2">(</span>
        <span class="s1">ClockBaseInterruptFreeBehavior</span><span class="s2">, </span><span class="s1">CyClockBaseFree</span><span class="s2">):</span>
    <span class="s0">'''The ``free_only`` kivy clock. See module for details. 
    '''</span>

    <span class="s4">def </span><span class="s1">idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">min_sleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
            <span class="s1">usleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">usleep</span>
            <span class="s1">undershoot </span><span class="s2">= </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">min_sleep</span>
            <span class="s1">min_t </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_min_free_timeout</span>
            <span class="s1">interupt_next_only </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interupt_next_only</span>

            <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>
            <span class="s4">while </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&gt; </span><span class="s1">min_sleep</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">event</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">():</span>
                    <span class="s1">do_free </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">t </span><span class="s2">= </span><span class="s1">min_t</span><span class="s2">()</span>
                    <span class="s4">if not </span><span class="s1">t</span><span class="s2">:</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s4">True</span>
                    <span class="s4">elif </span><span class="s1">interupt_next_only</span><span class="s2">:</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s4">False</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">sleeptime</span><span class="s2">, </span><span class="s1">t </span><span class="s2">- </span><span class="s1">current</span><span class="s2">)</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&lt;= </span><span class="s1">min_sleep</span>

                <span class="s4">if </span><span class="s1">do_free</span><span class="s2">:</span>
                    <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_process_free_events</span><span class="s2">(</span><span class="s1">current</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(</span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot</span><span class="s2">)</span>
                <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
                <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()  </span><span class="s5"># this needs to stay after _last_tick</span>
        <span class="s4">return </span><span class="s1">current</span>

    <span class="s4">async def </span><span class="s1">async_idle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_fps</span>
        <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
        <span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_event</span>
        <span class="s4">if </span><span class="s1">fps </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">min_sleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_resolution</span><span class="s2">()</span>
            <span class="s1">usleep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">usleep</span>
            <span class="s1">undershoot </span><span class="s2">= </span><span class="s6">4 </span><span class="s2">/ </span><span class="s6">5. </span><span class="s2">* </span><span class="s1">min_sleep</span>
            <span class="s1">min_t </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_min_free_timeout</span>
            <span class="s1">interupt_next_only </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interupt_next_only</span>

            <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>
            <span class="s1">slept </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s4">while </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&gt; </span><span class="s1">min_sleep</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">event</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">():</span>
                    <span class="s1">do_free </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">t </span><span class="s2">= </span><span class="s1">min_t</span><span class="s2">()</span>
                    <span class="s4">if not </span><span class="s1">t</span><span class="s2">:</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s4">True</span>
                    <span class="s4">elif </span><span class="s1">interupt_next_only</span><span class="s2">:</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s4">False</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">sleeptime </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">sleeptime</span><span class="s2">, </span><span class="s1">t </span><span class="s2">- </span><span class="s1">current</span><span class="s2">)</span>
                        <span class="s1">do_free </span><span class="s2">= </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot </span><span class="s2">&lt;= </span><span class="s1">min_sleep</span>

                <span class="s4">if </span><span class="s1">do_free</span><span class="s2">:</span>
                    <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_process_free_events</span><span class="s2">(</span><span class="s1">current</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">slept </span><span class="s2">= </span><span class="s4">True</span>
                    <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_wait_for</span><span class="s2">(</span>
                        <span class="s1">event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">(), </span><span class="s1">sleeptime </span><span class="s2">- </span><span class="s1">undershoot</span><span class="s2">)</span>
                <span class="s1">current </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">time</span><span class="s2">()</span>
                <span class="s1">sleeptime </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">fps </span><span class="s2">- (</span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span><span class="s2">)</span>

            <span class="s4">if not </span><span class="s1">slept</span><span class="s2">:</span>
                <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_async_lib</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dt </span><span class="s2">= </span><span class="s1">current </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_tick </span><span class="s2">= </span><span class="s1">current</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()  </span><span class="s5"># this needs to stay after _last_tick</span>
        <span class="s4">return </span><span class="s1">current</span>


<span class="s4">def </span><span class="s1">mainthread</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s0">'''Decorator that will schedule the call of the function for the next 
    available frame in the mainthread. It can be useful when you use 
    :class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread 
    programming: you cannot do any OpenGL-related work in a thread. 
 
    Please note that this method will return directly and no result can be 
    returned:: 
 
        @mainthread 
        def callback(self, *args): 
            print('The request succeeded!', 
                  'This callback is called in the main thread.') 
 
 
        self.req = UrlRequest(url='http://...', on_success=callback) 
 
    .. versionadded:: 1.8.0 
    '''</span>
    <span class="s2">@</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
    <span class="s4">def </span><span class="s1">delayed_func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">def </span><span class="s1">callback_func</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">):</span>
            <span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">Clock</span><span class="s2">.</span><span class="s1">schedule_once</span><span class="s2">(</span><span class="s1">callback_func</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">delayed_func</span>


<span class="s4">def </span><span class="s1">triggered</span><span class="s2">(</span><span class="s1">timeout</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s0">'''Decorator that will trigger the call of the function at the specified 
    timeout, through the method :meth:`CyClockBase.create_trigger`. Subsequent 
    calls to the decorated function (while the timeout is active) are ignored. 
 
    It can be helpful when an expensive function (i.e. call to a server) can be 
    triggered by different methods. Setting a proper timeout will delay the 
    calling and only one of them will be triggered. 
 
        @triggered(timeout, interval=False) 
        def callback(id): 
            print('The callback has been called with id=%d' % id) 
 
        &gt;&gt; callback(id=1) 
        &gt;&gt; callback(id=2) 
        The callback has been called with id=2 
 
    The decorated callback can also be unscheduled using: 
 
        &gt;&gt; callback.cancel() 
 
    .. versionadded:: 1.10.1 
    '''</span>

    <span class="s4">def </span><span class="s1">wrapper_triggered</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>

        <span class="s1">_args </span><span class="s2">= []</span>
        <span class="s1">_kwargs </span><span class="s2">= {}</span>

        <span class="s4">def </span><span class="s1">cb_function</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">):</span>
            <span class="s1">func</span><span class="s2">(*</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">_args</span><span class="s2">), **</span><span class="s1">_kwargs</span><span class="s2">)</span>

        <span class="s1">cb_trigger </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">create_trigger</span><span class="s2">(</span>
            <span class="s1">cb_function</span><span class="s2">,</span>
            <span class="s1">timeout</span><span class="s2">=</span><span class="s1">timeout</span><span class="s2">,</span>
            <span class="s1">interval</span><span class="s2">=</span><span class="s1">interval</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">trigger_function</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">_args</span><span class="s2">[:] = []</span>
            <span class="s1">_args</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">_kwargs</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
            <span class="s1">_kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">cb_trigger</span><span class="s2">()</span>

        <span class="s4">def </span><span class="s1">trigger_cancel</span><span class="s2">():</span>
            <span class="s1">cb_trigger</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

        <span class="s1">setattr</span><span class="s2">(</span><span class="s1">trigger_function</span><span class="s2">, </span><span class="s3">'cancel'</span><span class="s2">, </span><span class="s1">trigger_cancel</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">trigger_function</span>

    <span class="s4">return </span><span class="s1">wrapper_triggered</span>


<span class="s4">if </span><span class="s3">'KIVY_DOC_INCLUDE' </span><span class="s4">in </span><span class="s1">environ</span><span class="s2">:</span>
    <span class="s5">#: Instance of :class:`ClockBaseBehavior`.</span>
    <span class="s1">Clock</span><span class="s2">: </span><span class="s1">ClockBase </span><span class="s2">= </span><span class="s4">None</span>
<span class="s4">else</span><span class="s2">:</span>
    <span class="s1">_classes </span><span class="s2">= {</span><span class="s3">'default'</span><span class="s2">: </span><span class="s1">ClockBase</span><span class="s2">, </span><span class="s3">'interrupt'</span><span class="s2">: </span><span class="s1">ClockBaseInterrupt</span><span class="s2">,</span>
                <span class="s3">'free_all'</span><span class="s2">: </span><span class="s1">ClockBaseFreeInterruptAll</span><span class="s2">,</span>
                <span class="s3">'free_only'</span><span class="s2">: </span><span class="s1">ClockBaseFreeInterruptOnly</span><span class="s2">}</span>
    <span class="s1">_clk </span><span class="s2">= </span><span class="s1">environ</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'KIVY_CLOCK'</span><span class="s2">, </span><span class="s1">Config</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'kivy'</span><span class="s2">, </span><span class="s3">'kivy_clock'</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">_clk </span><span class="s4">not in </span><span class="s1">_classes</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">Exception</span><span class="s2">(</span>
            <span class="s3">'{} is not a valid kivy clock. Valid clocks are {}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                <span class="s1">_clk</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">_classes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())))</span>

    <span class="s1">Clock</span><span class="s2">: </span><span class="s1">ClockBase </span><span class="s2">= </span><span class="s1">register_context</span><span class="s2">(</span>
        <span class="s3">'Clock'</span><span class="s2">, </span><span class="s1">_classes</span><span class="s2">[</span><span class="s1">_clk</span><span class="s2">],</span>
        <span class="s1">async_lib</span><span class="s2">=</span><span class="s1">environ</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'KIVY_EVENTLOOP'</span><span class="s2">, </span><span class="s3">'asyncio'</span><span class="s2">))</span>
    <span class="s3">'''The kivy Clock instance. See module documentation for details. 
    '''</span>
</pre>
</body>
</html>