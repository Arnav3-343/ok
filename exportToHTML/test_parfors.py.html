<html>
<head>
<title>test_parfors.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_parfors.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Copyright (c) 2017 Intel Corporation</span>
<span class="s0"># SPDX-License-Identifier: BSD-2-Clause</span>
<span class="s0">#</span>


<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">dis</span>
<span class="s2">import </span><span class="s1">numbers</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">types </span><span class="s2">as </span><span class="s1">pytypes</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">random </span><span class="s2">import </span><span class="s1">randn</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span><span class="s3">, </span><span class="s1">namedtuple</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">cycle</span><span class="s3">, </span><span class="s1">chain</span>
<span class="s2">import </span><span class="s1">subprocess </span><span class="s2">as </span><span class="s1">subp</span>

<span class="s2">import </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span>
<span class="s2">from </span><span class="s1">numba </span><span class="s2">import </span><span class="s3">(</span><span class="s1">njit</span><span class="s3">, </span><span class="s1">prange</span><span class="s3">, </span><span class="s1">parallel_chunksize</span><span class="s3">,</span>
                   <span class="s1">get_parallel_chunksize</span><span class="s3">, </span><span class="s1">set_parallel_chunksize</span><span class="s3">,</span>
                   <span class="s1">set_num_threads</span><span class="s3">, </span><span class="s1">get_num_threads</span><span class="s3">, </span><span class="s1">typeof</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s3">(</span><span class="s1">types</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">, </span><span class="s1">rewrites</span><span class="s3">,</span>
                        <span class="s1">typed_passes</span><span class="s3">, </span><span class="s1">inline_closurecall</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">compiler</span><span class="s3">, </span><span class="s1">cpu</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typed </span><span class="s2">import </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">List</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s3">(</span><span class="s1">overload_method</span><span class="s3">, </span><span class="s1">register_model</span><span class="s3">,</span>
                             <span class="s1">typeof_impl</span><span class="s3">, </span><span class="s1">unbox</span><span class="s3">, </span><span class="s1">NativeValue</span><span class="s3">, </span><span class="s1">models</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">registry </span><span class="s2">import </span><span class="s1">cpu_target</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">annotations </span><span class="s2">import </span><span class="s1">type_annotations</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">ir_utils </span><span class="s2">import </span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">, </span><span class="s1">build_definitions</span><span class="s3">,</span>
                                 <span class="s1">get_definition</span><span class="s3">, </span><span class="s1">is_getitem</span><span class="s3">, </span><span class="s1">is_setitem</span><span class="s3">,</span>
                                 <span class="s1">index_var_of_get_setitem</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unsafe</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s2">import </span><span class="s1">empty_inferred </span><span class="s2">as </span><span class="s1">unsafe_empty</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">compiler </span><span class="s2">import </span><span class="s3">(</span><span class="s1">CompilerBase</span><span class="s3">, </span><span class="s1">DefaultPassBuilder</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">compiler_machinery </span><span class="s2">import </span><span class="s1">register_pass</span><span class="s3">, </span><span class="s1">AnalysisPass</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typed_passes </span><span class="s2">import </span><span class="s1">IRLegalization</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">tests</span><span class="s3">.</span><span class="s1">support </span><span class="s2">import </span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">, </span><span class="s1">captured_stdout</span><span class="s3">, </span><span class="s1">MemoryLeakMixin</span><span class="s3">,</span>
                                 <span class="s1">override_env_config</span><span class="s3">, </span><span class="s1">linux_only</span><span class="s3">, </span><span class="s1">tag</span><span class="s3">,</span>
                                 <span class="s1">skip_parfors_unsupported</span><span class="s3">, </span><span class="s1">_32bit</span><span class="s3">, </span><span class="s1">needs_blas</span><span class="s3">,</span>
                                 <span class="s1">needs_lapack</span><span class="s3">, </span><span class="s1">disabled_test</span><span class="s3">, </span><span class="s1">skip_unless_scipy</span><span class="s3">,</span>
                                 <span class="s1">needs_subprocess</span><span class="s3">,</span>
                                 <span class="s1">skip_ppc64le_invalid_ctr_loop</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">register_jitable</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">bytecode </span><span class="s2">import </span><span class="s1">_fix_LOAD_GLOBAL_arg</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">utils</span>

<span class="s2">import </span><span class="s1">cmath</span>
<span class="s2">import </span><span class="s1">unittest</span>

<span class="s0"># NOTE: Each parfors test class is run in separate subprocess, this is to reduce</span>
<span class="s0"># memory pressure in CI settings. The environment variable &quot;SUBPROC_TEST&quot; is</span>
<span class="s0"># used to determine whether a test is skipped or not, such that if you want to</span>
<span class="s0"># run any parfors test directly this environment variable can be set. The</span>
<span class="s0"># subprocesses running the test classes set this environment variable as the new</span>
<span class="s0"># process starts which enables the tests within the process. The decorator</span>
<span class="s0"># @needs_subprocess is used to ensure the appropriate test skips are made.</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsRunner</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>

    <span class="s1">_numba_parallel_test_ </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># Each test class can run for 30 minutes before time out. Extend this to an</span>
    <span class="s0"># hour on aarch64 (some public CI systems were timing out).</span>
    <span class="s1">_TIMEOUT </span><span class="s3">= </span><span class="s4">1800 </span><span class="s2">if </span><span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() != </span><span class="s5">'aarch64' </span><span class="s2">else </span><span class="s4">3600</span>

    <span class="s5">&quot;&quot;&quot;This is the test runner for all the parfors tests, it runs them in 
    subprocesses as described above. The convention for the test method naming 
    is: `test_&lt;TestClass&gt;` where &lt;TestClass&gt; is the name of the test class in 
    this module. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">runner</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">themod </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__module__</span>
        <span class="s1">test_clazz_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">id</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)[-</span><span class="s4">1</span><span class="s3">].</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">)[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s0"># don't specify a given test, it's an entire class that needs running</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">subprocess_test_runner</span><span class="s3">(</span><span class="s1">test_module</span><span class="s3">=</span><span class="s1">themod</span><span class="s3">,</span>
                                    <span class="s1">test_class</span><span class="s3">=</span><span class="s1">test_clazz_name</span><span class="s3">,</span>
                                    <span class="s1">timeout</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_TIMEOUT</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_TestParforBasic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforNumericalMisc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforNumPy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParfors</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsBitMask</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsDiagnostics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsLeaks</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsMisc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsOptions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsSlice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestParforsVectorizer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestPrangeBasic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">test_TestPrangeSpecific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">()</span>


<span class="s1">x86_only </span><span class="s3">= </span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">machine</span><span class="s3">() </span><span class="s2">not in </span><span class="s3">(</span><span class="s5">'i386'</span><span class="s3">, </span><span class="s5">'x86_64'</span><span class="s3">), </span><span class="s5">'x86 only test'</span><span class="s3">)</span>

<span class="s1">_GLOBAL_INT_FOR_TESTING1 </span><span class="s3">= </span><span class="s4">17</span>
<span class="s1">_GLOBAL_INT_FOR_TESTING2 </span><span class="s3">= </span><span class="s4">5</span>

<span class="s1">TestNamedTuple </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s5">'TestNamedTuple'</span><span class="s3">, (</span><span class="s5">'part0'</span><span class="s3">, </span><span class="s5">'part1'</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">null_comparer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Used with check_arq_equality to indicate that we do not care 
    whether the value of the parameter at the end of the function 
    has a particular value. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">needs_subprocess</span>
<span class="s2">class </span><span class="s1">TestParforsBase</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for testing parfors. 
    Provides functions for compilation and three way comparison between 
    python functions, njit'd functions and parfor njit'd functions. 
    &quot;&quot;&quot;</span>

    <span class="s1">_numba_parallel_test_ </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_compile_this</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, **</span><span class="s1">flags</span><span class="s3">):</span>
        <span class="s0"># This method originally used `compile_isolated` which returns a</span>
        <span class="s0"># &quot;CompileResult&quot;, hence this does the same.</span>
        <span class="s2">return </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">, **</span><span class="s1">flags</span><span class="s3">)(</span><span class="s1">func</span><span class="s3">).</span><span class="s1">overloads</span><span class="s3">[</span><span class="s1">sig</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_this</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_this</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compile_njit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compile_this</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compile_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>

        <span class="s0"># compile the prange injected function</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s0"># compile a standard njit of the original function</span>
        <span class="s1">cfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_njit</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span>

    <span class="s2">def </span><span class="s1">check_parfors_vs_others</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Checks python, njit and parfor impls produce the same result. 
 
        Arguments: 
            pyfunc - the python function to test 
            cfunc - CompilerResult from njit of pyfunc 
            cpfunc - CompilerResult from njit(parallel=True) of pyfunc 
            args - arguments for the function being tested 
        Keyword Arguments: 
            scheduler_type - 'signed', 'unsigned' or None, default is None. 
                           Supply in cases where the presence of a specific 
                           scheduler is to be asserted. 
            fastmath_pcres - a fastmath parallel compile result, if supplied 
                             will be run to make sure the result is correct 
            check_arg_equality - some functions need to check that a 
                                 parameter is modified rather than a certain 
                                 value returned.  If this keyword argument 
                                 is supplied, it should be a list of 
                                 comparison functions such that the i'th 
                                 function in the list is used to compare the 
                                 i'th parameter of the njit and parallel=True 
                                 functions against the i'th parameter of the 
                                 standard Python function, asserting if they 
                                 differ.  The length of this list must be equal 
                                 to the number of parameters to the function. 
                                 The null comparator is available for use 
                                 when you do not desire to test if some 
                                 particular parameter is changed. 
            Remaining kwargs are passed to np.testing.assert_almost_equal 
        &quot;&quot;&quot;</span>
        <span class="s1">scheduler_type </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'scheduler_type'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">check_fastmath </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'check_fastmath'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">fastmath_pcres </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'fastmath_pcres'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">check_scheduling </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'check_scheduling'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">check_args_for_equality </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'check_arg_equality'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">copy_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">args</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">tuple</span><span class="s3">()</span>
            <span class="s1">new_args </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s5">'k'</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">())</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">x </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:])</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">List</span><span class="s3">):</span>
                    <span class="s1">new_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'Unsupported argument type encountered'</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">new_args</span><span class="s3">)</span>

        <span class="s0"># python result</span>
        <span class="s1">py_args </span><span class="s3">= </span><span class="s1">copy_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">py_expected </span><span class="s3">= </span><span class="s1">pyfunc</span><span class="s3">(*</span><span class="s1">py_args</span><span class="s3">)</span>

        <span class="s0"># njit result</span>
        <span class="s1">njit_args </span><span class="s3">= </span><span class="s1">copy_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">njit_output </span><span class="s3">= </span><span class="s1">cfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(*</span><span class="s1">njit_args</span><span class="s3">)</span>

        <span class="s0"># parfor result</span>
        <span class="s1">parfor_args </span><span class="s3">= </span><span class="s1">copy_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">parfor_output </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(*</span><span class="s1">parfor_args</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">check_args_for_equality </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">njit_output</span><span class="s3">, </span><span class="s1">py_expected</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">parfor_output</span><span class="s3">, </span><span class="s1">py_expected</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">njit_output</span><span class="s3">), </span><span class="s1">type</span><span class="s3">(</span><span class="s1">parfor_output</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">py_args</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">check_args_for_equality</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">pyarg</span><span class="s3">, </span><span class="s1">njitarg</span><span class="s3">, </span><span class="s1">parforarg</span><span class="s3">, </span><span class="s1">argcomp </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span>
                <span class="s1">py_args</span><span class="s3">, </span><span class="s1">njit_args</span><span class="s3">, </span><span class="s1">parfor_args</span><span class="s3">, </span><span class="s1">check_args_for_equality</span><span class="s3">):</span>
                <span class="s1">argcomp</span><span class="s3">(</span><span class="s1">njitarg</span><span class="s3">, </span><span class="s1">pyarg</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
                <span class="s1">argcomp</span><span class="s3">(</span><span class="s1">parforarg</span><span class="s3">, </span><span class="s1">pyarg</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">check_scheduling</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check_scheduling</span><span class="s3">(</span><span class="s1">cpfunc</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">)</span>

        <span class="s0"># if requested check fastmath variant</span>
        <span class="s2">if </span><span class="s1">fastmath_pcres </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">parfor_fastmath_output </span><span class="s3">= </span><span class="s1">fastmath_pcres</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(*</span><span class="s1">copy_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">))</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">parfor_fastmath_output</span><span class="s3">, </span><span class="s1">py_expected</span><span class="s3">,</span>
                                           <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Checks that pyfunc compiles for *args under parallel=True and njit 
        and asserts that all version execute and produce the same result&quot;&quot;&quot;</span>
        <span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_all</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_parfors_vs_others</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">arg_gen</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Run self.check(impl, ...) on array data generated from arg_gen. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">arg_gen</span><span class="s3">():</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subTest</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">typeof</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">arg_gen</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Run self.countParfors(impl, ...) on array types generated from 
        arg_gen. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">arg_gen</span><span class="s3">():</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subTest</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">typeof</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))):</span>
                <span class="s1">argtys </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">typeof</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))</span>
                <span class="s0"># At least one parfors</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertGreaterEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">argtys</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">check_scheduling</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">):</span>
        <span class="s0"># make sure parfor set up scheduling</span>
        <span class="s1">scheduler_str </span><span class="s3">= </span><span class="s5">'@do_scheduling'</span>
        <span class="s2">if </span><span class="s1">scheduler_type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">scheduler_type </span><span class="s2">in </span><span class="s3">[</span><span class="s5">'signed'</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">]:</span>
                <span class="s1">scheduler_str </span><span class="s3">+= </span><span class="s5">'_' </span><span class="s3">+ </span><span class="s1">scheduler_type</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Unknown scheduler_type specified: %s&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">scheduler_type</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">scheduler_str</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_llvm_str</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">gen_linspace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Make *ct* sample 1D arrays of length *n* using np.linspace(). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">gen</span><span class="s3">():</span>
            <span class="s2">yield </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s1">src </span><span class="s3">= </span><span class="s1">cycle</span><span class="s3">(</span><span class="s1">gen</span><span class="s3">())</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">next</span><span class="s3">(</span><span class="s1">src</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ct</span><span class="s3">)]</span>

    <span class="s2">def </span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Make 1D, 2D, 3D variants of the data in C and F orders 
        &quot;&quot;&quot;</span>
        <span class="s0"># 1D</span>
        <span class="s2">yield </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">=</span><span class="s1">ct</span><span class="s3">)</span>

        <span class="s0"># 2D</span>
        <span class="s1">arr2ds </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
                  <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace</span><span class="s3">(</span><span class="s1">n</span><span class="s3">=</span><span class="s4">2 </span><span class="s3">* </span><span class="s4">3</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">=</span><span class="s1">ct</span><span class="s3">)]</span>
        <span class="s2">yield </span><span class="s1">arr2ds</span>
        <span class="s0"># Fortran order</span>
        <span class="s2">yield </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arr2ds</span><span class="s3">]</span>

        <span class="s0"># 3D</span>
        <span class="s1">arr3ds </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">))</span>
                  <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace</span><span class="s3">(</span><span class="s1">n</span><span class="s3">=</span><span class="s4">2 </span><span class="s3">* </span><span class="s4">3 </span><span class="s3">* </span><span class="s4">4</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">=</span><span class="s1">ct</span><span class="s3">)]</span>
        <span class="s2">yield </span><span class="s1">arr3ds</span>
        <span class="s0"># Fortran order</span>
        <span class="s2">yield </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arr3ds</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_filter_mod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mod</span><span class="s3">, </span><span class="s1">magicstr</span><span class="s3">, </span><span class="s1">checkstr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; helper function to filter out modules by name&quot;&quot;&quot;</span>
        <span class="s1">filt </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">mod </span><span class="s2">if </span><span class="s1">magicstr </span><span class="s2">in </span><span class="s1">x</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">checkstr </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">filt</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">checkstr </span><span class="s2">in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">filt</span>

    <span class="s2">def </span><span class="s1">_get_gufunc_modules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">magicstr</span><span class="s3">, </span><span class="s1">checkstr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; gets the gufunc LLVM Modules&quot;&quot;&quot;</span>
        <span class="s1">_modules </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">_codegen</span><span class="s3">.</span><span class="s1">_engine</span><span class="s3">.</span><span class="s1">_ee</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">]</span>
        <span class="s0"># make sure to only use modules that are actually used by cres and</span>
        <span class="s0"># aren't just in the EE by virtue of shared compilation context.</span>
        <span class="s1">potential_matches </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_filter_mod</span><span class="s3">(</span><span class="s1">_modules</span><span class="s3">, </span><span class="s1">magicstr</span><span class="s3">,</span>
                                             <span class="s1">checkstr</span><span class="s3">=</span><span class="s1">checkstr</span><span class="s3">)</span>

        <span class="s1">lib_asm </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_asm_str</span><span class="s3">()</span>
        <span class="s1">ret </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">potential_matches</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">lib_asm</span><span class="s3">:</span>
                <span class="s1">ret</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_get_gufunc_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; helper for gufunc IR/asm generation&quot;&quot;&quot;</span>
        <span class="s0"># get the gufunc modules</span>
        <span class="s1">magicstr </span><span class="s3">= </span><span class="s5">'__numba_parfor_gufunc'</span>
        <span class="s1">gufunc_mods </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_modules</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">, </span><span class="s1">magicstr</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">gufunc_mods</span><span class="s3">:</span>
            <span class="s1">x</span><span class="s3">[</span><span class="s1">mod</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_get_gufunc_ir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns the IR of the gufuncs used as parfor kernels 
        as a dict mapping the gufunc name to its IR. 
 
        Arguments: 
         cres - a CompileResult from `njit(parallel=True, ...)` 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_info</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_gufunc_asm</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cres</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns the assembly of the gufuncs used as parfor kernels 
        as a dict mapping the gufunc name to its assembly. 
 
        Arguments: 
         cres - a CompileResult from `njit(parallel=True, ...)` 
        &quot;&quot;&quot;</span>
        <span class="s1">tm </span><span class="s3">= </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">_codegen</span><span class="s3">.</span><span class="s1">_tm</span>
        <span class="s2">def </span><span class="s1">emit_asm</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">tm</span><span class="s3">.</span><span class="s1">emit_assembly</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_info</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">, </span><span class="s1">emit_asm</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">assert_fastmath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Asserts that the fastmath flag has some effect in that suitable 
        instructions are now labelled as `fast`. Whether LLVM can actually do 
        anything to optimise better now the derestrictions are supplied is 
        another matter! 
 
        Arguments: 
         pyfunc - a function that contains operations with parallel semantics 
         sig - the type signature of pyfunc 
        &quot;&quot;&quot;</span>

        <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>
        <span class="s1">_ir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_ir</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_get_fast_instructions</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">):</span>
            <span class="s1">splitted </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">()</span>
            <span class="s1">fast_inst </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">splitted</span><span class="s3">:</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s5">r'\bfast\b'</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)  </span><span class="s0"># \b for wholeword</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">fast_inst</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">fast_inst</span>

        <span class="s2">def </span><span class="s1">_assert_fast</span><span class="s3">(</span><span class="s1">instrs</span><span class="s3">):</span>
            <span class="s1">ops </span><span class="s3">= (</span><span class="s5">'fadd'</span><span class="s3">, </span><span class="s5">'fsub'</span><span class="s3">, </span><span class="s5">'fmul'</span><span class="s3">, </span><span class="s5">'fdiv'</span><span class="s3">, </span><span class="s5">'frem'</span><span class="s3">, </span><span class="s5">'fcmp'</span><span class="s3">, </span><span class="s5">'call'</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">instrs</span><span class="s3">:</span>
                <span class="s1">count </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops</span><span class="s3">:</span>
                    <span class="s1">match </span><span class="s3">= </span><span class="s1">op </span><span class="s3">+ </span><span class="s5">' fast'</span>
                    <span class="s2">if </span><span class="s1">match </span><span class="s2">in </span><span class="s1">inst</span><span class="s3">:</span>
                        <span class="s1">count </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">count </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">guir </span><span class="s2">in </span><span class="s1">_ir</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">inst </span><span class="s3">= </span><span class="s1">_get_fast_instructions</span><span class="s3">(</span><span class="s1">guir</span><span class="s3">)</span>
            <span class="s1">_assert_fast</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">blackscholes_impl</span><span class="s3">(</span><span class="s1">sptprice</span><span class="s3">, </span><span class="s1">strike</span><span class="s3">, </span><span class="s1">rate</span><span class="s3">, </span><span class="s1">volatility</span><span class="s3">, </span><span class="s1">timev</span><span class="s3">):</span>
    <span class="s0"># blackscholes example</span>
    <span class="s1">logterm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">sptprice </span><span class="s3">/ </span><span class="s1">strike</span><span class="s3">)</span>
    <span class="s1">powterm </span><span class="s3">= </span><span class="s4">0.5 </span><span class="s3">* </span><span class="s1">volatility </span><span class="s3">* </span><span class="s1">volatility</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s1">volatility </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">timev</span><span class="s3">)</span>
    <span class="s1">d1 </span><span class="s3">= (((</span><span class="s1">rate </span><span class="s3">+ </span><span class="s1">powterm</span><span class="s3">) * </span><span class="s1">timev</span><span class="s3">) + </span><span class="s1">logterm</span><span class="s3">) / </span><span class="s1">den</span>
    <span class="s1">d2 </span><span class="s3">= </span><span class="s1">d1 </span><span class="s3">- </span><span class="s1">den</span>
    <span class="s1">NofXd1 </span><span class="s3">= </span><span class="s4">0.5 </span><span class="s3">+ </span><span class="s4">0.5 </span><span class="s3">* </span><span class="s4">2.0 </span><span class="s3">* </span><span class="s1">d1</span>
    <span class="s1">NofXd2 </span><span class="s3">= </span><span class="s4">0.5 </span><span class="s3">+ </span><span class="s4">0.5 </span><span class="s3">* </span><span class="s4">2.0 </span><span class="s3">* </span><span class="s1">d2</span>
    <span class="s1">futureValue </span><span class="s3">= </span><span class="s1">strike </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(- </span><span class="s1">rate </span><span class="s3">* </span><span class="s1">timev</span><span class="s3">)</span>
    <span class="s1">c1 </span><span class="s3">= </span><span class="s1">futureValue </span><span class="s3">* </span><span class="s1">NofXd2</span>
    <span class="s1">call </span><span class="s3">= </span><span class="s1">sptprice </span><span class="s3">* </span><span class="s1">NofXd1 </span><span class="s3">- </span><span class="s1">c1</span>
    <span class="s1">put </span><span class="s3">= </span><span class="s1">call </span><span class="s3">- </span><span class="s1">futureValue </span><span class="s3">+ </span><span class="s1">sptprice</span>
    <span class="s2">return </span><span class="s1">put</span>


<span class="s2">def </span><span class="s1">lr_impl</span><span class="s3">(</span><span class="s1">Y</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">):</span>
    <span class="s0"># logistic regression example</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">iterations</span><span class="s3">):</span>
        <span class="s1">w </span><span class="s3">-= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(((</span><span class="s4">1.0 </span><span class="s3">/ (</span><span class="s4">1.0 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">Y </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">w</span><span class="s3">))) - </span><span class="s4">1.0</span><span class="s3">) * </span><span class="s1">Y</span><span class="s3">), </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">w</span>

<span class="s2">def </span><span class="s1">example_kmeans_test</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">numCenter</span><span class="s3">, </span><span class="s1">numIter</span><span class="s3">, </span><span class="s1">init_centroids</span><span class="s3">):</span>
    <span class="s1">centroids </span><span class="s3">= </span><span class="s1">init_centroids</span>
    <span class="s1">N</span><span class="s3">, </span><span class="s1">D </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">numIter</span><span class="s3">):</span>
        <span class="s1">dist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">((</span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">,:]-</span><span class="s1">centroids</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,:])**</span><span class="s4">2</span><span class="s3">))</span>
                                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">numCenter</span><span class="s3">)] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)])</span>
        <span class="s1">labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">dist</span><span class="s3">[</span><span class="s1">i</span><span class="s3">,:].</span><span class="s1">argmin</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)])</span>

        <span class="s1">centroids </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">==</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">==</span><span class="s1">i</span><span class="s3">)</span>
                                 <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">numCenter</span><span class="s3">)])</span>

    <span class="s2">return </span><span class="s1">centroids</span>

<span class="s2">def </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">typingctx </span><span class="s3">= </span><span class="s1">cpu_target</span><span class="s3">.</span><span class="s1">typing_context</span>
    <span class="s1">targetctx </span><span class="s3">= </span><span class="s1">cpu_target</span><span class="s3">.</span><span class="s1">target_context</span>
    <span class="s1">test_ir </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">run_frontend</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kws</span><span class="s3">:</span>
        <span class="s1">options </span><span class="s3">= </span><span class="s1">cpu</span><span class="s3">.</span><span class="s1">ParallelOptions</span><span class="s3">(</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">options </span><span class="s3">= </span><span class="s1">cpu</span><span class="s3">.</span><span class="s1">ParallelOptions</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">tp </span><span class="s3">= </span><span class="s1">TestPipeline</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">test_ir</span><span class="s3">)</span>

    <span class="s1">typingctx</span><span class="s3">.</span><span class="s1">refresh</span><span class="s3">()</span>
    <span class="s1">targetctx</span><span class="s3">.</span><span class="s1">refresh</span><span class="s3">()</span>

    <span class="s1">inline_pass </span><span class="s3">= </span><span class="s1">inline_closurecall</span><span class="s3">.</span><span class="s1">InlineClosureCallPass</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">,</span>
                                                            <span class="s1">options</span><span class="s3">,</span>
                                                            <span class="s1">typed</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">inline_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>

    <span class="s1">rewrites</span><span class="s3">.</span><span class="s1">rewrite_registry</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s5">'before-inference'</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">)</span>

    <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">\</span>
    <span class="s1">typed_passes</span><span class="s3">.</span><span class="s1">type_inference_stage</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">,</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">type_annotations</span><span class="s3">.</span><span class="s1">TypeAnnotation</span><span class="s3">(</span>
        <span class="s1">func_ir</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">,</span>
        <span class="s1">typemap</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">,</span>
        <span class="s1">calltypes</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">,</span>
        <span class="s1">lifted</span><span class="s3">=(),</span>
        <span class="s1">lifted_from</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">args</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,</span>
        <span class="s1">return_type</span><span class="s3">=</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
        <span class="s1">html_output</span><span class="s3">=</span><span class="s1">config</span><span class="s3">.</span><span class="s1">HTML</span><span class="s3">)</span>

    <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">ParforDiagnostics</span><span class="s3">()</span>

    <span class="s1">preparfor_pass </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">PreParforPass</span><span class="s3">(</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">,</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">options</span><span class="s3">,</span>
        <span class="s1">swapped</span><span class="s3">=</span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">replaced_fns</span><span class="s3">)</span>
    <span class="s1">preparfor_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>

    <span class="s1">rewrites</span><span class="s3">.</span><span class="s1">rewrite_registry</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s5">'after-inference'</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">)</span>

    <span class="s1">flags </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">Flags</span><span class="s3">()</span>
    <span class="s1">parfor_pass </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">ParforPass</span><span class="s3">(</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">,</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">,</span>
        <span class="s1">options</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">=</span><span class="s1">diagnostics</span><span class="s3">)</span>
    <span class="s1">parfor_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>
    <span class="s1">parfor_pass </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">ParforFusionPass</span><span class="s3">(</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">,</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">,</span>
        <span class="s1">options</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">=</span><span class="s1">diagnostics</span><span class="s3">)</span>
    <span class="s1">parfor_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>
    <span class="s1">parfor_pass </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">ParforPreLoweringPass</span><span class="s3">(</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">,</span>
        <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">,</span>
        <span class="s1">options</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">=</span><span class="s1">diagnostics</span><span class="s3">)</span>
    <span class="s1">parfor_pass</span><span class="s3">.</span><span class="s1">run</span><span class="s3">()</span>
    <span class="s1">test_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp</span>

<span class="s2">def </span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">ret_count</span>


<span class="s2">def </span><span class="s1">countArrays</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_count_arrays_inner</span><span class="s3">(</span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">get_init_block_size</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s1">blocks </span><span class="s3">= </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span>

    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">init_block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret_count</span>

<span class="s2">def </span><span class="s1">_count_arrays_inner</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">):</span>
    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">arr_set </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                <span class="s1">parfor_blocks </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loop_body</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
                <span class="s1">parfor_blocks</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">init_block</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">_count_arrays_inner</span><span class="s3">(</span><span class="s1">parfor_blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">],</span>
                                    <span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">)):</span>
                <span class="s1">arr_set</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_set</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ret_count</span>

<span class="s2">def </span><span class="s1">countArrayAllocs</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">block </span><span class="s2">in </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">_count_array_allocs_inner</span><span class="s3">(</span><span class="s1">test_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret_count</span>

<span class="s2">def </span><span class="s1">_count_array_allocs_inner</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">inst </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
            <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">_count_array_allocs_inner</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">init_block</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">loop_body</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">_count_array_allocs_inner</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'call'</span>
                <span class="s2">and </span><span class="s3">(</span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) == (</span><span class="s5">'empty'</span><span class="s3">, </span><span class="s5">'numpy'</span><span class="s3">)</span>
                <span class="s2">or </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s3">== (</span><span class="s5">'empty_inferred'</span><span class="s3">, </span><span class="s5">'numba.np.unsafe.ndarray'</span><span class="s3">))):</span>
            <span class="s1">ret_count </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">ret_count</span>

<span class="s2">def </span><span class="s1">countNonParforArrayAccesses</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_count_non_parfor_array_accesses_inner</span><span class="s3">(</span><span class="s1">test_ir</span><span class="s3">, </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">,</span>
                                                  <span class="s1">tp</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_count_non_parfor_array_accesses_inner</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">parfor_indices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">ret_count </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">parfor_indices </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">parfor_indices </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s2">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                <span class="s1">parfor_indices</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s1">parfor_blocks </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loop_body</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
                <span class="s1">parfor_blocks</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">init_block</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s1">_count_non_parfor_array_accesses_inner</span><span class="s3">(</span>
                    <span class="s1">f_ir</span><span class="s3">, </span><span class="s1">parfor_blocks</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">parfor_indices</span><span class="s3">)</span>

            <span class="s0"># getitem</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">is_getitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">],</span>
                        <span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">_uses_indices</span><span class="s3">(</span>
                        <span class="s1">f_ir</span><span class="s3">, </span><span class="s1">index_var_of_get_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">), </span><span class="s1">parfor_indices</span><span class="s3">)):</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s0"># setitem</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">is_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">],</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">_uses_indices</span><span class="s3">(</span>
                    <span class="s1">f_ir</span><span class="s3">, </span><span class="s1">index_var_of_get_setitem</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">), </span><span class="s1">parfor_indices</span><span class="s3">)):</span>
                <span class="s1">ret_count </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s0"># find parfor_index aliases</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s2">and</span>
                  <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">) </span><span class="s2">and</span>
                  <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">parfor_indices</span><span class="s3">):</span>
                <span class="s1">parfor_indices</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret_count</span>

<span class="s2">def </span><span class="s1">_uses_indices</span><span class="s3">(</span><span class="s1">f_ir</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">index_set</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">index</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">index_set</span><span class="s3">:</span>
        <span class="s2">return True</span>

    <span class="s1">ind_def </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">get_definition</span><span class="s3">, </span><span class="s1">f_ir</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ind_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">ind_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_tuple'</span><span class="s3">:</span>
        <span class="s1">varnames </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">ind_def</span><span class="s3">.</span><span class="s1">items</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">varnames </span><span class="s3">&amp; </span><span class="s1">index_set</span><span class="s3">) != </span><span class="s4">0</span>

    <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">TestPipeline</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">test_ir</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">StateDict</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx </span><span class="s3">= </span><span class="s1">typingctx</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx </span><span class="s3">= </span><span class="s1">targetctx</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir </span><span class="s3">= </span><span class="s1">test_ir</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">typemap </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">return_type </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">.</span><span class="s1">metadata </span><span class="s3">= {}</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforBasic</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Smoke tests for the parfors transforms. These tests check the most basic 
    functionality&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">TestParforsBase</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s0"># these are used in the mass of simple tests</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12.</span><span class="s3">), (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">3.</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">4.</span><span class="s3">), </span><span class="s1">m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">.</span><span class="s1">T</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">test_simple01</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(())</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_simple02</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">,))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple03</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple04</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple07</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple08</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple09</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple10</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple11</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)) + </span><span class="s4">1.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple12</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">(</span><span class="s4">1.</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple13</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">(</span><span class="s4">1.</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_simple14</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))[</span><span class="s4">0</span><span class="s3">::</span><span class="s4">20</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple15</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">v1 </span><span class="s3">+ </span><span class="s1">v1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple16</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">m1 </span><span class="s3">+ </span><span class="s1">m1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple17</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">m2 </span><span class="s3">+ </span><span class="s1">v1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">needs_lapack</span>
    <span class="s2">def </span><span class="s1">test_simple18</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">m1</span><span class="s3">.</span><span class="s1">T </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">svd</span><span class="s3">(</span><span class="s1">m2</span><span class="s3">)[</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_simple19</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_simple20</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">)</span>
        <span class="s0"># gemm is left to BLAS</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_simple21</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple22</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">v1 </span><span class="s3">+ </span><span class="s1">v1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple23</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">v1</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">v1</span>
            <span class="s2">return </span><span class="s4">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s4">2 </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">**</span><span class="s4">2 </span><span class="s3">&lt; </span><span class="s4">1</span><span class="s3">) / </span><span class="s4">10</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_simple24</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">20</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[:, </span><span class="s1">b</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_simple_operator_15</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;same as corresponding test_simple_&lt;n&gt; case but using operator.add&quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v1</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_simple_operator_16</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_simple_operator_17</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">m2</span><span class="s3">, </span><span class="s1">v1</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, *</span><span class="s1">self</span><span class="s3">.</span><span class="s1">simple_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_inplace_alias</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue7201</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s1">a</span><span class="s3">[:] = </span><span class="s4">3</span>

        <span class="s2">def </span><span class="s1">comparer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">check_arg_equality</span><span class="s3">=[</span><span class="s1">comparer</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforNumericalMisc</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Miscellaneous 'classical' numerical tests &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_pi</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) - </span><span class="s4">1</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) - </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s4">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s4">2 </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">**</span><span class="s4">2 </span><span class="s3">&lt; </span><span class="s4">1</span><span class="s3">) / </span><span class="s1">n</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100000</span><span class="s3">, </span><span class="s1">decimal</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrays</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_blackscholes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># blackscholes takes 5 1D float array args</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], ) * </span><span class="s4">5</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">blackscholes_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_logistic_regression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:,:], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:],</span>
                <span class="s1">numba</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">lr_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrayAllocs</span><span class="s3">(</span><span class="s1">lr_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_kmeans</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s4">1024</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s4">10</span>
        <span class="s1">centers </span><span class="s3">= </span><span class="s4">3</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">))</span>
        <span class="s1">init_centroids </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">centers</span><span class="s3">, </span><span class="s1">D</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">example_kmeans_test</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">centers</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">init_centroids</span><span class="s3">,</span>
                                                                    <span class="s1">decimal</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s0"># TODO: count parfors after k-means fusion is working</span>
        <span class="s0"># requires recursive parfor counting</span>
        <span class="s1">arg_typs </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span>
            <span class="s1">countNonParforArrayAccesses</span><span class="s3">(</span><span class="s1">example_kmeans_test</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforNumPy</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Tests NumPy functionality under parfors&quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_mvdot</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">20</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_fuse_argmin_argmax_max_min</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">]:</span>
            <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
                <span class="s1">C </span><span class="s3">= </span><span class="s1">op</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
                <span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
                <span class="s2">return </span><span class="s1">B </span><span class="s3">+ </span><span class="s1">C</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">256</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrays</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_np_random_func_direct_import</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_arange</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test with stop only</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s0"># start and stop</span>
        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s0"># start, step, stop</span>
        <span class="s2">def </span><span class="s1">test_impl3</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s4">11</span><span class="s3">, </span><span class="s4">128</span><span class="s3">, </span><span class="s4">30.0</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">(</span><span class="s4">4</span><span class="s3">,</span><span class="s4">5</span><span class="s3">), </span><span class="s1">complex</span><span class="s3">(</span><span class="s4">5</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_arange_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test with stop only</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
        <span class="s0"># start and stop</span>
        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
        <span class="s0"># start, step, stop</span>
        <span class="s2">def </span><span class="s1">test_impl3</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s4">11</span><span class="s3">, </span><span class="s4">128</span><span class="s3">, </span><span class="s4">30.0</span><span class="s3">]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_linspace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># without num</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">)</span>
        <span class="s0"># with num</span>
        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s4">11</span><span class="s3">, </span><span class="s4">128</span><span class="s3">, </span><span class="s4">30.0</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">(</span><span class="s4">4</span><span class="s3">,</span><span class="s4">5</span><span class="s3">), </span><span class="s1">complex</span><span class="s3">(</span><span class="s4">5</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s4">30</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_mean</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s4">100</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">N</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), )), </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), )), </span><span class="s4">1</span><span class="s3">)</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_var</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">var</span><span class="s3">()</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s4">100</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">N</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">A </span><span class="s3">+ </span><span class="s4">1j </span><span class="s3">* </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), )), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), )), </span><span class="s4">2</span><span class="s3">)</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_std</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">std</span><span class="s3">()</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s4">100</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">N</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">A </span><span class="s3">+ </span><span class="s4">1j </span><span class="s3">* </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">argty </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">argty</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">argty</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_random_parfor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Test function with only a random call to make sure a random function 
        like ranf is actually translated to a parfor. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_randoms</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">standard_normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">chisquare</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">E </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">F </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">triangular</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">+</span><span class="s1">B</span><span class="s3">+</span><span class="s1">C</span><span class="s3">+</span><span class="s1">D</span><span class="s3">+</span><span class="s1">E</span><span class="s3">+</span><span class="s1">F</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">128</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">n</span><span class="s3">),))</span>
        <span class="s1">parfor_output </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">py_output </span><span class="s3">= </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s0"># check results within 5% since random numbers generated in parallel</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">parfor_output</span><span class="s3">, </span><span class="s1">py_output</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s4">0.05</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_dead_randoms</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">standard_normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">chisquare</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">E </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">F </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">triangular</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s4">3</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">128</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">n</span><span class="s3">),))</span>
        <span class="s1">parfor_output </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">py_output </span><span class="s3">= </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">parfor_output</span><span class="s3">, </span><span class="s1">py_output</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_min</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))  </span><span class="s0"># test multi-dimensional array</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>

        <span class="s0"># checks that 0d array input raises</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;zero-size array to reduction operation &quot;</span>
               <span class="s5">&quot;minimum which has no identity&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">test_impl2</span><span class="s3">):</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">[:],))</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">pcfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))  </span><span class="s0"># test multi-dimensional array</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>

        <span class="s0"># checks that 0d array input raises</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;zero-size array to reduction operation &quot;</span>
               <span class="s5">&quot;maximum which has no identity&quot;</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">test_impl2</span><span class="s3">):</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">[:],))</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">pcfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_argmax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">3.</span><span class="s3">, </span><span class="s4">2.</span><span class="s3">, </span><span class="s4">3.</span><span class="s3">])</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))  </span><span class="s0"># test multi-dimensional array</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s4">2.</span><span class="s3">, </span><span class="s4">3.</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>

        <span class="s0"># checks that 0d array input raises</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">'attempt to get argmax of an empty sequence'</span>
        <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">test_impl2</span><span class="s3">):</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">[:],))</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">pcfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_argmin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl1</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">test_impl2</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">2.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">3.</span><span class="s3">])</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))  </span><span class="s0"># test multi-dimensional array</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">3.</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">D</span><span class="s3">)</span>

        <span class="s0"># checks that 0d array input raises</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">'attempt to get argmin of an empty sequence'</span>
        <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">test_impl2</span><span class="s3">):</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">[:],))</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">pcfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

        <span class="s0"># Test variants</span>
        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl1</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl2</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_ndarray_fill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">7.0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">argty </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">argty</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_ndarray_fill2d</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">7.0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">2</span><span class="s3">,</span><span class="s4">2</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">argty </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">argty</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reshape_with_neg_one</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue3314</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">result_matrix </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">b</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">sub_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">b</span><span class="s3">]</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ </span><span class="s4">1</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">result_data </span><span class="s3">= </span><span class="s1">sub_a </span><span class="s3">/ </span><span class="s1">z</span>
            <span class="s1">result_matrix</span><span class="s3">[:,:,</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">result_data</span>
            <span class="s2">return </span><span class="s1">result_matrix</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">6.0</span><span class="s3">,</span>
                   <span class="s4">7.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">10.0</span><span class="s3">, </span><span class="s4">11.0</span><span class="s3">, </span><span class="s4">12.0</span><span class="s3">])</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s4">3</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reshape_with_large_neg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue3314</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">result_matrix </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">b</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">sub_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">b</span><span class="s3">]</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ </span><span class="s4">1</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1307</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">result_data </span><span class="s3">= </span><span class="s1">sub_a </span><span class="s3">/ </span><span class="s1">z</span>
            <span class="s1">result_matrix</span><span class="s3">[:,:,</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">result_data</span>
            <span class="s2">return </span><span class="s1">result_matrix</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">6.0</span><span class="s3">,</span>
                   <span class="s4">7.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">10.0</span><span class="s3">, </span><span class="s4">11.0</span><span class="s3">, </span><span class="s4">12.0</span><span class="s3">])</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s4">3</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reshape_with_too_many_neg_one</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue3314</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedRewriteError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
                <span class="s1">rm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">b</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
                <span class="s1">sub_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">b</span><span class="s3">]</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">size</span>
                <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ </span><span class="s4">1</span>
                <span class="s1">z </span><span class="s3">= </span><span class="s1">sub_a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">)</span>
                <span class="s1">result_data </span><span class="s3">= </span><span class="s1">sub_a </span><span class="s3">/ </span><span class="s1">z</span>
                <span class="s1">rm</span><span class="s3">[:,:,</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">result_data</span>
                <span class="s2">return </span><span class="s1">rm</span>

            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">6.0</span><span class="s3">,</span>
                       <span class="s4">7.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">10.0</span><span class="s3">, </span><span class="s4">11.0</span><span class="s3">, </span><span class="s4">12.0</span><span class="s3">])</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;The reshape API may only include one negative argument.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_0d_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s4">7</span><span class="s3">), </span><span class="s1">check_scheduling</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_real_imag_attr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># See issue 8012</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">real </span><span class="s3">** </span><span class="s4">2 </span><span class="s3">+ </span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">** </span><span class="s4">2</span><span class="s3">)</span>

        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">5</span><span class="s3">) * (</span><span class="s4">1 </span><span class="s3">+ </span><span class="s4">1j</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">],)), </span><span class="s4">1</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestParforsUnsupported</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Tests for unsupported use of parfors&quot;&quot;&quot;</span>
    <span class="s3">@</span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skipIf</span><span class="s3">(</span><span class="s2">not </span><span class="s1">_32bit</span><span class="s3">, </span><span class="s5">&quot;Only impacts 32 bit hardware&quot;</span><span class="s3">)</span>
    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_unsupported_combination_raises</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        This test is in place until issues with the 'parallel' 
        target on 32 bit hardware are fixed. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedParforsError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">def </span><span class="s1">ddot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">20</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>
            <span class="s1">ddot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;The 'parallel' target is not currently supported on 32 bit &quot;</span>
               <span class="s5">&quot;hardware&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParfors</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Tests cpython, reduction and various parfors features&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_arraymap</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a </span><span class="s3">* </span><span class="s1">x </span><span class="s3">+ </span><span class="s1">y</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">3</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_0d_broadcast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">12</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">X </span><span class="s3">+ </span><span class="s1">Y</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ()), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_2d_parfor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">12</span><span class="s3">))</span>
            <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">12</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">X </span><span class="s3">+ </span><span class="s1">Y</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ()), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_nd_parfor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">case1</span><span class="s3">():</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">12</span><span class="s3">))</span>
            <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">12</span><span class="s3">))</span>
            <span class="s2">yield </span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">)</span>

        <span class="s1">data_gen </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">chain</span><span class="s3">(</span><span class="s1">case1</span><span class="s3">(), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">gen_linspace_variants</span><span class="s3">(</span><span class="s4">2</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">X </span><span class="s3">+ </span><span class="s1">Y</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count_parfors_variants</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">data_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_np_func_direct_import</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">ones  </span><span class="s0"># import here becomes FreeVar</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s4">111</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_size_assertion</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A </span><span class="s3">+ </span><span class="s1">B</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">cfunc </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">test_impl</span><span class="s3">)</span>
            <span class="s1">cfunc</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">9</span><span class="s3">)</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Sizes of A, B do not match&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_cfg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># from issue #2477</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">is_positive</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">2</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">( </span><span class="s1">i</span><span class="s3">*</span><span class="s1">N</span><span class="s3">//</span><span class="s4">2</span><span class="s3">, (</span><span class="s1">i</span><span class="s3">+</span><span class="s4">1</span><span class="s3">)*</span><span class="s1">N</span><span class="s3">//</span><span class="s4">2 </span><span class="s3">):</span>
                    <span class="s1">is_positive</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s4">0</span>
                    <span class="s2">if </span><span class="s1">x</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &gt; </span><span class="s4">0</span><span class="s3">:</span>
                        <span class="s1">is_positive</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s4">1</span>

            <span class="s2">return </span><span class="s1">is_positive</span>

        <span class="s1">N </span><span class="s3">= </span><span class="s4">100</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">is_positive </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">is_positive</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reduce</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">init_val </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s2">return </span><span class="s1">reduce</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s3">,</span><span class="s1">b</span><span class="s3">: </span><span class="s1">min</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s1">A</span><span class="s3">, </span><span class="s1">init_val</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>

        <span class="s0"># test checking the number of arguments for the reduce function</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">g </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x </span><span class="s3">** </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">]), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertTypingError</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

        <span class="s0"># test checking reduction over bitarray masked arrays</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s4">160</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">A</span><span class="s3">&gt;=</span><span class="s4">3</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s0"># TODO: this should fuse</span>
        <span class="s0"># self.assertTrue(countParfors(test_impl, (numba.float64[:],)) == 1)</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:,</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">B</span><span class="s3">&gt;=</span><span class="s4">3</span><span class="s3">,</span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">16</span><span class="s3">,</span><span class="s4">10</span><span class="s3">)))</span>
        <span class="s0"># TODO: this should also fuse</span>
        <span class="s0">#self.assertTrue(countParfors(test_impl, (numba.float64[:,:],)) == 1)</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:,</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">B</span><span class="s3">&gt;=</span><span class="s4">3</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s4">2</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">16</span><span class="s3">,</span><span class="s4">10</span><span class="s3">)))</span>
        <span class="s0"># this doesn't fuse due to mixed indices</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:,:],)), </span><span class="s4">2</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">min_val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amin</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">A </span><span class="s3">- </span><span class="s1">min_val</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s0"># this doesn't fuse due to use of reduction variable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:],)), </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_use_of_reduction_var1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">cmath</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">acc</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s0"># checks that invalid use of reduction variable is detected</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Use of reduction variable acc in an unsupported reduction function.&quot;</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_unsupported_floordiv1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">100</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">//= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s0"># checks that invalid use of ifloordiv reduction operator is detected</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Parallel floordiv reductions are not supported. &quot;</span>
               <span class="s5">&quot;If all divisors are integers then a floordiv &quot;</span>
               <span class="s5">&quot;reduction can in some cases be parallelized as &quot;</span>
               <span class="s5">&quot;a multiply reduction followed by a floordiv of &quot;</span>
               <span class="s5">&quot;the resulting product.&quot;</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_unsupported_xor1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">100</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">^= </span><span class="s1">i </span><span class="s3">+ </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">&quot;Use of reduction variable acc in an unsupported reduction function.&quot;</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">pcfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_array_access1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># signed index of the prange generated by sum() should be replaced</span>
        <span class="s0"># resulting in array A to be eliminated (see issue #2846)</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrays</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_array_access2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># in this test, the prange index has the same name (i) in two loops</span>
        <span class="s0"># thus, i has multiple definitions and is harder to replace</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s1">m </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s1">n</span><span class="s3">:  </span><span class="s0"># access in another block</span>
                    <span class="s1">n </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">return </span><span class="s1">m </span><span class="s3">+ </span><span class="s1">n</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countNonParforArrayAccesses</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_array_access3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s1">m </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">m</span><span class="s3">==</span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">= </span><span class="s1">m</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedRewriteError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;Overwrite of parallel loop index&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_parfor_array_access4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># in this test, one index of a multi-dim access should be replaced</span>
        <span class="s0"># np.dot parallel implementation produces this case</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s4">4</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">d</span><span class="s3">))</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>
        <span class="s0"># make sure the parfor index is replaced in build_tuple of access to A</span>
        <span class="s1">test_ir</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">get_optimized_numba_ir</span><span class="s3">(</span>
            <span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),</span>
                        <span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">)))</span>
        <span class="s0"># this code should have one basic block after optimization</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s4">0 </span><span class="s2">in </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">test_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">parfor_found </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">parfor </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                <span class="s1">parfor_found </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">parfor </span><span class="s3">= </span><span class="s1">stmt</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">parfor_found</span><span class="s3">)</span>
        <span class="s1">build_tuple_found </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s0"># there should be only one build_tuple</span>
        <span class="s2">for </span><span class="s1">bl </span><span class="s2">in </span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">loop_body</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">bl</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
                        <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
                        <span class="s2">and </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s5">'build_tuple'</span><span class="s3">):</span>
                    <span class="s1">build_tuple_found </span><span class="s3">= </span><span class="s2">True</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">index_var </span><span class="s2">in </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">items</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">build_tuple_found</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_dtype_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test array type replacement creates proper type</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s4">4</span><span class="s3">]</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_array_access5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># one dim is slice in multi-dim access</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">y </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">,:].</span><span class="s1">sum</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">y</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countNonParforArrayAccesses</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test </span><span class="s0"># Test itself is problematic, see #3155</span>
    <span class="s2">def </span><span class="s1">test_parfor_hoist_setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Make sure that read of out is not hoisted.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">out</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">needs_blas</span>
    <span class="s2">def </span><span class="s1">test_parfor_generate_fuse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #2857</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">):</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">))</span>
            <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">):</span>
                <span class="s1">B </span><span class="s3">= (-</span><span class="s1">Y </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">w</span><span class="s3">))</span>

            <span class="s2">return </span><span class="s1">B</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s4">3</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">d</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrayAllocs</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)), </span><span class="s4">4</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)), </span><span class="s4">4</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_ufunc_expr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #2885</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bitwise_and</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>

        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
        <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
        <span class="s1">B</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] = </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_find_callname_intrinsic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">unsafe_empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">,))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">+ </span><span class="s4">2.0</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s0"># the unsafe allocation should be found even though it is imported</span>
        <span class="s0"># as a different name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countArrayAllocs</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,)), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reduction_var_reuse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #3139</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">2</span>

            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">16</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_non_identity_initial</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #7344</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">):</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">if </span><span class="s1">cond</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
                    <span class="s1">s </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s5">'bool'</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_if_not_else_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #7344</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">):</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s1">t </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">if </span><span class="s1">cond</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
                    <span class="s1">s </span><span class="s3">+= </span><span class="s4">1</span>
                    <span class="s1">t </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">s </span><span class="s3">+= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s </span><span class="s3">+ </span><span class="s1">t</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s5">'bool'</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_two_d_array_reduction_reuse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">shp </span><span class="s3">= (</span><span class="s4">13</span><span class="s3">, </span><span class="s4">17</span><span class="s3">)</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">shp</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">shp</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">result1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">+= </span><span class="s1">tmp</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">+= </span><span class="s1">tmp</span>

            <span class="s2">return </span><span class="s1">result1</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_one_d_array_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">i</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_two_d_array_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">shp </span><span class="s3">= (</span><span class="s4">13</span><span class="s3">, </span><span class="s4">17</span><span class="s3">)</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">shp</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">shp</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">result1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">+= </span><span class="s1">tmp</span>

            <span class="s2">return </span><span class="s1">result1</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_two_d_array_reduction_with_float_sizes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># result1 is float32 and tmp is float64.</span>
        <span class="s0"># Tests reduction with differing dtypes.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">shp </span><span class="s3">= (</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">)</span>
            <span class="s1">result1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">6.0</span><span class="s3">]).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">+= </span><span class="s1">tmp</span>

            <span class="s2">return </span><span class="s1">result1</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_two_d_array_reduction_prod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">shp </span><span class="s3">= (</span><span class="s4">13</span><span class="s3">, </span><span class="s4">17</span><span class="s3">)</span>
            <span class="s1">result1 </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">result1</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">*= </span><span class="s1">tmp</span>

            <span class="s2">return </span><span class="s1">result1</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_three_d_array_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">shp </span><span class="s3">= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">7</span><span class="s3">)</span>
            <span class="s1">result1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">result1 </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">result1</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">100</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_preparfor_canonicalize_kws</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test canonicalize_array_math typing for calls with kw args</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">() + </span><span class="s4">1</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">211</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_preparfor_datetime64</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test array.dtype transformation for datetime64</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">.</span><span class="s1">dtype</span>

        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'datetime64[ns]'</span><span class="s3">))</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">A</span><span class="s3">),))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">(</span><span class="s1">A</span><span class="s3">), </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_no_hoisting_with_member_function_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">R </span><span class="s3">= {</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">}</span>
                <span class="s1">R</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">tmp </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">R</span><span class="s3">:</span>
                    <span class="s1">tmp </span><span class="s3">+= </span><span class="s1">x</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">tmp</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s4">128</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_array_compare_scalar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; issue3671: X != 0 becomes an arrayexpr with operator.ne. 
            That is turned into a parfor by devectorizing.  Make sure 
            the return type of the devectorized operator.ne 
            on integer types works properly. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">X </span><span class="s3">!= </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_array_analysis_optional_def</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">half</span><span class="s3">):</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">parr </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">size</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">half</span><span class="s3">:</span>
                <span class="s1">parr </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">size</span><span class="s3">//</span><span class="s4">2</span><span class="s3">]</span>

            <span class="s2">return </span><span class="s1">parr</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">20</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_scheduling</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_side_effects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">data</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10 </span><span class="s3">** </span><span class="s4">2</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10 </span><span class="s3">** </span><span class="s4">2</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,</span>
                                    <span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),</span>
                                     <span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">))), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">atup </span><span class="s3">= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">7</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">atup</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s1">atup</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] + </span><span class="s1">b</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">atup </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">7</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">atup</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s1">b</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">atup </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s4">4</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">7</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">atup</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">5</span><span class="s3">] + </span><span class="s1">atup</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] + </span><span class="s1">b</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_namedtuple1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">antup </span><span class="s3">= </span><span class="s1">TestNamedTuple</span><span class="s3">(</span><span class="s1">part0</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">part1</span><span class="s3">=</span><span class="s4">4</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">7</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">antup</span><span class="s3">.</span><span class="s1">part0 </span><span class="s3">+ </span><span class="s1">antup</span><span class="s3">.</span><span class="s1">part1 </span><span class="s3">+ </span><span class="s1">b</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_namedtuple2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">TestNamedTuple2 </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s5">'TestNamedTuple2'</span><span class="s3">, (</span><span class="s5">'part0'</span><span class="s3">, </span><span class="s5">'part1'</span><span class="s3">))</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">antup </span><span class="s3">= </span><span class="s1">TestNamedTuple2</span><span class="s3">(</span><span class="s1">part0</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">part1</span><span class="s3">=</span><span class="s4">4</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">7</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">antup</span><span class="s3">.</span><span class="s1">part0 </span><span class="s3">+ </span><span class="s1">antup</span><span class="s3">.</span><span class="s1">part1 </span><span class="s3">+ </span><span class="s1">b</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_namedtuple3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5872: test that a.y[:] = 5 is not removed as</span>
        <span class="s0"># deadcode.</span>
        <span class="s1">TestNamedTuple3 </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s5">f'TestNamedTuple3'</span><span class="s3">,[</span><span class="s5">'y'</span><span class="s3">])</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[:] = </span><span class="s4">5</span>

        <span class="s2">def </span><span class="s1">comparer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">y</span><span class="s3">, </span><span class="s1">b</span><span class="s3">.</span><span class="s1">y</span><span class="s3">)</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">TestNamedTuple3</span><span class="s3">(</span><span class="s1">y</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">check_arg_equality</span><span class="s3">=[</span><span class="s1">comparer</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_inplace_binop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">+= </span><span class="s1">a</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">) + </span><span class="s4">10</span>
        <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">) + </span><span class="s4">100</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,</span>
                                    <span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">),</span>
                                     <span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">))), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_concat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5383</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">array_shape </span><span class="s3">= </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(((</span><span class="s4">1</span><span class="s3">,) + </span><span class="s1">array_shape </span><span class="s3">+ (</span><span class="s4">1</span><span class="s3">,)), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint64</span><span class="s3">)</span>
            <span class="s1">k_list </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>

            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">g </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">k_list</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">k_list</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_concat_with_reverse_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5383</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">array_shape </span><span class="s3">= </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(((</span><span class="s4">1</span><span class="s3">,) + </span><span class="s1">array_shape </span><span class="s3">+ (</span><span class="s4">1</span><span class="s3">,))[:-</span><span class="s4">1</span><span class="s3">],</span>
                               <span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint64</span><span class="s3">)</span>
            <span class="s1">k_list </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>

            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">g </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">k_list</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">k_list</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_array_tuple_concat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue6399</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">S </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">,) + (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">S</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">sum</span><span class="s3">()</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_high_dimension1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue6749</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">x </span><span class="s3">* </span><span class="s4">5.0</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">15</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_arg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">), </span><span class="s1">sz</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_arg_not_whole_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">), (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_tuple_for_pndindex</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_tuple_arg_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">first</span><span class="s3">):</span>
            <span class="s1">sz </span><span class="s3">= (</span><span class="s1">first</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">), </span><span class="s4">10</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_of_literal_nonliteral</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This test has to be done manually as the self.check uses</span>
        <span class="s0"># compile_isolated and one function cannot &quot;see&quot; the other</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s2">def </span><span class="s1">call</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">3</span><span class="s3">)) </span><span class="s0"># Only want to iterate to the 3rd</span>

        <span class="s1">get_input </span><span class="s3">= </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">call</span><span class="s3">(</span><span class="s1">get_input</span><span class="s3">(), </span><span class="s1">test_impl</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">dec</span><span class="s3">):</span>
            <span class="s1">f1 </span><span class="s3">= </span><span class="s1">dec</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
            <span class="s1">f2 </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">call</span><span class="s3">) </span><span class="s0"># no parallel semantics in the caller</span>
            <span class="s1">got </span><span class="s3">= </span><span class="s1">f2</span><span class="s3">(</span><span class="s1">get_input</span><span class="s3">(), </span><span class="s1">f1</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">got</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s3">(</span><span class="s1">njit</span><span class="s3">, </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)):</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_arg_1d</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">,)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">), </span><span class="s1">sz</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_arg_1d_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">,)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">sz </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">,)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_int_arg_pndindex</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">pndindex</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)), </span><span class="s4">3</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_unknown_call1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">issue7854_proc</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">even</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">((</span><span class="s1">even </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) % </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">u</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">u</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] + </span><span class="s4">1</span>

        <span class="s0"># issue7854</span>
        <span class="s0"># Forbid fusion in unanalyzable call inside prange.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">issue7854_proc</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">issue7854_proc</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">u</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">4</span>
        <span class="s1">u </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">size</span><span class="s3">, </span><span class="s1">size</span><span class="s3">))</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_index_calc1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Should forbid fusion due to cross-iteration dependency as</span>
        <span class="s0"># detected by loop index calcuation (i+1) as array index.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">((</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) % </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                    <span class="s1">u</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">u</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] + </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">% </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">size </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                    <span class="s1">u</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">u</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] + </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">u</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">4</span>
        <span class="s1">u </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">size</span><span class="s3">, </span><span class="s1">size</span><span class="s3">))</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_reverse_order1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Testing if reversed loop index usage as array index</span>
        <span class="s0"># prevents fusion.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                    <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] + </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                    <span class="s1">b</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s4">3</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] + </span><span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">10</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">size</span><span class="s3">, </span><span class="s1">size</span><span class="s3">))</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">size</span><span class="s3">, </span><span class="s1">size</span><span class="s3">))</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_parfor_index_then_not</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Testing if accessing an array first with a parfor index then</span>
        <span class="s0"># without will prevent fusion.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">b </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">5</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">10</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_parfor_index_const_tuple_fusion</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Testing if accessing a tuple with prange index</span>
        <span class="s0"># and later with a constant will not prevent fusion.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">tup</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">tup</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">10</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:],</span>
                   <span class="s1">types</span><span class="s3">.</span><span class="s1">containers</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">size</span><span class="s3">),</span>
                   <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_non_parfor_index_then_opposite</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Testing if accessing an array first without a parfor index then</span>
        <span class="s0"># with will prevent fusion.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">5</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s0"># Need this to stop previous prange from being optimized away.</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s4">10</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">cptypes </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">cptypes</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_optional</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">pred </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">0.0</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">check_arg_equality</span><span class="s3">=[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">,</span>
                                       <span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">: </span><span class="s1">x </span><span class="s3">== </span><span class="s1">y</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(), </span><span class="s4">10.0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_untraced_value_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This is a test for issue #6478.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= (</span><span class="s4">1.2</span><span class="s3">, </span><span class="s4">1.3</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_recursive_untraced_value_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This is a test for issue #6478.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= ((</span><span class="s4">1.2</span><span class="s3">, </span><span class="s4">1.3</span><span class="s3">),)</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_untraced_value_parfor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This is a test for issue #6478.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= (</span><span class="s4">1.2</span><span class="s3">, </span><span class="s4">1.3</span><span class="s3">)</span>
            <span class="s1">n1 </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">arr2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">):</span>
                <span class="s1">arr2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">n2 </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr2</span><span class="s3">)</span>
            <span class="s1">arr3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n2</span><span class="s3">):</span>
                <span class="s1">arr3</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">arr2</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] - </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">total </span><span class="s3">= </span><span class="s4">0.0</span>
            <span class="s1">n3 </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr3</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n3</span><span class="s3">):</span>
                <span class="s1">total </span><span class="s3">+= </span><span class="s1">arr3</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">total </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">arg </span><span class="s3">= (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">), )</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_setitem_2d_one_replaced</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue7843</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">count </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s0"># Useless &quot;if&quot; necessary to trigger bug.</span>
                <span class="s2">if </span><span class="s1">n</span><span class="s3">:</span>
                    <span class="s1">n</span>
                <span class="s1">x</span><span class="s3">[</span><span class="s1">count</span><span class="s3">, :] = </span><span class="s4">1</span>
                <span class="s1">count </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">3</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_1array_control_flow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue8146</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">flag1</span><span class="s3">, </span><span class="s1">flag2</span><span class="s3">):</span>
            <span class="s1">inv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">flag1</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">inv</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">flag2</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">inv</span><span class="s3">[</span><span class="s1">inv</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">inv</span><span class="s3">[</span><span class="s1">inv </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_2array_1_control_flow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue8146</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">):</span>
            <span class="s1">inv1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">inv2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">l</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">flag</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">inv1</span><span class="s3">[</span><span class="s1">inv1</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">inv1</span><span class="s3">[</span><span class="s1">inv1 </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">inv2</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_2array_2_control_flow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue8146</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">):</span>
            <span class="s1">inv1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">inv2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">l</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">flag</span><span class="s3">:</span>
                <span class="s1">ret1 </span><span class="s3">= </span><span class="s1">inv1</span><span class="s3">[</span><span class="s1">inv1</span><span class="s3">]</span>
                <span class="s1">ret2 </span><span class="s3">= </span><span class="s1">inv2</span><span class="s3">[</span><span class="s1">inv1</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ret1 </span><span class="s3">= </span><span class="s1">inv1</span><span class="s3">[</span><span class="s1">inv1 </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">ret2 </span><span class="s3">= </span><span class="s1">inv2</span><span class="s3">[</span><span class="s1">inv1 </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">ret1 </span><span class="s3">/ </span><span class="s1">ret2</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue8515</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue8515: an array is filled in the first prange and</span>
        <span class="s0"># then accessed with c[i - 1] in the next prange which</span>
        <span class="s0"># should prevent fusion with the previous prange.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i</span><span class="s3">):</span>
                    <span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s4">1</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">r</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">c</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">r</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">15</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, )), </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue9029</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue9029: too many parfors executed in one function</span>
        <span class="s0"># overflowed the stack.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">i1</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">):</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s4">30</span>
            <span class="s1">S </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">N</span><span class="s3">,</span><span class="s1">N</span><span class="s3">))</span>
            <span class="s0"># The stack should overflow if there are 30*30*2 (# of parfors)</span>
            <span class="s0"># iterations.</span>
            <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
                    <span class="s1">values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">S</span><span class="s3">)</span>
                    <span class="s1">v </span><span class="s3">= </span><span class="s1">values</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

                    <span class="s1">p2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">S</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">i1</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">):</span>
                        <span class="s1">p2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
                    <span class="s1">j </span><span class="s3">= </span><span class="s1">p2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

                    <span class="s1">a</span><span class="s3">[</span><span class="s1">y</span><span class="s3">,</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">v </span><span class="s3">+ </span><span class="s1">j</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s0"># We pass in 0 and 3 so that the function can't analyze the loop</span>
        <span class="s0"># bounds on the prange to generate a signed loop whereas the</span>
        <span class="s0"># np.ones will be an unsigned loop.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_fusion_no_side_effects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
            <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">X </span><span class="s3">+ </span><span class="s1">Y </span><span class="s3">+ </span><span class="s1">c</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">3.7</span><span class="s3">, </span><span class="s4">4.3</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)), </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue9256_lower_sroa_conflict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">= </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">def_in_loop</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_issue9256_lower_sroa_conflict_variant1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">x</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">_i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">c</span><span class="s3">: </span><span class="s0"># forces 3 SSA versions</span>
                    <span class="s1">d </span><span class="s3">= </span><span class="s1">x </span><span class="s3">+ </span><span class="s4">4</span>
            <span class="s2">return </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d </span><span class="s3">&gt; </span><span class="s4">0</span>

        <span class="s1">expected </span><span class="s3">= </span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)(</span><span class="s1">def_in_loop</span><span class="s3">)(</span><span class="s4">4</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">def_in_loop</span><span class="s3">)(</span><span class="s4">4</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_issue9256_lower_sroa_conflict_variant2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">x</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">_i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">c</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">_j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">): </span><span class="s0"># forces 4 SSA versions</span>
                        <span class="s1">d </span><span class="s3">= </span><span class="s1">x </span><span class="s3">+ </span><span class="s4">4</span>
            <span class="s2">return </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d </span><span class="s3">&gt; </span><span class="s4">0</span>

        <span class="s1">expected </span><span class="s3">= </span><span class="s1">def_in_loop</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)(</span><span class="s1">def_in_loop</span><span class="s3">)(</span><span class="s4">4</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">def_in_loop</span><span class="s3">)(</span><span class="s4">4</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">needs_lapack  </span><span class="s0"># use of np.linalg.solve</span>
    <span class="s3">@</span><span class="s1">skip_ppc64le_invalid_ctr_loop</span>
    <span class="s2">def </span><span class="s1">test_issue9490_non_det_ssa_problem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test modified to include https://github.com/numba/numba/issues/9581</span>
        <span class="s0"># which is an issue with hoisting</span>
        <span class="s1">cmd </span><span class="s3">= [</span>
            <span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">,</span>
            <span class="s5">&quot;-m&quot;</span><span class="s3">,</span>
            <span class="s5">&quot;numba.tests.parfor_iss9490_usecase&quot;</span><span class="s3">,</span>
        <span class="s3">]</span>
        <span class="s1">envs </span><span class="s3">= {</span>
            <span class="s3">**</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">,</span>
            <span class="s0"># Reproducer consistently fail with the following hashseed.</span>
            <span class="s5">&quot;PYTHONHASHSEED&quot;</span><span class="s3">: </span><span class="s5">&quot;1&quot;</span><span class="s3">,</span>
            <span class="s0"># See https://github.com/numba/numba/issues/9501</span>
            <span class="s0"># for details of why num-thread pinning is needed.</span>
            <span class="s5">&quot;NUMBA_NUM_THREADS&quot;</span><span class="s3">: </span><span class="s5">&quot;1&quot;</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">subp</span><span class="s3">.</span><span class="s1">check_output</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">env</span><span class="s3">=</span><span class="s1">envs</span><span class="s3">,</span>
                              <span class="s1">stderr</span><span class="s3">=</span><span class="s1">subp</span><span class="s3">.</span><span class="s1">STDOUT</span><span class="s3">,</span>
                              <span class="s1">encoding</span><span class="s3">=</span><span class="s5">'utf-8'</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">subp</span><span class="s3">.</span><span class="s1">CalledProcessError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s5">f&quot;subprocess failed with output:</span><span class="s2">\n{</span><span class="s1">e</span><span class="s3">.</span><span class="s1">output</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsLeaks</span><span class="s3">(</span><span class="s1">MemoryLeakMixin</span><span class="s3">, </span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_all</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_parfors_vs_others</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue4299</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_multiple_reduction_vars</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s4">0.</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">1.</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">a </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">b </span><span class="s3">+= </span><span class="s4">1. </span><span class="s3">/ (</span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a </span><span class="s3">* </span><span class="s1">b</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsSlice</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">n</span><span class="s3">,) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s4">2</span><span class="s3">] + </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">n</span><span class="s3">,) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s4">2</span><span class="s3">] + </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s0"># runtime assertion should succeed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s4">9</span><span class="s3">)</span>
        <span class="s0"># next we expect failure</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">test_impl</span><span class="s3">)(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">),</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;do not match&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">m</span><span class="s3">-</span><span class="s4">1</span><span class="s3">,</span><span class="s4">0</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">] + </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">4</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[:,</span><span class="s4">0</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">] + </span><span class="s1">a</span><span class="s3">[:,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">4</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:</span><span class="s1">m</span><span class="s3">-</span><span class="s4">1</span><span class="s3">,:] + </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">,:]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">4</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,:] + </span><span class="s1">b</span><span class="s3">[:,</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">4</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice7</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,:] + </span><span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,:]</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s0"># runtime check should succeed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>
        <span class="s0"># next we expect failure</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">test_impl</span><span class="s3">)(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;do not match&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_parfor_slice8</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">9</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_parfor_slice9</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[:,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_parfor_slice10</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">2</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">2</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">m</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">9</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice11</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s1">l</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[:,</span><span class="s4">1</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">l</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[:,</span><span class="s4">2</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">l</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">27</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">,</span><span class="s4">3</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice12</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">,:-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice13</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">c </span><span class="s3">= -</span><span class="s4">1</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,</span><span class="s4">1</span><span class="s3">:</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">,-</span><span class="s1">n</span><span class="s3">:</span><span class="s1">c</span><span class="s3">-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice14</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,:-</span><span class="s4">1</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">,-</span><span class="s4">3</span><span class="s3">:</span><span class="s4">4</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice15</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">m</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">,-(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">):] = </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">,-</span><span class="s4">3</span><span class="s3">:</span><span class="s4">4</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">12</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)))</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_parfor_slice16</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; This test is disabled because if n is larger than the array size 
            then n and n-1 will both be the end of the array and thus the 
            slices will in fact be of different sizes and unable to fuse. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">assert</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">] = </span><span class="s4">10</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">:(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">)] = </span><span class="s4">10</span>
            <span class="s2">return </span><span class="s1">a </span><span class="s3">* </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:], </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice17</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s1">B</span><span class="s3">[-</span><span class="s1">n</span><span class="s3">:] = </span><span class="s1">A</span>
            <span class="s2">return </span><span class="s1">B</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice18</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue 3534</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s4">8</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">7</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">3</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">y</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice19</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issues #3561 and #3554, empty slice binop</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">X</span><span class="s3">[:</span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">X</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice20</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #4075, slice size</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:]</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">s</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">check_scheduling</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice21</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
            <span class="s1">x1 </span><span class="s3">= </span><span class="s1">x1</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">x2 </span><span class="s3">= </span><span class="s1">x2</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">x1 </span><span class="s3">&gt;= </span><span class="s1">x2</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">, :]</span>

        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s4">5</span><span class="s3">)</span>
        <span class="s1">x2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s4">6</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice22</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">,))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">b </span><span class="s3">+= </span><span class="s1">x1</span><span class="s3">[:, </span><span class="s1">x2</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">,</span><span class="s4">7</span><span class="s3">))</span>
        <span class="s1">x2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice23</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue #4630</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">x</span><span class="s3">[:</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice24</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">B</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:]</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)]</span>
            <span class="s2">return </span><span class="s1">B</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">15</span><span class="s3">, </span><span class="s4">15</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">i</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice25</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">B</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)]</span>
            <span class="s2">return </span><span class="s1">B</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">15</span><span class="s3">, </span><span class="s4">15</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">i</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice26</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">n</span><span class="s3">,) = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">[-(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">):] = </span><span class="s1">a</span><span class="s3">[-</span><span class="s4">3</span><span class="s3">:</span><span class="s4">4</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">4</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_slice27</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5601: tests array analysis of the slice with</span>
        <span class="s0"># n_valid_vals of unknown size.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">n_valid_vals </span><span class="s3">= </span><span class="s4">0</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">if </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">n_valid_vals </span><span class="s3">+= </span><span class="s4">1</span>

                <span class="s2">if </span><span class="s1">n_valid_vals</span><span class="s3">:</span>
                    <span class="s1">unused </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[:</span><span class="s1">n_valid_vals</span><span class="s3">]</span>

            <span class="s2">return </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">3</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_parfor_array_access_lower_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">ts </span><span class="s2">in </span><span class="s3">[</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">slice</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">),</span>
                   <span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s4">2</span><span class="s3">)]:</span>

            <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s4">4</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s4">4</span><span class="s3">))</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">y </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">ts</span><span class="s3">].</span><span class="s1">sum</span><span class="s3">()</span>
                <span class="s2">return </span><span class="s1">y</span>

            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s4">4</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s4">4</span><span class="s3">))</span>

            <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                    <span class="s1">y </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">ts</span><span class="s3">].</span><span class="s1">sum</span><span class="s3">()</span>
                <span class="s2">return </span><span class="s1">y</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsOptions</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">test_parfor_options</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([ </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) ])</span>
            <span class="s1">b</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">* </span><span class="s1">c</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">reduce</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">,</span><span class="s1">y</span><span class="s3">:</span><span class="s1">x</span><span class="s3">+</span><span class="s1">y</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">))</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">[:],)</span>
        <span class="s0"># everything should fuse with default option</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s0"># with no fusion</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">6</span><span class="s3">)</span>
        <span class="s0"># with no fusion, comprehension</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">comprehension</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">5</span><span class="s3">)</span>
        <span class="s0">#with no fusion, comprehension, setitem</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">comprehension</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">setitem</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">4</span><span class="s3">)</span>
         <span class="s0"># with no fusion, comprehension, prange</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">comprehension</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">setitem</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">prange</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">3</span><span class="s3">)</span>
         <span class="s0"># with no fusion, comprehension, prange, reduction</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">comprehension</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">setitem</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">prange</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">reduction</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s0"># with no fusion, comprehension, prange, reduction, numpy</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">countParfors</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fusion</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">comprehension</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">setitem</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">prange</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                         <span class="s1">reduction</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsBitMask</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s1">n</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = </span><span class="s4">0</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s4">5</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = </span><span class="s4">0</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s4">5</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s4">5</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">a</span><span class="s3">)[</span><span class="s1">b</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s4">5</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] * </span><span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s4">5</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_bitmask6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">b</span><span class="s3">] = </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s4">5</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">b</span><span class="s3">))</span>

        <span class="s0"># expect failure due to lack of parallelism</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\'</span><span class="s5">@do_scheduling</span><span class="s2">\' </span><span class="s5">not found&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsMisc</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Tests miscellaneous parts of ParallelAccelerator use. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">test_no_warn_if_cache_set</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">pyfunc</span><span class="s3">():</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">100</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">arr</span>

        <span class="s1">cfunc </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">cache</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">pyfunc</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised_warnings</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s5">'always'</span><span class="s3">)</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s1">action</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">,</span>
                                    <span class="s1">module</span><span class="s3">=</span><span class="s5">&quot;typeguard&quot;</span><span class="s3">)</span>
            <span class="s0"># Filter out warnings about TBB interface mismatch</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s1">action</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">,</span>
                                    <span class="s1">message</span><span class="s3">=</span><span class="s5">r&quot;.*TBB_INTERFACE_VERSION.*&quot;</span><span class="s3">,</span>
                                    <span class="s1">category</span><span class="s3">=</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaWarning</span><span class="s3">,</span>
                                    <span class="s1">module</span><span class="s3">=</span><span class="s5">r'numba\.np\.ufunc\.parallel.*'</span><span class="s3">)</span>
            <span class="s1">cfunc</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">raised_warnings</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>

        <span class="s0"># Make sure the dynamic globals flag is set</span>
        <span class="s1">has_dynamic_globals </span><span class="s3">= [</span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">has_dynamic_globals</span>
                               <span class="s2">for </span><span class="s1">cres </span><span class="s2">in </span><span class="s1">cfunc</span><span class="s3">.</span><span class="s1">overloads</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">has_dynamic_globals</span><span class="s3">, [</span><span class="s2">False</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_statement_reordering_respects_aliasing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:</span><span class="s4">8</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">7</span><span class="s3">)</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">'a[3]:'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">[</span><span class="s4">3</span><span class="s3">])</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">'a[3]:'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">[</span><span class="s4">3</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, ())</span>
        <span class="s2">with </span><span class="s1">captured_stdout</span><span class="s3">() </span><span class="s2">as </span><span class="s1">stdout</span><span class="s3">:</span>
            <span class="s1">cres</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">().</span><span class="s1">splitlines</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s5">'a[3]: 2.0'</span><span class="s3">, </span><span class="s1">line</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_ufunc_typing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">])</span>
        <span class="s1">cfunc </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">test_impl</span><span class="s3">)</span>
        <span class="s0"># save global state</span>
        <span class="s1">old_seq_flag </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">), </span><span class="s1">cfunc</span><span class="s3">(</span><span class="s1">A</span><span class="s3">))</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s0"># recover global state</span>
            <span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering </span><span class="s3">= </span><span class="s1">old_seq_flag</span>

    <span class="s2">def </span><span class="s1">test_init_block_dce</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue4690</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">arr </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s3">,</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">5</span><span class="s3">]</span>
            <span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">init_prange</span><span class="s3">()</span>
            <span class="s1">dummy </span><span class="s3">= </span><span class="s1">arr</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s4">5</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">+= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">res </span><span class="s3">+ </span><span class="s1">dummy</span><span class="s3">[</span><span class="s4">2</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_init_block_size</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ()), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_alias_analysis_for_parfor1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">4</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">acc</span><span class="s3">,))</span>
            <span class="s2">return </span><span class="s1">data</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_no_state_change_in_gufunc_lowering_on_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># tests #5098, if there's an exception arising in gufunc lowering the</span>
        <span class="s0"># sequential_parfor_lowering global variable should remain as False on</span>
        <span class="s0"># stack unwind.</span>

        <span class="s1">BROKEN_MSG </span><span class="s3">= </span><span class="s5">'BROKEN_MSG'</span>

        <span class="s3">@</span><span class="s1">register_pass</span><span class="s3">(</span><span class="s1">mutates_CFG</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">analysis_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">class </span><span class="s1">BreakParfors</span><span class="s3">(</span><span class="s1">AnalysisPass</span><span class="s3">):</span>
            <span class="s1">_name </span><span class="s3">= </span><span class="s5">&quot;break_parfors&quot;</span>

            <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s1">AnalysisPass</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">run_pass</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">blk </span><span class="s2">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                    <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">Parfor</span><span class="s3">):</span>
                            <span class="s0"># races should be a set(), that list is iterable</span>
                            <span class="s0"># permits it to get through to the</span>
                            <span class="s0"># _create_gufunc_for_parfor_body routine at which</span>
                            <span class="s0"># point it needs to be a set so e.g. set.difference</span>
                            <span class="s0"># can be computed, this therefore creates an error</span>
                            <span class="s0"># in the right location.</span>
                            <span class="s2">class </span><span class="s1">Broken</span><span class="s3">(</span><span class="s1">list</span><span class="s3">):</span>

                                <span class="s2">def </span><span class="s1">difference</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
                                    <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">LoweringError</span><span class="s3">(</span><span class="s1">BROKEN_MSG</span><span class="s3">)</span>

                            <span class="s1">stmt</span><span class="s3">.</span><span class="s1">races </span><span class="s3">= </span><span class="s1">Broken</span><span class="s3">()</span>
                    <span class="s2">return True</span>


        <span class="s2">class </span><span class="s1">BreakParforsCompiler</span><span class="s3">(</span><span class="s1">CompilerBase</span><span class="s3">):</span>

            <span class="s2">def </span><span class="s1">define_pipelines</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s1">pm </span><span class="s3">= </span><span class="s1">DefaultPassBuilder</span><span class="s3">.</span><span class="s1">define_nopython_pipeline</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">state</span><span class="s3">)</span>
                <span class="s1">pm</span><span class="s3">.</span><span class="s1">add_pass_after</span><span class="s3">(</span><span class="s1">BreakParfors</span><span class="s3">, </span><span class="s1">IRLegalization</span><span class="s3">)</span>
                <span class="s1">pm</span><span class="s3">.</span><span class="s1">finalize</span><span class="s3">()</span>
                <span class="s2">return </span><span class="s3">[</span><span class="s1">pm</span><span class="s3">]</span>


        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">pipeline_class</span><span class="s3">=</span><span class="s1">BreakParforsCompiler</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">foo</span><span class="s3">():</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">x </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s0"># assert default state for global</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">LoweringError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">foo</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">BROKEN_MSG</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

        <span class="s0"># assert state has not changed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue_5098</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">class </span><span class="s1">DummyType</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Opaque</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s1">dummy_type </span><span class="s3">= </span><span class="s1">DummyType</span><span class="s3">(</span><span class="s5">&quot;my_dummy&quot;</span><span class="s3">)</span>
        <span class="s1">register_model</span><span class="s3">(</span><span class="s1">DummyType</span><span class="s3">)(</span><span class="s1">models</span><span class="s3">.</span><span class="s1">OpaqueModel</span><span class="s3">)</span>

        <span class="s2">class </span><span class="s1">Dummy</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s3">@</span><span class="s1">typeof_impl</span><span class="s3">.</span><span class="s1">register</span><span class="s3">(</span><span class="s1">Dummy</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">typeof_Dummy</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">dummy_type</span>

        <span class="s3">@</span><span class="s1">unbox</span><span class="s3">(</span><span class="s1">DummyType</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">unbox_index</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NativeValue</span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">())</span>

        <span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">DummyType</span><span class="s3">, </span><span class="s5">&quot;method1&quot;</span><span class="s3">, </span><span class="s1">jit_options</span><span class="s3">={</span><span class="s5">&quot;parallel&quot;</span><span class="s3">:</span><span class="s2">True</span><span class="s3">})</span>
        <span class="s2">def </span><span class="s1">_get_method1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">_foo</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
                <span class="s2">def </span><span class="s1">baz</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">f</span><span class="s3">):</span>
                    <span class="s1">c </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
                    <span class="s1">c</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
                    <span class="s2">return </span><span class="s1">f</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)</span>

                <span class="s1">length </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
                <span class="s1">output_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">length</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">length</span><span class="s3">):</span>
                    <span class="s1">output_arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">baz</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">func</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s1">output_arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">baz</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">func</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">output_arr</span>
            <span class="s2">return </span><span class="s1">_foo</span>

        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">bar</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">v</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>

        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">test1</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">d</span><span class="s3">.</span><span class="s1">method1</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">], [</span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">6.0</span><span class="s3">]]), </span><span class="s1">bar</span><span class="s3">)</span>

        <span class="s1">save_state </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">save_state</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">test1</span><span class="s3">(</span><span class="s1">Dummy</span><span class="s3">())</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s0"># always set the sequential_parfor_lowering state back to the</span>
            <span class="s0"># original state</span>
            <span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor</span><span class="s3">.</span><span class="s1">sequential_parfor_lowering </span><span class="s3">= </span><span class="s1">save_state</span>

    <span class="s2">def </span><span class="s1">test_oversized_tuple_as_arg_to_kernel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">oversize_tuple</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">):</span>
            <span class="s1">big_tup </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s3">,</span><span class="s4">3</span><span class="s3">,</span><span class="s4">4</span><span class="s3">)</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">z </span><span class="s3">+= </span><span class="s1">big_tup</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">z</span>

        <span class="s2">with </span><span class="s1">override_env_config</span><span class="s3">(</span><span class="s5">'NUMBA_PARFOR_MAX_TUPLE_SIZE'</span><span class="s3">, </span><span class="s5">'3'</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedParforsError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
                <span class="s1">oversize_tuple</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>

        <span class="s1">errstr </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;Use of a tuple&quot;</span><span class="s3">, </span><span class="s1">errstr</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;in a parallel region&quot;</span><span class="s3">, </span><span class="s1">errstr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5167</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">ndvi_njit</span><span class="s3">(</span><span class="s1">img_nir</span><span class="s3">, </span><span class="s1">img_red</span><span class="s3">):</span>
            <span class="s1">fillvalue </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">out_img </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">img_nir</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">img_nir</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">dims </span><span class="s3">= </span><span class="s1">img_nir</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]):</span>
                    <span class="s1">out_img</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">] = ((</span><span class="s1">img_nir</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">] - </span><span class="s1">img_red</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">]) /</span>
                                     <span class="s3">(</span><span class="s1">img_nir</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">] + </span><span class="s1">img_red</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">]))</span>
            <span class="s2">return </span><span class="s1">out_img</span>

        <span class="s1">tile_shape </span><span class="s3">= (</span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">)</span>
        <span class="s1">array1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s4">10000.0</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">tile_shape</span><span class="s3">)</span>
        <span class="s1">array2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s4">10000.0</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">tile_shape</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">ndvi_njit</span><span class="s3">, </span><span class="s1">array1</span><span class="s3">, </span><span class="s1">array2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5065</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">reproducer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dist</span><span class="s3">, </span><span class="s1">dist_args</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                    <span class="s1">d </span><span class="s3">= </span><span class="s1">dist</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">a</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], *</span><span class="s1">dist_args</span><span class="s3">)</span>
                    <span class="s1">result</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">d</span>
                    <span class="s1">result</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">d</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">euclidean</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s4">0.0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s1">result </span><span class="s3">+= (</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) ** </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>

        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">random</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>

        <span class="s1">got </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)(</span><span class="s1">reproducer</span><span class="s3">)(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">euclidean</span><span class="s3">,())</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">reproducer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">euclidean</span><span class="s3">,())</span>

        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">got</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5001</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">test_numba_parallel</span><span class="s3">(</span><span class="s1">myarray</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">myarray</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">myarray</span><span class="s3">)):</span>
                <span class="s1">result</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">len</span><span class="s3">(</span><span class="s1">myarray</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">myarray </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">100</span><span class="s3">),</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">50</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_numba_parallel</span><span class="s3">, </span><span class="s1">myarray</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue3169</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">foo</span><span class="s3">(</span><span class="s1">grids</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">bar</span><span class="s3">(</span><span class="s1">grids</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">foo</span><span class="s3">(</span><span class="s1">grids</span><span class="s3">)</span>

        <span class="s0"># returns nothing, just check it compiles</span>
        <span class="s1">bar</span><span class="s3">(([</span><span class="s4">1</span><span class="s3">],) * </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_issue4846</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s1">mytype </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s5">&quot;mytype&quot;</span><span class="s3">, (</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s5">&quot;b&quot;</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">outer</span><span class="s3">(</span><span class="s1">mydata</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">3</span><span class="s3">):</span>
                <span class="s1">inner</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mydata</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">mydata</span><span class="s3">.</span><span class="s1">a</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">nogil</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">inner</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mydata</span><span class="s3">):</span>
            <span class="s1">f </span><span class="s3">= (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mydata</span><span class="s3">.</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">g </span><span class="s3">= (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mydata</span><span class="s3">.</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">mydata </span><span class="s3">= </span><span class="s1">mytype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s1">b</span><span class="s3">=</span><span class="s5">&quot;b&quot;</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">outer</span><span class="s3">, </span><span class="s1">mydata</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue3748</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">test1b</span><span class="s3">():</span>
            <span class="s1">x </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
                <span class="s1">a </span><span class="s3">+= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test1b</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">test_issue5277</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">parallel_test</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">size</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]):</span>
                    <span class="s1">arr</span><span class="s3">[</span><span class="s1">y</span><span class="s3">][</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">x </span><span class="s3">* </span><span class="s4">4.5 </span><span class="s3">+ </span><span class="s1">y</span>
            <span class="s2">return </span><span class="s1">arr</span>

        <span class="s1">size </span><span class="s3">= (</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">parallel_test</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5570_ssa_races</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">foo</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s1">out</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">method</span><span class="s3">:</span>
                <span class="s1">out </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">src </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">5</span><span class="s3">,</span><span class="s4">5</span><span class="s3">))</span>
        <span class="s1">method </span><span class="s3">= </span><span class="s4">57</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span>
            <span class="s1">foo</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">out</span><span class="s3">),</span>
            <span class="s1">foo</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue6095_numpy_max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">find_maxima_3D_jit</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">package </span><span class="s3">= </span><span class="s1">args</span>
            <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">z_stack </span><span class="s3">= </span><span class="s1">package</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, :, :]</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">z_stack</span><span class="s3">)</span>

        <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">random</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span>
            <span class="s1">find_maxima_3D_jit</span><span class="s3">(</span><span class="s1">args</span><span class="s3">),</span>
            <span class="s1">find_maxima_3D_jit</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">args</span><span class="s3">),</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5942_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5942: tests statement reordering of</span>
        <span class="s0"># aliased arguments.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">gg</span><span class="s3">, </span><span class="s1">gg_next</span><span class="s3">):</span>
            <span class="s1">gs </span><span class="s3">= </span><span class="s1">gg</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">d </span><span class="s3">= </span><span class="s1">gs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i_gg </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
                <span class="s1">gg_next</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, :]  = </span><span class="s1">gg</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, :]</span>
                <span class="s1">gg_next</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>

            <span class="s2">return </span><span class="s1">gg_next</span>

        <span class="s1">d </span><span class="s3">= </span><span class="s4">4</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s4">2</span>

        <span class="s1">gg      </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">gg_next </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">gg</span><span class="s3">, </span><span class="s1">gg_next</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue5942_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5942: tests statement reordering</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
            <span class="s1">gg      </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
            <span class="s1">gg_next </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">i_gg </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">k</span><span class="s3">):</span>
                    <span class="s1">gg</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, </span><span class="s1">n</span><span class="s3">] = </span><span class="s1">i_gg</span>
                <span class="s1">gg_next</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, :]  = </span><span class="s1">gg</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, :]</span>
                <span class="s1">gg_next</span><span class="s3">[</span><span class="s1">i_gg</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>

            <span class="s2">return </span><span class="s1">gg_next</span>

        <span class="s1">d </span><span class="s3">= </span><span class="s4">4</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s4">2</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_unless_scipy</span>
    <span class="s2">def </span><span class="s1">test_issue6102</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># The problem is originally observed on Python3.8 because of the</span>
        <span class="s0"># changes in how loops are represented in 3.8 bytecode.</span>
        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">f</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">ir </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s1">dist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span>
                <span class="s1">tr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">]:</span>
                    <span class="s1">dist_t </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">(</span><span class="s1">r</span><span class="s3">[</span><span class="s1">ir</span><span class="s3">, :] + </span><span class="s1">i</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">dist_t </span><span class="s3">&lt; </span><span class="s1">dist</span><span class="s3">:</span>
                        <span class="s1">dist </span><span class="s3">= </span><span class="s1">dist_t</span>
                        <span class="s1">tr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
                <span class="s1">r</span><span class="s3">[</span><span class="s1">ir</span><span class="s3">, :] += </span><span class="s1">tr</span>
            <span class="s2">return </span><span class="s1">r</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">0.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">], [</span><span class="s4">0.</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">1.</span><span class="s3">]])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">f</span><span class="s3">(</span><span class="s1">r</span><span class="s3">), </span><span class="s1">f</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">r</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_issue6774</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">5</span>
            <span class="s1">na_mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">,))</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">,))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)):</span>
                <span class="s1">result</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">na_mask</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue4963_globals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">buf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">_GLOBAL_INT_FOR_TESTING1</span><span class="s3">, </span><span class="s1">_GLOBAL_INT_FOR_TESTING2</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">buf</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue4963_freevars</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">_FREEVAR_INT_FOR_TESTING1 </span><span class="s3">= </span><span class="s4">17</span>
        <span class="s1">_FREEVAR_INT_FOR_TESTING2 </span><span class="s3">= </span><span class="s4">5</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">buf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">_FREEVAR_INT_FOR_TESTING1</span><span class="s3">, </span><span class="s1">_FREEVAR_INT_FOR_TESTING2</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">buf</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_issue_9182_recursion_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">ListType</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">intp</span>

        <span class="s3">@</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">_sink</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">pass</span>


        <span class="s3">@</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">cache</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">_ground_node_rule</span><span class="s3">(</span>
            <span class="s1">clauses</span><span class="s3">,</span>
            <span class="s1">nodes</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s2">for </span><span class="s1">piter </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">nodes</span><span class="s3">)):</span>
                <span class="s2">for </span><span class="s1">clause </span><span class="s2">in </span><span class="s1">clauses</span><span class="s3">:</span>
                    <span class="s1">clause_type </span><span class="s3">= </span><span class="s1">clause</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
                    <span class="s1">clause_variables </span><span class="s3">= </span><span class="s1">clause</span><span class="s3">[</span><span class="s4">2</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">clause_type </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                        <span class="s1">clause_var_1 </span><span class="s3">= </span><span class="s1">clause_variables</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
                    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">clause_variables</span><span class="s3">) == </span><span class="s4">2</span><span class="s3">:</span>
                        <span class="s1">clause_var_1</span><span class="s3">, </span><span class="s1">clause_var_2 </span><span class="s3">= (</span>
                            <span class="s1">clause_variables</span><span class="s3">[</span><span class="s4">0</span><span class="s3">],</span>
                            <span class="s1">clause_variables</span><span class="s3">[</span><span class="s4">1</span><span class="s3">],</span>
                        <span class="s3">)</span>

                    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">clause_variables</span><span class="s3">) == </span><span class="s4">4</span><span class="s3">:</span>
                        <span class="s2">pass</span>

                    <span class="s2">if </span><span class="s1">clause_type </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                        <span class="s1">_sink</span><span class="s3">(</span><span class="s1">clause_var_1</span><span class="s3">)</span>
                        <span class="s1">_sink</span><span class="s3">(</span><span class="s1">clause_var_2</span><span class="s3">)</span>

        <span class="s1">_ground_node_rule</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span>
            <span class="s3">(</span>
                <span class="s1">ListType</span><span class="s3">(</span><span class="s1">Tuple</span><span class="s3">([</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ListType</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">)])),</span>
                <span class="s1">ListType</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_lookup_cycle_detection</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This test is added due to a bug discovered in the PR 9244 patch.</span>
        <span class="s0"># The cyclic detection was incorrectly flagging cycles.</span>
        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">foo</span><span class="s3">():</span>
            <span class="s0"># The following `acc` variable is used in the `lookup()` function</span>
            <span class="s0"># in parfor's reduction code.</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                        <span class="s1">acc </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">foo</span><span class="s3">(), </span><span class="s1">foo</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforsDiagnostics</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_all</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_parfors_vs_others</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">assert_fusion_equivalence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">got</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fusion_equivalent</span><span class="s3">(</span><span class="s1">got</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fusion_equivalent</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fusion_equivalent</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">thing</span><span class="s3">):</span>
        <span class="s0"># parfors indexes the Parfors class instance id's from wherever the</span>
        <span class="s0"># internal state happens to be. To assert fusion equivalence we just</span>
        <span class="s0"># check that the relative difference between fusion adjacency lists</span>
        <span class="s0"># is the same. For example:</span>
        <span class="s0"># {3: [2, 1]} is the same as {13: [12, 11]}</span>
        <span class="s0"># this function strips the indexing etc out returning something suitable</span>
        <span class="s0"># for checking equivalence</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>
        <span class="s1">min_key </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">thing</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">thing</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
            <span class="s1">new</span><span class="s3">[</span><span class="s1">k </span><span class="s3">- </span><span class="s1">min_key</span><span class="s3">] = [</span><span class="s1">x </span><span class="s3">- </span><span class="s1">min_key </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">thing</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]]</span>
        <span class="s2">return </span><span class="s1">new</span>

    <span class="s2">def </span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                           <span class="s1">fusion_info</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">nested_fusion_info</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                           <span class="s1">replaced_fns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">hoisted_allocations</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">parfors_count </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">parfors_count</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">count_parfors</span><span class="s3">())</span>
        <span class="s2">if </span><span class="s1">fusion_info </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_fusion_equivalence</span><span class="s3">(</span><span class="s1">fusion_info</span><span class="s3">, </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">fusion_info</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">nested_fusion_info </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_fusion_equivalence</span><span class="s3">(</span><span class="s1">nested_fusion_info</span><span class="s3">,</span>
                                           <span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">nested_fusion_info</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">replaced_fns </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">repl </span><span class="s3">= </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">replaced_fns</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">replaced_fns</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">replaced </span><span class="s2">in </span><span class="s1">repl</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">replaced</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">x</span><span class="s3">:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Replacement for %s was not found. Had %s&quot; </span><span class="s3">% (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">repl</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hoisted_allocations </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">hoisted_allocs </span><span class="s3">= </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">hoisted_allocations</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">hoisted_allocations</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">hoisted_allocs</span><span class="s3">))</span>

        <span class="s0"># just make sure that the dump() function doesn't have an issue!</span>
        <span class="s2">with </span><span class="s1">captured_stdout</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">5</span><span class="s3">):</span>
                <span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_array_expr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
                                <span class="s1">fusion_info </span><span class="s3">= {</span><span class="s4">3</span><span class="s3">: [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">]})</span>

    <span class="s2">def </span><span class="s1">test_prange</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">* </span><span class="s4">10</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_user_varname</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;make sure original user variable name is used in fusion info 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">a </span><span class="s3">* </span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">b</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s0"># make sure original 'n' variable name is used in fusion report for loop</span>
        <span class="s0"># dimension mismatch</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span>
            <span class="s1">any</span><span class="s3">(</span><span class="s5">&quot;slice(0, n, 1)&quot; </span><span class="s2">in </span><span class="s1">r</span><span class="s3">.</span><span class="s1">message </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">fusion_reports</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_nested_prange</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">* </span><span class="s4">10 </span><span class="s3">+ </span><span class="s1">j</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">2</span><span class="s3">,</span>
                                <span class="s1">nested_fusion_info</span><span class="s3">={</span><span class="s4">2</span><span class="s3">: [</span><span class="s4">1</span><span class="s3">]})</span>

    <span class="s2">def </span><span class="s1">test_function_replacement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">b</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
                                <span class="s1">fusion_info</span><span class="s3">={</span><span class="s4">2</span><span class="s3">: [</span><span class="s4">3</span><span class="s3">]},</span>
                                <span class="s1">replaced_fns </span><span class="s3">= [(</span><span class="s5">'argmin'</span><span class="s3">, </span><span class="s5">'numpy'</span><span class="s3">),])</span>

    <span class="s2">def </span><span class="s1">test_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) </span><span class="s0"># prevent fusion</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_reduction_binop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) </span><span class="s0"># prevent fusion</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">acc </span><span class="s3">- </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[:] = </span><span class="s4">7</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">parfors_count</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_allocation_hoisting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s4">5</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">temp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">m</span><span class="s3">,)) </span><span class="s0"># the np.empty call should get hoisted</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
                    <span class="s1">temp</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">i</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">temp</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,)</span>
        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, ())</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_diagnostics</span><span class="s3">(</span><span class="s1">diagnostics</span><span class="s3">, </span><span class="s1">hoisted_allocations</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestPrangeBase</span><span class="s3">(</span><span class="s1">TestParforsBase</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">patch_instance</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        This function does the actual code augmentation to enable the explicit 
        testing of `prange` calls in place of `range`. 
        &quot;&quot;&quot;</span>
        <span class="s1">pyfunc_code </span><span class="s3">= </span><span class="s1">pyfunc</span><span class="s3">.</span><span class="s1">__code__</span>

        <span class="s1">prange_names </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_names</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">patch_instance </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># patch all instances, cheat by just switching</span>
            <span class="s0"># range for prange</span>
            <span class="s2">assert </span><span class="s5">'range' </span><span class="s2">in </span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_names</span>
            <span class="s1">prange_names </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">x </span><span class="s2">if </span><span class="s1">x </span><span class="s3">!= </span><span class="s5">'range' </span><span class="s2">else </span><span class="s5">'prange'</span>
                                  <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_names</span><span class="s3">])</span>
            <span class="s1">new_code </span><span class="s3">= </span><span class="s1">bytes</span><span class="s3">(</span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_code</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># patch specified instances...</span>
            <span class="s0"># find where 'range' is in co_names</span>
            <span class="s1">range_idx </span><span class="s3">= </span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_names</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s5">'range'</span><span class="s3">)</span>
            <span class="s1">range_locations </span><span class="s3">= []</span>
            <span class="s0"># look for LOAD_GLOBALs that point to 'range'</span>
            <span class="s2">for </span><span class="s1">instr </span><span class="s2">in </span><span class="s1">dis</span><span class="s3">.</span><span class="s1">Bytecode</span><span class="s3">(</span><span class="s1">pyfunc_code</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">opname </span><span class="s3">== </span><span class="s5">'LOAD_GLOBAL'</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">_fix_LOAD_GLOBAL_arg</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">arg</span><span class="s3">) == </span><span class="s1">range_idx</span><span class="s3">:</span>
                        <span class="s1">range_locations</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">offset </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s0"># add in 'prange' ref</span>
            <span class="s1">prange_names</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">'prange'</span><span class="s3">)</span>
            <span class="s1">prange_names </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">prange_names</span><span class="s3">)</span>
            <span class="s1">prange_idx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prange_names</span><span class="s3">) - </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s2">in </span><span class="s3">((</span><span class="s4">3</span><span class="s3">, </span><span class="s4">11</span><span class="s3">), (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">12</span><span class="s3">)):</span>
                <span class="s0"># this is the inverse of _fix_LOAD_GLOBAL_arg</span>
                <span class="s1">prange_idx </span><span class="s3">= </span><span class="s4">1 </span><span class="s3">+ (</span><span class="s1">prange_idx </span><span class="s3">&lt;&lt; </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION </span><span class="s2">in </span><span class="s3">((</span><span class="s4">3</span><span class="s3">, </span><span class="s4">9</span><span class="s3">), (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)):</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">PYVERSION</span><span class="s3">)</span>
            <span class="s1">new_code </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">co_code</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">patch_instance</span><span class="s3">) &lt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">range_locations</span><span class="s3">)</span>
            <span class="s0"># patch up the new byte code</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">patch_instance</span><span class="s3">:</span>
                <span class="s1">idx </span><span class="s3">= </span><span class="s1">range_locations</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">new_code</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">prange_idx</span>
            <span class="s1">new_code </span><span class="s3">= </span><span class="s1">bytes</span><span class="s3">(</span><span class="s1">new_code</span><span class="s3">)</span>

        <span class="s0"># create code object with prange mutation</span>
        <span class="s1">prange_code </span><span class="s3">= </span><span class="s1">pyfunc_code</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">co_code</span><span class="s3">=</span><span class="s1">new_code</span><span class="s3">,</span>
                                          <span class="s1">co_names</span><span class="s3">=</span><span class="s1">prange_names</span><span class="s3">)</span>

        <span class="s0"># get function</span>
        <span class="s1">pfunc </span><span class="s3">= </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">prange_code</span><span class="s3">, </span><span class="s1">globals</span><span class="s3">())</span>

        <span class="s2">return </span><span class="s1">pfunc</span>

    <span class="s2">def </span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pyfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; 
        The `prange` tester 
        This is a hack. It basically switches out range calls for prange. 
        It does this by copying the live code object of a function 
        containing 'range' then copying the .co_names and mutating it so 
        that 'range' is replaced with 'prange'. It then creates a new code 
        object containing the mutation and instantiates a function to contain 
        it. At this point three results are created: 
        1. The result of calling the original python function. 
        2. The result of calling a njit compiled version of the original 
            python function. 
        3. The result of calling a njit(parallel=True) version of the mutated 
           function containing `prange`. 
        The three results are then compared and the `prange` based function's 
        llvm_ir is inspected to ensure the scheduler code is present. 
 
        Arguments: 
         pyfunc - the python function to test 
         args - data arguments to pass to the pyfunc under test 
 
        Keyword Arguments: 
         patch_instance - iterable containing which instances of `range` to 
                          replace. If not present all instance of `range` are 
                          replaced. 
         scheduler_type - 'signed', 'unsigned' or None, default is None. 
                           Supply in cases where the presence of a specific 
                           scheduler is to be asserted. 
         check_fastmath - if True then a check will be performed to ensure the 
                          IR contains instructions labelled with 'fast' 
         check_fastmath_result - if True then a check will be performed to 
                                 ensure the result of running with fastmath 
                                 on matches that of the pyfunc 
         Remaining kwargs are passed to np.testing.assert_almost_equal 
 
 
        Example: 
            def foo(): 
                acc = 0 
                for x in range(5): 
                    for y in range(10): 
                        acc +=1 
                return acc 
 
            # calling as 
            prange_tester(foo) 
            # will test code equivalent to 
            # def foo(): 
            #     acc = 0 
            #     for x in prange(5): # &lt;- changed 
            #         for y in prange(10): # &lt;- changed 
            #             acc +=1 
            #     return acc 
 
            # calling as 
            prange_tester(foo, patch_instance=[1]) 
            # will test code equivalent to 
            # def foo(): 
            #     acc = 0 
            #     for x in range(5): # &lt;- outer loop (0) unchanged 
            #         for y in prange(10): # &lt;- inner loop (1) changed 
            #             acc +=1 
            #     return acc 
 
        &quot;&quot;&quot;</span>
        <span class="s1">patch_instance </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'patch_instance'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">check_fastmath </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'check_fastmath'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">check_fastmath_result </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'check_fastmath_result'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">pfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">patch_instance</span><span class="s3">)</span>

        <span class="s0"># Compile functions</span>
        <span class="s0"># compile a standard njit of the original function</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>
        <span class="s1">cfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_njit</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s0"># compile the prange injected function</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised_warnings</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s5">'always'</span><span class="s3">)</span>
            <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s0"># if check_fastmath is True then check fast instructions</span>
        <span class="s2">if </span><span class="s1">check_fastmath</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assert_fastmath</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

        <span class="s0"># if check_fastmath_result is True then compile a function</span>
        <span class="s0"># so that the parfors checker can assert the result is ok.</span>
        <span class="s2">if </span><span class="s1">check_fastmath_result</span><span class="s3">:</span>
            <span class="s1">fastcpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>
            <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">({</span><span class="s5">'fastmath_pcres'</span><span class="s3">: </span><span class="s1">fastcpfunc</span><span class="s3">}, **</span><span class="s1">kwargs</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_parfors_vs_others</span><span class="s3">(</span><span class="s1">pyfunc</span><span class="s3">, </span><span class="s1">cfunc</span><span class="s3">, </span><span class="s1">cpfunc</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">raised_warnings</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestPrangeBasic</span><span class="s3">(</span><span class="s1">TestPrangeBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Tests Prange &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_prange01</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">2.0 </span><span class="s3">* </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange02</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] = </span><span class="s4">2.0 </span><span class="s3">* </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange03</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">+= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange03mul</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">*= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange03sub</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">100</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">-= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange03div</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">10</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">/= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange04</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s4">2</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">4</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s1">a</span><span class="s3">:</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">b</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">0</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange05</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange06</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange07</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange08</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange08_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">4</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">4</span><span class="s3">):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange09</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s0"># patch inner loop to 'prange'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">],</span>
                           <span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange10</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">acc2 </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc1 </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">acc1 </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s1">acc2 </span><span class="s3">+= </span><span class="s1">acc1</span>
            <span class="s2">return </span><span class="s1">acc2</span>
        <span class="s0"># patch outer loop to 'prange'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">0</span><span class="s3">],</span>
                           <span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">unittest</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s5">&quot;list append is not thread-safe yet (#2391, #2408)&quot;</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_prange11</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">j</span><span class="s3">) </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange12</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange13</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">(</span><span class="s4">4</span><span class="s3">), </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange14</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s1">s </span><span class="s3">+= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]*</span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s0"># this tests reduction detection well since the accumulated variable</span>
        <span class="s0"># is initialized before the parfor and the value accessed from the array</span>
        <span class="s0"># is updated before accumulation</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s4">4</span><span class="s3">),</span>
                           <span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange15</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># from issue 2587</span>
        <span class="s0"># test parfor type inference when there is multi-dimensional indexing</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
                <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">1024</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s0"># Tests for negative ranges</span>
    <span class="s2">def </span><span class="s1">test_prange16</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">1024</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange17</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange18</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">, </span><span class="s4">5</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">4</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange19</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">M </span><span class="s3">= </span><span class="s1">N </span><span class="s3">+ </span><span class="s4">4</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">M</span><span class="s3">, </span><span class="s1">M</span><span class="s3">):</span>
                    <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange20</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange21</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">3</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">3</span>
            <span class="s2">return </span><span class="s1">acc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange22</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">3</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s1">a</span><span class="s3">:</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">b</span>
                <span class="s2">elif </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">1</span><span class="s3">:</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = -</span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">7</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange23</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test non-contig input</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">32</span><span class="s3">)[::</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange24</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># test non-contig input, signed range</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">), </span><span class="s4">0</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">32</span><span class="s3">)[::</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'signed'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange25</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s1">buf </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">A</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">buf</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">A </span><span class="s3">+ </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">buf</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s4">10</span><span class="s3">,))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">,  </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">],</span>
                           <span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">, </span><span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                           <span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">cpfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, (</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">A</span><span class="s3">),))</span>
        <span class="s1">diagnostics </span><span class="s3">= </span><span class="s1">cpfunc</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">[</span><span class="s5">'parfor_diagnostics'</span><span class="s3">]</span>
        <span class="s1">hoisted_allocs </span><span class="s3">= </span><span class="s1">diagnostics</span><span class="s3">.</span><span class="s1">hoisted_allocations</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">hoisted_allocs</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange26</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[::</span><span class="s4">3</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">B</span><span class="s3">)):</span>
                <span class="s1">B</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">32</span><span class="s3">)[::</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange27</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5597: usedef error in parfor</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]-</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">):</span>
                    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">c</span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span><span class="s1">c</span><span class="s3">+</span><span class="s4">1</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s4">0</span>

        <span class="s0"># patch inner loop to 'prange'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,</span>
                           <span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">20</span><span class="s3">),</span>
                           <span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">,</span><span class="s4">4</span><span class="s3">]),</span>
                           <span class="s4">0</span><span class="s3">,</span>
                           <span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">],</span>
                           <span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange28</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue7105: label conflict in nested parfor</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)):</span>
                <span class="s1">i0 </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
                <span class="s1">i1 </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">Pt1 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i0</span><span class="s3">]</span>
                <span class="s1">Pt2 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i1</span><span class="s3">]</span>
                <span class="s1">v </span><span class="s3">= </span><span class="s1">Pt1 </span><span class="s3">- </span><span class="s1">Pt2</span>
                <span class="s1">vl2 </span><span class="s3">= </span><span class="s1">v</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s1">v</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">vl2</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[-</span><span class="s4">1.</span><span class="s3">, -</span><span class="s4">1.</span><span class="s3">],</span>
                      <span class="s3">[-</span><span class="s4">1.</span><span class="s3">,  </span><span class="s4">1.</span><span class="s3">],</span>
                      <span class="s3">[ </span><span class="s4">0.</span><span class="s3">,  </span><span class="s4">0.</span><span class="s3">],</span>
                      <span class="s3">[ </span><span class="s4">1.</span><span class="s3">, -</span><span class="s4">1.</span><span class="s3">],</span>
                      <span class="s3">[ </span><span class="s4">1.</span><span class="s3">,  </span><span class="s4">0.</span><span class="s3">],</span>
                      <span class="s3">[ </span><span class="s4">1.</span><span class="s3">,  </span><span class="s4">1.</span><span class="s3">]])</span>

        <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">]])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange29</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue7630: SSA renaming in prange header</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">if </span><span class="s1">flag</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s1">result </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s1">result </span><span class="s3">-= </span><span class="s4">3</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange30</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue7675: broadcast setitem</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">par</span><span class="s3">, </span><span class="s1">numthreads</span><span class="s3">):</span>
            <span class="s1">n_par </span><span class="s3">= </span><span class="s1">par</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">n_x </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_par</span><span class="s3">, </span><span class="s1">n_x</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">chunklen </span><span class="s3">= (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) + </span><span class="s1">numthreads </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) // </span><span class="s1">numthreads</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">numthreads</span><span class="s3">):</span>
                <span class="s1">start </span><span class="s3">= </span><span class="s1">i </span><span class="s3">* </span><span class="s1">chunklen</span>
                <span class="s1">stop </span><span class="s3">= (</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) * </span><span class="s1">chunklen</span>
                <span class="s1">result</span><span class="s3">[:, </span><span class="s1">start</span><span class="s3">:</span><span class="s1">stop</span><span class="s3">] = </span><span class="s1">x</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">stop</span><span class="s3">] * </span><span class="s1">par</span><span class="s3">[:]</span>

            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">))</span>
        <span class="s1">par </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">par</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">test_call_hoisting_outcall</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestPrangeSpecific</span><span class="s3">(</span><span class="s1">TestPrangeBase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; Tests specific features/problems found under prange&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_prange_two_instances_same_reduction_var</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue4922 - multiple uses of same reduction variable</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s4">10</span><span class="s3">:</span>
                    <span class="s1">c </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">c</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_conflicting_reduction_ops</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s4">10</span><span class="s3">:</span>
                    <span class="s1">c </span><span class="s3">*= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">c</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">9</span><span class="s3">)</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s5">'Reduction variable c has multiple conflicting reduction '</span>
               <span class="s5">'operators.'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_prange_two_conditional_reductions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue6414</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">B </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s1">A </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
                    <span class="s2">if </span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]:</span>
                        <span class="s1">B </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_prange_nested_reduction1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                        <span class="s1">A </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">disabled_test</span>
    <span class="s2">def </span><span class="s1">test_check_error_model</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">32</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">i </span><span class="s0"># div-by-zero when i = 0</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ZeroDivisionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">test_impl</span><span class="s3">()</span>

        <span class="s0"># compile parallel functions</span>
        <span class="s1">pfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">pcres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, ())</span>
        <span class="s1">pfcres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, ())</span>

        <span class="s0"># should raise</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ZeroDivisionError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">pcres</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">()</span>

        <span class="s0"># should not raise</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">pfcres</span><span class="s3">.</span><span class="s1">entry_point</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">result</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_check_alias_analysis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># check alias analysis reports ok</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                <span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">B</span><span class="s3">[:] = </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">32</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">4</span><span class="s3">, </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_fastmath_result</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">pfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)])</span>
        <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>
        <span class="s1">_ir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_ir</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_ir</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">v</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">():</span>
                <span class="s0"># get the fn definition line</span>
                <span class="s2">if </span><span class="s5">'define' </span><span class="s2">in </span><span class="s1">line </span><span class="s2">and </span><span class="s1">k </span><span class="s2">in </span><span class="s1">line</span><span class="s3">:</span>
                    <span class="s0"># there should only be 2x noalias, one on each of the first</span>
                    <span class="s0"># 2 args (retptr, excinfo).</span>
                    <span class="s0"># Note: used to be 3x no noalias, but env arg is dropped.</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">line</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s5">'noalias'</span><span class="s3">), </span><span class="s4">2</span><span class="s3">)</span>
                    <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">test_prange_raises_invalid_step_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedRewriteError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raises</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">1024</span><span class="s3">)</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">'Only constant step size of 1 is supported for prange'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raises</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_prange_fastmath_check_works</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># this function will benefit from `fastmath`, the div will</span>
        <span class="s0"># get optimised to a multiply by reciprocal and the accumulator</span>
        <span class="s0"># then becomes an fmadd: A = A + i * 0.5</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">128</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A </span><span class="s3">+= </span><span class="s1">i </span><span class="s3">/ </span><span class="s4">2.0</span>
            <span class="s2">return </span><span class="s1">A</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">scheduler_type</span><span class="s3">=</span><span class="s5">'unsigned'</span><span class="s3">,</span>
                           <span class="s1">check_fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">pfunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pfunc</span><span class="s3">, ())</span>
        <span class="s1">ir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_ir</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">)</span>
        <span class="s1">_id </span><span class="s3">= </span><span class="s5">'%[A-Z_0-9]?(.[0-9]+)+[.]?[i]?'</span>
        <span class="s1">recipr_str </span><span class="s3">= </span><span class="s5">r'\s+%s = fmul fast double %s, 5.000000e-01'</span>
        <span class="s1">reciprocal_inst </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">recipr_str </span><span class="s3">% (</span><span class="s1">_id</span><span class="s3">, </span><span class="s1">_id</span><span class="s3">))</span>
        <span class="s1">fadd_inst </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'\s+%s = fadd fast double %s, %s'</span>
                               <span class="s3">% (</span><span class="s1">_id</span><span class="s3">, </span><span class="s1">_id</span><span class="s3">, </span><span class="s1">_id</span><span class="s3">))</span>
        <span class="s0"># check there is something like:</span>
        <span class="s0">#  %.329 = fmul fast double %.325, 5.000000e-01</span>
        <span class="s0">#  %.337 = fadd fast double %A.07, %.329</span>
        <span class="s1">found </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">kernel </span><span class="s2">in </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s0"># make sure to look at the kernel corresponding to the cres/pfunc</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_llvm_str</span><span class="s3">():</span>
                <span class="s1">splitted </span><span class="s3">= </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">()</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">splitted</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">reciprocal_inst</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">fadd_inst</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">splitted</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]))</span>
                        <span class="s1">found </span><span class="s3">= </span><span class="s2">True</span>
                        <span class="s2">break</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">found</span><span class="s3">, </span><span class="s5">&quot;fast instruction pattern was not found.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_alias1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">j </span><span class="s3">+ </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">b</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">4</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_alias2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
              <span class="s1">a </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
              <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">j</span>
            <span class="s2">return </span><span class="s1">b</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">4</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_alias3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
              <span class="s1">a </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
              <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                  <span class="s1">c</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">j </span><span class="s3">+ </span><span class="s1">k</span>
            <span class="s2">return </span><span class="s1">b</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">4</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_parfor_race_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
                <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span>
            <span class="s2">return </span><span class="s1">k</span>
        <span class="s1">raised_warnings </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s3">)</span>
        <span class="s1">warning_obj </span><span class="s3">= </span><span class="s1">raised_warnings</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">expected_msg </span><span class="s3">= (</span><span class="s5">&quot;Variable k used in parallel loop may be written to &quot;</span>
                        <span class="s5">&quot;simultaneously by multiple workers and may result &quot;</span>
                        <span class="s5">&quot;in non-deterministic or unintended results.&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">expected_msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">warning_obj</span><span class="s3">.</span><span class="s1">message</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_nested_parfor_push_call_vars</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; issue 3686: if a prange has something inside it that causes 
            a nested parfor to be generated and both the inner and outer 
            parfor use the same call variable defined outside the parfors 
            then ensure that when that call variable is pushed into the 
            parfor that the call variable isn't duplicated with the same 
            name resulting in a redundant type lock. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">negative</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">this_matters </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s4">1.</span><span class="s3">)</span>
                <span class="s1">B </span><span class="s3">+= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">,))[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">this_matters </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s4">1.</span><span class="s3">)</span>
                <span class="s1">B </span><span class="s3">+= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">,))[</span><span class="s4">0</span><span class="s3">]</span>

            <span class="s2">return </span><span class="s1">B</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_copy_global_for_parfor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; issue4903: a global is copied next to a parfor so that 
            it can be inlined into the parfor and thus not have to be 
            passed to the parfor (i.e., an unsupported function type). 
            This global needs to be renamed in the block into which 
            it is copied. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">zz</span><span class="s3">, </span><span class="s1">tc</span><span class="s3">):</span>
            <span class="s1">lh </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tc</span><span class="s3">))</span>
            <span class="s1">lc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tc</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">nt </span><span class="s3">= </span><span class="s1">tc</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
                    <span class="s1">lh </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">zz</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">t</span><span class="s3">])</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
                    <span class="s1">lc </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">zz</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">t</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">lh</span><span class="s3">, </span><span class="s1">lc</span>

        <span class="s1">m </span><span class="s3">= </span><span class="s4">2</span>
        <span class="s1">zz </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">))</span>
        <span class="s1">tc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">zz</span><span class="s3">, </span><span class="s1">tc</span><span class="s3">, </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">0</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_multiple_call_getattr_object</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">B </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">negative</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">this_matters </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">)</span>
                <span class="s1">B </span><span class="s3">+= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">B</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_argument_alias_recarray_field</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test for issue4007.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)):</span>
                <span class="s1">n</span><span class="s3">.</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">7.0</span>
            <span class="s2">return </span><span class="s1">n</span>
        <span class="s1">X1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s5">'x'</span><span class="s3">, </span><span class="s1">float</span><span class="s3">), (</span><span class="s5">'y'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">), ])</span>
        <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s5">'x'</span><span class="s3">, </span><span class="s1">float</span><span class="s3">), (</span><span class="s5">'y'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">), ])</span>
        <span class="s1">X3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s5">'x'</span><span class="s3">, </span><span class="s1">float</span><span class="s3">), (</span><span class="s5">'y'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">), ])</span>
        <span class="s1">v1 </span><span class="s3">= </span><span class="s1">X1</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">recarray</span><span class="s3">)</span>
        <span class="s1">v2 </span><span class="s3">= </span><span class="s1">X2</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">recarray</span><span class="s3">)</span>
        <span class="s1">v3 </span><span class="s3">= </span><span class="s1">X3</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">recarray</span><span class="s3">)</span>

        <span class="s0"># Numpy doesn't seem to support almost equal on recarray.</span>
        <span class="s0"># So, we convert to list and use assertEqual instead.</span>
        <span class="s1">python_res </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">))</span>
        <span class="s1">njit_res </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)(</span><span class="s1">v2</span><span class="s3">))</span>
        <span class="s1">pa_func </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">pa_res </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">pa_func</span><span class="s3">(</span><span class="s1">v3</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">python_res</span><span class="s3">, </span><span class="s1">njit_res</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">python_res</span><span class="s3">, </span><span class="s1">pa_res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_mutable_list_param</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; issue3699: test that mutable variable to call in loop 
            is not hoisted.  The call in test_impl forces a manual 
            check here rather than using prange_tester. 
        &quot;&quot;&quot;</span>
        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">list_check</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s6">&quot;&quot;&quot; If the variable X is hoisted in the test_impl prange 
                then subsequent list_check calls would return increasing 
                values. 
            &quot;&quot;&quot;</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] + </span><span class="s4">1</span>
            <span class="s1">X</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">X </span><span class="s3">= [</span><span class="s4">100</span><span class="s3">]</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">list_check</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a</span>
        <span class="s1">python_res </span><span class="s3">= </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">njit_res </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">pa_func </span><span class="s3">= </span><span class="s1">njit</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">pa_res </span><span class="s3">= </span><span class="s1">pa_func</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">python_res</span><span class="s3">, </span><span class="s1">njit_res</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">python_res</span><span class="s3">, </span><span class="s1">pa_res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_list_comprehension_prange</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue4569</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))])</span>
        <span class="s1">x </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s3">,</span><span class="s4">3</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">),</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_ssa_false_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5698</span>
        <span class="s0"># SSA for h creates assignments to h that make it look like a</span>
        <span class="s0"># reduction variable except that it lacks an associated</span>
        <span class="s0"># reduction operator.  Test here that h is excluded as a</span>
        <span class="s0"># reduction variable.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">image</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">empty </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">image</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">image</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">image</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] / </span><span class="s4">255.0</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">h </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s2">if </span><span class="s1">b </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">h </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s1">empty</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = [</span><span class="s1">h</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">h</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">empty</span>

        <span class="s1">image </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">image</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_list_setitem_hoisting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue5979</span>
        <span class="s0"># Don't hoist list initialization if list item set.</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">5</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">5</span><span class="s3">):</span>
                <span class="s1">X </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">]</span>
                <span class="s1">X</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">X</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_tuple_hoisting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue9529</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">):</span>
            <span class="s1">outputs </span><span class="s3">= [(</span><span class="s1">Dict</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">key_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">))]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">)):</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">i</span>
                <span class="s1">outputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = (</span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">out</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">outputs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">1</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">N </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, [</span><span class="s1">Dict</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">key_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)], </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_call_hoisting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue9529</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">):</span>
            <span class="s1">outputs </span><span class="s3">= [(</span><span class="s1">Dict</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">key_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">))]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">)):</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">i</span>
                <span class="s1">outputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">test_call_hoisting_outcall</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">out</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">outputs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">1</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">N </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, [</span><span class="s1">Dict</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">key_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)], </span><span class="s1">patch_instance</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_record_array_setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># issue6704</span>
        <span class="s1">state_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">([(</span><span class="s5">'var'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)])</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">states</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">states</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s5">'var'</span><span class="s3">] = </span><span class="s4">1</span>

        <span class="s2">def </span><span class="s1">comparer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">assert</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s5">'var'</span><span class="s3">] == </span><span class="s1">b</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s5">'var'</span><span class="s3">])</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,</span>
                           <span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">state_dtype</span><span class="s3">),</span>
                           <span class="s1">check_arg_equality</span><span class="s3">=[</span><span class="s1">comparer</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_record_array_setitem_yield_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">state_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">([(</span><span class="s5">'x'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)])</span>

        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">states</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">states</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">states</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
                <span class="s1">states</span><span class="s3">[</span><span class="s5">&quot;x&quot;</span><span class="s3">][</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">7 </span><span class="s3">+ </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">states</span>

        <span class="s1">states </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">state_dtype</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">comparer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">,</span>
                           <span class="s1">states</span><span class="s3">,</span>
                           <span class="s1">check_arg_equality</span><span class="s3">=[</span><span class="s1">comparer</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">test_issue7501</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">case</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">size</span><span class="s3">,))</span>
            <span class="s2">if </span><span class="s1">case </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                    <span class="s1">result</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
                    <span class="s1">result</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">result</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_kde_example</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s0"># KDE example</span>
            <span class="s1">b </span><span class="s3">= </span><span class="s4">0.5</span>
            <span class="s1">points </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">])</span>
            <span class="s1">N </span><span class="s3">= </span><span class="s1">points</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">exps </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">d </span><span class="s3">= (-(</span><span class="s1">p </span><span class="s3">- </span><span class="s1">points</span><span class="s3">)**</span><span class="s4">2</span><span class="s3">) / (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">b</span><span class="s3">**</span><span class="s4">2</span><span class="s3">)</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">d</span><span class="s3">)</span>
                <span class="s1">exps </span><span class="s3">+= </span><span class="s1">m </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">b </span><span class="s3">* </span><span class="s1">N</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">d </span><span class="s3">- </span><span class="s1">m</span><span class="s3">)))</span>
            <span class="s2">return </span><span class="s1">exps</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s4">128</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">ranf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
    <span class="s2">def </span><span class="s1">test_issue7578</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s0"># this can be any 1-arity ufunc</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">tmp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

            <span class="s2">return </span><span class="s1">A</span>

        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10.</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prange_tester</span><span class="s3">(</span><span class="s1">test_impl</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforChunksizing</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Tests chunksize handling in ParallelAccelerator. 
    &quot;&quot;&quot;</span>
    <span class="s1">_numba_parallel_test_ </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">setUp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">tearDown</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_python_parallel_chunksize_basic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test basic chunksize operations outside njit.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_python_with_chunksize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test &quot;with parallel_chunksize&quot; outside njit.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">parallel_chunksize</span><span class="s3">(</span><span class="s4">8</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_parallel_chunksize</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_njit_parallel_chunksize_basic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test basic chunksize operations inside njit.</span>
        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">get_cs</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">get_parallel_chunksize</span><span class="s3">()</span>

        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">set_cs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_cs</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">set_cs</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_cs</span><span class="s3">(), </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">set_cs</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">get_cs</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_njit_with_chunksize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test &quot;with parallel_chunksize&quot; inside njit.</span>
        <span class="s3">@</span><span class="s1">njit</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">cs1 </span><span class="s3">= </span><span class="s1">get_parallel_chunksize</span><span class="s3">()</span>
            <span class="s2">with </span><span class="s1">parallel_chunksize</span><span class="s3">(</span><span class="s4">8</span><span class="s3">):</span>
                <span class="s1">cs2 </span><span class="s3">= </span><span class="s1">get_parallel_chunksize</span><span class="s3">()</span>
            <span class="s1">cs3 </span><span class="s3">= </span><span class="s1">get_parallel_chunksize</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">cs1</span><span class="s3">, </span><span class="s1">cs2</span><span class="s3">, </span><span class="s1">cs3</span>

        <span class="s1">cs1</span><span class="s3">, </span><span class="s1">cs2</span><span class="s3">, </span><span class="s1">cs3 </span><span class="s3">= </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">cs1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">cs2</span><span class="s3">, </span><span class="s4">8</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">cs3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_all_iterations_reset_chunksize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; Test that all the iterations get run if you set the 
            chunksize.  Also check that the chunksize that each 
            worker thread sees has been reset to 0. &quot;&quot;&quot;</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">cs</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">inner_cs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, -</span><span class="s4">13</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parallel_chunksize</span><span class="s3">(</span><span class="s1">cs</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">inner_cs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">get_parallel_chunksize</span><span class="s3">()</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">13</span>
            <span class="s2">return </span><span class="s1">res</span><span class="s3">, </span><span class="s1">inner_cs</span>

        <span class="s0"># Test a variety of array and chunk sizes.</span>
        <span class="s0"># 1000 is a round number, 997 is prime, 943 is product of two</span>
        <span class="s0"># primes, 961 is square of a prime.</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s3">[</span><span class="s4">1000</span><span class="s3">, </span><span class="s4">997</span><span class="s3">, </span><span class="s4">943</span><span class="s3">, </span><span class="s4">961</span><span class="s3">]:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">15</span><span class="s3">):</span>
                <span class="s1">res</span><span class="s3">, </span><span class="s1">inner_cs </span><span class="s3">= </span><span class="s1">test_impl</span><span class="s3">(</span><span class="s1">i</span><span class="s3">+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">res </span><span class="s3">== </span><span class="s4">13</span><span class="s3">))</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">inner_cs </span><span class="s3">== </span><span class="s4">0</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_njit_parallel_chunksize_negative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test negative set_parallel_chunksize inside njit.</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">njit</span>
            <span class="s2">def </span><span class="s1">neg_test</span><span class="s3">():</span>
                <span class="s1">set_parallel_chunksize</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">)</span>

            <span class="s1">neg_test</span><span class="s3">()</span>

        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;chunksize must be greater than or equal to zero&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_python_parallel_chunksize_negative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Test negative set_parallel_chunksize outside njit.</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s1">set_parallel_chunksize</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">)</span>

        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;chunksize must be greater than or equal to zero&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_njit_parallel_chunksize_invalid_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">njit</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
                <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s5">'invalid_type'</span><span class="s3">)</span>

            <span class="s1">impl</span><span class="s3">()</span>

        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;The parallel chunksize must be an integer&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">test_python_parallel_chunksize_invalid_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">assertRaises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">raised</span><span class="s3">:</span>
            <span class="s1">set_parallel_chunksize</span><span class="s3">(</span><span class="s5">'invalid_type'</span><span class="s3">)</span>

        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;The parallel chunksize must be an integer&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">raised</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s3">@</span><span class="s1">x86_only</span>
<span class="s2">class </span><span class="s1">TestParforsVectorizer</span><span class="s3">(</span><span class="s1">TestPrangeBase</span><span class="s3">):</span>

    <span class="s0"># env mutating test</span>
    <span class="s1">_numba_parallel_test_ </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">schedule_type</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>

        <span class="s1">fastmath </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'fastmath'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">cpu_name </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'cpu_name'</span><span class="s3">, </span><span class="s5">'skylake-avx512'</span><span class="s3">)</span>
        <span class="s1">assertions </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'assertions'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s0"># force LLVM to use zmm registers for vectorization</span>
        <span class="s0"># https://reviews.llvm.org/D67259</span>
        <span class="s1">cpu_features </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'cpu_features'</span><span class="s3">, </span><span class="s5">'-prefer-256-bit'</span><span class="s3">)</span>

        <span class="s1">env_opts </span><span class="s3">= {</span><span class="s5">'NUMBA_CPU_NAME'</span><span class="s3">: </span><span class="s1">cpu_name</span><span class="s3">,</span>
                    <span class="s5">'NUMBA_CPU_FEATURES'</span><span class="s3">: </span><span class="s1">cpu_features</span><span class="s3">,</span>
                    <span class="s3">}</span>

        <span class="s1">overrides </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">env_opts</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">overrides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">override_env_config</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">))</span>

        <span class="s2">with </span><span class="s1">overrides</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">overrides</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]:</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>
            <span class="s1">pfunc_vectorizable </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">generate_prange_func</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">fastmath </span><span class="s3">== </span><span class="s2">True</span><span class="s3">:</span>
                <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel_fastmath</span><span class="s3">(</span><span class="s1">pfunc_vectorizable</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">cres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile_parallel</span><span class="s3">(</span><span class="s1">pfunc_vectorizable</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

            <span class="s0"># get the gufunc asm</span>
            <span class="s1">asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_gufunc_asm</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">assertions</span><span class="s3">:</span>
                <span class="s1">schedty </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'call\s+\w+\*\s+@do_scheduling_(\w+)\('</span><span class="s3">)</span>
                <span class="s1">matches </span><span class="s3">= </span><span class="s1">schedty</span><span class="s3">.</span><span class="s1">findall</span><span class="s3">(</span><span class="s1">cres</span><span class="s3">.</span><span class="s1">library</span><span class="s3">.</span><span class="s1">get_llvm_str</span><span class="s3">())</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertGreaterEqual</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">matches</span><span class="s3">), </span><span class="s4">1</span><span class="s3">) </span><span class="s0"># at least 1 parfor call</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">matches</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">schedule_type</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">assertNotEqual</span><span class="s3">(</span><span class="s1">asm</span><span class="s3">, {})</span>

            <span class="s2">return </span><span class="s1">asm</span>

    <span class="s3">@</span><span class="s1">linux_only</span>
    <span class="s3">@</span><span class="s1">TestCase</span><span class="s3">.</span><span class="s1">run_test_in_subprocess</span>
    <span class="s2">def </span><span class="s1">test_vectorizer_fastmath_asm</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; This checks that if fastmath is set and the underlying hardware 
        is suitable, and the function supplied is amenable to fastmath based 
        vectorization, that the vectorizer actually runs. 
        &quot;&quot;&quot;</span>

        <span class="s0"># This function will benefit from `fastmath` if run on a suitable</span>
        <span class="s0"># target. The vectorizer should unwind the loop and generate</span>
        <span class="s0"># packed dtype=double add and sqrt instructions.</span>
        <span class="s2">def </span><span class="s1">will_vectorize</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">arg </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

        <span class="s1">fast_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">will_vectorize</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">,</span>
                                       <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">slow_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">will_vectorize</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">,</span>
                                       <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">fast_asm</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s0"># should unwind and call vector sqrt then vector add</span>
            <span class="s0"># all on packed doubles using zmm's</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vaddpd' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtpd' </span><span class="s2">in </span><span class="s1">v </span><span class="s2">or </span><span class="s5">'__svml_sqrt' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'zmm' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">slow_asm</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s0"># vector variants should not be present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vaddpd' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtpd' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s0"># check scalar variant is present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtsd' </span><span class="s2">in </span><span class="s1">v </span><span class="s2">and </span><span class="s5">'__svml_sqrt' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vaddsd' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s0"># check no zmm addressing is present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'zmm' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">linux_only</span>
    <span class="s3">@</span><span class="s1">TestCase</span><span class="s3">.</span><span class="s1">run_test_in_subprocess</span><span class="s3">(</span><span class="s1">envvars</span><span class="s3">={</span><span class="s5">'NUMBA_BOUNDSCHECK'</span><span class="s3">: </span><span class="s5">'0'</span><span class="s3">})</span>
    <span class="s2">def </span><span class="s1">test_unsigned_refusal_to_vectorize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; This checks that if fastmath is set and the underlying hardware 
        is suitable, and the function supplied is amenable to fastmath based 
        vectorization, that the vectorizer actually runs. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">will_not_vectorize</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">n</span><span class="s3">, </span><span class="s4">0</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s2">def </span><span class="s1">will_vectorize</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s1">arg </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

        <span class="s0"># Boundschecking breaks vectorization</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">config</span><span class="s3">.</span><span class="s1">BOUNDSCHECK</span><span class="s3">)</span>
        <span class="s1">novec_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">will_not_vectorize</span><span class="s3">, </span><span class="s5">'signed'</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">,</span>
                                        <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">vec_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">will_vectorize</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">,</span>
                                        <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">novec_asm</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s0"># vector variant should not be present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtpd' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s0"># check scalar variant is present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtsd' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s0"># check no zmm addressing is present</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'zmm' </span><span class="s2">not in </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vec_asm</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s0"># should unwind and call vector sqrt then vector mov</span>
            <span class="s0"># all on packed doubles using zmm's</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vsqrtpd' </span><span class="s2">in </span><span class="s1">v </span><span class="s2">or </span><span class="s5">'__svml_sqrt' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'vmovupd' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">assertTrue</span><span class="s3">(</span><span class="s5">'zmm' </span><span class="s2">in </span><span class="s1">v</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">linux_only</span>
    <span class="s0"># needed as 32bit doesn't have equivalent signed/unsigned instruction</span>
    <span class="s0"># generation for this function</span>
    <span class="s3">@</span><span class="s1">TestCase</span><span class="s3">.</span><span class="s1">run_test_in_subprocess</span><span class="s3">(</span><span class="s1">envvars</span><span class="s3">={</span><span class="s5">'NUMBA_BOUNDSCHECK'</span><span class="s3">: </span><span class="s5">'0'</span><span class="s3">})</span>
    <span class="s2">def </span><span class="s1">test_signed_vs_unsigned_vec_asm</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; This checks vectorization for signed vs unsigned variants of a 
        trivial accumulator, the only meaningful difference should be the 
        presence of signed vs. unsigned unpack instructions (for the 
        induction var). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">signed_variant</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4096</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s4">0.</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(-</span><span class="s1">n</span><span class="s3">, </span><span class="s4">0</span><span class="s3">):</span>
                <span class="s1">A </span><span class="s3">+= </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s2">def </span><span class="s1">unsigned_variant</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s4">4096</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s4">0.</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">A </span><span class="s3">+= </span><span class="s1">i</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s0"># Boundschecking breaks the diff check below because of the pickled exception</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertFalse</span><span class="s3">(</span><span class="s1">config</span><span class="s3">.</span><span class="s1">BOUNDSCHECK</span><span class="s3">)</span>
        <span class="s1">signed_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">signed_variant</span><span class="s3">, </span><span class="s5">'signed'</span><span class="s3">,</span>
                                            <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">unsigned_asm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_gufunc_asm</span><span class="s3">(</span><span class="s1">unsigned_variant</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">,</span>
                                            <span class="s1">fastmath</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">strip_instrs</span><span class="s3">(</span><span class="s1">asm</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">asm</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">():</span>
                <span class="s1">spd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()</span>
                <span class="s0"># filter out anything that isn't a trivial instruction</span>
                <span class="s0"># and anything with the gufunc id as it contains an address</span>
                <span class="s2">if </span><span class="s1">spd </span><span class="s3">!= </span><span class="s5">'' </span><span class="s2">and not </span><span class="s3">(</span><span class="s1">spd</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)</span>
                                     <span class="s2">or </span><span class="s1">spd</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">)</span>
                                     <span class="s2">or </span><span class="s1">spd</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'&quot;'</span><span class="s3">)</span>
                                     <span class="s2">or </span><span class="s5">'__numba_parfor_gufunc' </span><span class="s2">in </span><span class="s1">spd</span><span class="s3">):</span>
                        <span class="s1">acc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">re</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s5">'[</span><span class="s2">\t</span><span class="s5">]'</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">spd</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">signed_asm</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">signed_instr </span><span class="s3">= </span><span class="s1">strip_instrs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s2">break</span>

        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">unsigned_asm</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">unsigned_instr </span><span class="s3">= </span><span class="s1">strip_instrs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s2">break</span>

        <span class="s2">from </span><span class="s1">difflib </span><span class="s2">import </span><span class="s1">SequenceMatcher </span><span class="s2">as </span><span class="s1">sm</span>
        <span class="s0"># make sure that the only difference in instruction (if there is a</span>
        <span class="s0"># difference) is the char 'u'. For example:</span>
        <span class="s0"># vcvtsi2sdq vs. vcvtusi2sdq</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">signed_instr</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unsigned_instr</span><span class="s3">))</span>
        <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">signed_instr</span><span class="s3">, </span><span class="s1">unsigned_instr</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s3">== </span><span class="s1">b</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">sm</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x </span><span class="s3">== </span><span class="s5">'</span><span class="s2">\t</span><span class="s5">'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>
                <span class="s1">ops </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">get_opcodes</span><span class="s3">()</span>
                <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">op</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s5">'insert'</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertEqual</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">op</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]:</span><span class="s1">op</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]], </span><span class="s5">'u'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestParforReductionSetNumThreads</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Test execution correctness on reductions with set_num_threads. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">test_add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">N</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">N </span><span class="s3">- </span><span class="s4">1</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
                <span class="s1">local_mask </span><span class="s3">= </span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">% </span><span class="s1">mask</span>
                <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">local_mask</span><span class="s3">)</span>
                <span class="s1">gnt </span><span class="s3">= </span><span class="s1">get_num_threads</span><span class="s3">()</span>
                <span class="s1">acc </span><span class="s3">+= </span><span class="s1">gnt</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">expect </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">got </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">expect</span><span class="s3">, </span><span class="s1">got</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_mul</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This min will prevent larger thread counts from generating</span>
        <span class="s0"># overflow in the loop below.</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s4">4</span><span class="s3">, </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS</span><span class="s3">)</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">N</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">N </span><span class="s3">- </span><span class="s4">1</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
                <span class="s1">local_mask </span><span class="s3">= </span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">% </span><span class="s1">mask</span>
                <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">local_mask</span><span class="s3">)</span>
                <span class="s1">gnt </span><span class="s3">= </span><span class="s1">get_num_threads</span><span class="s3">()</span>
                <span class="s1">acc </span><span class="s3">*= </span><span class="s1">gnt</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">expect </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">got </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">expect</span><span class="s3">, </span><span class="s1">got</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">config</span><span class="s3">.</span><span class="s1">NUMBA_NUM_THREADS</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">N</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">N </span><span class="s3">- </span><span class="s4">1</span>

        <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">):</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">nthreads</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
                <span class="s1">local_mask </span><span class="s3">= </span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">% </span><span class="s1">mask</span>
                <span class="s1">set_num_threads</span><span class="s3">(</span><span class="s1">local_mask</span><span class="s3">)</span>
                <span class="s1">gnt </span><span class="s3">= </span><span class="s1">get_num_threads</span><span class="s3">()</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">acc</span><span class="s3">, </span><span class="s1">gnt</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">acc</span>

        <span class="s1">expect </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">.</span><span class="s1">py_func</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">got </span><span class="s3">= </span><span class="s1">udt</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertPreciseEqual</span><span class="s3">(</span><span class="s1">expect</span><span class="s3">, </span><span class="s1">got</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">skip_parfors_unsupported</span>
<span class="s2">class </span><span class="s1">TestDiagnosticEnvVar</span><span class="s3">(</span><span class="s1">TestCase</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">TestCase</span><span class="s3">.</span><span class="s1">run_test_in_subprocess</span><span class="s3">()</span>
    <span class="s2">def </span><span class="s1">test_diagnostics_env_var1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s5">'NUMBA_PARALLEL_DIAGNOSTICS'</span><span class="s3">]=</span><span class="s5">'4'</span>
        <span class="s2">with </span><span class="s1">captured_stdout</span><span class="s3">() </span><span class="s2">as </span><span class="s1">stdout</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">njit</span><span class="s3">(</span><span class="s1">parallel</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">():</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s4">100</span>
                <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1</span>
                <span class="s2">return </span><span class="s1">b</span>

            <span class="s1">impl</span><span class="s3">()</span>
        <span class="s1">the_output </span><span class="s3">= </span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">assertIn</span><span class="s3">(</span><span class="s5">&quot;Parallel Accelerator Optimizing&quot;</span><span class="s3">, </span><span class="s1">the_output</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s5">&quot;__main__&quot;</span><span class="s3">:</span>
    <span class="s1">unittest</span><span class="s3">.</span><span class="s1">main</span><span class="s3">()</span>
</pre>
</body>
</html>