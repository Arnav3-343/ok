<html>
<head>
<title>npydecl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
npydecl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span><span class="s2">, </span><span class="s1">utils</span><span class="s2">, </span><span class="s1">config</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">templates </span><span class="s0">import </span><span class="s2">(</span><span class="s1">AttributeTemplate</span><span class="s2">, </span><span class="s1">AbstractTemplate</span><span class="s2">,</span>
                                         <span class="s1">CallableTemplate</span><span class="s2">, </span><span class="s1">Registry</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">)</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">numpy_support </span><span class="s0">import </span><span class="s2">(</span><span class="s1">ufunc_find_matching_loop</span><span class="s2">,</span>
                             <span class="s1">supported_ufunc_loop</span><span class="s2">, </span><span class="s1">as_dtype</span><span class="s2">,</span>
                             <span class="s1">from_dtype</span><span class="s2">, </span><span class="s1">as_dtype</span><span class="s2">, </span><span class="s1">resolve_output_type</span><span class="s2">,</span>
                             <span class="s1">carray</span><span class="s2">, </span><span class="s1">farray</span><span class="s2">, </span><span class="s1">_ufunc_loop_sig</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s2">(</span><span class="s1">TypingError</span><span class="s2">, </span><span class="s1">NumbaPerformanceWarning</span><span class="s2">,</span>
                               <span class="s1">NumbaTypeError</span><span class="s2">, </span><span class="s1">NumbaAssertionError</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">pndindex</span>

<span class="s1">registry </span><span class="s2">= </span><span class="s1">Registry</span><span class="s2">()</span>
<span class="s1">infer </span><span class="s2">= </span><span class="s1">registry</span><span class="s2">.</span><span class="s1">register</span>
<span class="s1">infer_global </span><span class="s2">= </span><span class="s1">registry</span><span class="s2">.</span><span class="s1">register_global</span>
<span class="s1">infer_getattr </span><span class="s2">= </span><span class="s1">registry</span><span class="s2">.</span><span class="s1">register_attr</span>


<span class="s0">class </span><span class="s1">Numpy_rules_ufunc</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_handle_inputs</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process argument types to a given *ufunc*. 
        Returns a (base types, explicit outputs, ndims, layout) tuple where: 
        - `base types` is a tuple of scalar types for each input 
        - `explicit outputs` is a tuple of explicit output types (arrays) 
        - `ndims` is the number of dimensions of the loop and also of 
          any outputs, explicit or implicit 
        - `layout` is the layout for any implicit output to be allocated 
        &quot;&quot;&quot;</span>
        <span class="s1">nin </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span>
        <span class="s1">nout </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout</span>
        <span class="s1">nargs </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nargs</span>

        <span class="s4"># preconditions</span>
        <span class="s0">assert </span><span class="s1">nargs </span><span class="s2">== </span><span class="s1">nin </span><span class="s2">+ </span><span class="s1">nout</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) &lt; </span><span class="s1">nin</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}': not enough arguments ({1} found, {2} required)&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">), </span><span class="s1">nin</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) &gt; </span><span class="s1">nargs</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}': too many arguments ({1} found, {2} maximum)&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">), </span><span class="s1">nargs</span><span class="s2">))</span>

        <span class="s1">args </span><span class="s2">= [</span><span class="s1">a</span><span class="s2">.</span><span class="s1">as_array </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">) </span><span class="s0">else </span><span class="s1">a</span>
                <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>
        <span class="s1">arg_ndims </span><span class="s2">= [</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">) </span><span class="s0">else </span><span class="s6">0</span>
                     <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>
        <span class="s1">ndims </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">arg_ndims</span><span class="s2">)</span>

        <span class="s4"># explicit outputs must be arrays (no explicit scalar return values supported)</span>
        <span class="s1">explicit_outputs </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s1">nin</span><span class="s2">:]</span>

        <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">output</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">)</span>
                   <span class="s0">for </span><span class="s1">output </span><span class="s0">in </span><span class="s1">explicit_outputs</span><span class="s2">):</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}' called with an explicit output that is not an array&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">))</span>

        <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">output</span><span class="s2">.</span><span class="s1">mutable </span><span class="s0">for </span><span class="s1">output </span><span class="s0">in </span><span class="s1">explicit_outputs</span><span class="s2">):</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}' called with an explicit output that is read-only&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">))</span>

        <span class="s4"># find the kernel to use, based only in the input types (as does NumPy)</span>
        <span class="s1">base_types </span><span class="s2">= [</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">) </span><span class="s0">else </span><span class="s1">x</span>
                      <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>

        <span class="s4"># Figure out the output array layout, if needed.</span>
        <span class="s1">layout </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">ndims </span><span class="s2">&gt; </span><span class="s6">0 </span><span class="s0">and </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">) &lt; </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout</span><span class="s2">):</span>
            <span class="s1">layout </span><span class="s2">= </span><span class="s5">'C'</span>
            <span class="s1">layouts </span><span class="s2">= [</span><span class="s1">x</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">) </span><span class="s0">else </span><span class="s5">''</span>
                       <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>

            <span class="s4"># Prefer C contig if any array is C contig.</span>
            <span class="s4"># Next, prefer F contig.</span>
            <span class="s4"># Defaults to C contig if not layouts are C/F.</span>
            <span class="s0">if </span><span class="s5">'C' </span><span class="s0">not in </span><span class="s1">layouts </span><span class="s0">and </span><span class="s5">'F' </span><span class="s0">in </span><span class="s1">layouts</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'F'</span>

        <span class="s0">return </span><span class="s1">base_types</span><span class="s2">, </span><span class="s1">explicit_outputs</span><span class="s2">, </span><span class="s1">ndims</span><span class="s2">, </span><span class="s1">layout</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s4"># First, strip optional types, ufunc loops are typed on concrete types</span>
        <span class="s1">args </span><span class="s2">= [</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">) </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>

        <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ufunc</span>
        <span class="s1">base_types</span><span class="s2">, </span><span class="s1">explicit_outputs</span><span class="s2">, </span><span class="s1">ndims</span><span class="s2">, </span><span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_inputs</span><span class="s2">(</span>
            <span class="s1">ufunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>
        <span class="s1">ufunc_loop </span><span class="s2">= </span><span class="s1">ufunc_find_matching_loop</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">base_types</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">ufunc_loop </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;can't resolve ufunc {0} for types {1}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">args</span><span class="s2">))</span>

        <span class="s4"># check if all the types involved in the ufunc loop are supported in this mode</span>
        <span class="s0">if not </span><span class="s1">supported_ufunc_loop</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">ufunc_loop</span><span class="s2">):</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}' using the loop '{1}' not supported in this mode&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">ufunc_loop</span><span class="s2">.</span><span class="s1">ufunc_sig</span><span class="s2">))</span>

        <span class="s4"># if there is any explicit output type, check that it is valid</span>
        <span class="s1">explicit_outputs_np </span><span class="s2">= [</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">explicit_outputs</span><span class="s2">]</span>

        <span class="s4"># Numpy will happily use unsafe conversions (although it will actually warn)</span>
        <span class="s0">if not </span><span class="s1">all </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">can_cast</span><span class="s2">(</span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s5">'unsafe'</span><span class="s2">) </span><span class="s0">for </span><span class="s2">(</span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">) </span><span class="s0">in</span>
                    <span class="s1">zip</span><span class="s2">(</span><span class="s1">ufunc_loop</span><span class="s2">.</span><span class="s1">numpy_outputs</span><span class="s2">, </span><span class="s1">explicit_outputs_np</span><span class="s2">)):</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;ufunc '{0}' can't cast result to explicit result type&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">))</span>

        <span class="s4"># A valid loop was found that is compatible. The result of type inference should</span>
        <span class="s4"># be based on the explicit output types, and when not available with the type given</span>
        <span class="s4"># by the selected NumPy loop</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">)</span>
        <span class="s1">implicit_output_count </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">explicit_outputs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">implicit_output_count </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># XXX this is sometimes wrong for datetime64 and timedelta64,</span>
            <span class="s4"># as ufunc_find_matching_loop() doesn't do any type inference</span>
            <span class="s1">ret_tys </span><span class="s2">= </span><span class="s1">ufunc_loop</span><span class="s2">.</span><span class="s1">outputs</span><span class="s2">[-</span><span class="s1">implicit_output_count</span><span class="s2">:]</span>
            <span class="s0">if </span><span class="s1">ndims </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s1">layout </span><span class="s0">is not None</span>
                <span class="s4"># If either of the types involved in the ufunc operation have a</span>
                <span class="s4"># __array_ufunc__ method then invoke the first such one to</span>
                <span class="s4"># determine the output type of the ufunc.</span>
                <span class="s1">array_ufunc_type </span><span class="s2">= </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s5">&quot;__array_ufunc__&quot;</span><span class="s2">):</span>
                        <span class="s1">array_ufunc_type </span><span class="s2">= </span><span class="s1">a</span>
                        <span class="s0">break</span>
                <span class="s1">output_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span>
                <span class="s0">if </span><span class="s1">array_ufunc_type </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">output_type </span><span class="s2">= </span><span class="s1">array_ufunc_type</span><span class="s2">.</span><span class="s1">__array_ufunc__</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s5">&quot;__call__&quot;</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">output_type </span><span class="s0">is </span><span class="s1">NotImplemented</span><span class="s2">:</span>
                        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">f&quot;unsupported use of ufunc </span><span class="s0">{</span><span class="s1">ufunc</span><span class="s0">} </span><span class="s5">on &quot;</span>
                               <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">array_ufunc_type</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                        <span class="s4"># raise TypeError here because</span>
                        <span class="s4"># NumpyRulesArrayOperator.generic is capturing</span>
                        <span class="s4"># TypingError</span>
                        <span class="s0">raise </span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                    <span class="s0">elif not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">output_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
                        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">f&quot;ufunc </span><span class="s0">{</span><span class="s1">ufunc</span><span class="s0">} </span><span class="s5">on </span><span class="s0">{</span><span class="s1">array_ufunc_type</span><span class="s0">}</span><span class="s5">&quot;</span>
                               <span class="s5">f&quot;cannot return non-array </span><span class="s0">{</span><span class="s1">output_type</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
                        <span class="s4"># raise TypeError here because</span>
                        <span class="s4"># NumpyRulesArrayOperator.generic is capturing</span>
                        <span class="s4"># TypingError</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

                <span class="s1">ret_tys </span><span class="s2">= [</span><span class="s1">output_type</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ret_ty</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndims</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s1">layout</span><span class="s2">)</span>
                           <span class="s0">for </span><span class="s1">ret_ty </span><span class="s0">in </span><span class="s1">ret_tys</span><span class="s2">]</span>
                <span class="s1">ret_tys </span><span class="s2">= [</span><span class="s1">resolve_output_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">ret_ty</span><span class="s2">)</span>
                           <span class="s0">for </span><span class="s1">ret_ty </span><span class="s0">in </span><span class="s1">ret_tys</span><span class="s2">]</span>
            <span class="s1">out</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">ret_tys</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">_ufunc_loop_sig</span><span class="s2">(</span><span class="s1">out</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NumpyRulesArrayOperator</span><span class="s2">(</span><span class="s1">Numpy_rules_ufunc</span><span class="s2">):</span>
    <span class="s1">_op_map </span><span class="s2">= {</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">add</span><span class="s2">: </span><span class="s5">&quot;add&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">: </span><span class="s5">&quot;subtract&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">: </span><span class="s5">&quot;multiply&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">truediv</span><span class="s2">: </span><span class="s5">&quot;true_divide&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">floordiv</span><span class="s2">: </span><span class="s5">&quot;floor_divide&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">mod</span><span class="s2">: </span><span class="s5">&quot;remainder&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">pow</span><span class="s2">: </span><span class="s5">&quot;power&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">lshift</span><span class="s2">: </span><span class="s5">&quot;left_shift&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">rshift</span><span class="s2">: </span><span class="s5">&quot;right_shift&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">: </span><span class="s5">&quot;bitwise_and&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">: </span><span class="s5">&quot;bitwise_or&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">xor</span><span class="s2">: </span><span class="s5">&quot;bitwise_xor&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">: </span><span class="s5">&quot;equal&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">gt</span><span class="s2">: </span><span class="s5">&quot;greater&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ge</span><span class="s2">: </span><span class="s5">&quot;greater_equal&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span><span class="s2">: </span><span class="s5">&quot;less&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span><span class="s2">: </span><span class="s5">&quot;less_equal&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">: </span><span class="s5">&quot;not_equal&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ufunc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_op_map</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">install_operations</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">ufunc_name </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_op_map</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">infer_global</span><span class="s2">(</span><span class="s1">op</span><span class="s2">)(</span>
                <span class="s1">type</span><span class="s2">(</span><span class="s5">&quot;NumpyRulesArrayOperator_&quot; </span><span class="s2">+ </span><span class="s1">ufunc_name</span><span class="s2">, (</span><span class="s1">cls</span><span class="s2">,), </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">op</span><span class="s2">))</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s3">'''Overloads and calls base class generic() method, returning 
        None if a TypingError occurred. 
 
        Returning None for operators is important since operators are 
        heavily overloaded, and by suppressing type errors, we allow 
        type inference to check other possibilities before giving up 
        (particularly user-defined operators). 
        '''</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyRulesArrayOperator</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">generic</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypingError</span><span class="s2">:</span>
            <span class="s0">return None</span>
        <span class="s0">if </span><span class="s1">sig </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return None</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s4"># Only accept at least one array argument, otherwise the operator</span>
        <span class="s4"># doesn't involve Numpy's ufunc machinery.</span>
        <span class="s0">if not </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">)</span>
                   <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">sig</span>


<span class="s1">_binop_map </span><span class="s2">= </span><span class="s1">NumpyRulesArrayOperator</span><span class="s2">.</span><span class="s1">_op_map</span>

<span class="s0">class </span><span class="s1">NumpyRulesInplaceArrayOperator</span><span class="s2">(</span><span class="s1">NumpyRulesArrayOperator</span><span class="s2">):</span>
    <span class="s1">_op_map </span><span class="s2">= {</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">iadd</span><span class="s2">: </span><span class="s5">&quot;add&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">isub</span><span class="s2">: </span><span class="s5">&quot;subtract&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">imul</span><span class="s2">: </span><span class="s5">&quot;multiply&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">itruediv</span><span class="s2">: </span><span class="s5">&quot;true_divide&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ifloordiv</span><span class="s2">: </span><span class="s5">&quot;floor_divide&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">imod</span><span class="s2">: </span><span class="s5">&quot;remainder&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ipow</span><span class="s2">: </span><span class="s5">&quot;power&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ilshift</span><span class="s2">: </span><span class="s5">&quot;left_shift&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">irshift</span><span class="s2">: </span><span class="s5">&quot;right_shift&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">iand</span><span class="s2">: </span><span class="s5">&quot;bitwise_and&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ior</span><span class="s2">: </span><span class="s5">&quot;bitwise_or&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">ixor</span><span class="s2">: </span><span class="s5">&quot;bitwise_xor&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s4"># Type the inplace operator as if an explicit output was passed,</span>
        <span class="s4"># to handle type resolution correctly.</span>
        <span class="s4"># (for example int8[:] += int16[:] should use an int8[:] output,</span>
        <span class="s4">#  not int16[:])</span>
        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">args </span><span class="s2">+ (</span><span class="s1">lhs</span><span class="s2">,)</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyRulesInplaceArrayOperator</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">generic</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>
        <span class="s4"># Strip off the fake explicit output</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">3</span>
        <span class="s1">real_sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, *</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[:</span><span class="s6">2</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">real_sig</span>


<span class="s0">class </span><span class="s1">NumpyRulesUnaryArrayOperator</span><span class="s2">(</span><span class="s1">NumpyRulesArrayOperator</span><span class="s2">):</span>
    <span class="s1">_op_map </span><span class="s2">= {</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">: </span><span class="s5">&quot;positive&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">neg</span><span class="s2">: </span><span class="s5">&quot;negative&quot;</span><span class="s2">,</span>
        <span class="s1">operator</span><span class="s2">.</span><span class="s1">invert</span><span class="s2">: </span><span class="s5">&quot;invert&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">(</span><span class="s1">NumpyRulesUnaryArrayOperator</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">generic</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">)</span>


<span class="s4"># list of unary ufuncs to register</span>

<span class="s1">math_operations </span><span class="s2">= [ </span><span class="s5">&quot;add&quot;</span><span class="s2">, </span><span class="s5">&quot;subtract&quot;</span><span class="s2">, </span><span class="s5">&quot;multiply&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;logaddexp&quot;</span><span class="s2">, </span><span class="s5">&quot;logaddexp2&quot;</span><span class="s2">, </span><span class="s5">&quot;true_divide&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;floor_divide&quot;</span><span class="s2">, </span><span class="s5">&quot;negative&quot;</span><span class="s2">, </span><span class="s5">&quot;positive&quot;</span><span class="s2">, </span><span class="s5">&quot;power&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;float_power&quot;</span><span class="s2">, </span><span class="s5">&quot;remainder&quot;</span><span class="s2">, </span><span class="s5">&quot;fmod&quot;</span><span class="s2">, </span><span class="s5">&quot;absolute&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;rint&quot;</span><span class="s2">, </span><span class="s5">&quot;sign&quot;</span><span class="s2">, </span><span class="s5">&quot;conjugate&quot;</span><span class="s2">, </span><span class="s5">&quot;exp&quot;</span><span class="s2">, </span><span class="s5">&quot;exp2&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;log&quot;</span><span class="s2">, </span><span class="s5">&quot;log2&quot;</span><span class="s2">, </span><span class="s5">&quot;log10&quot;</span><span class="s2">, </span><span class="s5">&quot;expm1&quot;</span><span class="s2">, </span><span class="s5">&quot;log1p&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;sqrt&quot;</span><span class="s2">, </span><span class="s5">&quot;square&quot;</span><span class="s2">, </span><span class="s5">&quot;cbrt&quot;</span><span class="s2">, </span><span class="s5">&quot;reciprocal&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;divide&quot;</span><span class="s2">, </span><span class="s5">&quot;mod&quot;</span><span class="s2">, </span><span class="s5">&quot;divmod&quot;</span><span class="s2">, </span><span class="s5">&quot;abs&quot;</span><span class="s2">, </span><span class="s5">&quot;fabs&quot; </span><span class="s2">, </span><span class="s5">&quot;gcd&quot;</span><span class="s2">, </span><span class="s5">&quot;lcm&quot;</span><span class="s2">]</span>

<span class="s1">trigonometric_functions </span><span class="s2">= [ </span><span class="s5">&quot;sin&quot;</span><span class="s2">, </span><span class="s5">&quot;cos&quot;</span><span class="s2">, </span><span class="s5">&quot;tan&quot;</span><span class="s2">, </span><span class="s5">&quot;arcsin&quot;</span><span class="s2">,</span>
                            <span class="s5">&quot;arccos&quot;</span><span class="s2">, </span><span class="s5">&quot;arctan&quot;</span><span class="s2">, </span><span class="s5">&quot;arctan2&quot;</span><span class="s2">,</span>
                            <span class="s5">&quot;hypot&quot;</span><span class="s2">, </span><span class="s5">&quot;sinh&quot;</span><span class="s2">, </span><span class="s5">&quot;cosh&quot;</span><span class="s2">, </span><span class="s5">&quot;tanh&quot;</span><span class="s2">,</span>
                            <span class="s5">&quot;arcsinh&quot;</span><span class="s2">, </span><span class="s5">&quot;arccosh&quot;</span><span class="s2">, </span><span class="s5">&quot;arctanh&quot;</span><span class="s2">,</span>
                            <span class="s5">&quot;deg2rad&quot;</span><span class="s2">, </span><span class="s5">&quot;rad2deg&quot;</span><span class="s2">, </span><span class="s5">&quot;degrees&quot;</span><span class="s2">,</span>
                            <span class="s5">&quot;radians&quot; </span><span class="s2">]</span>

<span class="s1">bit_twiddling_functions </span><span class="s2">= [</span><span class="s5">&quot;bitwise_and&quot;</span><span class="s2">, </span><span class="s5">&quot;bitwise_or&quot;</span><span class="s2">,</span>
                           <span class="s5">&quot;bitwise_xor&quot;</span><span class="s2">, </span><span class="s5">&quot;invert&quot;</span><span class="s2">,</span>
                           <span class="s5">&quot;left_shift&quot;</span><span class="s2">, </span><span class="s5">&quot;right_shift&quot;</span><span class="s2">,</span>
                           <span class="s5">&quot;bitwise_not&quot; </span><span class="s2">]</span>

<span class="s1">comparison_functions </span><span class="s2">= [ </span><span class="s5">&quot;greater&quot;</span><span class="s2">, </span><span class="s5">&quot;greater_equal&quot;</span><span class="s2">, </span><span class="s5">&quot;less&quot;</span><span class="s2">,</span>
                         <span class="s5">&quot;less_equal&quot;</span><span class="s2">, </span><span class="s5">&quot;not_equal&quot;</span><span class="s2">, </span><span class="s5">&quot;equal&quot;</span><span class="s2">,</span>
                         <span class="s5">&quot;logical_and&quot;</span><span class="s2">, </span><span class="s5">&quot;logical_or&quot;</span><span class="s2">,</span>
                         <span class="s5">&quot;logical_xor&quot;</span><span class="s2">, </span><span class="s5">&quot;logical_not&quot;</span><span class="s2">,</span>
                         <span class="s5">&quot;maximum&quot;</span><span class="s2">, </span><span class="s5">&quot;minimum&quot;</span><span class="s2">, </span><span class="s5">&quot;fmax&quot;</span><span class="s2">, </span><span class="s5">&quot;fmin&quot; </span><span class="s2">]</span>

<span class="s1">floating_functions </span><span class="s2">= [ </span><span class="s5">&quot;isfinite&quot;</span><span class="s2">, </span><span class="s5">&quot;isinf&quot;</span><span class="s2">, </span><span class="s5">&quot;isnan&quot;</span><span class="s2">, </span><span class="s5">&quot;signbit&quot;</span><span class="s2">,</span>
                       <span class="s5">&quot;copysign&quot;</span><span class="s2">, </span><span class="s5">&quot;nextafter&quot;</span><span class="s2">, </span><span class="s5">&quot;modf&quot;</span><span class="s2">, </span><span class="s5">&quot;ldexp&quot;</span><span class="s2">,</span>
                       <span class="s5">&quot;frexp&quot;</span><span class="s2">, </span><span class="s5">&quot;floor&quot;</span><span class="s2">, </span><span class="s5">&quot;ceil&quot;</span><span class="s2">, </span><span class="s5">&quot;trunc&quot;</span><span class="s2">,</span>
                       <span class="s5">&quot;spacing&quot; </span><span class="s2">]</span>

<span class="s1">logic_functions </span><span class="s2">= [ </span><span class="s5">&quot;isnat&quot; </span><span class="s2">]</span>


<span class="s4"># This is a set of the ufuncs that are not yet supported by Lowering. In order</span>
<span class="s4"># to trigger no-python mode we must not register them until their Lowering is</span>
<span class="s4"># implemented.</span>
<span class="s4">#</span>
<span class="s4"># It also works as a nice TODO list for ufunc support :)</span>
<span class="s1">_unsupported </span><span class="s2">= </span><span class="s1">set</span><span class="s2">([ </span><span class="s5">'frexp'</span><span class="s2">,</span>
                     <span class="s5">'modf'</span><span class="s2">,</span>
                 <span class="s2">])</span>


<span class="s0">def </span><span class="s1">register_numpy_ufunc</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">register_global</span><span class="s2">=</span><span class="s1">infer_global</span><span class="s2">):</span>
    <span class="s1">func </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
    <span class="s0">class </span><span class="s1">typing_class</span><span class="s2">(</span><span class="s1">Numpy_rules_ufunc</span><span class="s2">):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">func</span>

    <span class="s1">typing_class</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s5">&quot;resolve_{0}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s4"># A list of ufuncs that are in fact aliases of other ufuncs. They need to</span>
    <span class="s4"># insert the resolve method, but not register the ufunc itself</span>
    <span class="s1">aliases </span><span class="s2">= (</span><span class="s5">&quot;abs&quot;</span><span class="s2">, </span><span class="s5">&quot;bitwise_not&quot;</span><span class="s2">, </span><span class="s5">&quot;divide&quot;</span><span class="s2">, </span><span class="s5">&quot;abs&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">aliases</span><span class="s2">:</span>
        <span class="s1">register_global</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">typing_class</span><span class="s2">))</span>

<span class="s1">all_ufuncs </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">([</span><span class="s1">math_operations</span><span class="s2">, </span><span class="s1">trigonometric_functions</span><span class="s2">,</span>
                  <span class="s1">bit_twiddling_functions</span><span class="s2">, </span><span class="s1">comparison_functions</span><span class="s2">,</span>
                  <span class="s1">floating_functions</span><span class="s2">, </span><span class="s1">logic_functions</span><span class="s2">], [])</span>

<span class="s1">supported_ufuncs </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">all_ufuncs </span><span class="s0">if </span><span class="s1">x </span><span class="s0">not in </span><span class="s1">_unsupported</span><span class="s2">]</span>

<span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">supported_ufuncs</span><span class="s2">:</span>
    <span class="s1">register_numpy_ufunc</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>

<span class="s1">all_ufuncs </span><span class="s2">= [</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">all_ufuncs</span><span class="s2">]</span>
<span class="s1">supported_ufuncs </span><span class="s2">= [</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">supported_ufuncs</span><span class="s2">]</span>

<span class="s1">NumpyRulesUnaryArrayOperator</span><span class="s2">.</span><span class="s1">install_operations</span><span class="s2">()</span>
<span class="s1">NumpyRulesArrayOperator</span><span class="s2">.</span><span class="s1">install_operations</span><span class="s2">()</span>
<span class="s1">NumpyRulesInplaceArrayOperator</span><span class="s2">.</span><span class="s1">install_operations</span><span class="s2">()</span>

<span class="s1">supported_array_operators </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span>
    <span class="s1">NumpyRulesUnaryArrayOperator</span><span class="s2">.</span><span class="s1">_op_map</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
<span class="s2">).</span><span class="s1">union</span><span class="s2">(</span>
    <span class="s1">NumpyRulesArrayOperator</span><span class="s2">.</span><span class="s1">_op_map</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
<span class="s2">).</span><span class="s1">union</span><span class="s2">(</span>
    <span class="s1">NumpyRulesInplaceArrayOperator</span><span class="s2">.</span><span class="s1">_op_map</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
<span class="s2">)</span>

<span class="s0">del </span><span class="s1">_unsupported</span>


<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Install global helpers for array methods.</span>

<span class="s0">class </span><span class="s1">Numpy_method_redirection</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    A template redirecting a Numpy global function (e.g. np.sum) to an 
    array method of the same name (e.g. ndarray.sum). 
    &quot;&quot;&quot;</span>

    <span class="s4"># Arguments like *axis* can specialize on literals but also support</span>
    <span class="s4"># non-literals</span>
    <span class="s1">prefer_literal </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">pysig </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">kws</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">method_name </span><span class="s2">== </span><span class="s5">'sum'</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s5">'axis' </span><span class="s0">in </span><span class="s1">kws </span><span class="s0">and </span><span class="s5">'dtype' </span><span class="s0">not in </span><span class="s1">kws</span><span class="s2">:</span>
                    <span class="s0">def </span><span class="s1">sum_stub</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
                        <span class="s0">pass</span>
                    <span class="s1">pysig </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">pysignature</span><span class="s2">(</span><span class="s1">sum_stub</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s5">'dtype' </span><span class="s0">in </span><span class="s1">kws </span><span class="s0">and </span><span class="s5">'axis' </span><span class="s0">not in </span><span class="s1">kws</span><span class="s2">:</span>
                    <span class="s0">def </span><span class="s1">sum_stub</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
                        <span class="s0">pass</span>
                    <span class="s1">pysig </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">pysignature</span><span class="s2">(</span><span class="s1">sum_stub</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s5">'dtype' </span><span class="s0">in </span><span class="s1">kws </span><span class="s0">and </span><span class="s5">'axis' </span><span class="s0">in </span><span class="s1">kws</span><span class="s2">:</span>
                    <span class="s0">def </span><span class="s1">sum_stub</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
                        <span class="s0">pass</span>
                    <span class="s1">pysig </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">pysignature</span><span class="s2">(</span><span class="s1">sum_stub</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">method_name </span><span class="s2">== </span><span class="s5">'argsort'</span><span class="s2">:</span>
                <span class="s0">def </span><span class="s1">argsort_stub</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s5">'quicksort'</span><span class="s2">):</span>
                    <span class="s0">pass</span>
                <span class="s1">pysig </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">pysignature</span><span class="s2">(</span><span class="s1">argsort_stub</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">fmt </span><span class="s2">= </span><span class="s5">&quot;numba doesn't support kwarg for {}&quot;</span>
                <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">method_name</span><span class="s2">))</span>

        <span class="s1">arr </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s4"># This will return a BoundFunction</span>
        <span class="s1">meth_ty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_getattr</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">method_name</span><span class="s2">)</span>
        <span class="s4"># Resolve arguments on the bound function</span>
        <span class="s1">meth_sig </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s1">meth_ty</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:], </span><span class="s1">kws</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">meth_sig </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">meth_sig</span><span class="s2">.</span><span class="s1">as_function</span><span class="s2">().</span><span class="s1">replace</span><span class="s2">(</span><span class="s1">pysig</span><span class="s2">=</span><span class="s1">pysig</span><span class="s2">)</span>


<span class="s4"># Function to glue attributes onto the numpy-esque object</span>
<span class="s0">def </span><span class="s1">_numpy_redirect</span><span class="s2">(</span><span class="s1">fname</span><span class="s2">):</span>
    <span class="s1">numpy_function </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">)</span>
    <span class="s1">cls </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s5">&quot;Numpy_redirect_{0}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">fname</span><span class="s2">), (</span><span class="s1">Numpy_method_redirection</span><span class="s2">,),</span>
               <span class="s1">dict</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">numpy_function</span><span class="s2">, </span><span class="s1">method_name</span><span class="s2">=</span><span class="s1">fname</span><span class="s2">))</span>
    <span class="s1">infer_global</span><span class="s2">(</span><span class="s1">numpy_function</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Function</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">))</span>


<span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'sum'</span><span class="s2">, </span><span class="s5">'argsort'</span><span class="s2">, </span><span class="s5">'nonzero'</span><span class="s2">, </span><span class="s5">'ravel'</span><span class="s2">]:</span>
    <span class="s1">_numpy_redirect</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>


<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Numpy scalar constructors</span>

<span class="s4"># Register np.int8, etc. as converters to the equivalent Numba types</span>
<span class="s1">np_types </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">nb_type</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">nb_type </span><span class="s0">in </span><span class="s1">types</span><span class="s2">.</span><span class="s1">number_domain</span><span class="s2">)</span>
<span class="s1">np_types</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
<span class="s4"># Those may or may not be aliases (depending on the Numpy build / version)</span>
<span class="s1">np_types</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intc</span><span class="s2">)</span>
<span class="s1">np_types</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
<span class="s1">np_types</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uintc</span><span class="s2">)</span>
<span class="s1">np_types</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uintp</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">register_number_classes</span><span class="s2">(</span><span class="s1">register_global</span><span class="s2">):</span>
    <span class="s0">for </span><span class="s1">np_type </span><span class="s0">in </span><span class="s1">np_types</span><span class="s2">:</span>
        <span class="s1">nb_type </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">types</span><span class="s2">, </span><span class="s1">np_type</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>

        <span class="s1">register_global</span><span class="s2">(</span><span class="s1">np_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">(</span><span class="s1">nb_type</span><span class="s2">))</span>


<span class="s1">register_number_classes</span><span class="s2">(</span><span class="s1">infer_global</span><span class="s2">)</span>


<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Numpy array constructors</span>

<span class="s0">def </span><span class="s1">parse_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Given a shape, return the number of dimensions. 
    &quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">):</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">)):</span>
        <span class="s1">int_tys </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">IntEnumMember</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">int_tys</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">shape</span><span class="s2">):</span>
            <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ndim</span>

<span class="s0">def </span><span class="s1">parse_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return the dtype of a type, if it is either a DtypeSpec (used for most 
    dtypes) or a TypeRef (used for record types). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">DTypeSpec</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">dtype</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">TypeRef</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">instance_type</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">StringLiteral</span><span class="s2">):</span>
        <span class="s1">dtstr </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">literal_value</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">dt </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">dtstr</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">f&quot;Invalid NumPy dtype specified: '</span><span class="s0">{</span><span class="s1">dtstr</span><span class="s0">}</span><span class="s5">'&quot;</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">_parse_nested_sequence</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Parse a (possibly 0d) nested sequence type. 
    A (ndim, dtype) tuple is returned.  Note the sequence may still be 
    heterogeneous, as long as it converts to the given dtype. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Buffer</span><span class="s2">,)):</span>
        <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;%s not allowed in a homogeneous sequence&quot; </span><span class="s2">% </span><span class="s1">typ</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">,)):</span>
        <span class="s1">n</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">_parse_nested_sequence</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">,)):</span>
        <span class="s0">if </span><span class="s1">typ</span><span class="s2">.</span><span class="s1">count </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># Mimic Numpy's behaviour</span>
            <span class="s0">return </span><span class="s6">1</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span>
        <span class="s1">n</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">_parse_nested_sequence</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
        <span class="s1">dtypes </span><span class="s2">= [</span><span class="s1">dtype</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">.</span><span class="s1">count</span><span class="s2">):</span>
            <span class="s1">_n</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">_parse_nested_sequence</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">_n </span><span class="s2">!= </span><span class="s1">n</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;type %s does not have a regular shape&quot;</span>
                                  <span class="s2">% (</span><span class="s1">typ</span><span class="s2">,))</span>
            <span class="s1">dtypes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">unify_types</span><span class="s2">(*</span><span class="s1">dtypes</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;cannot convert %s to a homogeneous type&quot; </span><span class="s2">% </span><span class="s1">typ</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s4"># Scalar type =&gt; check it's valid as a Numpy array dtype</span>
        <span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s6">0</span><span class="s2">, </span><span class="s1">typ</span>


<span class="s0">def </span><span class="s1">_infer_dtype_from_inputs</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">dtype</span>


<span class="s0">def </span><span class="s1">_homogeneous_dims</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">):</span>
    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arrays</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">ndim</span>
    <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">func_name</span><span class="s0">}</span><span class="s5">(): all the input arrays must have same number &quot;</span>
                   <span class="s5">&quot;of dimensions&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ndim</span>

<span class="s0">def </span><span class="s1">_sequence_of_arrays</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">,</span>
                        <span class="s1">dim_chooser</span><span class="s2">=</span><span class="s1">_homogeneous_dims</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">)</span>
        <span class="s0">or not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s0">or not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;%s(): expecting a non-empty tuple of arrays, &quot;</span>
                        <span class="s5">&quot;got %s&quot; </span><span class="s2">% (</span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">))</span>

    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">dim_chooser</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">)</span>

    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">unify_types</span><span class="s2">(*(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;%s(): input arrays must have &quot;</span>
                        <span class="s5">&quot;compatible dtypes&quot; </span><span class="s2">% </span><span class="s1">func_name</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span>

<span class="s0">def </span><span class="s1">_choose_concatenation_layout</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">):</span>
    <span class="s4"># Only create a F array if all input arrays have F layout.</span>
    <span class="s4"># This is a simplified version of Numpy's behaviour,</span>
    <span class="s4"># while Numpy's actually processes the input strides to</span>
    <span class="s4"># decide on optimal output strides</span>
    <span class="s4"># (see PyArray_CreateMultiSortedStridePerm()).</span>
    <span class="s0">return </span><span class="s5">'F' </span><span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">layout </span><span class="s2">== </span><span class="s5">'F' </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">) </span><span class="s0">else </span><span class="s5">'C'</span>


<span class="s0">class </span><span class="s1">BaseStackTemplate</span><span class="s2">(</span><span class="s1">CallableTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">typer</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">):</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim </span><span class="s2">= </span><span class="s1">_sequence_of_arrays</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">context</span><span class="s2">,</span>
                                              <span class="s1">self</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">)</span>

            <span class="s1">ndim </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim_min</span><span class="s2">)</span>
            <span class="s1">layout </span><span class="s2">= </span><span class="s1">_choose_concatenation_layout</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">typer</span>


<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Linear algebra</span>


<span class="s0">class </span><span class="s1">MatMulTyperMixin</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">matmul_typer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Typer function for Numpy matrix multiplication. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s0">in </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;%s only supported on 1-D and 2-D arrays&quot;</span>
                              <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">, ))</span>
        <span class="s4"># Output dimensionality</span>
        <span class="s1">ndims </span><span class="s2">= </span><span class="s1">set</span><span class="s2">([</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">])</span>
        <span class="s0">if </span><span class="s1">ndims </span><span class="s2">== </span><span class="s1">set</span><span class="s2">([</span><span class="s6">2</span><span class="s2">]):</span>
            <span class="s4"># M * M</span>
            <span class="s1">out_ndim </span><span class="s2">= </span><span class="s6">2</span>
        <span class="s0">elif </span><span class="s1">ndims </span><span class="s2">== </span><span class="s1">set</span><span class="s2">([</span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">]):</span>
            <span class="s4"># M* V and V * M</span>
            <span class="s1">out_ndim </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s0">elif </span><span class="s1">ndims </span><span class="s2">== </span><span class="s1">set</span><span class="s2">([</span><span class="s6">1</span><span class="s2">]):</span>
            <span class="s4"># V * V</span>
            <span class="s1">out_ndim </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s0">if </span><span class="s1">out </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">out_ndim </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;explicit output unsupported for vector * vector&quot;</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">out</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">out_ndim</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;explicit output has incorrect dimensionality&quot;</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">out</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">) </span><span class="s0">or </span><span class="s1">out</span><span class="s2">.</span><span class="s1">layout </span><span class="s2">!= </span><span class="s5">'C'</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;output must be a C-contiguous array&quot;</span><span class="s2">)</span>
            <span class="s1">all_args </span><span class="s2">= (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">all_args </span><span class="s2">= (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s2">(</span><span class="s1">config</span><span class="s2">.</span><span class="s1">DISABLE_PERFORMANCE_WARNINGS </span><span class="s0">or</span>
                <span class="s1">all</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">in </span><span class="s5">'CF' </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))):</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;%s is faster on contiguous arrays, called on %s&quot; </span><span class="s2">%</span>
                   <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)))</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">NumbaPerformanceWarning</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">))</span>
        <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">all_args</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;%s arguments must all have &quot;</span>
                              <span class="s5">&quot;the same dtype&quot; </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Float</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Complex</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;%s only supported on &quot;</span>
                              <span class="s5">&quot;float and complex arrays&quot;</span>
                              <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func_name</span><span class="s2">,))</span>
        <span class="s0">if </span><span class="s1">out</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">out</span>
        <span class="s0">elif </span><span class="s1">out_ndim </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">out_ndim</span><span class="s2">, </span><span class="s5">'C'</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span>


<span class="s0">def </span><span class="s1">_check_linalg_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">):</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
        <span class="s0">return</span>
    <span class="s0">if not </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;np.linalg.%s() only supported on 2-D arrays&quot;</span>
                          <span class="s2">% </span><span class="s1">func_name</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Float</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Complex</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s5">&quot;np.linalg.%s() only supported on &quot;</span>
                          <span class="s5">&quot;float and complex arrays&quot; </span><span class="s2">% </span><span class="s1">func_name</span><span class="s2">)</span>

<span class="s4"># -----------------------------------------------------------------------------</span>
<span class="s4"># Miscellaneous functions</span>

<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndenumerate</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NdEnumerate</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s1">arr</span><span class="s2">, = </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">):</span>
            <span class="s1">enumerate_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumpyNdEnumerateType</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">enumerate_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nditer</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NdIter</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) != </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s1">arrays</span><span class="s2">, = </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">arrays</span><span class="s2">:</span>
                <span class="s0">return</span>
            <span class="s1">arrays </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">arrays </span><span class="s2">= [</span><span class="s1">arrays</span><span class="s2">]</span>
        <span class="s1">nditerty </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumpyNdIterType</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">nditerty</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">pndindex</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndindex</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">NdIndex</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">kws</span>

        <span class="s4"># Either ndindex(shape) or ndindex(*shape)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BaseTuple</span><span class="s2">):</span>
            <span class="s1">tup </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">tup</span><span class="s2">.</span><span class="s1">count </span><span class="s2">&gt; </span><span class="s6">0 </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">):</span>
                <span class="s4"># Heterogeneous tuple</span>
                <span class="s0">return</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">args</span>

        <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">shape</span><span class="s2">):</span>
            <span class="s1">iterator_type </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumpyNdIndexType</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">iterator_type</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">infer_global</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">DtypeEq</span><span class="s2">(</span><span class="s1">AbstractTemplate</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s2">[</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">DType</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">DType</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">)</span>
</pre>
</body>
</html>