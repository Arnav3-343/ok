<html>
<head>
<title>test_linalg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_linalg.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span><span class="s2">, </span><span class="s1">cycle</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Number</span><span class="s2">, </span><span class="s1">Integral</span>
<span class="s0">import </span><span class="s1">platform</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">jit</span><span class="s2">, </span><span class="s1">njit</span><span class="s2">, </span><span class="s1">typeof</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">errors</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">support </span><span class="s0">import </span><span class="s2">(</span><span class="s1">TestCase</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">needs_lapack</span><span class="s2">, </span><span class="s1">needs_blas</span><span class="s2">,</span>
                                 <span class="s1">_is_armv7l</span><span class="s2">, </span><span class="s1">EnableNRTStatsMixin</span><span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">matmul_usecase </span><span class="s0">import </span><span class="s1">matmul_usecase</span>
<span class="s0">import </span><span class="s1">unittest</span>


<span class="s0">def </span><span class="s1">dot2</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">dot3</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">vdot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestProduct</span><span class="s2">(</span><span class="s1">EnableNRTStatsMixin</span><span class="s2">, </span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for dot products. 
    &quot;&quot;&quot;</span>

    <span class="s1">dtypes </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Collect leftovers from previous test cases before checking for leaks</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TestProduct</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">setUp</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s4"># Be careful to generate only exactly representable float values,</span>
        <span class="s4"># to avoid rounding discrepancies between Numpy and Numba</span>
        <span class="s1">base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">base </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s5">0.5j</span><span class="s2">) + </span><span class="s5">2j</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">base </span><span class="s2">* </span><span class="s5">0.5 </span><span class="s2">- </span><span class="s5">1</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">m </span><span class="s2">* </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">contextlib</span><span class="s2">.</span><span class="s1">contextmanager</span>
    <span class="s0">def </span><span class="s1">check_contiguity_warning</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check performance warning(s) for non-contiguity. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">(</span><span class="s1">record</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">as </span><span class="s1">w</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s6">'always'</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaPerformanceWarning</span><span class="s2">)</span>
            <span class="s0">yield</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertGreaterEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">w</span><span class="s2">), </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">category</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaPerformanceWarning</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s6">&quot;faster on contiguous arrays&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">w</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">message</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">w</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">filename</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_filename</span><span class="s2">)</span>
        <span class="s4"># This works because our functions are one-liners</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">w</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_firstlineno </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">pyfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertPreciseEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">ignore_sign_on_zero</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">del </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span>


    <span class="s0">def </span><span class="s1">_aligned_copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">):</span>
        <span class="s4"># This exists for armv7l because NumPy wants aligned arrays for the</span>
        <span class="s4"># `out` arg of functions, but np.empty/np.copy doesn't seem to always</span>
        <span class="s4"># produce them, in particular for complex dtypes</span>
        <span class="s1">size </span><span class="s2">= (</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">size </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">+ </span><span class="s5">1</span>
        <span class="s1">datasize </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">size </span><span class="s2">* </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">itemsize</span>
        <span class="s1">tmp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">):</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">tmp</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">datasize</span><span class="s2">].</span><span class="s1">view</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">new</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s6">&quot;Could not obtain aligned array&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">:</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'C'</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[:] = </span><span class="s1">arr</span><span class="s2">[:]</span>
        <span class="s0">assert </span><span class="s1">new</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">aligned</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">check_func_out</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">out</span><span class="s2">):</span>
        <span class="s1">copier </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_aligned_copy </span><span class="s0">if </span><span class="s1">_is_armv7l </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">copier</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">copier</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIs</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">expected</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIs</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">got</span><span class="s2">), </span><span class="s1">got</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertPreciseEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">ignore_sign_on_zero</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">del </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span>

    <span class="s0">def </span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">is_out</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s6">&quot;incompatible output array size&quot; </span><span class="s0">if </span><span class="s1">is_out </span><span class="s0">else</span>
               <span class="s6">&quot;incompatible array sizes&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">=</span><span class="s6">&quot;np.dot()&quot;</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s6">&quot;%s arguments must all have the same dtype&quot;</span>
                      <span class="s2">% (</span><span class="s1">func_name</span><span class="s2">,),</span>
                      <span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">check_dot_vv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">):</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s5">3</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pyfunc</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">:</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
            <span class="s4"># Non-contiguous</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">b</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]))</span>

        <span class="s4"># Mismatching sizes</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
        <span class="s4"># Mismatching dtypes</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">func_name</span><span class="s2">=</span><span class="s1">func_name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_dot_vv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test vector * vector np.dot() 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_vv</span><span class="s2">(</span><span class="s1">dot2</span><span class="s2">, </span><span class="s6">&quot;np.dot()&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_vdot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.vdot() 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_vv</span><span class="s2">(</span><span class="s1">vdot</span><span class="s2">, </span><span class="s6">&quot;np.vdot()&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_dot_vm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">order </span><span class="s0">in </span><span class="s6">'CF'</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
                <span class="s0">yield </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>
            <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s0">yield </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>
            <span class="s4"># Non-contiguous</span>
            <span class="s0">yield </span><span class="s1">a</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">b</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s1">cfunc2 </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pyfunc2</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">cfunc3 </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pyfunc3</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">),</span>
                     <span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">),</span>
                     <span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">)</span>
                     <span class="s2">]:</span>
            <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
                    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func_out</span><span class="s2">(</span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">out</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func_out</span><span class="s2">(</span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">), </span><span class="s1">out</span><span class="s2">)</span>

        <span class="s4"># Mismatching sizes</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">out</span><span class="s2">))</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">m </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">), </span><span class="s1">is_out</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">out</span><span class="s2">), </span><span class="s1">is_out</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s4"># Mismatching dtypes</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">func_name</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">), </span><span class="s1">func_name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_dot_vm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test vector * matrix and matrix * vector np.dot() 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_vm</span><span class="s2">(</span><span class="s1">dot2</span><span class="s2">, </span><span class="s1">dot3</span><span class="s2">, </span><span class="s6">&quot;np.dot()&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_dot_mm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">order_a</span><span class="s2">, </span><span class="s1">order_b </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s6">'CF'</span><span class="s2">, </span><span class="s6">'CF'</span><span class="s2">):</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">order_a</span><span class="s2">)</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">order_b</span><span class="s2">)</span>
                <span class="s0">yield </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>
            <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s0">yield </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>
            <span class="s4"># Non-contiguous</span>
            <span class="s0">yield </span><span class="s1">a</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">b</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s1">cfunc2 </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pyfunc2</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">cfunc3 </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pyfunc3</span><span class="s2">)</span>

        <span class="s4"># Test generic matrix * matrix as well as &quot;degenerate&quot; cases</span>
        <span class="s4"># where one of the outer dimensions is 1 (i.e. really represents</span>
        <span class="s4"># a vector, which may select a different implementation),</span>
        <span class="s4"># one of the matrices is empty, or both matrices are empty.</span>
        <span class="s0">for </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">),  </span><span class="s4"># Generic matrix * matrix</span>
                        <span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">),  </span><span class="s4"># 2d vector * matrix</span>
                        <span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">),  </span><span class="s4"># 2d vector * 2d vector</span>
                        <span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">),  </span><span class="s4"># Empty matrix * matrix, empty output</span>
                        <span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">),  </span><span class="s4"># Matrix * empty matrix, empty output</span>
                        <span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">),  </span><span class="s4"># Both arguments empty, empty output</span>
                        <span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">),  </span><span class="s4"># Both arguments empty, nonempty output</span>
                        <span class="s2">]:</span>
            <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func</span><span class="s2">(</span><span class="s1">pyfunc2</span><span class="s2">, </span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">samples</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
                    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func_out</span><span class="s2">(</span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">out</span><span class="s2">)</span>
                    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">check_func_out</span><span class="s2">(</span><span class="s1">pyfunc3</span><span class="s2">, </span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">b</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">T</span><span class="s2">), </span><span class="s1">out</span><span class="s2">)</span>

        <span class="s4"># Mismatching sizes</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k </span><span class="s2">= </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">))</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_sizes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">), </span><span class="s1">is_out</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s4"># Mismatching dtypes</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">cfunc2</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">func_name</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">pyfunc3 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_mismatching_dtypes</span><span class="s2">(</span><span class="s1">cfunc3</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">), </span><span class="s1">func_name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_dot_mm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test matrix * matrix np.dot() 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_mm</span><span class="s2">(</span><span class="s1">dot2</span><span class="s2">, </span><span class="s1">dot3</span><span class="s2">, </span><span class="s6">&quot;np.dot()&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_matmul_vv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test vector @ vector 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_vv</span><span class="s2">(</span><span class="s1">matmul_usecase</span><span class="s2">, </span><span class="s6">&quot;'@'&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_matmul_vm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test vector @ matrix and matrix @ vector 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_vm</span><span class="s2">(</span><span class="s1">matmul_usecase</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s6">&quot;'@'&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_matmul_mm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test matrix @ matrix 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_dot_mm</span><span class="s2">(</span><span class="s1">matmul_usecase</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s6">&quot;'@'&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_blas</span>
    <span class="s0">def </span><span class="s1">test_contiguity_warnings</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">dot2</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_contiguity_warning</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">):</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">dot3</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_contiguity_warning</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">):</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>

        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">vdot</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_contiguity_warning</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">):</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s4"># Implementation definitions for the purpose of jitting.</span>

<span class="s0">def </span><span class="s1">invert_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">inv</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">cholesky_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cholesky</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">eig_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eig</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">eigvals_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eigvals</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">eigh_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">eigvalsh_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eigvalsh</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">svd_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">full_matrices</span><span class="s2">=</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">svd</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">full_matrices</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">qr_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">lstsq_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">lstsq</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">solve_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">solve</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">pinv_matrix</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=</span><span class="s5">1e-15</span><span class="s2">):  </span><span class="s4"># 1e-15 from numpy impl</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">pinv</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">slogdet_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">slogdet</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">det_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">det</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">norm_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">cond_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">matrix_rank_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">matrix_power_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_power</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">trace_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">trace</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">trace_matrix_no_offset</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">trace</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">outer_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">outer</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">kron_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">kron</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgBase</span><span class="s2">(</span><span class="s1">EnableNRTStatsMixin</span><span class="s2">, </span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Provides setUp and common data/error modes for testing np.linalg functions. 
    &quot;&quot;&quot;</span>

    <span class="s4"># supported dtypes</span>
    <span class="s1">dtypes </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Collect leftovers from previous test cases before checking for leaks</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">setUp</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s4"># Be careful to generate only exactly representable float values,</span>
        <span class="s4"># to avoid rounding discrepancies between Numpy and Numba</span>
        <span class="s1">base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">base </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s5">0.5j</span><span class="s2">) + </span><span class="s5">2j</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">base </span><span class="s2">* </span><span class="s5">0.5 </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Provides a sample matrix with an optionally specified rank or condition 
        number. 
 
        size: (rows, columns), the dimensions of the returned matrix. 
        dtype: the dtype for the returned matrix. 
        order: the memory layout for the returned matrix, 'F' or 'C'. 
        rank: the rank of the matrix, an integer value, defaults to full rank. 
        condition: the condition number of the matrix (defaults to 1.) 
 
        NOTE: Only one of rank or condition may be set. 
        &quot;&quot;&quot;</span>

        <span class="s4"># default condition</span>
        <span class="s1">d_cond </span><span class="s2">= </span><span class="s5">1.</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">size</span><span class="s2">) != </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;size must be a length 2 tuple.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">order </span><span class="s0">not in </span><span class="s2">[</span><span class="s6">'F'</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;order must be one of 'F' or 'C'.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">not in </span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;dtype must be a numpy floating point type.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">rank </span><span class="s0">is not None and </span><span class="s1">condition </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Only one of rank or condition can be specified.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">condition </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">condition </span><span class="s2">= </span><span class="s1">d_cond</span>

        <span class="s0">if </span><span class="s1">condition </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Condition number must be &gt;=1.&quot;</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)  </span><span class="s4"># repeatable seed</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">size</span>

        <span class="s0">if </span><span class="s1">m </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">n </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Negative dimensions given for matrix shape.&quot;</span><span class="s2">)</span>

        <span class="s1">minmn </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">rank </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">rv </span><span class="s2">= </span><span class="s1">minmn</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">rank </span><span class="s2">&lt;= </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Rank must be greater than zero.&quot;</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">, </span><span class="s1">Integral</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Rank must an integer.&quot;</span><span class="s2">)</span>
            <span class="s1">rv </span><span class="s2">= </span><span class="s1">rank</span>
            <span class="s0">if </span><span class="s1">rank </span><span class="s2">&gt; </span><span class="s1">minmn</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Rank given greater than full rank.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">m </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">n </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># vector, must be rank 1 (enforced above)</span>
            <span class="s4"># condition of vector is also 1</span>
            <span class="s0">if </span><span class="s1">condition </span><span class="s2">!= </span><span class="s1">d_cond</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s6">&quot;Condition number was specified for a vector (always 1.).&quot;</span><span class="s2">)</span>
            <span class="s1">maxmn </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">Q </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">maxmn</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Build a sample matrix via combining SVD like inputs.</span>

            <span class="s4"># Create matrices of left and right singular vectors.</span>
            <span class="s4"># This could use Modified Gram-Schmidt and perhaps be quicker,</span>
            <span class="s4"># at present it uses QR decompositions to obtain orthonormal</span>
            <span class="s4"># matrices.</span>
            <span class="s1">tmp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">m </span><span class="s2">* </span><span class="s1">m</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
            <span class="s1">U</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">)</span>
            <span class="s4"># flip the second array, else for m==n the identity matrix appears</span>
            <span class="s1">tmp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">n </span><span class="s2">* </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">V</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">)</span>
            <span class="s4"># create singular values.</span>
            <span class="s1">sv </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s1">d_cond</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">, </span><span class="s1">rv</span><span class="s2">)</span>
            <span class="s1">S </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>
            <span class="s1">idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>
            <span class="s1">S</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][:</span><span class="s1">rv</span><span class="s2">], </span><span class="s1">idx</span><span class="s2">[</span><span class="s5">1</span><span class="s2">][:</span><span class="s1">rv</span><span class="s2">]] = </span><span class="s1">sv</span>
            <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">U</span><span class="s2">, </span><span class="s1">S</span><span class="s2">), </span><span class="s1">V</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)  </span><span class="s4"># construct</span>
            <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)  </span><span class="s4"># sort out order/type</span>

        <span class="s0">return </span><span class="s1">Q</span>

    <span class="s0">def </span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">err</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">assert_non_square</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;np.linalg.%s() only supported on float and complex arrays&quot; </span><span class="s2">% </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">la_prefix</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s1">prefix </span><span class="s2">= </span><span class="s6">&quot;np.linalg&quot; </span><span class="s0">if </span><span class="s1">la_prefix </span><span class="s0">else </span><span class="s6">&quot;np&quot;</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;%s.%s() only supported on 2-D arrays&quot; </span><span class="s2">% (</span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Array must not contain infs or NaNs.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected_contig</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This checks that in a computed result from numba (array, possibly tuple 
        of arrays) all the arrays are contiguous in memory and that they are 
        all at least one of &quot;C_CONTIGUOUS&quot; or &quot;F_CONTIGUOUS&quot;. The computed 
        result of the contiguousness is then compared against a hardcoded 
        expected result. 
 
        got: is the computed results from numba 
        expected_contig: is &quot;C&quot; or &quot;F&quot; and is the expected type of 
                        contiguousness across all input values 
                        (and therefore tests). 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s4"># tuple present, check all results</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">got</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">expected_contig</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">):</span>
                <span class="s4"># else a single array is present</span>
                <span class="s1">c_contig </span><span class="s2">= </span><span class="s1">got</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous</span>
                <span class="s1">f_contig </span><span class="s2">= </span><span class="s1">got</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">f_contiguous</span>

                <span class="s4"># check that the result (possible set of) is at least one of</span>
                <span class="s4"># C or F contiguous.</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Results are not at least one of all C or F contiguous.&quot;</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">c_contig </span><span class="s2">| </span><span class="s1">f_contig</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>

                <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Computed contiguousness does not match expected.&quot;</span>
                <span class="s0">if </span><span class="s1">expected_contig </span><span class="s2">== </span><span class="s6">&quot;C&quot;</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">c_contig</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">expected_contig </span><span class="s2">== </span><span class="s6">&quot;F&quot;</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">f_contig</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Unknown contig&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_raise_on_singular</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Matrix is singular to machine precision.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_is_identity_matrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">got</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Checks if a matrix is equal to the identity matrix. 
        &quot;&quot;&quot;</span>
        <span class="s4"># check it is square</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">got</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">])</span>
        <span class="s4"># create identity matrix</span>
        <span class="s1">eye </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">got</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
        <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">rtol </span><span class="s2">= </span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span>
        <span class="s0">if </span><span class="s1">atol </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">atol </span><span class="s2">= </span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
        <span class="s4"># check it matches</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_invalid_norm_kind</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        For use in norm() and cond() tests. 
        &quot;&quot;&quot;</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Invalid norm order for matrices.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">'Arrays cannot be empty'</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestTestLinalgBase</span><span class="s2">(</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The sample matrix code TestLinalgBase.specific_sample_matrix() 
    is a bit involved, this class tests it works as intended. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_specific_sample_matrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>

        <span class="s4"># add a default test to the ctor, it never runs so doesn't matter</span>
        <span class="s1">inst </span><span class="s2">= </span><span class="s1">TestLinalgBase</span><span class="s2">(</span><span class="s6">'specific_sample_matrix'</span><span class="s2">)</span>

        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">size</span>
            <span class="s1">minmn </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

            <span class="s4"># test default full rank</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">A</span><span class="s2">), </span><span class="s1">minmn</span><span class="s2">)</span>

            <span class="s4"># test reduced rank if a reduction is possible</span>
            <span class="s0">if </span><span class="s1">minmn </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">rank </span><span class="s2">= </span><span class="s1">minmn </span><span class="s2">- </span><span class="s5">1</span>
                <span class="s1">A </span><span class="s2">= </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">=</span><span class="s1">rank</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">A</span><span class="s2">), </span><span class="s1">rank</span><span class="s2">)</span>

            <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>

            <span class="s4"># test default condition</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span><span class="s1">A</span><span class="s2">),</span>
                                       <span class="s5">1.</span><span class="s2">,</span>
                                       <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                                       <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

            <span class="s4"># test specified condition if matrix is &gt; 1D</span>
            <span class="s0">if </span><span class="s1">minmn </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">condition </span><span class="s2">= </span><span class="s5">10.</span>
                <span class="s1">A </span><span class="s2">= </span><span class="s1">inst</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
                    <span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">=</span><span class="s1">condition</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span><span class="s1">A</span><span class="s2">),</span>
                                           <span class="s5">10.</span><span class="s2">,</span>
                                           <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                                           <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

        <span class="s4"># check errors are raised appropriately</span>
        <span class="s0">def </span><span class="s1">check_error</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">err</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
                <span class="s1">inst</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">))</span>

        <span class="s4"># check the checker runs ok</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">AssertionError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;blank&quot;</span>
            <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># check invalid inputs...</span>

        <span class="s4"># bad size</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;size must be a length 2 tuple.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">1</span><span class="s2">,), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># bad order</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;order must be one of 'F' or 'C'.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'z'</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># bad type</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;dtype must be a numpy floating point type.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying both rank and condition</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Only one of rank or condition can be specified.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying negative condition</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Condition number must be &gt;=1.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying negative matrix dimension</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Negative dimensions given for matrix shape.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying negative rank</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Rank must be greater than zero.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying a rank greater than maximum rank</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Rank given greater than full rank.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s5">4</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying a condition number for a vector</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Condition number was specified for a vector (always 1.).&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s5">10</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>

        <span class="s4"># specifying a non integer rank</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Rank must an integer.&quot;</span>
        <span class="s1">check_error</span><span class="s2">(((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">), </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">ValueError</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgInv</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.inv. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_inv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.inv 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s5">10</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">invert_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">invert_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>

            <span class="s4"># try strict</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                                                          <span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                <span class="s4"># fall back to reconstruction</span>
                <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_is_identity_matrix</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'CF'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">((</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># 0 dimensioned matrix</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)))</span>

        <span class="s4"># Non square matrix</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_non_square</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">)),))</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s6">&quot;inv&quot;</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s6">&quot;inv&quot;</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">),))</span>

        <span class="s4"># Singular matrix</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_singular</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                      <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">ainv</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">inv</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">ainv</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">ainv</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgCholesky</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.cholesky. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">):</span>
        <span class="s4"># pd. (positive definite) matrix has eigenvalues in Z+</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)  </span><span class="s4"># repeatable seed</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
        <span class="s4"># orthonormal q needed to form up q^{-1}*D*q</span>
        <span class="s4"># no &quot;orth()&quot; in numpy</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
        <span class="s1">L </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">m </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)  </span><span class="s4"># some positive eigenvalues</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">q</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">L</span><span class="s2">)), </span><span class="s1">q</span><span class="s2">)  </span><span class="s4"># construct</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)  </span><span class="s4"># sort out order/type</span>
        <span class="s0">return </span><span class="s1">Q</span>

    <span class="s0">def </span><span class="s1">assert_not_pd</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Matrix is not positive definite.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_cholesky</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.cholesky 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s5">10</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">cholesky_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">cholesky_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># check that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;C&quot;</span><span class="s2">)</span>

            <span class="s4"># try strict</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                                                          <span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                <span class="s4"># fall back to reconstruction</span>
                <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s4"># try via reconstruction</span>
            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">T</span><span class="s2">))</span>
                <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                    <span class="s1">a</span><span class="s2">,</span>
                    <span class="s1">rec</span><span class="s2">,</span>
                    <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                    <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span>
                <span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># 0 dimensioned matrix</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)))</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;cholesky&quot;</span>
        <span class="s4"># Non square matrices</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_non_square</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># not pd</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_not_pd</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                           <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">),))</span>


<span class="s0">class </span><span class="s1">TestLinalgEigenSystems</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.eig/eigvals. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">):</span>
        <span class="s4"># This is a tridiag with the same but skewed values on the diagonals</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">Q</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s5">1</span><span class="s2">))</span>
        <span class="s1">Q</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">v</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">Q</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], -</span><span class="s5">1</span><span class="s2">))</span>
        <span class="s1">Q</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">v</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Q</span>

    <span class="s0">def </span><span class="s1">assert_no_domain_change</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">name </span><span class="s2">+ </span><span class="s6">&quot;() argument must not cause a domain change.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_check_worker</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected_res_len</span><span class="s2">,</span>
                      <span class="s1">check_for_domain_change</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">check</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s4"># check that the returned tuple is same length</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>
            <span class="s4"># and that dimension is correct</span>
            <span class="s1">res_is_tuple </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">res_is_tuple </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">), </span><span class="s1">expected_res_len</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:  </span><span class="s4"># its an array</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">expected_res_len</span><span class="s2">)</span>

            <span class="s4"># and that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># try plain match of each array to np first</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                        <span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># plain match failed, test by reconstruction</span>
                    <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s4"># If plain match fails then reconstruction is used.</span>
            <span class="s4"># this checks that A*V ~== V*diag(W)</span>
            <span class="s4"># i.e. eigensystem ties out</span>
            <span class="s4"># this is required as numpy uses only double precision lapack</span>
            <span class="s4"># routines and computation of eigenvectors is numerically</span>
            <span class="s4"># sensitive, numba uses the type specific routines therefore</span>
            <span class="s4"># sometimes comes out with a different (but entirely</span>
            <span class="s4"># valid) answer (eigenvectors are not unique etc.).</span>
            <span class="s4"># This is only applicable if eigenvectors are computed</span>
            <span class="s4"># along with eigenvalues i.e. result is a tuple.</span>
            <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">res_is_tuple</span><span class="s2">:</span>
                    <span class="s1">w</span><span class="s2">, </span><span class="s1">v </span><span class="s2">= </span><span class="s1">got</span>
                    <span class="s4"># modify 'a' if hermitian eigensystem functionality is</span>
                    <span class="s4"># being tested. 'L' for use lower part is default and</span>
                    <span class="s4"># the only thing used at present so we conjugate transpose</span>
                    <span class="s4"># the lower part into the upper for use in the</span>
                    <span class="s4"># reconstruction. By construction the sample matrix is</span>
                    <span class="s4"># tridiag so this is just a question of copying the lower</span>
                    <span class="s4"># diagonal into the upper and conjugating on the way.</span>
                    <span class="s0">if </span><span class="s1">name</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] == </span><span class="s6">'h'</span><span class="s2">:</span>
                        <span class="s1">idxl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], -</span><span class="s5">1</span><span class="s2">))</span>
                        <span class="s1">idxu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s5">1</span><span class="s2">))</span>
                        <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
                        <span class="s4"># upper idx must match lower for default uplo=&quot;L&quot;</span>
                        <span class="s4"># if complex, conjugate</span>
                        <span class="s1">a</span><span class="s2">[</span><span class="s1">idxu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">idxl</span><span class="s2">])</span>
                        <span class="s4"># also, only the real part of the diagonals is</span>
                        <span class="s4"># considered in the calculation so the imag is zeroed</span>
                        <span class="s4"># out for the purposes of use in reconstruction.</span>
                        <span class="s1">a</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag_indices</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">real</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">a</span><span class="s2">))</span>

                    <span class="s1">lhs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>
                    <span class="s1">rhs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">w</span><span class="s2">))</span>

                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                        <span class="s1">lhs</span><span class="s2">.</span><span class="s1">real</span><span class="s2">,</span>
                        <span class="s1">rhs</span><span class="s2">.</span><span class="s1">real</span><span class="s2">,</span>
                        <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                        <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span>
                    <span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                            <span class="s1">lhs</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">,</span>
                            <span class="s1">rhs</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">,</span>
                            <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                            <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span>
                        <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># This isn't technically reconstruction but is here to</span>
                    <span class="s4"># deal with that the order of the returned eigenvalues</span>
                    <span class="s4"># may differ in the case of routines just returning</span>
                    <span class="s4"># eigenvalues and there's no true reconstruction</span>
                    <span class="s4"># available with which to perform a check.</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">),</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">got</span><span class="s2">),</span>
                        <span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">,</span>
                        <span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span>
                    <span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">check</span>

    <span class="s0">def </span><span class="s1">checker_for_linalg_eig</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">expected_res_len</span><span class="s2">, </span><span class="s1">check_for_domain_change</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.eig 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s5">10</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s1">check </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_worker</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected_res_len</span><span class="s2">,</span>
                                   <span class="s1">check_for_domain_change</span><span class="s2">)</span>


        <span class="s4"># The main test loop</span>
        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_matrix</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># Test both a real and complex type as the impls are different</span>
        <span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">]:</span>

            <span class="s4"># 0 dimensioned matrix</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">))</span>

            <span class="s4"># Non square matrices</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_non_square</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">),))</span>

            <span class="s4"># Wrong dtype</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                    <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

            <span class="s4"># Dimension issue</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">),))</span>

            <span class="s4"># no nans or infs</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                      <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                                <span class="s1">dtype</span><span class="s2">=</span><span class="s1">ty</span><span class="s2">),))</span>

        <span class="s0">if </span><span class="s1">check_for_domain_change</span><span class="s2">:</span>
            <span class="s4"># By design numba does not support dynamic return types, numpy does</span>
            <span class="s4"># and uses this in the case of returning eigenvalues/vectors of</span>
            <span class="s4"># a real matrix. The return type of np.linalg.eig(), when</span>
            <span class="s4"># operating on a matrix in real space depends on the values present</span>
            <span class="s4"># in the matrix itself (recalling that eigenvalues are the roots of the</span>
            <span class="s4"># characteristic polynomial of the system matrix, which will by</span>
            <span class="s4"># construction depend on the values present in the system matrix).</span>
            <span class="s4"># This test asserts that if a domain change is required on the return</span>
            <span class="s4"># type, i.e. complex eigenvalues from a real input, an error is raised.</span>
            <span class="s4"># For complex types, regardless of the value of the imaginary part of</span>
            <span class="s4"># the returned eigenvalues, a complex type will be returned, this</span>
            <span class="s4"># follows numpy and fits in with numba.</span>

            <span class="s4"># First check that the computation is valid (i.e. in complex space)</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]])</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">))</span>
            <span class="s4"># and that the imaginary part is nonzero</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">l</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">))</span>

            <span class="s4"># Now check that the computation fails in real space</span>
            <span class="s0">for </span><span class="s1">ty </span><span class="s0">in </span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">]:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_domain_change</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">A</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_eig</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">checker_for_linalg_eig</span><span class="s2">(</span><span class="s6">&quot;eig&quot;</span><span class="s2">, </span><span class="s1">eig_matrix</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_eigvals</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">checker_for_linalg_eig</span><span class="s2">(</span><span class="s6">&quot;eigvals&quot;</span><span class="s2">, </span><span class="s1">eigvals_matrix</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_eigh</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">checker_for_linalg_eig</span><span class="s2">(</span><span class="s6">&quot;eigh&quot;</span><span class="s2">, </span><span class="s1">eigh_matrix</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_eigvalsh</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">checker_for_linalg_eig</span><span class="s2">(</span><span class="s6">&quot;eigvalsh&quot;</span><span class="s2">, </span><span class="s1">eigvalsh_matrix</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># checks inputs are not mutated</span>

        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s2">((</span><span class="s6">'eig'</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s6">'eigvals'</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s6">'eigh'</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s0">False</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s6">'eigvalsh'</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)):</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">nout</span><span class="s2">, </span><span class="s1">domain_change </span><span class="s2">= </span><span class="s1">c</span>

            <span class="s1">meth </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>

            <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                    <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                    <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
                <span class="s0">return </span><span class="s1">meth</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

            <span class="s1">check </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_worker</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">nout</span><span class="s2">, </span><span class="s1">domain_change</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">):</span>
                <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">subTest</span><span class="s2">(</span><span class="s1">meth</span><span class="s2">=</span><span class="s1">meth</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">):</span>
                    <span class="s4"># trivial system, doesn't matter, just checking if it gets</span>
                    <span class="s4"># mutated</span>
                    <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">10.</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
                                <span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">],</span>
                                <span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s2">],</span>
                                <span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">7</span><span class="s2">],</span>
                                <span class="s2">], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

                    <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

                    <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

                    <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

                    <span class="s1">check</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgSvd</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.svd. 
    &quot;&quot;&quot;</span>

    <span class="s4"># This checks that A ~= U*S*V**H, i.e. SV decomposition ties out.  This is</span>
    <span class="s4"># required as NumPy uses only double precision LAPACK routines and</span>
    <span class="s4"># computation of SVD is numerically sensitive. Numba uses type-specific</span>
    <span class="s4"># routines and therefore sometimes comes out with a different answer to</span>
    <span class="s4"># NumPy (orthonormal bases are not unique, etc.).</span>

    <span class="s0">def </span><span class="s1">check_reconstruction</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">):</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">sv</span><span class="s2">, </span><span class="s1">vt </span><span class="s2">= </span><span class="s1">got</span>

        <span class="s4"># Check they are dimensionally correct</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">)</span>

        <span class="s4"># Columns in u and rows in vt dictates the working size of s</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">u</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">vt</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">fill_diagonal</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">sv</span><span class="s2">)</span>

        <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">), </span><span class="s1">vt</span><span class="s2">)</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
            <span class="s1">a</span><span class="s2">,</span>
            <span class="s1">rec</span><span class="s2">,</span>
            <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
            <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_svd</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.svd 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">svd_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">svd_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s4"># check that the returned tuple is same length</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>
            <span class="s4"># and that length is 3</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">), </span><span class="s5">3</span><span class="s2">)</span>
            <span class="s4"># and that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># try plain match of each array to np first</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>

                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                        <span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># plain match failed, test by reconstruction</span>
                    <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">check_reconstruction</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">7</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># flip on reduced or full matrices</span>
        <span class="s1">full_matrices </span><span class="s2">= (</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fmat</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">full_matrices</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>

            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">full_matrices</span><span class="s2">=</span><span class="s1">fmat</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;svd&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>
        <span class="s4"># empty</span>
        <span class="s0">for </span><span class="s1">sz </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]:</span>
            <span class="s1">args </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sz</span><span class="s2">), </span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                      <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">svd</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">e_a</span><span class="s2">, </span><span class="s1">g_a </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">):</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">e_a</span><span class="s2">, </span><span class="s1">g_a</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_reconstruction</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgQr</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.qr. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_qr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.qr 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">qr_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">qr_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># check that the returned tuple is same length</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>
            <span class="s4"># and that length is 2</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">), </span><span class="s5">2</span><span class="s2">)</span>
            <span class="s4"># and that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># try plain match of each array to np first</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                        <span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># plain match failed, test by reconstruction</span>
                    <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s4"># if plain match fails then reconstruction is used.</span>
            <span class="s4"># this checks that A ~= Q*R and that (Q^H)*Q = I</span>
            <span class="s4"># i.e. QR decomposition ties out</span>
            <span class="s4"># this is required as numpy uses only double precision lapack</span>
            <span class="s4"># routines and computation of qr is numerically</span>
            <span class="s4"># sensitive, numba using the type specific routines therefore</span>
            <span class="s4"># sometimes comes out with a different answer (orthonormal bases</span>
            <span class="s4"># are not unique etc.).</span>
            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s1">q</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">got</span>

                <span class="s4"># check they are dimensionally correct</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">)</span>

                <span class="s4"># check A=q*r</span>
                <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">r</span><span class="s2">)</span>
                <span class="s1">resolution </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                    <span class="s1">a</span><span class="s2">,</span>
                    <span class="s1">rec</span><span class="s2">,</span>
                    <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                    <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
                <span class="s2">)</span>

                <span class="s4"># check q is orthonormal</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_is_identity_matrix</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">conjugate</span><span class="s2">(</span><span class="s1">q</span><span class="s2">.</span><span class="s1">T</span><span class="s2">), </span><span class="s1">q</span><span class="s2">))</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;qr&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># empty</span>
        <span class="s0">for </span><span class="s1">sz </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sz</span><span class="s2">),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                      <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">e_a</span><span class="s2">, </span><span class="s1">g_a </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">):</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">e_a</span><span class="s2">, </span><span class="s1">g_a</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgSystems</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for testing &quot;system&quot; solvers from np.linalg. 
    Namely np.linalg.solve() and np.linalg.lstsq(). 
    &quot;&quot;&quot;</span>

    <span class="s4"># check for RHS with dimension &gt; 2 raises</span>
    <span class="s0">def </span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">la_prefix</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s1">prefix </span><span class="s2">= </span><span class="s6">&quot;np.linalg&quot; </span><span class="s0">if </span><span class="s1">la_prefix </span><span class="s0">else </span><span class="s6">&quot;np&quot;</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;%s.%s() only supported on 1 and 2-D arrays&quot; </span><span class="s2">% (</span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">)</span>

    <span class="s4"># check that a dimensionally invalid system raises</span>
    <span class="s0">def </span><span class="s1">assert_dimensionally_invalid</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;Incompatible array sizes, system is not dimensionally valid.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">)</span>

    <span class="s4"># check that args with differing dtypes raise</span>
    <span class="s0">def </span><span class="s1">assert_homogeneous_dtypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;np.linalg.%s() only supports inputs that have homogeneous dtypes.&quot; </span><span class="s2">% </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgLstsq</span><span class="s2">(</span><span class="s1">TestLinalgSystems</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.lstsq. 
    &quot;&quot;&quot;</span>

    <span class="s4"># NOTE: The testing of this routine is hard as it has to handle numpy</span>
    <span class="s4"># using double precision routines on single precision input, this has</span>
    <span class="s4"># a knock on effect especially in rank deficient cases and cases where</span>
    <span class="s4"># conditioning is generally poor. As a result computed ranks can differ</span>
    <span class="s4"># and consequently the calculated residual can differ.</span>
    <span class="s4"># The tests try and deal with this as best as they can through the use</span>
    <span class="s4"># of reconstruction and measures like residual norms.</span>
    <span class="s4"># Suggestions for improvements are welcomed!</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_lstsq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.lstsq 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">lstsq_system</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">lstsq_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># check that the returned tuple is same length</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>
            <span class="s4"># and that length is 4</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">), </span><span class="s5">4</span><span class="s2">)</span>
            <span class="s4"># and that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;C&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>

            <span class="s4"># check the ranks are the same and continue to a standard</span>
            <span class="s4"># match if that is the case (if ranks differ, then output</span>
            <span class="s4"># in e.g. residual array is of different size!).</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s5">2</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">2</span><span class="s2">])</span>
                <span class="s4"># try plain match of each array to np first</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)):</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                            <span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                        <span class="s4"># plain match failed, test by reconstruction</span>
                        <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s </span><span class="s2">= </span><span class="s1">got</span>

                <span class="s4"># indicies in the output which are ndarrays</span>
                <span class="s1">out_array_idx </span><span class="s2">= [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]</span>

                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s4"># check the ranks are the same</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">rank</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">2</span><span class="s2">])</span>
                    <span class="s4"># check they are dimensionally correct, skip [2] = rank.</span>
                    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">out_array_idx</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># check the rank differs by 1. (numerical fuzz)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rank </span><span class="s2">- </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]) &lt; </span><span class="s5">2</span><span class="s2">)</span>

                <span class="s4"># check if A*X = B</span>
                <span class="s1">resolution </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s4"># this will work so long as the conditioning is</span>
                    <span class="s4"># ok and the rank is full</span>
                    <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                        <span class="s1">B</span><span class="s2">,</span>
                        <span class="s1">rec</span><span class="s2">,</span>
                        <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                        <span class="s1">atol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span>
                    <span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># system is probably under/over determined and/or</span>
                    <span class="s4"># poorly conditioned. Check slackened equality</span>
                    <span class="s4"># and that the residual norm is the same.</span>
                    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">out_array_idx</span><span class="s2">:</span>
                        <span class="s0">try</span><span class="s2">:</span>
                            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                                <span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">],</span>
                                <span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">],</span>
                                <span class="s1">rtol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                                <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution</span>
                            <span class="s2">)</span>
                        <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                            <span class="s4"># check the fail is likely due to bad conditioning</span>
                            <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cond</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertGreater</span><span class="s2">(</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">c</span><span class="s2">, (</span><span class="s5">1. </span><span class="s2">/ </span><span class="s1">resolution</span><span class="s2">))</span>

                        <span class="s4"># make sure the residual 2-norm is ok</span>
                        <span class="s4"># if this fails its probably due to numpy using double</span>
                        <span class="s4"># precision LAPACK routines for singles.</span>
                        <span class="s1">res_expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span>
                            <span class="s1">B </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
                        <span class="s1">res_got </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">B </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">x</span><span class="s2">))</span>
                        <span class="s4"># rtol = 10. as all the systems are products of orthonormals</span>
                        <span class="s4"># and on the small side (rows, cols) &lt; 100.</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                            <span class="s1">res_expected</span><span class="s2">, </span><span class="s1">res_got</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s5">10.</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes, the A's</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>
        <span class="s4"># compatible B's for Ax=B must have same number of rows and 1 or more</span>
        <span class="s4"># columns</span>

        <span class="s4"># This test takes ages! So combinations are trimmed via cycling</span>

        <span class="s4"># gets a dtype</span>
        <span class="s1">cycle_dt </span><span class="s2">= </span><span class="s1">cycle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">)</span>

        <span class="s1">orders </span><span class="s2">= [</span><span class="s6">'F'</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">]</span>
        <span class="s4"># gets a memory order flag</span>
        <span class="s1">cycle_order </span><span class="s2">= </span><span class="s1">cycle</span><span class="s2">(</span><span class="s1">orders</span><span class="s2">)</span>

        <span class="s4"># a specific condition number to use in the following tests</span>
        <span class="s4"># there is nothing special about it other than it is not magic</span>
        <span class="s1">specific_cond </span><span class="s2">= </span><span class="s5">10.</span>

        <span class="s4"># inner test loop, extracted as there's additional logic etc required</span>
        <span class="s4"># that'd end up with this being repeated a lot</span>
        <span class="s0">def </span><span class="s1">inner_test_loop_fn</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s4"># test solve Ax=B for (column, matrix) B, same dtype as A</span>
            <span class="s1">b_sizes </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">13</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">b_size </span><span class="s0">in </span><span class="s1">b_sizes</span><span class="s2">:</span>

                <span class="s4"># check 2D B</span>
                <span class="s1">b_order </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">cycle_order</span><span class="s2">)</span>
                <span class="s1">B </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">b_size</span><span class="s2">), </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">b_order</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

                <span class="s4"># check 1D B</span>
                <span class="s1">b_order </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">cycle_order</span><span class="s2">)</span>
                <span class="s1">tmp </span><span class="s2">= </span><span class="s1">B</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">b_order</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">tmp</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">a_size </span><span class="s0">in </span><span class="s1">sizes</span><span class="s2">:</span>

            <span class="s1">dt </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">cycle_dt</span><span class="s2">)</span>
            <span class="s1">a_order </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">cycle_order</span><span class="s2">)</span>

            <span class="s4"># A full rank, well conditioned system</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">a_size</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">a_order</span><span class="s2">)</span>

            <span class="s4"># run the test loop</span>
            <span class="s1">inner_test_loop_fn</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">a_size</span>
            <span class="s1">minmn </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

            <span class="s4"># operations that only make sense with a 2D matrix system</span>
            <span class="s0">if </span><span class="s1">m </span><span class="s2">!= </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">n </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>

                <span class="s4"># Test a rank deficient system</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">minmn </span><span class="s2">- </span><span class="s5">1</span>
                <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
                    <span class="s1">a_size</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">a_order</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">=</span><span class="s1">r</span><span class="s2">)</span>
                <span class="s4"># run the test loop</span>
                <span class="s1">inner_test_loop_fn</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">)</span>

                <span class="s4"># Test a system with a given condition number for use in</span>
                <span class="s4"># testing the rcond parameter.</span>
                <span class="s4"># This works because the singular values in the</span>
                <span class="s4"># specific_sample_matrix code are linspace (1, cond, [0... if</span>
                <span class="s4"># rank deficient])</span>
                <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
                    <span class="s1">a_size</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">a_order</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">=</span><span class="s1">specific_cond</span><span class="s2">)</span>
                <span class="s4"># run the test loop</span>
                <span class="s1">rcond </span><span class="s2">= </span><span class="s5">1. </span><span class="s2">/ </span><span class="s1">specific_cond</span>
                <span class="s1">approx_half_rank_rcond </span><span class="s2">= </span><span class="s1">minmn </span><span class="s2">* </span><span class="s1">rcond</span>
                <span class="s1">inner_test_loop_fn</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">,</span>
                                   <span class="s1">rcond</span><span class="s2">=</span><span class="s1">approx_half_rank_rcond</span><span class="s2">)</span>

        <span class="s4"># check empty arrays</span>
        <span class="s1">empties </span><span class="s2">= [</span>
        <span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">,)], </span><span class="s4"># empty A, valid b</span>
        <span class="s2">[(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">,)], </span><span class="s4"># empty A, valid b</span>
        <span class="s2">[(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">,)], </span><span class="s4"># valid A, empty 1D b</span>
        <span class="s2">[(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)],  </span><span class="s4"># valid A, empty 2D b</span>
        <span class="s2">]</span>

        <span class="s0">for </span><span class="s1">A</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">empties</span><span class="s2">:</span>
            <span class="s1">args </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">A</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

        <span class="s4"># Test input validation</span>
        <span class="s1">ok </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], [</span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s4"># check ok input is ok</span>
        <span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">)</span>

        <span class="s4"># check bad inputs</span>
        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;lstsq&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># different dtypes</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_homogeneous_dtypes</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_homogeneous_dtypes</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># check 1D is accepted for B (2D is done previously)</span>
        <span class="s4"># and then that anything of higher dimension raises</span>
        <span class="s1">oneD </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">oneD</span><span class="s2">)</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]], [[</span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">], [</span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">]]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>

        <span class="s4"># check a dimensionally invalid system raises (1D and 2D cases</span>
        <span class="s4"># checked)</span>
        <span class="s1">bad1D </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">bad2D </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">], [</span><span class="s5">2.</span><span class="s2">], [</span><span class="s5">3.</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_dimensionally_invalid</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad1D</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_dimensionally_invalid</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad2D</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_issue3368</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">7.54</span><span class="s2">, </span><span class="s5">6.52</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.70</span><span class="s2">, </span><span class="s5">4.00</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.50</span><span class="s2">, </span><span class="s5">3.80</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.15</span><span class="s2">, </span><span class="s5">5.64</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">4.22</span><span class="s2">, </span><span class="s5">3.27</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.41</span><span class="s2">, </span><span class="s5">5.70</span><span class="s2">],], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s2">, </span><span class="s5">5.</span><span class="s2">, </span><span class="s5">6.</span><span class="s2">])</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">f2</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># never executed, but necessary to trigger the bug</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">lstsq</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s1">f2</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgSolve</span><span class="s2">(</span><span class="s1">TestLinalgSystems</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.solve. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_solve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.solve 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">solve_system</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">solve_system</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># check that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># try plain match of the result first</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                    <span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                <span class="s4"># plain match failed, test by reconstruction</span>
                <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s4"># If plain match fails then reconstruction is used,</span>
            <span class="s4"># this checks that AX ~= B.</span>
            <span class="s4"># Plain match can fail due to numerical fuzziness associated</span>
            <span class="s4"># with system size and conditioning, or more simply from</span>
            <span class="s4"># numpy using double precision routines for computation that</span>
            <span class="s4"># could be done in single precision (which is what numba does).</span>
            <span class="s4"># Therefore minor differences in results can appear due to</span>
            <span class="s4"># e.g. numerical roundoff being different between two precisions.</span>
            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>
                <span class="s4"># check they are dimensionally correct</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

                <span class="s4"># check AX=B</span>
                <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>
                <span class="s1">resolution </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                    <span class="s1">b</span><span class="s2">,</span>
                    <span class="s1">rec</span><span class="s2">,</span>
                    <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                    <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
                <span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: prime size squares</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>

            <span class="s1">b_sizes </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">13</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">b_size</span><span class="s2">, </span><span class="s1">b_order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">b_sizes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
                <span class="s4"># check 2D B</span>
                <span class="s1">B </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">b_size</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">b_order</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">)</span>

                <span class="s4"># check 1D B</span>
                <span class="s1">tmp </span><span class="s2">= </span><span class="s1">B</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">b_order</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">tmp</span><span class="s2">)</span>

        <span class="s4"># check empty</span>
        <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">,)))</span>

        <span class="s4"># Test input validation</span>
        <span class="s1">ok </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">], [</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s4"># check ok input is ok</span>
        <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">)</span>

        <span class="s4"># check bad inputs</span>
        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;solve&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># different dtypes</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_homogeneous_dtypes</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_homogeneous_dtypes</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

        <span class="s4"># check 1D is accepted for B (2D is done previously)</span>
        <span class="s4"># and then that anything of higher dimension raises</span>
        <span class="s1">ok_oneD </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">ok_oneD</span><span class="s2">)</span>
        <span class="s1">bad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]], [[</span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">], [</span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">]]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad</span><span class="s2">))</span>

        <span class="s4"># check an invalid system raises (1D and 2D cases checked)</span>
        <span class="s1">bad1D </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">bad2D </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">], [</span><span class="s5">2.</span><span class="s2">], [</span><span class="s5">3.</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_dimensionally_invalid</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad1D</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_dimensionally_invalid</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">ok</span><span class="s2">, </span><span class="s1">bad2D</span><span class="s2">))</span>

        <span class="s4"># check that a singular system raises</span>
        <span class="s1">bad2D </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_singular</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">bad2D</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
                      <span class="s2">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4</span><span class="s2">])</span>
        <span class="s1">y_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, triggers A order in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">solve</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">y_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">y_orig</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgPinv</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.pinv. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_pinv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.pinv 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">pinv_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">pinv_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># check that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;F&quot;</span><span class="s2">)</span>

            <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># try plain match of each array to np first</span>

            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
                    <span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                <span class="s4"># plain match failed, test by reconstruction</span>
                <span class="s1">use_reconstruction </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s4"># If plain match fails then reconstruction is used.</span>
            <span class="s4"># This can occur due to numpy using double precision</span>
            <span class="s4"># LAPACK when single can be used, this creates round off</span>
            <span class="s4"># problems. Also, if the matrix has machine precision level</span>
            <span class="s4"># zeros in its singular values then the singular vectors are</span>
            <span class="s4"># likely to vary depending on round off.</span>
            <span class="s0">if </span><span class="s1">use_reconstruction</span><span class="s2">:</span>

                <span class="s4"># check they are dimensionally correct</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">got</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

                <span class="s4"># check pinv(A)*A~=eye</span>
                <span class="s4"># if the problem is numerical fuzz then this will probably</span>
                <span class="s4"># work, if the problem is rank deficiency then it won't!</span>
                <span class="s1">rec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_is_identity_matrix</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:</span>
                    <span class="s4"># check A=pinv(pinv(A))</span>
                    <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
                    <span class="s1">rec </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">got</span><span class="s2">)</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                        <span class="s1">rec</span><span class="s2">,</span>
                        <span class="s1">a</span><span class="s2">,</span>
                        <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                        <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
                    <span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] &gt;= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
                        <span class="s4"># if it is overdetermined or fully determined</span>
                        <span class="s4"># use numba lstsq function (which is type specific) to</span>
                        <span class="s4"># compute the inverse and check against that.</span>
                        <span class="s1">lstsq </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">lstsq_system</span><span class="s2">)</span>
                        <span class="s1">lstsq_pinv </span><span class="s2">= </span><span class="s1">lstsq</span><span class="s2">(</span>
                            <span class="s1">a</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span>
                                <span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]).</span><span class="s1">astype</span><span class="s2">(</span>
                                <span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), **</span><span class="s1">kwargs</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
                        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
                            <span class="s1">got</span><span class="s2">,</span>
                            <span class="s1">lstsq_pinv</span><span class="s2">,</span>
                            <span class="s1">rtol</span><span class="s2">=</span><span class="s5">10 </span><span class="s2">* </span><span class="s1">resolution</span><span class="s2">,</span>
                            <span class="s1">atol</span><span class="s2">=</span><span class="s5">100 </span><span class="s2">* </span><span class="s1">resolution  </span><span class="s4"># zeros tend to be fuzzy</span>
                        <span class="s2">)</span>
                    <span class="s4"># check the 2 norm of the difference is small</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">assertLess</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">got </span><span class="s2">- </span><span class="s1">expected</span><span class="s2">), </span><span class="s1">resolution</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># When required, a specified condition number</span>
        <span class="s1">specific_cond </span><span class="s2">= </span><span class="s5">10.</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s4"># check a full rank matrix</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">size</span>
            <span class="s0">if </span><span class="s1">m </span><span class="s2">!= </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">n </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4"># check a rank deficient matrix</span>
                <span class="s1">minmn </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">,</span>
                                                <span class="s1">condition</span><span class="s2">=</span><span class="s1">specific_cond</span><span class="s2">)</span>
                <span class="s1">rcond </span><span class="s2">= </span><span class="s5">1. </span><span class="s2">/ </span><span class="s1">specific_cond</span>
                <span class="s1">approx_half_rank_rcond </span><span class="s2">= </span><span class="s1">minmn </span><span class="s2">* </span><span class="s1">rcond</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=</span><span class="s1">approx_half_rank_rcond</span><span class="s2">)</span>

        <span class="s4"># check empty</span>
        <span class="s0">for </span><span class="s1">sz </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]:</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sz</span><span class="s2">))</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;pinv&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_issue5870</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># testing for mutation of input matrix</span>
        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">some_fn</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">pinv</span><span class="s2">(</span><span class="s1">v</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s1">v_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                           <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                           <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                           <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">v_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">v_data</span><span class="s2">)</span>
        <span class="s1">reshaped_v </span><span class="s2">= </span><span class="s1">v_data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s2">))</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">some_fn</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">reshaped_v</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">v_data</span><span class="s2">, </span><span class="s1">v_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">some_fn</span><span class="s2">(</span><span class="s1">reshaped_v</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">v_data</span><span class="s2">, </span><span class="s1">v_orig</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgDetAndSlogdet</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.det. and np.linalg.slogdet. 
    Exactly the same inputs are used for both tests as 
    det() is a trivial function of slogdet(), the tests 
    are therefore combined. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">check_det</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">det_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>

        <span class="s4"># check the determinants are the same</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

        <span class="s4"># Ensure proper resource management</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_slogdet</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">slogdet_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># As numba returns python floats types and numpy returns</span>
        <span class="s4"># numpy float types, some more adjustment and different</span>
        <span class="s4"># types of comparison than those used with array based</span>
        <span class="s4"># results is required.</span>

        <span class="s4"># check that the returned tuple is same length</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>
        <span class="s4"># and that length is 2</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">), </span><span class="s5">2</span><span class="s2">)</span>

        <span class="s4"># check that the domain of the results match</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]),</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]))</span>

        <span class="s4"># turn got[0] into the same dtype as `a`</span>
        <span class="s4"># this is so checking with nulp will work</span>
        <span class="s1">got_conv </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_almost_equal_nulp</span><span class="s2">(</span>
            <span class="s1">got_conv</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">nulp</span><span class="s2">=</span><span class="s5">10</span><span class="s2">)</span>
        <span class="s4"># compare log determinant magnitude with a more fuzzy value</span>
        <span class="s4"># as numpy values come from higher precision lapack routines</span>
        <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span>
            <span class="s1">got</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

        <span class="s4"># Ensure proper resource management</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">do_test</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">rn</span><span class="s2">, </span><span class="s1">check</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">):</span>

        <span class="s4"># test: 1x1 as it is unusual, 4x4 as it is even and 7x7 as is it odd!</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># test loop</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s4"># check a full rank matrix</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># use a matrix of zeros to trip xgetrf U(i,i)=0 singular test</span>
        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># check empty</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)))</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_det</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">det_matrix</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">do_test</span><span class="s2">(</span><span class="s6">&quot;det&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_det</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_slogdet</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">slogdet_matrix</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">do_test</span><span class="s2">(</span><span class="s6">&quot;slogdet&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_slogdet</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                      <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">slogdet</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>

<span class="s4"># Use TestLinalgSystems as a base to get access to additional</span>
<span class="s4"># testing for 1 and 2D inputs.</span>


<span class="s0">class </span><span class="s1">TestLinalgNorm</span><span class="s2">(</span><span class="s1">TestLinalgSystems</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.norm. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_norm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.norm 
        &quot;&quot;&quot;</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">norm_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">norm_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># All results should be in the real domain</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s0">not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>

            <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>

            <span class="s4"># check the norms are the same to the arg `a` precision</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># Check 1D inputs</span>
        <span class="s1">sizes </span><span class="s2">= [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">7</span><span class="s2">]</span>
        <span class="s1">nrm_types </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6.7</span><span class="s2">, -</span><span class="s5">4.3</span><span class="s2">]</span>

        <span class="s4"># standard 1D input</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">nrm_type </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">nrm_types</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

        <span class="s4"># sliced 1D input</span>
        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">nrm_type </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">nrm_types</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)[::</span><span class="s5">3</span><span class="s2">]</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

        <span class="s4"># Check 2D inputs:</span>
        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>
        <span class="s1">nrm_types </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">]</span>

        <span class="s4"># standard 2D input</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">nrm_type </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">, </span><span class="s1">nrm_types</span><span class="s2">):</span>
            <span class="s4"># check a full rank matrix</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

        <span class="s4"># check 2D slices work for the case where xnrm2 is called from</span>
        <span class="s4"># BLAS (ord=None) to make sure it is working ok.</span>
        <span class="s1">nrm_types </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">nrm_type</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">nrm_types</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">((</span><span class="s5">17</span><span class="s2">, </span><span class="s5">13</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s4"># contig for C order</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[:</span><span class="s5">3</span><span class="s2">], </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

            <span class="s4"># contig for Fortran order</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[:, </span><span class="s5">3</span><span class="s2">:], </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

            <span class="s4"># contig for neither order</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">::</span><span class="s5">3</span><span class="s2">], </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">nrm_type</span><span class="s2">)</span>

        <span class="s4"># check that numba returns zero for empty arrays. Numpy returns zero</span>
        <span class="s4"># for most norm types and raises ValueError for +/-np.inf.</span>
        <span class="s4"># there is not a great deal of consistency in Numpy's response so</span>
        <span class="s4"># it is not being emulated in Numba</span>
        <span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">nrm_type</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">nrm_types</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">nrm_type</span><span class="s2">), </span><span class="s5">0.0</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">nrm_type</span><span class="s2">), </span><span class="s5">0.0</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;norm&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue, reuse the test from the TestLinalgSystems class</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span>
            <span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span>
                <span class="s5">12</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span>
                <span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs for 2d case when SVD is used (e.g 2-norm)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s5">2</span><span class="s2">))</span>

        <span class="s4"># assert 2D input raises for an invalid norm kind kwarg</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_invalid_norm_kind</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], [</span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s2">]],</span>
                                                       <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s5">6</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">TestLinalgCond</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.cond. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_cond</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.cond 
        &quot;&quot;&quot;</span>

        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">cond_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">cond_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># All results should be in the real domain</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertTrue</span><span class="s2">(</span><span class="s0">not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">got</span><span class="s2">))</span>

            <span class="s1">resolution </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>

            <span class="s4"># check the cond is the same to the arg `a` precision</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">resolution</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># valid p values (used to indicate norm type)</span>
        <span class="s1">ps </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">]</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">, </span><span class="s1">ps</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">=</span><span class="s1">p</span><span class="s2">)</span>

        <span class="s4"># When p=None non-square matrices are accepted.</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>
        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># empty</span>
        <span class="s0">for </span><span class="s1">sz </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sz</span><span class="s2">),))</span>

        <span class="s4"># singular systems to trip divide-by-zero</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">=-</span><span class="s5">2</span><span class="s2">)</span>

        <span class="s4"># try an ill-conditioned system with 2-norm, make sure np raises an</span>
        <span class="s4"># overflow warning as the result is `+inf` and that the result from</span>
        <span class="s4"># numba matches.</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.e308</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s6">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;cond&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs when p=&quot;None&quot; (default for kwarg).</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

        <span class="s4"># assert raises for an invalid norm kind kwarg</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_invalid_norm_kind</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">], [</span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s2">]],</span>
                                                       <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s5">6</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">TestLinalgMatrixRank</span><span class="s2">(</span><span class="s1">TestLinalgSystems</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.matrix_rank. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_matrix_rank</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test np.linalg.matrix_rank 
        &quot;&quot;&quot;</span>

        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">matrix_rank_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">matrix_rank_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s4"># Ranks are integral so comparison should be trivial.</span>
            <span class="s4"># check the rank is the same</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s4"># check full rank system</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

            <span class="s4"># If the system is a matrix, check rank deficiency is reported</span>
            <span class="s4"># correctly. Check all ranks from 0 to (full rank - 1).</span>
            <span class="s1">tol </span><span class="s2">= </span><span class="s5">1e-13</span>
            <span class="s4"># first check 1 to (full rank - 1)</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">min</span><span class="s2">(</span><span class="s1">size</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">):</span>
                <span class="s4"># check rank k</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">=</span><span class="s1">k</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">k</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
                <span class="s4"># check provision of a tolerance works as expected</span>
                <span class="s4"># create a (m x n) diagonal matrix with a singular value</span>
                <span class="s4"># guaranteed below the tolerance 1e-13</span>
                <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span>
                <span class="s1">a</span><span class="s2">[:, :] = </span><span class="s5">0.  </span><span class="s4"># reuse `a`'s memory</span>
                <span class="s1">idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
                    <span class="s1">b </span><span class="s2">= </span><span class="s5">1. </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s1">k</span><span class="s2">) + </span><span class="s5">1.j </span><span class="s2">+</span><span class="s1">\</span>
                        <span class="s5">1.j </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
                    <span class="s4"># min singular value is sqrt(2)*1e-14</span>
                    <span class="s1">b</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s5">1e-14 </span><span class="s2">+ </span><span class="s5">1e-14j</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">b </span><span class="s2">= </span><span class="s5">1. </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
                    <span class="s1">b</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s5">1e-14  </span><span class="s4"># min singular value is 1e-14</span>
                <span class="s1">a</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][:</span><span class="s1">k</span><span class="s2">], </span><span class="s1">idx</span><span class="s2">[</span><span class="s5">1</span><span class="s2">][:</span><span class="s1">k</span><span class="s2">]] = </span><span class="s1">b</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s4"># rank should be k-1 (as tol is present)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">), </span><span class="s1">k </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>
            <span class="s4"># then check zero rank</span>
            <span class="s1">a</span><span class="s2">[:, :] = </span><span class="s5">0.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s4"># add in a singular value that is small</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
                <span class="s1">a</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">] = </span><span class="s5">1e-14 </span><span class="s2">+ </span><span class="s5">1e-14j</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">a</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">] = </span><span class="s5">1e-14</span>
            <span class="s4"># check the system has zero rank to a given tolerance</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">), </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>

        <span class="s4"># check the zero vector returns rank 0 and a nonzero vector</span>
        <span class="s4"># returns rank 1.</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">:</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">5</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s4"># make it a nonzero vector</span>
            <span class="s1">a</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s5">1.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s4"># empty</span>
        <span class="s0">for </span><span class="s1">sz </span><span class="s0">in </span><span class="s2">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]:</span>
            <span class="s0">for </span><span class="s1">tol </span><span class="s0">in </span><span class="s2">[</span><span class="s0">None</span><span class="s2">, </span><span class="s5">1e-13</span><span class="s2">]:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_empty</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sz</span><span class="s2">), </span><span class="s1">tol</span><span class="s2">))</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;matrix_rank&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">),))</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span>
            <span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span>
                <span class="s5">12</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span>
                <span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">),))</span>

        <span class="s4"># no nans or infs for 2D case</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_no_nan_or_inf</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">,</span>
                                  <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, ], [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]],</span>
                                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),))</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_no_input_mutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># this is here to test no input mutation by</span>
        <span class="s4"># numba.np.linalg._compute_singular_values</span>
        <span class="s4"># which is the workhorse for norm with 2d input, rank and cond.</span>

        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">,],</span>
                      <span class="s2">[-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">9</span><span class="s2">, -</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,],</span>
                      <span class="s2">[</span><span class="s5">2</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s2">,]], </span><span class="s1">order</span><span class="s2">=</span><span class="s6">'F'</span><span class="s2">)</span>

        <span class="s1">X_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">test</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">test</span><span class="s2">:</span>
                <span class="s4"># not executed, but necessary to trigger A ordering in X</span>
                <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:</span><span class="s5">2</span><span class="s2">, :]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">py_func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_orig</span><span class="s2">)</span>

        <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">got</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestLinalgMatrixPower</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.linalg.matrix_power. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">assert_int_exponenent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4"># validate first arg is ok</span>
        <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s4"># pass in both args and assert fail</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">):</span>
            <span class="s1">cfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">needs_lapack</span>
    <span class="s0">def </span><span class="s1">test_linalg_matrix_power</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">matrix_power_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">):</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">matrix_power_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">)</span>

            <span class="s4"># check that the computed results are contig and in the same way</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_contig_sanity</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s6">&quot;C&quot;</span><span class="s2">)</span>

            <span class="s1">res </span><span class="s2">= </span><span class="s5">7 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">)</span>

        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>
        <span class="s1">powers </span><span class="s2">= [-</span><span class="s5">33</span><span class="s2">, -</span><span class="s5">17</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">)) + [</span><span class="s5">17</span><span class="s2">, </span><span class="s5">33</span><span class="s2">]</span>

        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">powers</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">pwr</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;matrix_power&quot;</span>

        <span class="s4"># Wrong dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">), </span><span class="s5">1</span><span class="s2">))</span>

        <span class="s4"># not an int power</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dtype</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">), </span><span class="s5">1</span><span class="s2">))</span>

        <span class="s4"># non square system</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s2">)), </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">'input must be a square array'</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s5">1</span><span class="s2">))</span>

        <span class="s4"># non-integer supplied as exponent</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_int_exponenent</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)), </span><span class="s5">1.2</span><span class="s2">))</span>

        <span class="s4"># singular matrix is not invertible</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_raise_on_singular</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]]), -</span><span class="s5">1</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">TestTrace</span><span class="s2">(</span><span class="s1">TestLinalgBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Tests for np.trace. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TestTrace</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">setUp</span><span class="s2">()</span>
        <span class="s4"># compile two versions, one with and one without the offset kwarg</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_w_offset </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">trace_matrix</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_no_offset </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">trace_matrix_no_offset</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">assert_int_offset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4"># validate first arg is ok</span>
        <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s4"># pass in kwarg and assert fail</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">):</span>
            <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_trace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s6">'offset' </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s1">expected </span><span class="s2">= </span><span class="s1">trace_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_w_offset</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">expected </span><span class="s2">= </span><span class="s1">trace_matrix_no_offset</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_no_offset</span>

            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s1">res </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># test: column vector, tall, wide, square, row vector</span>
        <span class="s4"># prime sizes</span>
        <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), (</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">)]</span>

        <span class="s4"># offsets to cover the range of the matrix sizes above</span>
        <span class="s1">offsets </span><span class="s2">= [-</span><span class="s5">13</span><span class="s2">, -</span><span class="s5">12</span><span class="s2">, -</span><span class="s5">11</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">)) + [</span><span class="s5">11</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">13</span><span class="s2">]</span>

        <span class="s0">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">, </span><span class="s6">'FC'</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">specific_sample_matrix</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">offset </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">offset </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s1">rn </span><span class="s2">= </span><span class="s6">&quot;trace&quot;</span>

        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_w_offset</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s5">1</span><span class="s2">), </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_no_offset</span><span class="s2">,</span>
                                     <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">),), </span><span class="s0">False</span><span class="s2">)</span>

        <span class="s4"># non-integer supplied as exponent</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_int_offset</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cfunc_w_offset</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)), </span><span class="s1">offset</span><span class="s2">=</span><span class="s5">1.2</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_trace_w_optional_input</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;Issue 2314&quot;</span>
        <span class="s2">@</span><span class="s1">jit</span><span class="s2">(</span><span class="s6">&quot;(optional(float64[:,:]),)&quot;</span><span class="s2">, </span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">tested</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">trace</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tested</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">raises</span><span class="s2">:</span>
            <span class="s1">tested</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">errmsg </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">raises</span><span class="s2">.</span><span class="s1">exception</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s6">'expected array(float64, 2d, A), got None'</span><span class="s2">, </span><span class="s1">errmsg</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestBasics</span><span class="s2">(</span><span class="s1">TestLinalgSystems</span><span class="s2">):  </span><span class="s4"># TestLinalgSystems for 1d test</span>

    <span class="s1">order1 </span><span class="s2">= </span><span class="s1">cycle</span><span class="s2">([</span><span class="s6">'F'</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">])</span>
    <span class="s1">order2 </span><span class="s2">= </span><span class="s1">cycle</span><span class="s2">([</span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">, </span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">])</span>

    <span class="s4"># test: column vector, matrix, row vector, 1d sizes</span>
    <span class="s4"># (7, 1, 3) and two scalars</span>
    <span class="s1">sizes </span><span class="s2">= [(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">), (</span><span class="s5">7</span><span class="s2">,), (</span><span class="s5">1</span><span class="s2">,), (</span><span class="s5">3</span><span class="s2">,), </span><span class="s5">3.</span><span class="s2">, </span><span class="s5">5.</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_assert_wrong_dim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">):</span>
        <span class="s4"># Dimension issue</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span>
            <span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">]]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)), </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_wrong_dimensions_1D</span><span class="s2">(</span>
            <span class="s1">rn</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">]]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)), </span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_gen_input</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">size</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">size</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span><span class="s1">size</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sample_vector</span><span class="s2">(</span>
                    <span class="s1">size</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] * </span><span class="s1">size</span><span class="s2">[</span><span class="s5">1</span><span class="s2">],</span>
                    <span class="s1">dtype</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span>
                    <span class="s1">size</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_input</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">size1</span><span class="s2">, </span><span class="s1">size2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gen_input</span><span class="s2">(</span><span class="s1">size1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">next</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">order1</span><span class="s2">))</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gen_input</span><span class="s2">(</span><span class="s1">size2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">next</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">order2</span><span class="s2">))</span>
        <span class="s4"># force domain consistency as underlying ufuncs require it</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">b </span><span class="s2">+ </span><span class="s5">1j</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">a </span><span class="s2">+ </span><span class="s5">1j</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_outer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">outer_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>

            <span class="s4"># check without kwargs</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">outer_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

            <span class="s1">res </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>

            <span class="s4"># if kwargs present check with them too</span>
            <span class="s0">if </span><span class="s6">'out' </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">,</span>
                                           <span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">[</span><span class="s6">'out'</span><span class="s2">], </span><span class="s1">expected</span><span class="s2">,</span>
                                           <span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">dts </span><span class="s2">= </span><span class="s1">cycle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">size1</span><span class="s2">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sizes</span><span class="s2">):</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">dts</span><span class="s2">)</span>
            <span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_input</span><span class="s2">(</span><span class="s1">size1</span><span class="s2">, </span><span class="s1">size2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">size</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">b</span><span class="s2">).</span><span class="s1">size</span><span class="s2">),</span>
                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">c</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_assert_wrong_dim</span><span class="s2">(</span><span class="s6">&quot;outer&quot;</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_kron</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">cfunc </span><span class="s2">= </span><span class="s1">jit</span><span class="s2">(</span><span class="s1">nopython</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)(</span><span class="s1">kron_matrix</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>

            <span class="s1">expected </span><span class="s2">= </span><span class="s1">kron_matrix</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">got </span><span class="s2">= </span><span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

            <span class="s1">res </span><span class="s2">= </span><span class="s5">5 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">resolution</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>

            <span class="s4"># Ensure proper resource management</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertNoNRTLeak</span><span class="s2">():</span>
                <span class="s1">cfunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s2">, </span><span class="s1">size2</span><span class="s2">, </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">\</span>
                <span class="s1">product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">):</span>
            <span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_input</span><span class="s2">(</span><span class="s1">size1</span><span class="s2">, </span><span class="s1">size2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">check</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_assert_wrong_dim</span><span class="s2">(</span><span class="s6">&quot;kron&quot;</span><span class="s2">, </span><span class="s1">cfunc</span><span class="s2">)</span>

        <span class="s1">args </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)[::</span><span class="s5">2</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)[::</span><span class="s5">2</span><span class="s2">])</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;only supports 'C' or 'F' layout&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_error</span><span class="s2">(</span><span class="s1">cfunc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">err</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestHelpers</span><span class="s2">(</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_copy_to_fortran_order</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg </span><span class="s0">import </span><span class="s1">_copy_to_fortran_order</span>

        <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">udt</span><span class="s2">, </span><span class="s1">expectfn</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order </span><span class="s0">in </span><span class="s1">product</span><span class="s2">(</span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">):</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>

                <span class="s1">r </span><span class="s2">= </span><span class="s1">udt</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
                <span class="s4"># check correct operation</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertPreciseEqual</span><span class="s2">(</span><span class="s1">expectfn</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">r</span><span class="s2">)</span>
                <span class="s4"># check new copy has made</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotEqual</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">direct_call</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">_copy_to_fortran_order</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

        <span class="s1">shapes </span><span class="s2">= [(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">)]</span>
        <span class="s1">dtypes </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
        <span class="s1">orders </span><span class="s2">= [</span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">]</span>
        <span class="s1">check</span><span class="s2">(</span><span class="s1">direct_call</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">)</span>


        <span class="s2">@</span><span class="s1">njit</span>
        <span class="s0">def </span><span class="s1">slice_to_any</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s4"># make a 'any' layout slice</span>
            <span class="s1">sliced </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[::</span><span class="s5">2</span><span class="s2">][</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">_copy_to_fortran_order</span><span class="s2">(</span><span class="s1">sliced</span><span class="s2">)</span>

        <span class="s1">shapes </span><span class="s2">= [(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">), (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">)]</span>
        <span class="s1">dtypes </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
        <span class="s1">orders </span><span class="s2">= [</span><span class="s6">'C'</span><span class="s2">, </span><span class="s6">'F'</span><span class="s2">]</span>

        <span class="s0">def </span><span class="s1">expected_slice_to_any</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s4"># make a 'any' layout slice</span>
            <span class="s1">sliced </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[::</span><span class="s5">2</span><span class="s2">][</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">sliced</span><span class="s2">)</span>

        <span class="s1">check</span><span class="s2">(</span><span class="s1">slice_to_any</span><span class="s2">, </span><span class="s1">expected_slice_to_any</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">)</span>

<span class="s0">if </span><span class="s1">__name__ </span><span class="s2">== </span><span class="s6">'__main__'</span><span class="s2">:</span>
    <span class="s1">unittest</span><span class="s2">.</span><span class="s1">main</span><span class="s2">()</span>
</pre>
</body>
</html>