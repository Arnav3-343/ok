<html>
<head>
<title>context.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
context.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>

<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">config</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">PYVERSION</span>


<span class="s1">_NRT_Meminfo_Functions </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s3">&quot;_NRT_Meminfo_Functions&quot;</span><span class="s2">,</span>
                                    <span class="s2">(</span><span class="s3">&quot;alloc&quot;</span><span class="s2">,</span>
                                     <span class="s3">&quot;alloc_dtor&quot;</span><span class="s2">,</span>
                                     <span class="s3">&quot;alloc_aligned&quot;</span><span class="s2">))</span>


<span class="s1">_NRT_MEMINFO_SAFE_API </span><span class="s2">= </span><span class="s1">_NRT_Meminfo_Functions</span><span class="s2">(</span><span class="s3">&quot;NRT_MemInfo_alloc_safe&quot;</span><span class="s2">,</span>
                                               <span class="s3">&quot;NRT_MemInfo_alloc_dtor_safe&quot;</span><span class="s2">,</span>
                                               <span class="s3">&quot;NRT_MemInfo_alloc_safe_aligned&quot;</span><span class="s2">)</span>


<span class="s1">_NRT_MEMINFO_DEFAULT_API </span><span class="s2">= </span><span class="s1">_NRT_Meminfo_Functions</span><span class="s2">(</span><span class="s3">&quot;NRT_MemInfo_alloc&quot;</span><span class="s2">,</span>
                                                  <span class="s3">&quot;NRT_MemInfo_alloc_dtor&quot;</span><span class="s2">,</span>
                                                  <span class="s3">&quot;NRT_MemInfo_alloc_aligned&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NRTContext</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    An object providing access to NRT APIs in the lowering pass. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">enabled</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_context </span><span class="s2">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_enabled </span><span class="s2">= </span><span class="s1">enabled</span>
        <span class="s5"># If DEBUG_NRT is set, use the safe function variants which use memset</span>
        <span class="s5"># to inject a few known bytes into the start of allocated regions.</span>
        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">DEBUG_NRT</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_meminfo_api </span><span class="s2">= </span><span class="s1">_NRT_MEMINFO_SAFE_API</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_meminfo_api </span><span class="s2">= </span><span class="s1">_NRT_MEMINFO_DEFAULT_API</span>

    <span class="s0">def </span><span class="s1">_require_nrt</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_enabled</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaRuntimeError</span><span class="s2">(</span><span class="s3">&quot;NRT required but not enabled&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_check_null_result</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">memptr </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Allocation failed (probably too large).&quot;</span>
            <span class="s1">cgutils</span><span class="s2">.</span><span class="s1">guard_memory_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">memptr</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">memptr</span>
        <span class="s0">return </span><span class="s1">wrap</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">allocate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Low-level allocate a new memory area of `size` bytes. The result of the 
        call is checked and if it is NULL, i.e. allocation failed, then a 
        MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">allocate_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">allocate_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Low-level allocate a new memory area of `size` bytes. Returns NULL to 
        indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, [</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s3">&quot;NRT_Allocate&quot;</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">free</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Low-level free a memory area allocated with allocate(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">VoidType</span><span class="s2">(), [</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s3">&quot;NRT_Free&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">ptr</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_alloc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with a data payload of `size` bytes. 
 
        A pointer to the MemInfo is returned. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_alloc_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_alloc_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with a data payload of `size` bytes. 
 
        A pointer to the MemInfo is returned. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, [</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">,</span>
                                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_meminfo_api</span><span class="s2">.</span><span class="s1">alloc</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_alloc_dtor</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with a data payload of `size` bytes and a 
        destructor `dtor`. 
 
        A pointer to the MemInfo is returned. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_alloc_dtor_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_alloc_dtor_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with a data payload of `size` bytes and a 
        destructor `dtor`. 
 
        A pointer to the MemInfo is returned. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">,</span>
                               <span class="s2">[</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">,</span>
                                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_meminfo_api</span><span class="s2">.</span><span class="s1">alloc_dtor</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">,</span>
                                 <span class="s1">builder</span><span class="s2">.</span><span class="s1">bitcast</span><span class="s2">(</span><span class="s1">dtor</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">)])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_alloc_aligned</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">align</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with an aligned data payload of `size` bytes. 
        The data pointer is aligned to `align` bytes.  `align` can be either 
        a Python int or a LLVM uint32 value. 
 
        A pointer to the MemInfo is returned. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_alloc_aligned_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">align</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_alloc_aligned_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">align</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new MemInfo with an aligned data payload of `size` bytes. 
        The data pointer is aligned to `align` bytes.  `align` can be either 
        a Python int or a LLVM uint32 value. 
 
        A pointer to the MemInfo is returned. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">u32 </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s6">32</span><span class="s2">)</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, [</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">, </span><span class="s1">u32</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">,</span>
                                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_meminfo_api</span><span class="s2">.</span><span class="s1">alloc_aligned</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">align</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s1">align </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">, </span><span class="s1">align</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">align</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s1">u32</span><span class="s2">, </span><span class="s3">&quot;align must be a uint32&quot;</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">, </span><span class="s1">align</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_new_varsize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a MemInfo pointing to a variable-sized data area.  The area 
        is separately allocated (i.e. two allocations are made) so that 
        re-allocating it doesn't change the MemInfo's address. 
 
        A pointer to the MemInfo is returned. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_new_varsize_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_new_varsize_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a MemInfo pointing to a variable-sized data area.  The area 
        is separately allocated (i.e. two allocations are made) so that 
        re-allocating it doesn't change the MemInfo's address. 
 
        A pointer to the MemInfo is returned. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, [</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">,</span>
                                            <span class="s3">&quot;NRT_MemInfo_new_varsize&quot;</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_new_varsize_dtor</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Like meminfo_new_varsize() but also set the destructor for 
        cleaning up references to objects inside the allocation. 
 
        A pointer to the MemInfo is returned. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_new_varsize_dtor_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_new_varsize_dtor_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Like meminfo_new_varsize() but also set the destructor for 
        cleaning up references to objects inside the allocation. 
 
        A pointer to the MemInfo is returned. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">,</span>
                               <span class="s2">[</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span>
            <span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s3">&quot;NRT_MemInfo_new_varsize_dtor&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtor</span><span class="s2">])</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_varsize_alloc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new data area for a MemInfo created by meminfo_new_varsize(). 
        The new data pointer is returned, for convenience. 
 
        Contrary to realloc(), this always allocates a new area and doesn't 
        copy the old data.  This is useful if resizing a container needs 
        more than simply copying the data area (e.g. for hash tables). 
 
        The old pointer will have to be freed with meminfo_varsize_free(). 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_varsize_alloc_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_varsize_alloc_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Allocate a new data area for a MemInfo created by meminfo_new_varsize(). 
        The new data pointer is returned, for convenience. 
 
        Contrary to realloc(), this always allocates a new area and doesn't 
        copy the old data.  This is useful if resizing a container needs 
        more than simply copying the data area (e.g. for hash tables). 
 
        The old pointer will have to be freed with meminfo_varsize_free(). 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_call_varsize_alloc</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">,</span>
                                        <span class="s3">&quot;NRT_MemInfo_varsize_alloc&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">_check_null_result</span>
    <span class="s0">def </span><span class="s1">meminfo_varsize_realloc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Reallocate a data area allocated by meminfo_new_varsize(). 
        The new data pointer is returned, for convenience. 
 
        The result of the call is checked and if it is NULL, i.e. allocation 
        failed, then a MemoryError is raised. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">meminfo_varsize_realloc_unchecked</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_varsize_realloc_unchecked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Reallocate a data area allocated by meminfo_new_varsize(). 
        The new data pointer is returned, for convenience. 
 
        Returns NULL to indicate error/failure to allocate. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_call_varsize_alloc</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">,</span>
                                        <span class="s3">&quot;NRT_MemInfo_varsize_realloc&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">meminfo_varsize_free</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Free a memory area allocated for a NRT varsize object. 
        Note this does *not* free the NRT object itself! 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">VoidType</span><span class="s2">(),</span>
                               <span class="s2">[</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">,</span>
                                            <span class="s3">&quot;NRT_MemInfo_varsize_free&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, (</span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_call_varsize_alloc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">,</span>
                               <span class="s2">[</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">intp_t</span><span class="s2">])</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">return_value</span><span class="s2">.</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">meminfo</span><span class="s2">, </span><span class="s1">size</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">meminfo_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">meminfo</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Given a MemInfo pointer, return a pointer to the allocated data 
        managed by it.  This works for MemInfos allocated with all the 
        above methods. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">runtime</span><span class="s2">.</span><span class="s1">nrtdynmod </span><span class="s0">import </span><span class="s1">meminfo_data_ty</span>

        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">meminfo_data_ty</span><span class="s2">,</span>
                                            <span class="s3">&quot;NRT_MemInfo_data_fast&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">meminfo</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">get_meminfos</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a list of *(type, meminfo)* inside the given value. 
        &quot;&quot;&quot;</span>
        <span class="s1">datamodel </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">]</span>
        <span class="s1">members </span><span class="s2">= </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">traverse</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">)</span>

        <span class="s1">meminfos </span><span class="s2">= []</span>
        <span class="s0">if </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">has_nrt_meminfo</span><span class="s2">():</span>
            <span class="s1">mi </span><span class="s2">= </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">get_nrt_meminfo</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
            <span class="s1">meminfos</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">mi</span><span class="s2">))</span>

        <span class="s0">for </span><span class="s1">mtyp</span><span class="s2">, </span><span class="s1">getter </span><span class="s0">in </span><span class="s1">members</span><span class="s2">:</span>
            <span class="s1">field </span><span class="s2">= </span><span class="s1">getter</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
            <span class="s1">inner_meminfos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_meminfos</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">mtyp</span><span class="s2">, </span><span class="s1">field</span><span class="s2">)</span>
            <span class="s1">meminfos</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">inner_meminfos</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">meminfos</span>

    <span class="s0">def </span><span class="s1">_call_incref_decref</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Call function of *funcname* on every meminfo found in *value*. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">runtime</span><span class="s2">.</span><span class="s1">nrtdynmod </span><span class="s0">import </span><span class="s1">incref_decref_ty</span>

        <span class="s1">meminfos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_meminfos</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">mi </span><span class="s0">in </span><span class="s1">meminfos</span><span class="s2">:</span>
            <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
            <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">incref_decref_ty</span><span class="s2">,</span>
                                                <span class="s1">funcname</span><span class="s2">)</span>
            <span class="s5"># XXX &quot;nonnull&quot; causes a crash in test_dyn_array: can this</span>
            <span class="s5"># function be called with a NULL pointer?</span>
            <span class="s1">fn</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;noalias&quot;</span><span class="s2">)</span>
            <span class="s1">fn</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">add_attribute</span><span class="s2">(</span><span class="s3">&quot;nocapture&quot;</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, [</span><span class="s1">mi</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">incref</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Recursively incref the given *value* and its members. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_call_incref_decref</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s3">&quot;NRT_incref&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">decref</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Recursively decref the given *value* and its members. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_call_incref_decref</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s3">&quot;NRT_decref&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_nrt_api</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Calls NRT_get_api(), which returns the NRT API function table. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_require_nrt</span><span class="s2">()</span>

        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, ())</span>
        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s3">&quot;NRT_get_api&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, ())</span>

    <span class="s0">def </span><span class="s1">eh_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Check if an exception is raised 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span>
        <span class="s1">cc </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">call_conv</span>
        <span class="s5"># Inspect the excinfo argument on the function</span>
        <span class="s1">trystatus </span><span class="s2">= </span><span class="s1">cc</span><span class="s2">.</span><span class="s1">check_try_status</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">)</span>
        <span class="s1">excinfo </span><span class="s2">= </span><span class="s1">trystatus</span><span class="s2">.</span><span class="s1">excinfo</span>
        <span class="s1">has_raised </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">not_</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_null</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">excinfo</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">PYVERSION </span><span class="s2">&lt; (</span><span class="s6">3</span><span class="s2">, </span><span class="s6">11</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_then</span><span class="s2">(</span><span class="s1">has_raised</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">eh_end_try</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">has_raised</span>

    <span class="s0">def </span><span class="s1">eh_try</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Begin a try-block. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span>
        <span class="s1">cc </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">call_conv</span>
        <span class="s1">cc</span><span class="s2">.</span><span class="s1">set_try_status</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">eh_end_try</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;End a try-block 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span>
        <span class="s1">cc </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">call_conv</span>
        <span class="s1">cc</span><span class="s2">.</span><span class="s1">unset_try_status</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">)</span>
</pre>
</body>
</html>