<html>
<head>
<title>arrayobj.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arrayobj.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of operations on Array objects and objects supporting 
the buffer protocol. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">llvmlite </span><span class="s2">import </span><span class="s1">ir</span>
<span class="s2">from </span><span class="s1">llvmlite</span><span class="s3">.</span><span class="s1">ir </span><span class="s2">import </span><span class="s1">Constant</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numba </span><span class="s2">import </span><span class="s1">pndindex</span><span class="s3">, </span><span class="s1">literal_unroll</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">, </span><span class="s1">extending</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">, </span><span class="s1">from_dtype</span><span class="s3">, </span><span class="s1">carray</span><span class="s3">, </span><span class="s1">farray</span><span class="s3">,</span>
                                    <span class="s1">is_contiguous</span><span class="s3">, </span><span class="s1">is_fortran</span><span class="s3">,</span>
                                    <span class="s1">check_is_integer</span><span class="s3">, </span><span class="s1">type_is_scalar</span><span class="s3">,</span>
                                    <span class="s1">lt_complex</span><span class="s3">, </span><span class="s1">lt_floats</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">numpy_support </span><span class="s2">import </span><span class="s1">type_can_asarray</span><span class="s3">, </span><span class="s1">is_nonelike</span><span class="s3">, </span><span class="s1">numpy_version</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">imputils </span><span class="s2">import </span><span class="s3">(</span><span class="s1">lower_builtin</span><span class="s3">, </span><span class="s1">lower_getattr</span><span class="s3">,</span>
                                 <span class="s1">lower_getattr_generic</span><span class="s3">,</span>
                                 <span class="s1">lower_setattr_generic</span><span class="s3">,</span>
                                 <span class="s1">lower_cast</span><span class="s3">, </span><span class="s1">lower_constant</span><span class="s3">,</span>
                                 <span class="s1">iternext_impl</span><span class="s3">, </span><span class="s1">impl_ret_borrowed</span><span class="s3">,</span>
                                 <span class="s1">impl_ret_new_ref</span><span class="s3">, </span><span class="s1">impl_ret_untracked</span><span class="s3">,</span>
                                 <span class="s1">RefType</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">StringLiteral</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s3">(</span><span class="s1">register_jitable</span><span class="s3">, </span><span class="s1">overload</span><span class="s3">, </span><span class="s1">overload_method</span><span class="s3">,</span>
                                  <span class="s1">intrinsic</span><span class="s3">, </span><span class="s1">overload_attribute</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">misc </span><span class="s2">import </span><span class="s1">quicksort</span><span class="s3">, </span><span class="s1">mergesort</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">cpython </span><span class="s2">import </span><span class="s1">slicing</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">cpython</span><span class="s3">.</span><span class="s1">unsafe</span><span class="s3">.</span><span class="s1">tuple </span><span class="s2">import </span><span class="s1">tuple_setitem</span><span class="s3">, </span><span class="s1">build_full_slice_tuple</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">overload_classmethod</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">npydecl </span><span class="s2">import </span><span class="s3">(</span><span class="s1">parse_dtype </span><span class="s2">as </span><span class="s1">ty_parse_dtype</span><span class="s3">,</span>
                                       <span class="s1">parse_shape </span><span class="s2">as </span><span class="s1">ty_parse_shape</span><span class="s3">,</span>
                                       <span class="s1">_parse_nested_sequence</span><span class="s3">,</span>
                                       <span class="s1">_sequence_of_arrays</span><span class="s3">,</span>
                                       <span class="s1">_choose_concatenation_layout</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">set_range_metadata</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">load</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set the &quot;range&quot; metadata on a load instruction. 
    Note the interval is in the form [lower_bound, upper_bound). 
    &quot;&quot;&quot;</span>
    <span class="s1">range_operands </span><span class="s3">= [</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">load</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">),</span>
                      <span class="s1">Constant</span><span class="s3">(</span><span class="s1">load</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">)]</span>
    <span class="s1">md </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">add_metadata</span><span class="s3">(</span><span class="s1">range_operands</span><span class="s3">)</span>
    <span class="s1">load</span><span class="s3">.</span><span class="s1">set_metadata</span><span class="s3">(</span><span class="s4">&quot;range&quot;</span><span class="s3">, </span><span class="s1">md</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">mark_positive</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">load</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Mark the result of a load instruction as positive (or zero). 
    &quot;&quot;&quot;</span>
    <span class="s1">upper_bound </span><span class="s3">= (</span><span class="s5">1 </span><span class="s3">&lt;&lt; (</span><span class="s1">load</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">width </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)) - </span><span class="s5">1</span>
    <span class="s1">set_range_metadata</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">load</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">array_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the Structure representation of the given *array_type* 
    (an instance of types.ArrayCompatible). 
 
    Note this does not call __array_wrap__ in case a new array structure 
    is being created (rather than populated). 
    &quot;&quot;&quot;</span>
    <span class="s1">real_array_type </span><span class="s3">= </span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">as_array</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">real_array_type</span><span class="s3">)</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">real_array_type</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">class </span><span class="s1">ArrayStruct</span><span class="s3">(</span><span class="s1">base</span><span class="s3">):</span>

        <span class="s2">def </span><span class="s1">_make_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">):</span>
            <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">real_array_type</span><span class="s3">, </span><span class="s1">array_type</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">array_impl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s4">'__array__'</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">super</span><span class="s3">(</span><span class="s1">ArrayStruct</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">_make_refs</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>

            <span class="s6"># Return a wrapped structure and its unwrapped reference</span>
            <span class="s1">datamodel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">array_type</span><span class="s3">]</span>
            <span class="s1">be_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_be_type</span><span class="s3">(</span><span class="s1">datamodel</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">ref </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">outer_ref </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, </span><span class="s1">be_type</span><span class="s3">,</span>
                                                <span class="s1">zfill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">outer_ref </span><span class="s3">= </span><span class="s1">ref</span>
            <span class="s6"># NOTE: __array__ is called with a pointer and expects a pointer</span>
            <span class="s6"># in return!</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s1">array_impl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, (</span><span class="s1">outer_ref</span><span class="s3">,))</span>
            <span class="s2">return </span><span class="s1">outer_ref</span><span class="s3">, </span><span class="s1">ref</span>

        <span class="s3">@</span><span class="s1">property</span>
        <span class="s2">def </span><span class="s1">shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Override .shape to inform LLVM that its elements are all positive. 
            &quot;&quot;&quot;</span>
            <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span>
            <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">base</span><span class="s3">.</span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;shape&quot;</span><span class="s3">)</span>

            <span class="s6"># Unfortunately, we can't use llvm.assume as its presence can</span>
            <span class="s6"># seriously pessimize performance,</span>
            <span class="s6"># *and* the range metadata currently isn't improving anything here,</span>
            <span class="s6"># see https://llvm.org/bugs/show_bug.cgi?id=23848 !</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">&quot;shape&quot;</span><span class="s3">)</span>
            <span class="s1">dims </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
                <span class="s1">dimptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">load </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">dimptr</span><span class="s3">)</span>
                <span class="s1">dims</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">load</span><span class="s3">)</span>
                <span class="s1">mark_positive</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">load</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ArrayStruct</span>


<span class="s2">def </span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">array_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the item size for the given array or buffer type. 
    &quot;&quot;&quot;</span>
    <span class="s1">llty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">llty</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Load the item at the given array pointer. 
    &quot;&quot;&quot;</span>
    <span class="s1">align </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">arrayty</span><span class="s3">.</span><span class="s1">aligned </span><span class="s2">else </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">unpack_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">,</span>
                                <span class="s1">align</span><span class="s3">=</span><span class="s1">align</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Store the item at the given array pointer. 
    &quot;&quot;&quot;</span>
    <span class="s1">align </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">arrayty</span><span class="s3">.</span><span class="s1">aligned </span><span class="s2">else </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">pack_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">align</span><span class="s3">=</span><span class="s1">align</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fix_integer_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fix the integer index' type and value for the given dimension size. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">signed</span><span class="s3">:</span>
        <span class="s1">ind </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">ind </span><span class="s3">= </span><span class="s1">slicing</span><span class="s3">.</span><span class="s1">fix_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ind </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ind</span>


<span class="s2">def </span><span class="s1">normalize_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Normalize the index type and value.  0-d arrays are converted to scalars. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
        <span class="s1">idxary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">)</span>
        <span class="s1">idxval </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idxary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">idxval</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx</span>


<span class="s2">def </span><span class="s1">normalize_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Same as normalize_index(), but operating on sequences of 
    index types and values. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*[</span><span class="s1">normalize_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">,</span>
                                                     <span class="s1">idx</span><span class="s3">)</span>
                                     <span class="s2">for </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
                                     <span class="s3">])</span>
    <span class="s2">return </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span>


<span class="s2">def </span><span class="s1">populate_array</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function for populating array structures. 
    This avoids forgetting to set fields. 
 
    *shape* and *strides* can be Python tuples or LLVM arrays. 
    &quot;&quot;&quot;</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_context</span>
    <span class="s1">builder </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_builder</span>
    <span class="s1">datamodel </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_datamodel</span>
    <span class="s6"># doesn't matter what this array type instance is, it's just to get the</span>
    <span class="s6"># fields for the datamodel of the standard array type in this context</span>
    <span class="s1">standard_array </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">standard_array_type_datamodel </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">standard_array</span><span class="s3">]</span>
    <span class="s1">required_fields </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">standard_array_type_datamodel</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">)</span>
    <span class="s1">datamodel_fields </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">datamodel</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">)</span>
    <span class="s6"># Make sure that the presented array object has a data model that is close</span>
    <span class="s6"># enough to an array for this function to proceed.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">required_fields </span><span class="s3">&amp; </span><span class="s1">datamodel_fields</span><span class="s3">) != </span><span class="s1">required_fields</span><span class="s3">:</span>
        <span class="s1">missing </span><span class="s3">= </span><span class="s1">required_fields </span><span class="s3">- </span><span class="s1">datamodel_fields</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">f&quot;The datamodel for type </span><span class="s2">{</span><span class="s1">array</span><span class="s3">.</span><span class="s1">_fe_type</span><span class="s2">} </span><span class="s4">is missing &quot;</span>
               <span class="s4">f&quot;field</span><span class="s2">{</span><span class="s4">'s' </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">missing</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s4">''</span><span class="s2">} {</span><span class="s1">missing</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">meminfo </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">meminfo </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span>
            <span class="s1">datamodel</span><span class="s3">.</span><span class="s1">get_type</span><span class="s3">(</span><span class="s4">'meminfo'</span><span class="s3">)), </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">)</span>

    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">,</span>
                 <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                 <span class="s1">data</span><span class="s3">=</span><span class="s1">data</span><span class="s3">,</span>
                 <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">itemsize</span><span class="s3">,</span>
                 <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">meminfo</span><span class="s3">,)</span>

    <span class="s6"># Set `parent` attribute</span>
    <span class="s2">if </span><span class="s1">parent </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">attrs</span><span class="s3">[</span><span class="s4">'parent'</span><span class="s3">] = </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span>
            <span class="s1">datamodel</span><span class="s3">.</span><span class="s1">get_type</span><span class="s3">(</span><span class="s4">'parent'</span><span class="s3">)), </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">attrs</span><span class="s3">[</span><span class="s4">'parent'</span><span class="s3">] = </span><span class="s1">parent</span>
    <span class="s6"># Calc num of items from shape</span>
    <span class="s1">nitems </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">unpacked_shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
    <span class="s6"># (note empty shape =&gt; 0d array therefore nitems = 1)</span>
    <span class="s2">for </span><span class="s1">axlen </span><span class="s2">in </span><span class="s1">unpacked_shape</span><span class="s3">:</span>
        <span class="s1">nitems </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">axlen</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=[</span><span class="s4">'nsw'</span><span class="s3">])</span>
    <span class="s1">attrs</span><span class="s3">[</span><span class="s4">'nitems'</span><span class="s3">] = </span><span class="s1">nitems</span>

    <span class="s6"># Make sure that we have all the fields</span>
    <span class="s1">got_fields </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s2">if </span><span class="s1">got_fields </span><span class="s3">!= </span><span class="s1">required_fields</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;missing {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">required_fields </span><span class="s3">- </span><span class="s1">got_fields</span><span class="s3">))</span>

    <span class="s6"># Set field value</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">array</span>


<span class="s2">def </span><span class="s1">update_array_info</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">array</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Update some auxiliary information in *array* after some of its fields 
    were changed.  `itemsize` and `nitems` are updated. 
    &quot;&quot;&quot;</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_context</span>
    <span class="s1">builder </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_builder</span>

    <span class="s6"># Calc num of items from shape</span>
    <span class="s1">nitems </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">unpacked_shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">axlen </span><span class="s2">in </span><span class="s1">unpacked_shape</span><span class="s3">:</span>
        <span class="s1">nitems </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">axlen</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=[</span><span class="s4">'nsw'</span><span class="s3">])</span>
    <span class="s1">array</span><span class="s3">.</span><span class="s1">nitems </span><span class="s3">= </span><span class="s1">nitems</span>

    <span class="s1">array</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                          <span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Constrain axis values to valid positive values.&quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">normalize_axis</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">normalize_axis_overloads</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">StringLiteral</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;func_name must be a str literal.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">StringLiteral</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;arg_name must be a str literal.&quot;</span><span class="s3">)</span>

    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">func_name</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s2">}</span><span class="s4">: Argument </span><span class="s2">{</span><span class="s1">arg_name</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s2">} </span><span class="s4">&quot;</span>
        <span class="s4">&quot;out of bounds for dimensions of the array&quot;</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arg_name</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">+= </span><span class="s1">ndim</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">&gt;= </span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">axis</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'getiter'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">getiter_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">arrayty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">array</span><span class="s3">] = </span><span class="s1">args</span>

    <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">indexptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>

    <span class="s1">iterobj</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">indexptr</span>
    <span class="s1">iterobj</span><span class="s3">.</span><span class="s1">array </span><span class="s3">= </span><span class="s1">array</span>

    <span class="s6"># Incref array</span>
    <span class="s2">if </span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">incref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">, </span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>

    <span class="s6"># Note: a decref on the iterator will dereference all internal MemInfo*</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_getitem_array_single_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; Evaluate `ary[idx]`, where idx is a single int. &quot;&quot;&quot;</span>
    <span class="s6"># optimized form of _getitem_array_generic</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">idx</span><span class="s3">)</span>
    <span class="s1">dataptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pointer_add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
    <span class="s1">view_shapes </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
    <span class="s1">view_strides </span><span class="s3">= </span><span class="s1">strides</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">):</span>
        <span class="s6"># Build array view</span>
        <span class="s1">retary </span><span class="s3">= </span><span class="s1">make_view</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">,</span>
                           <span class="s1">dataptr</span><span class="s3">, </span><span class="s1">view_shapes</span><span class="s3">, </span><span class="s1">view_strides</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">retary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Load scalar from 0-d result</span>
        <span class="s2">assert not </span><span class="s1">view_shapes</span>
        <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">dataptr</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayIterator</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">iterty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">iter</span><span class="s3">] = </span><span class="s1">args</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">iterty</span><span class="s3">.</span><span class="s1">array_type</span>

    <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">iter</span><span class="s3">)</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrayty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">nitems</span><span class="s3">, = </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
    <span class="s1">is_valid </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">)</span>
    <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s1">is_valid</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_valid</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">_getitem_array_single_int</span><span class="s3">(</span>
            <span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterty</span><span class="s3">.</span><span class="s1">yield_type</span><span class="s3">, </span><span class="s1">arrayty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index</span>
        <span class="s3">)</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">nindex </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">nindex</span><span class="s3">, </span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Basic indexing (with integers and slices only)</span>

<span class="s2">def </span><span class="s1">basic_indexing</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">,</span>
                   <span class="s1">boundscheck</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform basic indexing on the given array. 
    A (data pointer, shapes, strides) tuple is returned describing 
    the corresponding view. 
    &quot;&quot;&quot;</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s1">output_indices </span><span class="s3">= []</span>
    <span class="s1">output_shapes </span><span class="s3">= []</span>
    <span class="s1">output_strides </span><span class="s3">= []</span>

    <span class="s1">num_newaxes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">idx </span><span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">index_types </span><span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)])</span>
    <span class="s1">ax </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">indexval</span><span class="s3">, </span><span class="s1">idxty </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">idxty </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s6"># Fill up missing dimensions at the middle</span>
            <span class="s1">n_missing </span><span class="s3">= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) + </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">num_newaxes</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_missing</span><span class="s3">):</span>
                <span class="s1">output_indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">)</span>
                <span class="s1">output_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
                <span class="s1">output_strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
                <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">continue</span>
        <span class="s6"># Regular index value</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">SliceType</span><span class="s3">):</span>
            <span class="s1">slice </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">indexval</span><span class="s3">)</span>
            <span class="s1">slicing</span><span class="s3">.</span><span class="s1">guard_invalid_slice</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">)</span>
            <span class="s1">slicing</span><span class="s3">.</span><span class="s1">fix_slice</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
            <span class="s1">output_indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">sh </span><span class="s3">= </span><span class="s1">slicing</span><span class="s3">.</span><span class="s1">get_slice_length</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">)</span>
            <span class="s1">st </span><span class="s3">= </span><span class="s1">slicing</span><span class="s3">.</span><span class="s1">fix_stride</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
            <span class="s1">output_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">)</span>
            <span class="s1">output_strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">st</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s1">ind </span><span class="s3">= </span><span class="s1">fix_integer_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">indexval</span><span class="s3">,</span>
                                    <span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">boundscheck</span><span class="s3">:</span>
                <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">do_boundscheck</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">], </span><span class="s1">ax</span><span class="s3">)</span>
            <span class="s1">output_indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">):</span>
            <span class="s1">output_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">one</span><span class="s3">)</span>
            <span class="s1">output_strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">)</span>
            <span class="s1">ax </span><span class="s3">-= </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;unexpected index type: %s&quot; </span><span class="s3">% (</span><span class="s1">idxty</span><span class="s3">,))</span>
        <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s6"># Fill up missing dimensions at the end</span>
    <span class="s2">assert </span><span class="s1">ax </span><span class="s3">&lt;= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">while </span><span class="s1">ax </span><span class="s3">&lt; </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s1">output_shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
        <span class="s1">output_strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
        <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s6"># No need to check wraparound, as negative indices were already</span>
    <span class="s6"># fixed in the loop above.</span>
    <span class="s1">dataptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">,</span>
                                       <span class="s1">output_indices</span><span class="s3">,</span>
                                       <span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">boundscheck</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">dataptr</span><span class="s3">, </span><span class="s1">output_shapes</span><span class="s3">, </span><span class="s1">output_strides</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_view</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">,</span>
              <span class="s1">data</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a view over the given array with the given parameters. 
    &quot;&quot;&quot;</span>
    <span class="s1">retary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">retary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shapes</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">retary</span>


<span class="s2">def </span><span class="s1">_getitem_array_generic</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">,</span>
                           <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the result of indexing *ary* with the given *indices*, 
    returning either a scalar or a view. 
    &quot;&quot;&quot;</span>
    <span class="s1">dataptr</span><span class="s3">, </span><span class="s1">view_shapes</span><span class="s3">, </span><span class="s1">view_strides </span><span class="s3">= </span><span class="s1">\</span>
        <span class="s1">basic_indexing</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">,</span>
                       <span class="s1">boundscheck</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_boundscheck</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">):</span>
        <span class="s6"># Build array view</span>
        <span class="s1">retary </span><span class="s3">= </span><span class="s1">make_view</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">,</span>
                           <span class="s1">dataptr</span><span class="s3">, </span><span class="s1">view_shapes</span><span class="s3">, </span><span class="s1">view_strides</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">retary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Load scalar from 0-d result</span>
        <span class="s2">assert not </span><span class="s1">view_shapes</span>
        <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">dataptr</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">SliceType</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">getitem_arraynd_intp</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic indexing with an integer or a slice. 
    &quot;&quot;&quot;</span>
    <span class="s1">aryty</span><span class="s3">, </span><span class="s1">idxty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s2">assert </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt;= </span><span class="s5">1</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">_getitem_array_generic</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                                 <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, (</span><span class="s1">idxty</span><span class="s3">,), (</span><span class="s1">idx</span><span class="s3">,))</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">getitem_array_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic or advanced indexing with a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s1">aryty</span><span class="s3">, </span><span class="s1">tupty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, </span><span class="s1">tup </span><span class="s3">= </span><span class="s1">args</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>

    <span class="s1">index_types </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">.</span><span class="s1">types</span>
    <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tupty</span><span class="s3">))</span>

    <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices </span><span class="s3">= </span><span class="s1">normalize_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                             <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">for </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">index_types</span><span class="s3">):</span>
        <span class="s6"># Advanced indexing</span>
        <span class="s2">return </span><span class="s1">fancy_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                             <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">_getitem_array_generic</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                                 <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">setitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">setitem_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    array[a] = scalar_or_array 
    array[a,..,b] = scalar_or_array 
    &quot;&quot;&quot;</span>
    <span class="s1">aryty</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">valty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s1">index_types </span><span class="s3">= </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">types</span>
        <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">index_types </span><span class="s3">= (</span><span class="s1">idxty</span><span class="s3">,)</span>
        <span class="s1">indices </span><span class="s3">= (</span><span class="s1">idx</span><span class="s3">,)</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>

    <span class="s6"># First try basic indexing to see if a single array location is denoted.</span>
    <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices </span><span class="s3">= </span><span class="s1">normalize_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                             <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">dataptr</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides </span><span class="s3">= </span><span class="s1">\</span>
            <span class="s1">basic_indexing</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">,</span>
                           <span class="s1">boundscheck</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_boundscheck</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
        <span class="s1">use_fancy_indexing </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">use_fancy_indexing </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">use_fancy_indexing</span><span class="s3">:</span>
        <span class="s6"># Index describes a non-trivial view =&gt; use generic slice assignment</span>
        <span class="s6"># (NOTE: this also handles scalar broadcasting)</span>
        <span class="s2">return </span><span class="s1">fancy_setslice</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                              <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s6"># Store source value the given location</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">dataptr</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">len</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_len</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s3">(</span><span class="s1">aryty</span><span class="s3">,) = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">(</span><span class="s1">ary</span><span class="s3">,) = </span><span class="s1">args</span>
    <span class="s1">arystty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">arystty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">shapeary </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">shapeary</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.item&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty</span><span class="s3">, = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, = </span><span class="s1">args</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>

    <span class="s1">nitems </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)),</span>
                         <span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;item(): can only convert an array of size 1 to a Python scalar&quot;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

    <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&lt; (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.itemset&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">array_itemset</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">aryty</span><span class="s3">, </span><span class="s1">valty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
        <span class="s1">ary</span><span class="s3">, </span><span class="s1">val </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s2">assert </span><span class="s1">valty </span><span class="s3">== </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>

        <span class="s1">nitems </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)),</span>
                             <span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;itemset(): can only write to an array of size 1&quot;</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

        <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Advanced / fancy indexing</span>


<span class="s2">class </span><span class="s1">Indexer</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generic indexer interface, for generating indices over a fancy indexed 
    array on a single dimension. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Prepare the indexer by initializing any required variables, basic 
        blocks... 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return this dimension's size as an integer. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return this dimension's shape as a tuple. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a half-open [lower, upper) range of indices this dimension 
        is guaranteed not to step out of. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Start indexation loop.  Return a (index, count) tuple. 
        *index* is an integer LLVM value representing the index over this 
        dimension. 
        *count* is either an integer LLVM value representing the current 
        iteration count, or None if this dimension should be omitted from 
        the indexation result. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Finish indexation loop. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">EntireIndexer</span><span class="s3">(</span><span class="s1">Indexer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute indices along an entire array dimension. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">aryty </span><span class="s3">= </span><span class="s1">aryty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ary </span><span class="s3">= </span><span class="s1">ary</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dim </span><span class="s3">= </span><span class="s1">dim</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6"># [0, size)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s6"># Initialize loop variable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">cur_index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">),</span>
                             <span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">cur_index</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">next_index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">IntegerIndexer</span><span class="s3">(</span><span class="s1">Indexer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute indices from a single integer. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idx </span><span class="s3">= </span><span class="s1">idx</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6"># [idx, idx+1)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_size</span><span class="s3">()))</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx</span><span class="s3">, </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">IntegerArrayIndexer</span><span class="s3">(</span><span class="s1">Indexer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute indices from an array of integer indices. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idxary</span><span class="s3">, </span><span class="s1">size</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idxty </span><span class="s3">= </span><span class="s1">idxty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idxary </span><span class="s3">= </span><span class="s1">idxary</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">size</span>
        <span class="s2">assert </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idx_size </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_size</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_size</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6"># Pessimal heuristic, as we don't want to scan for the min and max</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s6"># Initialize loop variable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">cur_index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_size</span><span class="s3">),</span>
            <span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span>
        <span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>
        <span class="s6"># Load the actual index from the array of indices</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">_getitem_array_single_int</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxary</span><span class="s3">,</span>
            <span class="s1">cur_index</span>
        <span class="s3">)</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">fix_integer_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                  <span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">index</span><span class="s3">, </span><span class="s1">cur_index</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">next_index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BooleanArrayIndexer</span><span class="s3">(</span><span class="s1">Indexer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute indices from an array of boolean predicates. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idxary</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idxty </span><span class="s3">= </span><span class="s1">idxty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idxary </span><span class="s3">= </span><span class="s1">idxary</span>
        <span class="s2">assert </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">zero </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">size </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_tail </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">zero</span><span class="s3">)</span>
        <span class="s6"># Sum all true values</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop</span><span class="s3">:</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span>
            <span class="s1">pred </span><span class="s3">= </span><span class="s1">_getitem_array_single_int</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxary</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span>
            <span class="s3">)</span>
            <span class="s1">c </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">zext</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">c</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_size</span><span class="s3">(),)</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6"># Pessimal heuristic, as we don't want to scan for the</span>
        <span class="s6"># first and last true items</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s6"># Initialize loop variable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">cur_index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s1">cur_count </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">size</span><span class="s3">),</span>
                             <span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>
        <span class="s6"># Load the predicate and branch if false</span>
        <span class="s1">pred </span><span class="s3">= </span><span class="s1">_getitem_array_single_int</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxary</span><span class="s3">,</span>
            <span class="s1">cur_index</span>
        <span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">)):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_tail</span><span class="s3">)</span>
        <span class="s6"># Increment the count for next iteration</span>
        <span class="s1">next_count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">cur_count</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_count</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">cur_count</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_tail</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_tail</span><span class="s3">)</span>
        <span class="s1">next_index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idx_index</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">SliceIndexer</span><span class="s3">(</span><span class="s1">Indexer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute indices along a slice. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">aryty </span><span class="s3">= </span><span class="s1">aryty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ary </span><span class="s3">= </span><span class="s1">ary</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dim </span><span class="s3">= </span><span class="s1">dim</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">idxty </span><span class="s3">= </span><span class="s1">idxty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">slice</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">zero </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s6"># Fix slice for the dimension's size</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dim_size </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">slicing</span><span class="s3">.</span><span class="s1">guard_invalid_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">idxty</span><span class="s3">,</span>
                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">)</span>
        <span class="s1">slicing</span><span class="s3">.</span><span class="s1">fix_slice</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dim_size</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">is_step_negative </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_neg_int</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">step</span><span class="s3">)</span>
        <span class="s6"># Create loop entities</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">slicing</span><span class="s3">.</span><span class="s1">get_slice_length</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_size</span><span class="s3">(),)</span>

    <span class="s2">def </span><span class="s1">get_index_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">lower</span><span class="s3">, </span><span class="s1">upper </span><span class="s3">= </span><span class="s1">slicing</span><span class="s3">.</span><span class="s1">get_slice_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>

    <span class="s2">def </span><span class="s1">loop_head</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s6"># Initialize loop variable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">cur_index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">cur_count </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s1">is_finished </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_step_negative</span><span class="s3">,</span>
                                     <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;='</span><span class="s3">, </span><span class="s1">cur_index</span><span class="s3">,</span>
                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">),</span>
                                     <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">cur_index</span><span class="s3">,</span>
                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">stop</span><span class="s3">))</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_finished</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cur_index</span><span class="s3">, </span><span class="s1">cur_count</span>

    <span class="s2">def </span><span class="s1">loop_tail</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">next_index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">step</span><span class="s3">,</span>
                                 <span class="s1">flags</span><span class="s3">=[</span><span class="s4">'nsw'</span><span class="s3">])</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">next_count </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_count</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_start</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">bb_end</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">FancyIndexer</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform fancy indexing on the given array. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">aryty </span><span class="s3">= </span><span class="s1">aryty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">newaxes </span><span class="s3">= []</span>

        <span class="s1">indexers </span><span class="s3">= []</span>
        <span class="s1">num_newaxes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">([</span><span class="s1">idx </span><span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">index_types </span><span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)])</span>

        <span class="s1">ax </span><span class="s3">= </span><span class="s5">0 </span><span class="s6"># keeps track of position of original axes</span>
        <span class="s1">new_ax </span><span class="s3">= </span><span class="s5">0 </span><span class="s6"># keeps track of position for inserting new axes</span>
        <span class="s2">for </span><span class="s1">indexval</span><span class="s3">, </span><span class="s1">idxty </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">idxty </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
                <span class="s6"># Fill up missing dimensions at the middle</span>
                <span class="s1">n_missing </span><span class="s3">= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) + </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">num_newaxes</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_missing</span><span class="s3">):</span>
                    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">EntireIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">)</span>
                    <span class="s1">indexers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
                    <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>
                    <span class="s1">new_ax </span><span class="s3">+= </span><span class="s5">1</span>
                <span class="s2">continue</span>

            <span class="s6"># Regular index value</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">SliceType</span><span class="s3">):</span>
                <span class="s1">slice </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">indexval</span><span class="s3">)</span>
                <span class="s1">indexer </span><span class="s3">= </span><span class="s1">SliceIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">,</span>
                                       <span class="s1">idxty</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">)</span>
                <span class="s1">indexers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
                <span class="s1">ind </span><span class="s3">= </span><span class="s1">fix_integer_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">indexval</span><span class="s3">,</span>
                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
                <span class="s1">indexer </span><span class="s3">= </span><span class="s1">IntegerIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">)</span>
                <span class="s1">indexers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                <span class="s1">idxary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indexval</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
                    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">IntegerArrayIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                                  <span class="s1">idxty</span><span class="s3">, </span><span class="s1">idxary</span><span class="s3">,</span>
                                                  <span class="s1">self</span><span class="s3">.</span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">):</span>
                    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">BooleanArrayIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                                  <span class="s1">idxty</span><span class="s3">, </span><span class="s1">idxary</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s5">0</span>
                <span class="s1">indexers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">idxty</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">newaxes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">new_ax</span><span class="s3">)</span>
                <span class="s1">ax </span><span class="s3">-= </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s4">&quot;unexpected index type: %s&quot; </span><span class="s3">% (</span><span class="s1">idxty</span><span class="s3">,))</span>
            <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">new_ax </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s6"># Fill up missing dimensions at the end</span>
        <span class="s2">assert </span><span class="s1">ax </span><span class="s3">&lt;= </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, (</span><span class="s1">ax</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">while </span><span class="s1">ax </span><span class="s3">&lt; </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s1">indexer </span><span class="s3">= </span><span class="s1">EntireIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">)</span>
            <span class="s1">indexers</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
            <span class="s1">ax </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indexers</span><span class="s3">) == </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">indexers</span><span class="s3">), </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">indexers </span><span class="s3">= </span><span class="s1">indexers</span>

    <span class="s2">def </span><span class="s1">prepare</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">:</span>
            <span class="s1">i</span><span class="s3">.</span><span class="s1">prepare</span><span class="s3">()</span>

        <span class="s1">one </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s6"># Compute the resulting shape given by the indices</span>
        <span class="s1">res_shape </span><span class="s3">= [</span><span class="s1">i</span><span class="s3">.</span><span class="s1">get_shape</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">]</span>

        <span class="s6"># At every position where newaxis/None is present insert</span>
        <span class="s6"># one as a constant shape in the resulting list of shapes.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">newaxes</span><span class="s3">:</span>
            <span class="s1">res_shape</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, (</span><span class="s1">one</span><span class="s3">,))</span>

        <span class="s6"># Store the shape as a tuple, we can't do a simple</span>
        <span class="s6"># tuple(res_shape) here since res_shape is a list</span>
        <span class="s6"># of tuples which may be differently sized.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">indexers_shape </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">res_shape</span><span class="s3">, ())</span>

    <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the resulting data shape as Python tuple. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers_shape</span>

    <span class="s2">def </span><span class="s1">get_offset_bounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get a half-open [lower, upper) range of byte offsets spanned by 
        the indexer with the given strides and itemsize.  The indexer is 
        guaranteed to not go past those bounds. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">) == </span><span class="s1">self</span><span class="s3">.</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">builder</span>
        <span class="s1">is_empty </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_bit</span>
        <span class="s1">zero </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">one </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">lower </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">stride </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers_shape</span><span class="s3">,</span>
                                          <span class="s1">strides</span><span class="s3">):</span>
            <span class="s1">is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">,</span>
                                   <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">))</span>
            <span class="s6"># Compute [lower, upper) indices on this dimension</span>
            <span class="s1">lower_index</span><span class="s3">, </span><span class="s1">upper_index </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">get_index_bounds</span><span class="s3">()</span>
            <span class="s1">lower_offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">stride</span><span class="s3">, </span><span class="s1">lower_index</span><span class="s3">)</span>
            <span class="s1">upper_offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">stride</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">upper_index</span><span class="s3">, </span><span class="s1">one</span><span class="s3">))</span>
            <span class="s6"># Adjust total interval</span>
            <span class="s1">is_downwards </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
            <span class="s1">lower </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">lower</span><span class="s3">,</span>
                                <span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_downwards</span><span class="s3">,</span>
                                               <span class="s1">upper_offset</span><span class="s3">,</span>
                                               <span class="s1">lower_offset</span><span class="s3">))</span>
            <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">upper</span><span class="s3">,</span>
                                <span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_downwards</span><span class="s3">,</span>
                                               <span class="s1">lower_offset</span><span class="s3">,</span>
                                               <span class="s1">upper_offset</span><span class="s3">))</span>
        <span class="s6"># Make interval half-open</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)</span>
        <span class="s6"># Adjust for empty shape</span>
        <span class="s1">lower </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>

    <span class="s2">def </span><span class="s1">begin_loops</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">indices</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*(</span><span class="s1">i</span><span class="s3">.</span><span class="s1">loop_head</span><span class="s3">() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">counts</span>

    <span class="s2">def </span><span class="s1">end_loops</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">):</span>
            <span class="s1">i</span><span class="s3">.</span><span class="s1">loop_tail</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">fancy_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                  <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>

    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">FancyIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">,</span>
                           <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
    <span class="s1">indexer</span><span class="s3">.</span><span class="s1">prepare</span><span class="s3">()</span>

    <span class="s6"># Construct output array</span>
    <span class="s1">out_ty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">out_shapes </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">get_shape</span><span class="s3">()</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_ty</span><span class="s3">, </span><span class="s1">out_shapes</span><span class="s3">)</span>
    <span class="s1">out_data </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">out_idx </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                        <span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s6"># Loop on source and copy to destination</span>
    <span class="s1">indices</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">begin_loops</span><span class="s3">()</span>

    <span class="s6"># No need to check for wraparound, as the indexers all ensure</span>
    <span class="s6"># a positive index is returned.</span>
    <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                                    <span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                    <span class="s1">boundscheck</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_boundscheck</span><span class="s3">)</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

    <span class="s6"># Since the destination is C-contiguous, no need for multi-dimensional</span>
    <span class="s6"># indexing.</span>
    <span class="s1">cur </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">out_idx</span><span class="s3">)</span>
    <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">out_data</span><span class="s3">, [</span><span class="s1">cur</span><span class="s3">])</span>
    <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
    <span class="s1">next_idx </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">next_idx</span><span class="s3">, </span><span class="s1">out_idx</span><span class="s3">)</span>

    <span class="s1">indexer</span><span class="s3">.</span><span class="s1">end_loops</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_ty</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">fancy_getitem_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Advanced or basic indexing with an array. 
    &quot;&quot;&quot;</span>
    <span class="s1">aryty</span><span class="s3">, </span><span class="s1">idxty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">args</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">idxty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># 0-d array index acts as a basic integer index</span>
        <span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">normalize_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">_getitem_array_generic</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                                     <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, (</span><span class="s1">idxty</span><span class="s3">,), (</span><span class="s1">idx</span><span class="s3">,))</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Advanced indexing</span>
        <span class="s2">return </span><span class="s1">fancy_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                             <span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, (</span><span class="s1">idxty</span><span class="s3">,), (</span><span class="s1">idx</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">offset_bounds_from_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a half-open range [lower, upper) of byte offsets from the 
    array's data pointer, that bound the in-memory extent of the array. 
 
    This mimics offset_bounds_from_strides() from 
    numpy/core/src/private/mem_overlap.c 
    &quot;&quot;&quot;</span>
    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">itemsize</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">itemsize</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">in </span><span class="s4">'CF'</span><span class="s3">:</span>
        <span class="s6"># Array is contiguous: contents are laid out sequentially</span>
        <span class="s6"># starting from arr.data and upwards</span>
        <span class="s1">lower </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Non-contiguous array: need to examine strides</span>
        <span class="s1">lower </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s6"># Compute the largest byte offset on this dimension</span>
            <span class="s6">#   max_axis_offset = strides[i] * (shapes[i] - 1)</span>
            <span class="s6"># (shapes[i] == 0 is catered for by the empty array case below)</span>
            <span class="s1">max_axis_offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">],</span>
                                          <span class="s1">builder</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">one</span><span class="s3">))</span>
            <span class="s1">is_upwards </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">max_axis_offset</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
            <span class="s6"># Expand either upwards or downwards depending on stride</span>
            <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_upwards</span><span class="s3">,</span>
                                   <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">max_axis_offset</span><span class="s3">), </span><span class="s1">upper</span><span class="s3">)</span>
            <span class="s1">lower </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_upwards</span><span class="s3">,</span>
                                   <span class="s1">lower</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">lower</span><span class="s3">, </span><span class="s1">max_axis_offset</span><span class="s3">))</span>
        <span class="s6"># Return a half-open range</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)</span>
        <span class="s6"># Adjust for empty arrays</span>
        <span class="s1">is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
        <span class="s1">upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">)</span>
        <span class="s1">lower </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>


<span class="s2">def </span><span class="s1">compute_memory_extents</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given [lower, upper) byte offsets and a base data pointer, 
    compute the memory pointer bounds as pointer-sized integers. 
    &quot;&quot;&quot;</span>
    <span class="s1">data_ptr_as_int </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">ptrtoint</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
    <span class="s1">start </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">data_ptr_as_int</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">)</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">data_ptr_as_int</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span>


<span class="s2">def </span><span class="s1">get_array_memory_extents</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                             <span class="s1">data</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a half-open range [start, end) of pointer-sized integers 
    which fully contain the array data. 
    &quot;&quot;&quot;</span>
    <span class="s1">lower</span><span class="s3">, </span><span class="s1">upper </span><span class="s3">= </span><span class="s1">offset_bounds_from_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">,</span>
                                              <span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">compute_memory_extents</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">extents_may_overlap</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">a_start</span><span class="s3">, </span><span class="s1">a_end</span><span class="s3">, </span><span class="s1">b_start</span><span class="s3">, </span><span class="s1">b_end</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Whether two memory extents [a_start, a_end) and [b_start, b_end) 
    may overlap. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Comparisons are unsigned, since we are really comparing pointers</span>
    <span class="s1">may_overlap </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">and_</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">a_start</span><span class="s3">, </span><span class="s1">b_end</span><span class="s3">),</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">b_start</span><span class="s3">, </span><span class="s1">a_end</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">may_overlap</span>


<span class="s2">def </span><span class="s1">maybe_copy_source</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">use_copy</span><span class="s3">,</span>
                      <span class="s1">srcty</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">src_shapes</span><span class="s3">, </span><span class="s1">src_strides</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">):</span>
    <span class="s1">ptrty </span><span class="s3">= </span><span class="s1">src_data</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s1">copy_layout </span><span class="s3">= </span><span class="s4">'C'</span>
    <span class="s1">copy_data </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">)</span>
    <span class="s1">copy_shapes </span><span class="s3">= </span><span class="s1">src_shapes</span>
    <span class="s1">copy_strides </span><span class="s3">= </span><span class="s2">None  </span><span class="s6"># unneeded for contiguous arrays</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">use_copy</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6"># Allocate temporary scratchpad</span>
        <span class="s6"># XXX: should we use a stack-allocated array for very small</span>
        <span class="s6"># data sizes?</span>
        <span class="s1">allocsize </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">src</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">src</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">allocate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">)</span>
        <span class="s1">voidptrty </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptrty</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy_data</span><span class="s3">)</span>

        <span class="s6"># Copy source data into scratchpad</span>
        <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_shapes</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s1">src_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">,</span>
                                                <span class="s1">src_shapes</span><span class="s3">, </span><span class="s1">src_strides</span><span class="s3">,</span>
                                                <span class="s1">srcty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">dest_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">,</span>
                                                 <span class="s1">copy_shapes</span><span class="s3">, </span><span class="s1">copy_strides</span><span class="s3">,</span>
                                                 <span class="s1">copy_layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">src_ptr</span><span class="s3">), </span><span class="s1">dest_ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">src_getitem</span><span class="s3">(</span><span class="s1">source_indices</span><span class="s3">):</span>
        <span class="s1">src_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptrty</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">use_copy</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">if_copy</span><span class="s3">, </span><span class="s1">otherwise</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">if_copy</span><span class="s3">:</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                    <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                              <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">copy_data</span><span class="s3">),</span>
                                              <span class="s1">copy_shapes</span><span class="s3">, </span><span class="s1">copy_strides</span><span class="s3">,</span>
                                              <span class="s1">copy_layout</span><span class="s3">, </span><span class="s1">source_indices</span><span class="s3">,</span>
                                              <span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">),</span>
                    <span class="s1">src_ptr</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">otherwise</span><span class="s3">:</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span>
                    <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">,</span>
                                              <span class="s1">src_shapes</span><span class="s3">, </span><span class="s1">src_strides</span><span class="s3">,</span>
                                              <span class="s1">srcty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">source_indices</span><span class="s3">,</span>
                                              <span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">),</span>
                    <span class="s1">src_ptr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">src_ptr</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">src_cleanup</span><span class="s3">():</span>
        <span class="s6"># Deallocate memory</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">use_copy</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">copy_data</span><span class="s3">)</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">voidptrty</span><span class="s3">)</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">free</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">src_getitem</span><span class="s3">, </span><span class="s1">src_cleanup</span>


<span class="s2">def </span><span class="s1">_bc_adjust_dimension</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">target_shape</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Preprocess dimension for broadcasting. 
    Returns (shapes, strides) such that the ndim match *target_shape*. 
    When expanding to higher ndim, the returning shapes and strides are 
    prepended with ones and zeros, respectively. 
    When truncating to lower ndim, the shapes are checked (in runtime). 
    All extra dimension must have size of 1. 
    &quot;&quot;&quot;</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s6"># Adjust for broadcasting to higher dimension</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">) &gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">):</span>
        <span class="s1">nd_diff </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s6"># Fill missing shapes with one, strides with zeros</span>
        <span class="s1">shapes </span><span class="s3">= [</span><span class="s1">one</span><span class="s3">] * </span><span class="s1">nd_diff </span><span class="s3">+ </span><span class="s1">shapes</span>
        <span class="s1">strides </span><span class="s3">= [</span><span class="s1">zero</span><span class="s3">] * </span><span class="s1">nd_diff </span><span class="s3">+ </span><span class="s1">strides</span>
    <span class="s6"># Adjust for broadcasting to lower dimension</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">):</span>
        <span class="s6"># Accepted if all extra dims has shape 1</span>
        <span class="s1">nd_diff </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">)</span>
        <span class="s1">dim_is_one </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">sh</span><span class="s3">, </span><span class="s1">one</span><span class="s3">)</span>
                      <span class="s2">for </span><span class="s1">sh </span><span class="s2">in </span><span class="s1">shapes</span><span class="s3">[:</span><span class="s1">nd_diff</span><span class="s3">]]</span>
        <span class="s1">accepted </span><span class="s3">= </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">and_</span><span class="s3">, </span><span class="s1">dim_is_one</span><span class="s3">,</span>
                                    <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_bit</span><span class="s3">)</span>
        <span class="s6"># Check error</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">accepted</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;cannot broadcast source array for assignment&quot;</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>
        <span class="s6"># Truncate extra shapes, strides</span>
        <span class="s1">shapes </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">nd_diff</span><span class="s3">:]</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">strides</span><span class="s3">[</span><span class="s1">nd_diff</span><span class="s3">:]</span>

    <span class="s2">return </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span>


<span class="s2">def </span><span class="s1">_bc_adjust_shape_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">target_shape</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Broadcast shapes and strides to target_shape given that their ndim already 
    matches.  For each location where the shape is 1 and does not match the 
    dim for target, it is set to the value at the target and the stride is 
    set to zero. 
    &quot;&quot;&quot;</span>
    <span class="s1">bc_shapes </span><span class="s3">= []</span>
    <span class="s1">bc_strides </span><span class="s3">= []</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s6"># Adjust all mismatching ones in shape</span>
    <span class="s1">mismatch </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">tar</span><span class="s3">, </span><span class="s1">old</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">tar</span><span class="s3">, </span><span class="s1">old </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)]</span>
    <span class="s1">src_is_one </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">one</span><span class="s3">) </span><span class="s2">for </span><span class="s1">old </span><span class="s2">in </span><span class="s1">shapes</span><span class="s3">]</span>
    <span class="s1">preds </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">and_</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">mismatch</span><span class="s3">, </span><span class="s1">src_is_one</span><span class="s3">)]</span>
    <span class="s1">bc_shapes </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">tar</span><span class="s3">, </span><span class="s1">old</span><span class="s3">)</span>
                 <span class="s2">for </span><span class="s1">p</span><span class="s3">, </span><span class="s1">tar</span><span class="s3">, </span><span class="s1">old </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">preds</span><span class="s3">, </span><span class="s1">target_shape</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)]</span>
    <span class="s1">bc_strides </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">old</span><span class="s3">)</span>
                  <span class="s2">for </span><span class="s1">p</span><span class="s3">, </span><span class="s1">old </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">preds</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">)]</span>
    <span class="s2">return </span><span class="s1">bc_shapes</span><span class="s3">, </span><span class="s1">bc_strides</span>


<span class="s2">def </span><span class="s1">_broadcast_to_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">target_shape</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Broadcast the given array to the target_shape. 
    Returns (array_type, array) 
    &quot;&quot;&quot;</span>
    <span class="s6"># Compute broadcasted shape and strides</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>

    <span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides </span><span class="s3">= </span><span class="s1">_bc_adjust_dimension</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                                           <span class="s1">target_shape</span><span class="s3">)</span>
    <span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides </span><span class="s3">= </span><span class="s1">_bc_adjust_shape_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">,</span>
                                               <span class="s1">strides</span><span class="s3">, </span><span class="s1">target_shape</span><span class="s3">)</span>
    <span class="s1">new_arrtype </span><span class="s3">= </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">target_shape</span><span class="s3">), </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">)</span>
    <span class="s6"># Create new view</span>
    <span class="s1">new_arr </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">new_arrtype</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">new_arr</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">),</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">),</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">new_arrtype</span><span class="s3">, </span><span class="s1">new_arr</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_numpy_broadcast_to</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">.</span><span class="s1">count</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">, </span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">src</span><span class="s3">, </span><span class="s1">shape_ </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">srcty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">src </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">srcty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src</span><span class="s3">)</span>
        <span class="s1">shape_ </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape_</span><span class="s3">)</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">dest </span><span class="s3">= </span><span class="s1">_broadcast_to_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">shape_</span><span class="s3">,)</span>

        <span class="s6"># Hack to get np.broadcast_to to return a read-only array</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s4">'parent'</span><span class="s3">, </span><span class="s1">Constant</span><span class="s3">(</span>
                <span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_type</span><span class="s3">(</span><span class="s4">'parent'</span><span class="s3">)),</span>
                <span class="s2">None</span><span class="s3">))</span>

        <span class="s1">res </span><span class="s3">= </span><span class="s1">dest</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">get_readonly_array</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s6"># returns a copy of arr which is readonly</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">src</span><span class="s3">] = </span><span class="s1">args</span>
        <span class="s1">srcty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">dest </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">srcty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src</span><span class="s3">)</span>
        <span class="s6"># Hack to return a read-only array</span>
        <span class="s1">dest</span><span class="s3">.</span><span class="s1">parent </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">dest</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_can_broadcast</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">dest_shape</span><span class="s3">):</span>
    <span class="s1">src_shape </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">src_ndim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">src_shape</span><span class="s3">)</span>
    <span class="s1">dest_ndim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dest_shape</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">src_ndim </span><span class="s3">&gt; </span><span class="s1">dest_ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'input operand has more dimensions than allowed '</span>
                         <span class="s4">'by the axis remapping'</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">size </span><span class="s2">in </span><span class="s1">dest_shape</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'all elements of broadcast shape must be '</span>
                             <span class="s4">'non-negative'</span><span class="s3">)</span>

    <span class="s6"># based on _broadcast_onto function in numba/np/npyimpl.py</span>
    <span class="s1">src_index </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">dest_index </span><span class="s3">= </span><span class="s1">dest_ndim </span><span class="s3">- </span><span class="s1">src_ndim</span>
    <span class="s2">while </span><span class="s1">src_index </span><span class="s3">&lt; </span><span class="s1">src_ndim</span><span class="s3">:</span>
        <span class="s1">src_dim </span><span class="s3">= </span><span class="s1">src_shape</span><span class="s3">[</span><span class="s1">src_index</span><span class="s3">]</span>
        <span class="s1">dest_dim </span><span class="s3">= </span><span class="s1">dest_shape</span><span class="s3">[</span><span class="s1">dest_index</span><span class="s3">]</span>
        <span class="s6"># possible cases for (src_dim, dest_dim):</span>
        <span class="s6">#  * (1, 1)   -&gt; Ok</span>
        <span class="s6">#  * (&gt;1, 1)  -&gt; Error!</span>
        <span class="s6">#  * (&gt;1, &gt;1) -&gt; src_dim == dest_dim else error!</span>
        <span class="s6">#  * (1, &gt;1)  -&gt; Ok</span>
        <span class="s2">if </span><span class="s1">src_dim </span><span class="s3">== </span><span class="s1">dest_dim </span><span class="s2">or </span><span class="s1">src_dim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">src_index </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">dest_index </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'operands could not be broadcast together '</span>
                             <span class="s4">'with remapped shapes'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_default_broadcast_to_impl</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
    <span class="s1">_can_broadcast</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_numpy_broadcast_to</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_broadcast_to</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;array&quot; must '</span>
                                 <span class="s4">'be array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, (</span><span class="s1">shape</span><span class="s3">,))</span>
        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The second argument &quot;shape&quot; must be a tuple of integers'</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_default_broadcast_to_impl</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">shape</span><span class="s3">.</span><span class="s1">count </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># check if all types are integers</span>
        <span class="s2">if not </span><span class="s1">all</span><span class="s3">([</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">) </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">]):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f'&quot;</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">&quot; object cannot be interpreted as an integer'</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_default_broadcast_to_impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">shape</span><span class="s3">.</span><span class="s1">count </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">is_scalar_array </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">array</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">type_is_scalar</span><span class="s3">(</span><span class="s1">array</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_scalar_array</span><span class="s3">:</span>

            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):  </span><span class="s6"># broadcast_to(array, ())</span>
                <span class="s6"># Array type must be supported by &quot;type_can_asarray&quot;</span>
                <span class="s6"># Quick note that unicode types are not supported!</span>
                <span class="s1">array </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">get_readonly_array</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">impl</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">'Cannot broadcast a non-scalar to a scalar array'</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'The argument &quot;shape&quot; must be a tuple or an integer. '</span>
               <span class="s4">'Got %s' </span><span class="s3">% </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">numpy_broadcast_shapes_list</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">m </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) + </span><span class="s1">i</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;negative dimensions are not allowed&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">tmp</span>
        <span class="s2">elif </span><span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] != </span><span class="s1">tmp</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;shape mismatch: objects&quot;</span>
                             <span class="s4">&quot; cannot be broadcast&quot;</span>
                             <span class="s4">&quot; to a single shape&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_numpy_broadcast_shapes</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s6"># Based on https://github.com/numpy/numpy/blob/f702b26fff3271ba6a6ba29a021fc19051d1f007/numpy/core/src/multiarray/iterators.c#L1129-L1212  # noqa</span>
    <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">is_int </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
        <span class="s1">is_int_tuple </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">\</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
        <span class="s1">is_empty_tuple </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">types</span><span class="s3">) == </span><span class="s5">0</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">is_int </span><span class="s2">or </span><span class="s1">is_int_tuple </span><span class="s2">or </span><span class="s1">is_empty_tuple</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">f'Argument </span><span class="s2">{</span><span class="s1">idx</span><span class="s2">} </span><span class="s4">must be either an int or tuple[int]. '</span>
                   <span class="s4">f'Got </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s6"># discover the number of dimensions</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return lambda </span><span class="s3">*</span><span class="s1">args</span><span class="s3">: ()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">tup_init </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">,) * </span><span class="s1">m</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s6"># propagate args</span>
            <span class="s1">r </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">m</span>
            <span class="s1">tup </span><span class="s3">= </span><span class="s1">tup_init</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">literal_unroll</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">numpy_broadcast_shapes_list</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
                    <span class="s1">numpy_broadcast_shapes_list</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, (</span><span class="s1">arg</span><span class="s3">,))</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
                <span class="s1">tup </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">tup</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_broadcast_arrays</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>

    <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">f'Argument &quot;</span><span class="s2">{</span><span class="s1">idx</span><span class="s2">}</span><span class="s4">&quot; must '</span>
                                     <span class="s4">'be array-like'</span><span class="s3">)</span>

    <span class="s1">unified_dtype </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)):</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">arg</span>

        <span class="s2">if </span><span class="s1">unified_dtype </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">unified_dtype </span><span class="s3">= </span><span class="s1">dt</span>
        <span class="s2">elif </span><span class="s1">unified_dtype </span><span class="s3">!= </span><span class="s1">dt</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'Mismatch of argument types. Numba cannot '</span>
                                     <span class="s4">'broadcast arrays with different types. '</span>
                                     <span class="s4">f'Got </span><span class="s2">{</span><span class="s1">args</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s6"># number of dimensions</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">):</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)):</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">f'Unhandled type </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s1">tup_init </span><span class="s3">= (</span><span class="s5">0</span><span class="s3">,) * </span><span class="s1">m</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s6"># find out the output shape</span>
        <span class="s6"># we can't call np.broadcast_shapes here since args may have arrays</span>
        <span class="s6"># with different shapes and it is not possible to create a list</span>
        <span class="s6"># with those shapes dynamically</span>
        <span class="s1">shape </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">m</span>
        <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">literal_unroll</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">numpy_broadcast_shapes_list</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">).</span><span class="s1">shape</span><span class="s3">)</span>

        <span class="s1">tup </span><span class="s3">= </span><span class="s1">tup_init</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
            <span class="s1">tup </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

        <span class="s6"># numpy checks if the input arrays have the same shape as `shape`</span>
        <span class="s1">outs </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">literal_unroll</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">outs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">), </span><span class="s1">tup</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">outs</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">fancy_setslice</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Implement slice assignment for arrays.  This implementation works for 
    basic as well as fancy indexing, since there's no functional difference 
    between the two for indexed assignment. 
    &quot;&quot;&quot;</span>
    <span class="s1">aryty</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">srcty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">ary</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">src </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">dest_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">dest_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">dest_data </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">FancyIndexer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">,</span>
                           <span class="s1">index_types</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
    <span class="s1">indexer</span><span class="s3">.</span><span class="s1">prepare</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">):</span>
        <span class="s6"># Source is an array</span>
        <span class="s1">src_dtype </span><span class="s3">= </span><span class="s1">srcty</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s1">index_shape </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">get_shape</span><span class="s3">()</span>
        <span class="s1">src </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">srcty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src</span><span class="s3">)</span>
        <span class="s6"># Broadcast source array to shape</span>
        <span class="s1">srcty</span><span class="s3">, </span><span class="s1">src </span><span class="s3">= </span><span class="s1">_broadcast_to_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">src</span><span class="s3">,</span>
                                         <span class="s1">index_shape</span><span class="s3">)</span>
        <span class="s1">src_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">src_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
        <span class="s1">src_data </span><span class="s3">= </span><span class="s1">src</span><span class="s3">.</span><span class="s1">data</span>

        <span class="s6"># Check shapes are equal</span>
        <span class="s1">shape_error </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_bit</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">index_shape</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">src_shapes</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">u</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">src_shapes</span><span class="s3">, </span><span class="s1">index_shape</span><span class="s3">):</span>
            <span class="s1">shape_error </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">shape_error</span><span class="s3">,</span>
                                      <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">v</span><span class="s3">))</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">shape_error</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;cannot assign slice from input of different size&quot;</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

        <span class="s6"># Check for array overlap</span>
        <span class="s1">src_start</span><span class="s3">, </span><span class="s1">src_end </span><span class="s3">= </span><span class="s1">get_array_memory_extents</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">,</span>
                                                      <span class="s1">src</span><span class="s3">, </span><span class="s1">src_shapes</span><span class="s3">,</span>
                                                      <span class="s1">src_strides</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">)</span>

        <span class="s1">dest_lower</span><span class="s3">, </span><span class="s1">dest_upper </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">get_offset_bounds</span><span class="s3">(</span><span class="s1">dest_strides</span><span class="s3">,</span>
                                                           <span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">)</span>
        <span class="s1">dest_start</span><span class="s3">, </span><span class="s1">dest_end </span><span class="s3">= </span><span class="s1">compute_memory_extents</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                                      <span class="s1">dest_lower</span><span class="s3">, </span><span class="s1">dest_upper</span><span class="s3">,</span>
                                                      <span class="s1">dest_data</span><span class="s3">)</span>

        <span class="s1">use_copy </span><span class="s3">= </span><span class="s1">extents_may_overlap</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_start</span><span class="s3">, </span><span class="s1">src_end</span><span class="s3">,</span>
                                       <span class="s1">dest_start</span><span class="s3">, </span><span class="s1">dest_end</span><span class="s3">)</span>

        <span class="s1">src_getitem</span><span class="s3">, </span><span class="s1">src_cleanup </span><span class="s3">= </span><span class="s1">maybe_copy_source</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">use_copy</span><span class="s3">,</span>
                                                     <span class="s1">srcty</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">src_shapes</span><span class="s3">,</span>
                                                     <span class="s1">src_strides</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s1">src_dtype </span><span class="s3">= </span><span class="s1">srcty</span><span class="s3">.</span><span class="s1">dtype</span>

        <span class="s6"># Check shape is equal to sequence length</span>
        <span class="s1">index_shape </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">get_shape</span><span class="s3">()</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">index_shape</span><span class="s3">) == </span><span class="s5">1</span>
        <span class="s1">len_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">len</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">))</span>
        <span class="s1">seq_len </span><span class="s3">= </span><span class="s1">len_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">src</span><span class="s3">,))</span>

        <span class="s1">shape_error </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">index_shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">seq_len</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">shape_error</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;cannot assign slice from input of different size&quot;</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

        <span class="s2">def </span><span class="s1">src_getitem</span><span class="s3">(</span><span class="s1">source_indices</span><span class="s3">):</span>
            <span class="s1">idx</span><span class="s3">, = </span><span class="s1">source_indices</span>
            <span class="s1">getitem_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span>
                <span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">,</span>
                <span class="s1">signature</span><span class="s3">(</span><span class="s1">src_dtype</span><span class="s3">, </span><span class="s1">srcty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">getitem_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">src</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">src_cleanup</span><span class="s3">():</span>
            <span class="s2">pass</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Source is a scalar (broadcast or not, depending on destination</span>
        <span class="s6"># shape).</span>
        <span class="s1">src_dtype </span><span class="s3">= </span><span class="s1">srcty</span>

        <span class="s2">def </span><span class="s1">src_getitem</span><span class="s3">(</span><span class="s1">source_indices</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">src</span>

        <span class="s2">def </span><span class="s1">src_cleanup</span><span class="s3">():</span>
            <span class="s2">pass</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s6"># Loop on destination and copy from source to destination</span>
    <span class="s1">dest_indices</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">begin_loops</span><span class="s3">()</span>

    <span class="s6"># Source is iterated in natural order</span>

    <span class="s6"># Counts represent a counter for the number of times a specified axis</span>
    <span class="s6"># is being accessed, during setitem they are used as source</span>
    <span class="s6"># indices</span>
    <span class="s1">counts </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">counts</span><span class="s3">)</span>

    <span class="s6"># We need to artifically introduce the index zero wherever a</span>
    <span class="s6"># newaxis is present within the indexer. These always remain</span>
    <span class="s6"># zero.</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indexer</span><span class="s3">.</span><span class="s1">newaxes</span><span class="s3">:</span>
        <span class="s1">counts</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>

    <span class="s1">source_indices </span><span class="s3">= [</span><span class="s1">c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">counts </span><span class="s2">if </span><span class="s1">c </span><span class="s2">is not None</span><span class="s3">]</span>

    <span class="s1">val </span><span class="s3">= </span><span class="s1">src_getitem</span><span class="s3">(</span><span class="s1">source_indices</span><span class="s3">)</span>

    <span class="s6"># Cast to the destination dtype (cross-dtype slice assignment is allowed)</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">src_dtype</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s6"># No need to check for wraparound, as the indexers all ensure</span>
    <span class="s6"># a positive index is returned.</span>
    <span class="s1">dest_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest_data</span><span class="s3">,</span>
                                         <span class="s1">dest_shapes</span><span class="s3">, </span><span class="s1">dest_strides</span><span class="s3">,</span>
                                         <span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">dest_indices</span><span class="s3">,</span>
                                         <span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                         <span class="s1">boundscheck</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_boundscheck</span><span class="s3">)</span>
    <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">dest_ptr</span><span class="s3">)</span>

    <span class="s1">indexer</span><span class="s3">.</span><span class="s1">end_loops</span><span class="s3">()</span>

    <span class="s1">src_cleanup</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Shape / layout altering</span>

<span class="s2">def </span><span class="s1">vararg_to_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">dimtys </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
    <span class="s6"># values</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">dims </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
    <span class="s6"># coerce all types to intp</span>
    <span class="s1">dims </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">dimtys</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">)]</span>
    <span class="s6"># make a tuple</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">type</span><span class="s3">)</span>

    <span class="s1">shapety </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">))</span>
    <span class="s1">new_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">shapety</span><span class="s3">)</span>
    <span class="s1">new_args </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">shape</span>

    <span class="s2">return </span><span class="s1">new_sig</span><span class="s3">, </span><span class="s1">new_args</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.transpose'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_transpose</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">array_T</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">permute_arrays</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;repeated axis in transpose&quot;</span><span class="s3">)</span>
    <span class="s1">dim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">axis</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s1">dim </span><span class="s2">or </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s1">dim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;axis is out of bounds for array of &quot;</span>
                             <span class="s4">&quot;given dimension&quot;</span><span class="s3">)</span>

    <span class="s1">shape</span><span class="s3">[:] = </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s1">strides</span><span class="s3">[:] = </span><span class="s1">strides</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>


<span class="s6"># Transposing an array involves permuting the shape and strides of the array</span>
<span class="s6"># based on the given axes.</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.transpose'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_transpose_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

    <span class="s1">axisty</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">num_axis</span><span class="s3">, </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">axisty</span><span class="s3">.</span><span class="s1">count</span><span class="s3">, </span><span class="s1">axisty</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">ll_ary_size </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s1">num_axis</span><span class="s3">)</span>

    <span class="s6"># Allocate memory for axes, shapes, and strides arrays.</span>
    <span class="s1">arys </span><span class="s3">= [</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">]</span>
    <span class="s1">ll_arys </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_ary_size</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">arys</span><span class="s3">]</span>

    <span class="s6"># Store axes, shapes, and strides arrays to the allocated memory.</span>
    <span class="s2">for </span><span class="s1">src</span><span class="s3">, </span><span class="s1">dst </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arys</span><span class="s3">, </span><span class="s1">ll_arys</span><span class="s3">):</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">)</span>

    <span class="s1">np_ary_ty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">np_itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                       <span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">ll_intp</span><span class="s3">))</span>

    <span class="s6"># Form NumPy arrays for axes, shapes, and strides arrays.</span>
    <span class="s1">np_arys </span><span class="s3">= [</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">np_ary_ty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">arys</span><span class="s3">]</span>

    <span class="s6"># Roughly, `np_ary = np.array(ll_ary)` for each of axes, shapes, and strides</span>
    <span class="s2">for </span><span class="s1">np_ary</span><span class="s3">, </span><span class="s1">ll_ary </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">np_arys</span><span class="s3">, </span><span class="s1">ll_arys</span><span class="s3">):</span>
        <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">np_ary</span><span class="s3">,</span>
                       <span class="s1">data</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">ll_ary</span><span class="s3">, </span><span class="s1">ll_intp</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()),</span>
                       <span class="s1">shape</span><span class="s3">=[</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">num_axis</span><span class="s3">)],</span>
                       <span class="s1">strides</span><span class="s3">=[</span><span class="s1">np_itemsize</span><span class="s3">],</span>
                       <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">np_itemsize</span><span class="s3">,</span>
                       <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s6"># Pass NumPy arrays formed above to permute_arrays function that permutes</span>
    <span class="s6"># shapes and strides based on axis contents.</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">permute_arrays</span><span class="s3">,</span>
                             <span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">void</span><span class="s3">,</span>
                                              <span class="s1">np_ary_ty</span><span class="s3">, </span><span class="s1">np_ary_ty</span><span class="s3">, </span><span class="s1">np_ary_ty</span><span class="s3">),</span>
                             <span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">np_arys</span><span class="s3">])</span>

    <span class="s6"># Make a new array based on permuted shape and strides and return it.</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ll_arys</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]),</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ll_arys</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]),</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.transpose'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">VarArg</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">array_transpose_vararg</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">new_sig</span><span class="s3">, </span><span class="s1">new_args </span><span class="s3">= </span><span class="s1">vararg_to_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">array_transpose_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">new_sig</span><span class="s3">, </span><span class="s1">new_args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_transpose</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s4">&quot;np.transpose does not accept tuples&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_transpose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_transpose_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">np_transpose_impl</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'T'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_T</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">value</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">,</span>
                       <span class="s1">data</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                       <span class="s1">shape</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]),</span>
                       <span class="s1">strides</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]),</span>
                       <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                       <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                       <span class="s1">parent</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">logspace</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_logspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;start&quot; must be a number'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The second argument &quot;stop&quot; must be a number'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The third argument &quot;num&quot; must be an integer'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s5">10.0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">geomspace</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_geomspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;start&quot; must be a number'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;stop&quot; must be a number'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;num&quot; must be an integer'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">]):</span>
        <span class="s1">result_dtype </span><span class="s3">= </span><span class="s1">from_dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">start</span><span class="s3">),</span>
                                                 <span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">), </span><span class="s2">None</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">start </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">stop </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Geometric sequence cannot include zero'</span><span class="s3">)</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">result_dtype</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">stop </span><span class="s3">= </span><span class="s1">result_dtype</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">)</span>
            <span class="s1">both_imaginary </span><span class="s3">= (</span><span class="s1">start</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s5">0</span><span class="s3">) &amp; (</span><span class="s1">stop</span><span class="s3">.</span><span class="s1">real </span><span class="s3">== </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">both_negative </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">start</span><span class="s3">) == -</span><span class="s5">1</span><span class="s3">) &amp; (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">) == -</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">out_sign </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">both_imaginary</span><span class="s3">:</span>
                <span class="s1">start </span><span class="s3">= </span><span class="s1">start</span><span class="s3">.</span><span class="s1">imag</span>
                <span class="s1">stop </span><span class="s3">= </span><span class="s1">stop</span><span class="s3">.</span><span class="s1">imag</span>
                <span class="s1">out_sign </span><span class="s3">= </span><span class="s5">1j</span>
            <span class="s2">if </span><span class="s1">both_negative</span><span class="s3">:</span>
                <span class="s1">start </span><span class="s3">= -</span><span class="s1">start</span>
                <span class="s1">stop </span><span class="s3">= -</span><span class="s1">stop</span>
                <span class="s1">out_sign </span><span class="s3">= -</span><span class="s1">out_sign</span>
            <span class="s1">logstart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">logstop </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logspace</span><span class="s3">(</span><span class="s1">logstart</span><span class="s3">, </span><span class="s1">logstop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">)</span>
            <span class="s6"># Make sure the endpoints match the start and stop arguments.</span>
            <span class="s6"># This is necessary because np.exp(np.log(x)) is not necessarily</span>
            <span class="s6"># equal to x.</span>
            <span class="s2">if </span><span class="s1">num </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">start</span>
                <span class="s2">if </span><span class="s1">num </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">result</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">stop</span>
            <span class="s2">return </span><span class="s1">out_sign </span><span class="s3">* </span><span class="s1">result</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">start </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">stop </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Geometric sequence cannot include zero'</span><span class="s3">)</span>
            <span class="s1">both_negative </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">start</span><span class="s3">) == -</span><span class="s5">1</span><span class="s3">) &amp; (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">) == -</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">out_sign </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">both_negative</span><span class="s3">:</span>
                <span class="s1">start </span><span class="s3">= -</span><span class="s1">start</span>
                <span class="s1">stop </span><span class="s3">= -</span><span class="s1">stop</span>
                <span class="s1">out_sign </span><span class="s3">= -</span><span class="s1">out_sign</span>
            <span class="s1">logstart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s1">logstop </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logspace</span><span class="s3">(</span><span class="s1">logstart</span><span class="s3">, </span><span class="s1">logstop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">)</span>
            <span class="s6"># Make sure the endpoints match the start and stop arguments.</span>
            <span class="s6"># This is necessary because np.exp(np.log(x)) is not necessarily</span>
            <span class="s6"># equal to x.</span>
            <span class="s2">if </span><span class="s1">num </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">start</span>
                <span class="s2">if </span><span class="s1">num </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">result</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">stop</span>
            <span class="s2">return </span><span class="s1">out_sign </span><span class="s3">* </span><span class="s1">result</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">rot90</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_rot90</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6"># supporting axes argument it needs to be included in np.flip</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The second argument &quot;k&quot; must be an integer'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;m&quot; must be an array'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s4">'Input must be &gt;= 2-d.'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">% </span><span class="s5">4</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">m</span><span class="s3">[:]</span>
        <span class="s2">elif </span><span class="s1">k </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">fliplr</span><span class="s3">(</span><span class="s1">m</span><span class="s3">), </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">k </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flipud</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">fliplr</span><span class="s3">(</span><span class="s1">m</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">k </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fliplr</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AssertionError  </span><span class="s6"># unreachable</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_attempt_nocopy_reshape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">,</span>
                            <span class="s1">newnd</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">, </span><span class="s1">newstrides</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call into Numba_attempt_nocopy_reshape() for the given array type 
    and instance, and the specified new shape. 
 
    Return value is non-zero if successful, and the array pointed to 
    by *newstrides* will be filled up with the computed results. 
    &quot;&quot;&quot;</span>
    <span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">ll_intp_star </span><span class="s3">= </span><span class="s1">ll_intp</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>
    <span class="s1">ll_intc </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">)</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ll_intc</span><span class="s3">, [</span>
        <span class="s6"># nd, *dims, *strides</span>
        <span class="s1">ll_intp</span><span class="s3">, </span><span class="s1">ll_intp_star</span><span class="s3">, </span><span class="s1">ll_intp_star</span><span class="s3">,</span>
        <span class="s6"># newnd, *newdims, *newstrides</span>
        <span class="s1">ll_intp</span><span class="s3">, </span><span class="s1">ll_intp_star</span><span class="s3">, </span><span class="s1">ll_intp_star</span><span class="s3">,</span>
        <span class="s6"># itemsize, is_f_order</span>
        <span class="s1">ll_intp</span><span class="s3">, </span><span class="s1">ll_intc</span><span class="s3">])</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">,</span>
                                        <span class="s4">&quot;numba_attempt_nocopy_reshape&quot;</span><span class="s3">)</span>

    <span class="s1">nd </span><span class="s3">= </span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'shape'</span><span class="s3">), </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'strides'</span><span class="s3">),</span>
                                   <span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">newnd </span><span class="s3">= </span><span class="s1">ll_intp</span><span class="s3">(</span><span class="s1">newnd</span><span class="s3">)</span>
    <span class="s1">newshape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">newstrides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">newstrides</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">is_f_order </span><span class="s3">= </span><span class="s1">ll_intc</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [</span><span class="s1">nd</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                            <span class="s1">newnd</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">, </span><span class="s1">newstrides</span><span class="s3">,</span>
                            <span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">is_f_order</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">normalize_reshape_value</span><span class="s3">(</span><span class="s1">origsize</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
    <span class="s1">num_neg_value </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">known_size </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">num_neg_value </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">neg_ax </span><span class="s3">= </span><span class="s1">ax</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">known_size </span><span class="s3">*= </span><span class="s1">s</span>

    <span class="s2">if </span><span class="s1">num_neg_value </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">origsize </span><span class="s3">!= </span><span class="s1">known_size</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;total size of new array must be unchanged&quot;</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">num_neg_value </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s6"># Infer negative dimension</span>
        <span class="s2">if </span><span class="s1">known_size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">inferred </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">ok </span><span class="s3">= </span><span class="s1">origsize </span><span class="s3">== </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">inferred </span><span class="s3">= </span><span class="s1">origsize </span><span class="s3">// </span><span class="s1">known_size</span>
            <span class="s1">ok </span><span class="s3">= </span><span class="s1">origsize </span><span class="s3">% </span><span class="s1">known_size </span><span class="s3">== </span><span class="s5">0</span>
        <span class="s2">if not </span><span class="s1">ok</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;total size of new array must be unchanged&quot;</span><span class="s3">)</span>
        <span class="s1">shape</span><span class="s3">[</span><span class="s1">neg_ax</span><span class="s3">] = </span><span class="s1">inferred</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;multiple negative shape values&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.reshape'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_reshape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>

    <span class="s1">shapety </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s1">ll_intp </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">ll_shape </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ll_intp</span><span class="s3">, </span><span class="s1">shapety</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

    <span class="s6"># We will change the target shape in this slot</span>
    <span class="s6"># (see normalize_reshape_value() below)</span>
    <span class="s1">newshape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shape</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">)</span>

    <span class="s6"># Create a shape array pointing to the value of newshape.</span>
    <span class="s6"># (roughly, `shape_ary = np.array(ary.shape)`)</span>
    <span class="s1">shape_ary_ty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">shapety</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">shape_ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">shape_ary_ty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">shape_itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                          <span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">ll_intp</span><span class="s3">))</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">shape_ary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">, </span><span class="s1">ll_intp</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()),</span>
                   <span class="s1">shape</span><span class="s3">=[</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">shapety</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)],</span>
                   <span class="s1">strides</span><span class="s3">=[</span><span class="s1">shape_itemsize</span><span class="s3">],</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">shape_itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s6"># Compute the original array size</span>
    <span class="s1">size </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span>

    <span class="s6"># Call our normalizer which will fix the shape array in case of negative</span>
    <span class="s6"># shape value</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">normalize_reshape_value</span><span class="s3">,</span>
                             <span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">void</span><span class="s3">,</span>
                                              <span class="s1">types</span><span class="s3">.</span><span class="s1">uintp</span><span class="s3">, </span><span class="s1">shape_ary_ty</span><span class="s3">),</span>
                             <span class="s3">[</span><span class="s1">size</span><span class="s3">, </span><span class="s1">shape_ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()])</span>

    <span class="s6"># Perform reshape (nocopy)</span>
    <span class="s1">newnd </span><span class="s3">= </span><span class="s1">shapety</span><span class="s3">.</span><span class="s1">count</span>
    <span class="s1">newstrides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shape</span><span class="s3">)</span>

    <span class="s1">ok </span><span class="s3">= </span><span class="s1">_attempt_nocopy_reshape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">newnd</span><span class="s3">,</span>
                                 <span class="s1">newshape</span><span class="s3">, </span><span class="s1">newstrides</span><span class="s3">)</span>
    <span class="s1">fail </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">ok</span><span class="s3">, </span><span class="s1">ok</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">))</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">fail</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;incompatible shape for array&quot;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">NotImplementedError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">),</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">newstrides</span><span class="s3">),</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.reshape'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">VarArg</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">array_reshape_vararg</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">new_sig</span><span class="s3">, </span><span class="s1">new_args </span><span class="s3">= </span><span class="s1">vararg_to_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">array_reshape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">new_sig</span><span class="s3">, </span><span class="s1">new_args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_reshape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">np_reshape_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np_reshape_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">resize</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_resize</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;a&quot; must be array-like'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s3">((</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)</span>
             <span class="s2">and</span>
             <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">))</span>
            <span class="s2">or</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'The argument &quot;new_shape&quot; must be an integer or '</span>
               <span class="s4">'a tuple of integers'</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">new_size </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s2">for </span><span class="s1">dim_length </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">):</span>
                <span class="s1">new_size </span><span class="s3">*= </span><span class="s1">dim_length</span>
                <span class="s2">if </span><span class="s1">dim_length </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">msg </span><span class="s3">= </span><span class="s4">'All elements of `new_shape` must be non-negative'</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">new_shape </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">msg2 </span><span class="s3">= </span><span class="s4">'All elements of `new_shape` must be non-negative'</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg2</span><span class="s3">)</span>
            <span class="s1">new_size </span><span class="s3">= </span><span class="s1">new_shape</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">repeats </span><span class="s3">= -(-</span><span class="s1">new_size </span><span class="s3">// </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)  </span><span class="s6"># ceil division</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">repeats </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">res</span><span class="s3">, </span><span class="s1">a</span><span class="s3">))</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">res</span><span class="s3">[:</span><span class="s1">new_size</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">append</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_append</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;arr&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">values</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The second argument &quot;values&quot; must be '</span>
                                 <span class="s4">'array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">))</span>
            <span class="s1">values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">values</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The third argument &quot;axis&quot; must be an '</span>
                                     <span class="s4">'integer'</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.ravel'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ravel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s6"># Only support no argument version (default order='C')</span>
    <span class="s2">def </span><span class="s1">imp_nocopy</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;No copy version&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">imp_copy</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Copy version&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">()</span>

    <span class="s6"># If the input array is C layout already, use the nocopy version</span>
    <span class="s2">if </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'C'</span><span class="s3">:</span>
        <span class="s1">imp </span><span class="s3">= </span><span class="s1">imp_nocopy</span>
    <span class="s6"># otherwise, use flatten under-the-hood</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">imp </span><span class="s3">= </span><span class="s1">imp_copy</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_ravel</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">np_ravel_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">np_ravel_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.flatten'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_flatten</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s6"># Only support flattening to C layout currently.</span>
    <span class="s2">def </span><span class="s1">imp</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_np_clip_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s6"># Both a_min and a_max are numpy arrays</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
    <span class="s1">a_b</span><span class="s3">, </span><span class="s1">a_min_b</span><span class="s3">, </span><span class="s1">a_max_b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a_b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s1">val_a </span><span class="s3">= </span><span class="s1">a_b</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">val_a_min </span><span class="s3">= </span><span class="s1">a_min_b</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">val_a_max </span><span class="s3">= </span><span class="s1">a_max_b</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">ret</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">val_a_min</span><span class="s3">), </span><span class="s1">val_a_max</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_np_clip_impl_none</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">use_min</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s1">val_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s1">val_b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">use_min</span><span class="s3">:</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">val_b</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">max</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">val_b</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_clip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a_min</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">((</span><span class="s4">'The argument &quot;a_min&quot; must be a number '</span>
                                 <span class="s4">'or an array-like'</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;a_max&quot; must be a number '</span>
                                 <span class="s4">'or an array-like'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;out&quot; must be an array if it is provided'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s6"># TODO: support scalar a (issue #3469)</span>
    <span class="s1">a_min_is_none </span><span class="s3">= </span><span class="s1">a_min </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">)</span>
    <span class="s1">a_max_is_none </span><span class="s3">= </span><span class="s1">a_max </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a_min_is_none </span><span class="s2">and </span><span class="s1">a_max_is_none</span><span class="s3">:</span>
        <span class="s6"># Raises value error when both a_min and a_max are None</span>
        <span class="s2">def </span><span class="s1">np_clip_nn</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;array_clip: must set either max or min&quot;</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">np_clip_nn</span>

    <span class="s1">a_min_is_scalar </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>
    <span class="s1">a_max_is_scalar </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a_min_is_scalar </span><span class="s2">and </span><span class="s1">a_max_is_scalar</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">np_clip_ss</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s6"># a_min and a_max are scalars</span>
            <span class="s6"># since their shape will be empty</span>
            <span class="s6"># so broadcasting is not needed at all</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
            <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
                <span class="s1">val_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
                <span class="s1">ret</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">), </span><span class="s1">a_max</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">ret</span>

        <span class="s2">return </span><span class="s1">np_clip_ss</span>
    <span class="s2">elif </span><span class="s1">a_min_is_scalar </span><span class="s2">and not </span><span class="s1">a_max_is_scalar</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a_max_is_none</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_sn</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_min is a scalar</span>
                <span class="s6"># since its shape will be empty</span>
                <span class="s6"># so broadcasting is not needed at all</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
                <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
                    <span class="s1">val_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
                    <span class="s1">ret</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">max</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">)</span>

                <span class="s2">return </span><span class="s1">ret</span>

            <span class="s2">return </span><span class="s1">np_clip_sn</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_sa</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_min is a scalar</span>
                <span class="s6"># since its shape will be empty</span>
                <span class="s6"># broadcast it to shape of a</span>
                <span class="s6"># by using np.full_like</span>
                <span class="s1">a_min_full </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_np_clip_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min_full</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">np_clip_sa</span>
    <span class="s2">elif not </span><span class="s1">a_min_is_scalar </span><span class="s2">and </span><span class="s1">a_max_is_scalar</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a_min_is_none</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_ns</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_max is a scalar</span>
                <span class="s6"># since its shape will be empty</span>
                <span class="s6"># so broadcasting is not needed at all</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
                <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
                    <span class="s1">val_a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>
                    <span class="s1">ret</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">val_a</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">)</span>

                <span class="s2">return </span><span class="s1">ret</span>

            <span class="s2">return </span><span class="s1">np_clip_ns</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_as</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_max is a scalar</span>
                <span class="s6"># since its shape will be empty</span>
                <span class="s6"># broadcast it to shape of a</span>
                <span class="s6"># by using np.full_like</span>
                <span class="s1">a_max_full </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_np_clip_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max_full</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">np_clip_as</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Case where exactly one of a_min or a_max is None</span>
        <span class="s2">if </span><span class="s1">a_min_is_none</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_na</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_max is a numpy array but a_min is None</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
                <span class="s1">a_b</span><span class="s3">, </span><span class="s1">a_max_b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_np_clip_impl_none</span><span class="s3">(</span><span class="s1">a_b</span><span class="s3">, </span><span class="s1">a_max_b</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">np_clip_na</span>
        <span class="s2">elif </span><span class="s1">a_max_is_none</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_an</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># a_min is a numpy array but a_max is None</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out</span>
                <span class="s1">a_b</span><span class="s3">, </span><span class="s1">a_min_b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_np_clip_impl_none</span><span class="s3">(</span><span class="s1">a_b</span><span class="s3">, </span><span class="s1">a_min_b</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">np_clip_an</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_clip_aa</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s6"># Both a_min and a_max are clearly arrays</span>
                <span class="s6"># because none of the above branches</span>
                <span class="s6"># returned</span>
                <span class="s2">return </span><span class="s1">_np_clip_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">np_clip_aa</span>


<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'clip'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_clip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">a_min</span><span class="s3">, </span><span class="s1">a_max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_change_dtype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">oldty</span><span class="s3">, </span><span class="s1">newty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Attempt to fix up *ary* for switching from *oldty* to *newty*. 
 
    See Numpy's array_descr_set() 
    (np/core/src/multiarray/getset.c). 
    Attempt to fix the array's shape and strides for a new dtype. 
    False is returned on failure, True on success. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">oldty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">newty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">assert </span><span class="s1">oldty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">newty</span><span class="s3">.</span><span class="s1">layout</span>

    <span class="s1">new_layout </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s1">any_layout </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s4">'A'</span><span class="s3">)</span>
    <span class="s1">c_layout </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">f_layout </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s4">'F'</span><span class="s3">)</span>

    <span class="s1">int8 </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int8</span>

    <span class="s2">def </span><span class="s1">imp</span><span class="s3">(</span><span class="s1">nd</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">old_itemsize</span><span class="s3">, </span><span class="s1">new_itemsize</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">):</span>
        <span class="s6"># Attempt to update the layout due to limitation of the numba</span>
        <span class="s6"># type system.</span>
        <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s1">any_layout</span><span class="s3">:</span>
            <span class="s6"># Test rightmost stride to be contiguous</span>
            <span class="s2">if </span><span class="s1">strides</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s1">old_itemsize</span><span class="s3">:</span>
                <span class="s6"># Process this as if it is C contiguous</span>
                <span class="s1">layout </span><span class="s3">= </span><span class="s1">int8</span><span class="s3">(</span><span class="s1">c_layout</span><span class="s3">)</span>
            <span class="s6"># Test leftmost stride to be F contiguous</span>
            <span class="s2">elif </span><span class="s1">strides</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s1">old_itemsize</span><span class="s3">:</span>
                <span class="s6"># Process this as if it is F contiguous</span>
                <span class="s1">layout </span><span class="s3">= </span><span class="s1">int8</span><span class="s3">(</span><span class="s1">f_layout</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">old_itemsize </span><span class="s3">!= </span><span class="s1">new_itemsize </span><span class="s2">and </span><span class="s3">(</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">any_layout </span><span class="s2">or </span><span class="s1">nd </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s1">c_layout</span><span class="s3">:</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">nd </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s2">if </span><span class="s1">new_itemsize </span><span class="s3">&lt; </span><span class="s1">old_itemsize</span><span class="s3">:</span>
            <span class="s6"># If it is compatible, increase the size of the dimension</span>
            <span class="s6"># at the end (or at the front if F-contiguous)</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">old_itemsize </span><span class="s3">% </span><span class="s1">new_itemsize</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">return False</span>

            <span class="s1">newdim </span><span class="s3">= </span><span class="s1">old_itemsize </span><span class="s3">// </span><span class="s1">new_itemsize</span>
            <span class="s1">dims</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] *= </span><span class="s1">newdim</span>
            <span class="s1">strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">new_itemsize</span>

        <span class="s2">elif </span><span class="s1">new_itemsize </span><span class="s3">&gt; </span><span class="s1">old_itemsize</span><span class="s3">:</span>
            <span class="s6"># Determine if last (or first if F-contiguous) dimension</span>
            <span class="s6"># is compatible</span>
            <span class="s1">bytelength </span><span class="s3">= </span><span class="s1">dims</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">old_itemsize</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">bytelength </span><span class="s3">% </span><span class="s1">new_itemsize</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">return False</span>

            <span class="s1">dims</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">bytelength </span><span class="s3">// </span><span class="s1">new_itemsize</span>
            <span class="s1">strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">new_itemsize</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Same item size: nothing to do (this also works for</span>
            <span class="s6"># non-contiguous arrays).</span>
            <span class="s2">pass</span>

        <span class="s2">return True</span>

    <span class="s1">old_itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                        <span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">oldty</span><span class="s3">))</span>
    <span class="s1">new_itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                        <span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">newty</span><span class="s3">))</span>

    <span class="s1">nd </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">newty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">shape_data </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'shape'</span><span class="s3">),</span>
                                      <span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">strides_data </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                        <span class="s1">ary</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'strides'</span><span class="s3">), </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">shape_strides_array_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">arycls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">shape_strides_array_type</span><span class="s3">)</span>

    <span class="s1">shape_constant </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                        <span class="s3">[</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                                              <span class="s1">newty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)])</span>

    <span class="s1">sizeof_intp </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">))</span>
    <span class="s1">sizeof_intp </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">sizeof_intp</span><span class="s3">)</span>
    <span class="s1">strides_constant </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, [</span><span class="s1">sizeof_intp</span><span class="s3">])</span>

    <span class="s1">shape_ary </span><span class="s3">= </span><span class="s1">arycls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">shape_ary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">shape_data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape_constant</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides_constant</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">sizeof_intp</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">strides_ary </span><span class="s3">= </span><span class="s1">arycls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">strides_ary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">strides_data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape_constant</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides_constant</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">sizeof_intp</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">shape </span><span class="s3">= </span><span class="s1">shape_ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">strides_ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s1">args </span><span class="s3">= [</span><span class="s1">nd</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">old_itemsize</span><span class="s3">, </span><span class="s1">new_itemsize</span><span class="s3">,</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">, </span><span class="s1">new_layout</span><span class="s3">)]</span>

    <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">,</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,  </span><span class="s6"># nd</span>
                    <span class="s1">shape_strides_array_type</span><span class="s3">,  </span><span class="s6"># dims</span>
                    <span class="s1">shape_strides_array_type</span><span class="s3">,  </span><span class="s6"># strides</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,  </span><span class="s6"># old_itemsize</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,  </span><span class="s6"># new_itemsize</span>
                    <span class="s1">types</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">,  </span><span class="s6"># layout</span>
                    <span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">update_array_info</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_shape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;The argument to np.shape must be array-like&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">shape</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_size</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;The argument to np.size must be array-like&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">size</span>
    <span class="s2">return </span><span class="s1">impl</span>

<span class="s6"># ------------------------------------------------------------------------------</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_unique</span><span class="s3">(</span><span class="s1">ar</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">np_unique_impl</span><span class="s3">(</span><span class="s1">ar</span><span class="s3">):</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">ar</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s1">head </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[:</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">tail </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]) </span><span class="s2">if </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">x</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">head </span><span class="s3">+ </span><span class="s1">tail</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np_unique_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_repeat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">):</span>
    <span class="s6"># Implementation for repeats being a scalar is a module global function</span>
    <span class="s6"># (see below) because it might be called from the implementation below.</span>

    <span class="s2">def </span><span class="s1">np_repeat_impl_repeats_array_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">):</span>
        <span class="s6"># implementation if repeats is an array like</span>
        <span class="s1">repeats_array </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s6"># if it is a singleton array, invoke the scalar implementation</span>
        <span class="s2">if </span><span class="s1">repeats_array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np_repeat_impl_repeats_scaler</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats_array</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">repeats_array </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;negative dimensions are not allowed&quot;</span><span class="s3">)</span>
        <span class="s1">asa </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">aravel </span><span class="s3">= </span><span class="s1">asa</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">aravel</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">aravel</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">repeats_array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;operands could not be broadcast together&quot;</span><span class="s3">)</span>
        <span class="s1">to_return </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">repeats_array</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">asa</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">pos </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">to_return</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">: </span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">repeats_array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]] = </span><span class="s1">aravel</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">pos </span><span class="s3">+= </span><span class="s1">repeats_array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">to_return</span>

    <span class="s6"># type checking</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,</span>
                      <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">,</span>
                      <span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">,</span>
                      <span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">,</span>
                      <span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">,</span>
                      <span class="s3">)</span>
                  <span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np_repeat_impl_repeats_scaler</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np_repeat_impl_repeats_array_like</span>

        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
            <span class="s4">&quot;The repeats argument must be an integer &quot;</span>
            <span class="s4">&quot;or an array-like of integer dtype&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">np_repeat_impl_repeats_scaler</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">repeats </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;negative dimensions are not allowed&quot;</span><span class="s3">)</span>
    <span class="s1">asa </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">aravel </span><span class="s3">= </span><span class="s1">asa</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">aravel</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">repeats </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">asa</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">repeats </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">aravel</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">to_return </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">repeats</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">asa</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">to_return</span><span class="s3">[</span><span class="s1">i </span><span class="s3">* </span><span class="s1">repeats </span><span class="s3">: (</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">repeats</span><span class="s3">] = </span><span class="s1">aravel</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">to_return</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'repeat'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_repeat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">array_repeat_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">array_repeat_impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_intrin_get_itemsize</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Computes the itemsize of the dtype&quot;&quot;&quot;</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">):</span>
        <span class="s1">llty </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">llintp </span><span class="s3">= </span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">llintp</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">llty</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s2">def </span><span class="s1">_compatible_view</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_compatible_view</span><span class="s3">, </span><span class="s1">target</span><span class="s3">=</span><span class="s4">'generic'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_compatible_view</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Determines if the array and dtype are compatible for forming a view.&quot;&quot;&quot;</span>
    <span class="s6"># NOTE: NumPy 1.23+ uses this check.</span>
    <span class="s6"># Code based on:</span>
    <span class="s6"># https://github.com/numpy/numpy/blob/750ad21258cfc00663586d5a466e24f91b48edc7/numpy/core/src/multiarray/getset.c#L500-L555  # noqa: E501</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">dtype_size </span><span class="s3">= </span><span class="s1">_intrin_get_itemsize</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dtype_size </span><span class="s3">!= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">:</span>
            <span class="s6"># catch forbidden cases</span>
            <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">msg1 </span><span class="s3">= (</span><span class="s4">&quot;Changing the dtype of a 0d array is only supported &quot;</span>
                        <span class="s4">&quot;if the itemsize is unchanged&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg1</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># NumPy has a check here for subarray type conversion which</span>
                <span class="s6"># Numba doesn't support</span>
                <span class="s2">pass</span>

            <span class="s6"># Resize on last axis only</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span>
            <span class="s1">p1 </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] != </span><span class="s5">1</span>
            <span class="s1">p2 </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s1">p3 </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] != </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">p1 </span><span class="s2">and </span><span class="s1">p2 </span><span class="s2">and </span><span class="s1">p3</span><span class="s3">):</span>
                <span class="s1">msg2 </span><span class="s3">= (</span><span class="s4">&quot;To change to a dtype of a different size, the last &quot;</span>
                        <span class="s4">&quot;axis must be contiguous&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg2</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">dtype_size </span><span class="s3">&lt; </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">dtype_size </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">% </span><span class="s1">dtype_size </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">msg3 </span><span class="s3">= (</span><span class="s4">&quot;When changing to a smaller dtype, its size must &quot;</span>
                            <span class="s4">&quot;be a divisor of the size of original dtype&quot;</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg3</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">newdim </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] * </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span>
                <span class="s2">if </span><span class="s1">newdim </span><span class="s3">% </span><span class="s1">dtype_size </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">msg4 </span><span class="s3">= (</span><span class="s4">&quot;When changing to a larger dtype, its size must be &quot;</span>
                            <span class="s4">&quot;a divisor of the total size in bytes of the last &quot;</span>
                            <span class="s4">&quot;axis of the array.&quot;</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg4</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'array.view'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_view</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s6"># Copy all fields, casting the &quot;data&quot; pointer appropriately</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">fields</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s4">'data'</span><span class="s3">:</span>
            <span class="s1">ptrty </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s1">ret</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptrty</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&gt;= (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">23</span><span class="s3">):</span>
        <span class="s6"># NumPy 1.23+ bans views using a dtype that is a different size to that</span>
        <span class="s6"># of the array when the last axis is not contiguous. For example, this</span>
        <span class="s6"># manifests at runtime when a dtype size altering view is requested</span>
        <span class="s6"># on a Fortran ordered array.</span>

        <span class="s1">tyctx </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">typing_context</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">tyctx</span><span class="s3">.</span><span class="s1">resolve_value_type</span><span class="s3">(</span><span class="s1">_compatible_view</span><span class="s3">)</span>
        <span class="s1">_compatible_view_sig </span><span class="s3">= </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">get_call_type</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, (*</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,), {})</span>
        <span class="s1">impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">_compatible_view_sig</span><span class="s3">)</span>
        <span class="s1">impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s1">ok </span><span class="s3">= </span><span class="s1">_change_dtype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>
    <span class="s1">fail </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">ok</span><span class="s3">, </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ok</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">fail</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;new type not compatible with array&quot;</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Array attributes</span>

<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_dtype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;shape&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;shape&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;strides&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;strides&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">strides</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;ndim&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;ndim&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ndim</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;size&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_size</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">nitems</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;itemsize&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;itemsize&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">itemsize</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;nbytes&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;nbytes&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_nbytes</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    nbytes = size * itemsize 
    &quot;&quot;&quot;</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">array</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;contiguous&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">is_contig</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;c_contiguous&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_c_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">is_c_contig</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;f_contiguous&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_f_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">is_f_contig</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemoryView</span><span class="s3">, </span><span class="s4">&quot;readonly&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_readonly</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s2">not </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">mutable</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s6"># array.ctypes</span>

<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;ctypes&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ctypes</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s6"># Create new ArrayCType structure</span>
    <span class="s1">act </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCTypes</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">ctinfo </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">act</span><span class="s3">)</span>
    <span class="s1">ctinfo</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">ctinfo</span><span class="s3">.</span><span class="s1">meminfo </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">meminfo</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ctinfo</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">act</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCTypes</span><span class="s3">, </span><span class="s4">&quot;data&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ctypes_data</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">ctinfo </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ctinfo</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s6"># Convert it to an integer</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">ptrtoint</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCTypes</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCTypes</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">voidptr</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ctypes_to_pointer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">ctinfo </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">val</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ctinfo</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">toty</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_call_contiguous_check</span><span class="s3">(</span><span class="s1">checker</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Helper to invoke the contiguous checker function on an array 
 
    Args 
    ---- 
    checker : 
        ``numba.numpy_supports.is_contiguous``, or 
        ``numba.numpy_supports.is_fortran``. 
    context : target context 
    builder : llvm ir builder 
    aryty : numba type 
    ary : llvm value 
    &quot;&quot;&quot;</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">)</span>
    <span class="s1">tup_intp </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s1">check_sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">, </span><span class="s1">tup_intp</span><span class="s3">, </span><span class="s1">tup_intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">check_args </span><span class="s3">= [</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
                  <span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)]</span>
    <span class="s1">is_contig </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">checker</span><span class="s3">, </span><span class="s1">check_sig</span><span class="s3">,</span>
                                         <span class="s1">check_args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">is_contig</span>


<span class="s6"># array.flags</span>

<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;flags&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_flags</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s1">flagsobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayFlags</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">))</span>
    <span class="s1">flagsobj</span><span class="s3">.</span><span class="s1">parent </span><span class="s3">= </span><span class="s1">value</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">flagsobj</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">incref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayFlags</span><span class="s3">, </span><span class="s4">&quot;contiguous&quot;</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayFlags</span><span class="s3">, </span><span class="s4">&quot;c_contiguous&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_flags_c_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s4">'C'</span><span class="s3">:</span>
        <span class="s6"># any layout can still be contiguous</span>
        <span class="s1">flagsobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">_call_contiguous_check</span><span class="s3">(</span><span class="s1">is_contiguous</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                     <span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">, </span><span class="s1">flagsobj</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'C'</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayFlags</span><span class="s3">, </span><span class="s4">&quot;f_contiguous&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_flags_f_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s4">'F'</span><span class="s3">:</span>
        <span class="s6"># any layout can still be contiguous</span>
        <span class="s1">flagsobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">_call_contiguous_check</span><span class="s3">(</span><span class="s1">is_fortran</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                     <span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">, </span><span class="s1">flagsobj</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">layout </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">layout</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F' </span><span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">layout </span><span class="s2">in </span><span class="s4">'CF'</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># .real / .imag</span>

<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;real&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_real_part</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">array_complex_attr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">=</span><span class="s4">'real'</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">number_domain</span><span class="s3">:</span>
        <span class="s6"># as an identity function</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">'unsupported .real for {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">type</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;imag&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_imag_part</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">array_complex_attr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">=</span><span class="s4">'imag'</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">number_domain</span><span class="s3">:</span>
        <span class="s6"># return a readonly zero array</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">True</span><span class="s3">), </span><span class="s1">typ</span><span class="s3">)</span>
        <span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes </span><span class="s3">= </span><span class="s1">_parse_empty_like_args</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, [</span><span class="s1">value</span><span class="s3">])</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                                                      <span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">), </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                                <span class="s1">ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">'unsupported .imag for {}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">type</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">array_complex_attr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a complex array, it's memory layout is: 
 
        R C R C R C 
        ^   ^   ^ 
 
    (`R` indicates a float for the real part; 
     `C` indicates a float for the imaginary part; 
     the `^` indicates the start of each element) 
 
    To get the real part, we can simply change the dtype and itemsize to that 
    of the underlying float type.  The new layout is: 
 
        R x R x R x 
        ^   ^   ^ 
 
    (`x` indicates unused) 
 
    A load operation will use the dtype to determine the number of bytes to 
    load. 
 
    To get the imaginary part, we shift the pointer by 1 float offset and 
    change the dtype and itemsize.  The new layout is: 
 
        x C x C x C 
          ^   ^   ^ 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attr </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'real'</span><span class="s3">, </span><span class="s4">'imag'</span><span class="s3">] </span><span class="s2">or </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">not in </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex_domain</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;cannot get attribute `{}`&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">))</span>

    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s6"># sizeof underlying float type</span>
    <span class="s1">flty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">underlying_float</span>
    <span class="s1">sizeof_flty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">flty</span><span class="s3">))</span>
    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">sizeof_flty</span><span class="s3">)</span>

    <span class="s6"># cast data pointer to float type</span>
    <span class="s1">llfltptrty </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">flty</span><span class="s3">).</span><span class="s1">as_pointer</span><span class="s3">()</span>
    <span class="s1">dataptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">array</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">llfltptrty</span><span class="s3">)</span>

    <span class="s6"># add offset</span>
    <span class="s2">if </span><span class="s1">attr </span><span class="s3">== </span><span class="s4">'imag'</span><span class="s3">:</span>
        <span class="s1">dataptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">dataptr</span><span class="s3">, [</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s5">32</span><span class="s3">)(</span><span class="s5">1</span><span class="s3">)])</span>

    <span class="s6"># make result</span>
    <span class="s1">resultty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">flty</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">resultty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">repl </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">data</span><span class="s3">=</span><span class="s1">dataptr</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">=</span><span class="s1">itemsize</span><span class="s3">)</span>
    <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">copy_struct</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">repl</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">resultty</span><span class="s3">, </span><span class="s1">result</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'conj'</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'conjugate'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_conj</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>

<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># DType attribute</span>


<span class="s2">def </span><span class="s1">dtype_type</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dtypety</span><span class="s3">, </span><span class="s1">dtypeval</span><span class="s3">):</span>
    <span class="s6"># Just return a dummy opaque value</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>


<span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">, </span><span class="s4">'type'</span><span class="s3">)(</span><span class="s1">dtype_type</span><span class="s3">)</span>
<span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">, </span><span class="s4">'kind'</span><span class="s3">)(</span><span class="s1">dtype_type</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># static_getitem on Numba numerical types to create &quot;array&quot; types</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_getitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumberClass</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">static_getitem_number_clazz</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;This handles the &quot;static_getitem&quot; when a Numba type is subscripted e.g: 
    var = typed.List.empty_list(float64[::1, :]) 
    It only allows this on simple numerical types. Compound types, like 
    records, are not supported. 
    &quot;&quot;&quot;</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s6"># This isn't used or practically accessible, but has to exist, so just</span>
        <span class="s6"># put in a NULL of the right type.</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># This should be unreachable unless the implementation on the Type</span>
        <span class="s6"># metaclass is changed.</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Unreachable; the definition of __getitem__ on the &quot;</span>
               <span class="s4">&quot;numba.types.abstract.Type metaclass should prevent access.&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">LoweringError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Structured / record lookup</span>

<span class="s3">@</span><span class="s1">lower_getattr_generic</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_record_getattr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generic getattr() implementation for record arrays: fetch the given 
    record member, i.e. a subarray. 
    &quot;&quot;&quot;</span>
    <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">arrayty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s1">rectype </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rectype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;attribute %r of %s not defined&quot;</span>
                                  <span class="s3">% (</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">))</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">rectype</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s1">rectype</span><span class="s3">.</span><span class="s1">offset</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NestedArray</span><span class="s3">):</span>
        <span class="s1">resty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">resty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">)</span>

    <span class="s1">raryty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">resty</span><span class="s3">)</span>

    <span class="s1">rary </span><span class="s3">= </span><span class="s1">raryty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">constoffset </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>

    <span class="s1">newdataptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pointer_add</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">constoffset</span><span class="s3">,  </span><span class="s1">return_type</span><span class="s3">=</span><span class="s1">rary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NestedArray</span><span class="s3">):</span>
        <span class="s6"># new shape = recarray shape + inner dimension from nestedarray</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">shape </span><span class="s3">+= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">]</span>
        <span class="s6"># new strides = recarray strides + strides of the inner nestedarray</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">strides </span><span class="s3">+= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">]</span>
        <span class="s6"># New datasize = size of elements of the nestedarray</span>
        <span class="s1">datasize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># New shape, strides, and datasize match the underlying array</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">strides</span>
        <span class="s1">datasize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">rary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">newdataptr</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">datasize</span><span class="s3">),</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">array</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">array</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">rary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_getitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_record_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">index </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s6"># This will fallback to normal getitem</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">return </span><span class="s1">array_record_getattr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">index</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_getattr_generic</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_getattr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generic getattr() implementation for records: get the given record member. 
    &quot;&quot;&quot;</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">sentry_record_alignment</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">offset</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
    <span class="s1">elemty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">elemty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NestedArray</span><span class="s3">):</span>
        <span class="s6"># Only a nested array's *data* is stored in a structured array,</span>
        <span class="s6"># so we create an array structure to point to that data.</span>
        <span class="s1">aryty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">elemty</span><span class="s3">)</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">aryty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">elemty</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s1">newshape </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">s</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in</span>
                    <span class="s1">elemty</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">]</span>
        <span class="s1">newstrides </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">s</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in</span>
                      <span class="s1">elemty</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">]</span>
        <span class="s1">newdata </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_record_member</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">,</span>
                                            <span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">))</span>
        <span class="s1">populate_array</span><span class="s3">(</span>
            <span class="s1">ary</span><span class="s3">,</span>
            <span class="s1">data</span><span class="s3">=</span><span class="s1">newdata</span><span class="s3">,</span>
            <span class="s1">shape</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">),</span>
            <span class="s1">strides</span><span class="s3">=</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">newstrides</span><span class="s3">),</span>
            <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">elemty</span><span class="s3">.</span><span class="s1">size</span><span class="s3">),</span>
            <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">parent</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_record_member</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">,</span>
                                         <span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">elemty</span><span class="s3">))</span>
        <span class="s1">align </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">aligned </span><span class="s2">else </span><span class="s5">1</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">unpack_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">elemty</span><span class="s3">, </span><span class="s1">dptr</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_setattr_generic</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_setattr</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generic setattr() implementation for records: set the given record member. 
    &quot;&quot;&quot;</span>
    <span class="s1">typ</span><span class="s3">, </span><span class="s1">valty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">target</span><span class="s3">, </span><span class="s1">val </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">sentry_record_alignment</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">offset</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
    <span class="s1">elemty </span><span class="s3">= </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">typeof</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">elemty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NestedArray</span><span class="s3">):</span>
        <span class="s6"># Copy the data from the RHS into the nested array</span>
        <span class="s1">val_struct </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">valty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                                        <span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">src </span><span class="s3">= </span><span class="s1">val_struct</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">dest </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_record_member</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">,</span>
                                         <span class="s1">src</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">)</span>
        <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">src</span><span class="s3">,</span>
                       <span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">elemty</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Set the given scalar record member</span>
        <span class="s1">dptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_record_member</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">,</span>
                                         <span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">elemty</span><span class="s3">))</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">elemty</span><span class="s3">)</span>
        <span class="s1">align </span><span class="s3">= </span><span class="s2">None if </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">aligned </span><span class="s2">else </span><span class="s5">1</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">pack_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">elemty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">dptr</span><span class="s3">, </span><span class="s1">align</span><span class="s3">=</span><span class="s1">align</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_getitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_static_getitem_str</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Record.__getitem__ redirects to getattr() 
    &quot;&quot;&quot;</span>
    <span class="s1">impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_getattr</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_getitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_static_getitem_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Record.__getitem__ redirects to getattr() 
    &quot;&quot;&quot;</span>
    <span class="s1">idx </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">literal_value</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">fields</span><span class="s3">)</span>
    <span class="s1">ll_field </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">insert_const_string</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fields</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>
    <span class="s1">impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_getattr</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">ll_field</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">fields</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_setitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_static_setitem_str</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Record.__setitem__ redirects to setattr() 
    &quot;&quot;&quot;</span>
    <span class="s1">recty</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">valty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">rec</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val </span><span class="s3">= </span><span class="s1">args</span>
    <span class="s1">getattr_sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">recty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
    <span class="s1">impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_setattr</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">getattr_sig</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">impl </span><span class="s2">is not None</span>
    <span class="s2">return </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">rec</span><span class="s3">, </span><span class="s1">val</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'static_setitem'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">record_static_setitem_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Record.__setitem__ redirects to setattr() 
    &quot;&quot;&quot;</span>
    <span class="s1">recty</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">valty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">rec</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">val </span><span class="s3">= </span><span class="s1">args</span>
    <span class="s1">getattr_sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">recty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">)</span>
    <span class="s1">fields </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">fields</span><span class="s3">)</span>
    <span class="s1">impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_setattr</span><span class="s3">(</span><span class="s1">fields</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">], </span><span class="s1">getattr_sig</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">impl </span><span class="s2">is not None</span>
    <span class="s2">return </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">rec</span><span class="s3">, </span><span class="s1">val</span><span class="s3">))</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Constant arrays and records</span>


<span class="s3">@</span><span class="s1">lower_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">constant_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">pyval</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a constant array (mechanism is target-dependent). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_constant_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">pyval</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Record</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">constant_record</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">pyval</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a record constant as a stack-allocated array of bytes. 
    &quot;&quot;&quot;</span>
    <span class="s1">lty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">pyval</span><span class="s3">.</span><span class="s1">nbytes</span><span class="s3">)</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">lty</span><span class="s3">(</span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">pyval</span><span class="s3">.</span><span class="s1">tostring</span><span class="s3">()))</span>
    <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Bytes</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">constant_bytes</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">pyval</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a constant array from bytes (mechanism is target-dependent). 
    &quot;&quot;&quot;</span>
    <span class="s1">buf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">pyval</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_constant_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">buf</span><span class="s3">)</span>

<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Comparisons</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">is_</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_is</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aty</span><span class="s3">, </span><span class="s1">bty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s2">if </span><span class="s1">aty </span><span class="s3">!= </span><span class="s1">bty</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_bit</span>

    <span class="s2">def </span><span class="s1">array_is_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">and</span>
                <span class="s1">a</span><span class="s3">.</span><span class="s1">strides </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">strides </span><span class="s2">and</span>
                <span class="s1">a</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">data </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_is_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Hash</span>


<span class="s3">@</span><span class="s1">overload_attribute</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;__hash__&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_array_hash</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">return lambda </span><span class="s1">arr</span><span class="s3">: </span><span class="s2">None</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># builtin `np.flat` implementation</span>

<span class="s2">def </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the Structure representation of the given *flatiterty* (an 
    instance of types.NumpyFlatType). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_make_flattening_iter_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">, </span><span class="s4">'flat'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_array_ndenumerate_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the Structure representation of the given *nditerty* (an 
    instance of types.NumpyNdEnumerateType). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_make_flattening_iter_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">, </span><span class="s4">'ndenumerate'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_increment_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">end_flag</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">loop_continue</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loop_break</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'end_increment'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">end_flag </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_byte</span><span class="s3">, </span><span class="s1">end_flag</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)):</span>
        <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">idxptr</span><span class="s3">))</span>

        <span class="s1">count </span><span class="s3">= </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
        <span class="s1">in_bounds </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_likely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">in_bounds</span><span class="s3">):</span>
            <span class="s6"># New index is still in bounds</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">loop_continue </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">loop_continue</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>
        <span class="s6"># Index out of bounds =&gt; reset it and proceed it to outer index</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">loop_break </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">loop_break</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">end_flag </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_byte</span><span class="s3">, </span><span class="s1">end_flag</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_increment_indices_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">,</span>
                             <span class="s1">end_flag</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">_increment_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">end_flag</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_nditer_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the Structure representation of the given *nditerty* (an 
    instance of types.NumpyNdIterType). 
    &quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">layout</span>
    <span class="s1">narrays </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">)</span>
    <span class="s1">nshapes </span><span class="s3">= </span><span class="s1">ndim </span><span class="s2">if </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">need_shaped_indexing </span><span class="s2">else </span><span class="s5">1</span>

    <span class="s2">class </span><span class="s1">BaseSubIter</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Base class for sub-iterators of a nditer() instance. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nditer</span><span class="s3">, </span><span class="s1">member_name</span><span class="s3">, </span><span class="s1">start_dim</span><span class="s3">, </span><span class="s1">end_dim</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditer</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">member_name </span><span class="s3">= </span><span class="s1">member_name</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">start_dim </span><span class="s3">= </span><span class="s1">start_dim</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">end_dim </span><span class="s3">= </span><span class="s1">end_dim</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">= </span><span class="s1">end_dim </span><span class="s3">- </span><span class="s1">start_dim</span>

        <span class="s2">def </span><span class="s1">set_member_ptr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">):</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_name</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

        <span class="s3">@</span><span class="s1">functools</span><span class="s3">.</span><span class="s1">cached_property</span>
        <span class="s2">def </span><span class="s1">member_ptr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_name</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">loop_continue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">logical_dim</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">loop_break</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">logical_dim</span><span class="s3">):</span>
            <span class="s2">pass</span>

    <span class="s2">class </span><span class="s1">FlatSubIter</span><span class="s3">(</span><span class="s1">BaseSubIter</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-iterator walking a contiguous array in physical order, with 
        support for broadcasting (the index is reset on the outer dimension). 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
            <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_member_ptr</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">index</span><span class="s3">])</span>

        <span class="s2">def </span><span class="s1">loop_continue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">logical_dim</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">logical_dim </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s6"># Only increment index inside innermost logical dimension</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">loop_break</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">logical_dim</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">logical_dim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s6"># At the exit of outermost logical dimension, reset index</span>
                <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">logical_dim </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s6"># Inside innermost logical dimension, increment index</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">member_ptr</span><span class="s3">)</span>

    <span class="s2">class </span><span class="s1">TrivialFlatSubIter</span><span class="s3">(</span><span class="s1">BaseSubIter</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-iterator walking a contiguous array in physical order, 
        *without* support for broadcasting. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
            <span class="s2">assert not </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">need_shaped_indexing</span>

        <span class="s2">def </span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) &lt;= </span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s2">class </span><span class="s1">IndexedSubIter</span><span class="s3">(</span><span class="s1">BaseSubIter</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-iterator walking an array in logical order. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) == </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">,</span>
                                            <span class="s1">indices</span><span class="s3">, </span><span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">class </span><span class="s1">ZeroDimSubIter</span><span class="s3">(</span><span class="s1">BaseSubIter</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-iterator &quot;walking&quot; a 0-d array. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s2">class </span><span class="s1">ScalarSubIter</span><span class="s3">(</span><span class="s1">BaseSubIter</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-iterator &quot;walking&quot; a scalar value. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">class </span><span class="s1">NdIter</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        .nditer() implementation. 
 
        Note: 'F' layout means the shape is iterated in reverse logical order, 
        so indices and shapes arrays have to be reversed as well. 
        &quot;&quot;&quot;</span>

        <span class="s3">@</span><span class="s1">functools</span><span class="s3">.</span><span class="s1">cached_property</span>
        <span class="s2">def </span><span class="s1">subiters</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s1">l </span><span class="s3">= []</span>
            <span class="s1">factories </span><span class="s3">= {</span><span class="s4">'flat'</span><span class="s3">: </span><span class="s1">FlatSubIter </span><span class="s2">if </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">need_shaped_indexing</span>
                         <span class="s2">else </span><span class="s1">TrivialFlatSubIter</span><span class="s3">,</span>
                         <span class="s4">'indexed'</span><span class="s3">: </span><span class="s1">IndexedSubIter</span><span class="s3">,</span>
                         <span class="s4">'0d'</span><span class="s3">: </span><span class="s1">ZeroDimSubIter</span><span class="s3">,</span>
                         <span class="s4">'scalar'</span><span class="s3">: </span><span class="s1">ScalarSubIter</span><span class="s3">,</span>
                         <span class="s3">}</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">indexers</span><span class="s3">):</span>
                <span class="s1">kind</span><span class="s3">, </span><span class="s1">start_dim</span><span class="s3">, </span><span class="s1">end_dim</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">sub</span>
                <span class="s1">member_name </span><span class="s3">= </span><span class="s4">'index%d' </span><span class="s3">% </span><span class="s1">i</span>
                <span class="s1">factory </span><span class="s3">= </span><span class="s1">factories</span><span class="s3">[</span><span class="s1">kind</span><span class="s3">]</span>
                <span class="s1">l</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">factory</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">member_name</span><span class="s3">, </span><span class="s1">start_dim</span><span class="s3">, </span><span class="s1">end_dim</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">l</span>

        <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Initialize the nditer() instance for the specific array inputs. 
            &quot;&quot;&quot;</span>
            <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

            <span class="s6"># Store inputs</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">arrays </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">),</span>
                                             <span class="s1">arrays</span><span class="s3">)</span>
            <span class="s6"># Create slots for scalars</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ty </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                    <span class="s1">member_name </span><span class="s3">= </span><span class="s4">'scalar%d' </span><span class="s3">% </span><span class="s1">i</span>
                    <span class="s6"># XXX as_data()?</span>
                    <span class="s1">slot </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
                    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">member_name</span><span class="s3">, </span><span class="s1">slot</span><span class="s3">)</span>

            <span class="s1">arrays </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arrays_or_scalars</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>

            <span class="s6"># Extract iterator shape (the shape of the most-dimensional input)</span>
            <span class="s1">main_shape_ty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">main_shape </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">main_nitems </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arrty </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">ndim</span><span class="s3">:</span>
                    <span class="s1">main_shape </span><span class="s3">= </span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">shape</span>
                    <span class="s1">main_nitems </span><span class="s3">= </span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">nitems</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># Only scalar inputs =&gt; synthesize a dummy shape</span>
                <span class="s2">assert </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span>
                <span class="s1">main_shape </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">main_shape_ty</span><span class="s3">, ())</span>
                <span class="s1">main_nitems </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

            <span class="s6"># Validate shapes of array inputs</span>
            <span class="s2">def </span><span class="s1">check_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">main_shape</span><span class="s3">):</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">main_shape</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">main_shape</span><span class="s3">) - </span><span class="s1">n </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">]:</span>
                        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nditer(): operands could not be &quot;</span>
                                         <span class="s4">&quot;broadcast together&quot;</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">,</span>
                                    <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">),</span>
                                    <span class="s1">main_shape_ty</span><span class="s3">)</span>
                    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">check_shape</span><span class="s3">,</span>
                                             <span class="s1">sig</span><span class="s3">, (</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">main_shape</span><span class="s3">))</span>

            <span class="s6"># Compute shape and size</span>
            <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">main_shape</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">:</span>
                <span class="s1">shapes </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>

            <span class="s6"># If shape is empty, mark iterator exhausted</span>
            <span class="s1">shape_is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">main_nitems</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
            <span class="s1">exhausted </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">shape_is_empty</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_byte</span><span class="s3">,</span>
                                       <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_byte</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">need_shaped_indexing</span><span class="s3">:</span>
                <span class="s6"># Flatten shape to make iteration faster on small innermost</span>
                <span class="s6"># dimensions (e.g. a (100000, 3) shape)</span>
                <span class="s1">shapes </span><span class="s3">= (</span><span class="s1">main_nitems</span><span class="s3">,)</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) == </span><span class="s1">nshapes</span>

            <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">nshapes</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nshapes</span><span class="s3">):</span>
                <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">indices </span><span class="s3">= </span><span class="s1">indices</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exhausted</span><span class="s3">)</span>

            <span class="s6"># Initialize subiterators</span>
            <span class="s2">for </span><span class="s1">subiter </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subiters</span><span class="s3">:</span>
                <span class="s1">subiter</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Compute next iteration of the nditer() instance. 
            &quot;&quot;&quot;</span>
            <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'end'</span><span class="s3">)</span>

            <span class="s6"># Branch early if exhausted</span>
            <span class="s1">exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">as_bool_bit</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">))</span>
            <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exhausted</span><span class="s3">):</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

            <span class="s1">arrtys </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">arrays</span>
            <span class="s1">arrays </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">)</span>
            <span class="s1">arrays </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_arrays_or_scalars</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span>

            <span class="s6"># Compute iterated results</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s1">views </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_views</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>
            <span class="s1">views </span><span class="s3">= [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">() </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">views</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">views</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">views</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">yield_type</span><span class="s3">,</span>
                                                 <span class="s1">views</span><span class="s3">))</span>

            <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">_increment_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">,</span>
                               <span class="s1">indices</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">,</span>
                               <span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_loop_continue</span><span class="s3">,</span>
                                                 <span class="s1">context</span><span class="s3">,</span>
                                                 <span class="s1">builder</span><span class="s3">),</span>
                               <span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_loop_break</span><span class="s3">,</span>
                                                 <span class="s1">context</span><span class="s3">,</span>
                                                 <span class="s1">builder</span><span class="s3">),</span>
                               <span class="s3">)</span>

            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_loop_continue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subiters</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">start_dim </span><span class="s3">&lt;= </span><span class="s1">dim </span><span class="s3">&lt; </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">end_dim</span><span class="s3">:</span>
                    <span class="s1">sub</span><span class="s3">.</span><span class="s1">loop_continue</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim </span><span class="s3">- </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">start_dim</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_loop_break</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subiters</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">start_dim </span><span class="s3">&lt;= </span><span class="s1">dim </span><span class="s3">&lt; </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">end_dim</span><span class="s3">:</span>
                    <span class="s1">sub</span><span class="s3">.</span><span class="s1">loop_break</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim </span><span class="s3">- </span><span class="s1">sub</span><span class="s3">.</span><span class="s1">start_dim</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">_make_views</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Compute the views to be yielded. 
            &quot;&quot;&quot;</span>
            <span class="s1">views </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">narrays</span>
            <span class="s1">indexers </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">indexers</span>
            <span class="s1">subiters </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subiters</span>
            <span class="s1">rettys </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">yield_type</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rettys</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
                <span class="s1">rettys </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">rettys</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">rettys </span><span class="s3">= [</span><span class="s1">rettys</span><span class="s3">]</span>
            <span class="s1">indices </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>
                       <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nshapes</span><span class="s3">)]</span>

            <span class="s2">for </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">subiter </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indexers</span><span class="s3">, </span><span class="s1">subiters</span><span class="s3">):</span>
                <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">array_indices </span><span class="s3">= </span><span class="s1">sub</span>
                <span class="s1">sub_indices </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">[</span><span class="s1">subiter</span><span class="s3">.</span><span class="s1">start_dim</span><span class="s3">:</span><span class="s1">subiter</span><span class="s3">.</span><span class="s1">end_dim</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">:</span>
                    <span class="s1">sub_indices </span><span class="s3">= </span><span class="s1">sub_indices</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">array_indices</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">views</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">is None</span>
                    <span class="s1">views</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_view</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sub_indices</span><span class="s3">,</span>
                                               <span class="s1">rettys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">],</span>
                                               <span class="s1">arrtys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">arrays</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">subiter</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">views</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">views</span>

        <span class="s2">def </span><span class="s1">_make_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">,</span>
                       <span class="s1">subiter</span><span class="s3">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Compute a 0d view for a given input array. 
            &quot;&quot;&quot;</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span>

            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">subiter</span><span class="s3">.</span><span class="s1">compute_pointer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s1">view </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

            <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                                       <span class="s3">())</span>
            <span class="s1">strides </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                                         <span class="s3">())</span>
            <span class="s6"># HACK: meminfo=None avoids expensive refcounting operations</span>
            <span class="s6"># on ephemeral views</span>
            <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">view</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">view</span>

        <span class="s2">def </span><span class="s1">_arrays_or_scalars</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">):</span>
            <span class="s6"># Return a list of either array structures or pointers to</span>
            <span class="s6"># scalar slots</span>
            <span class="s1">l </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)):</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                    <span class="s1">l</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">,</span>
                                                       <span class="s1">builder</span><span class="s3">,</span>
                                                       <span class="s1">value</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">l</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;scalar%d&quot; </span><span class="s3">% </span><span class="s1">i</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">l</span>

    <span class="s2">return </span><span class="s1">NdIter</span>


<span class="s2">def </span><span class="s1">make_ndindex_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the Structure representation of the given *nditerty* (an 
    instance of types.NumpyNdIndexType). 
    &quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">class </span><span class="s1">NdIndexIter</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        .ndindex() implementation. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">):</span>
            <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,</span>
                                          <span class="s1">size</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                                                    <span class="s1">ndim</span><span class="s3">))</span>
            <span class="s1">exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_byte</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
                <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>
                <span class="s6"># 0-sized dimensions really indicate an empty array,</span>
                <span class="s6"># but we have to catch that condition early to avoid</span>
                <span class="s6"># a bug inside the iteration logic.</span>
                <span class="s1">dim_size </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
                <span class="s1">dim_is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">dim_size</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
                <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim_is_empty</span><span class="s3">):</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_byte</span><span class="s3">, </span><span class="s1">exhausted</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">indices </span><span class="s3">= </span><span class="s1">indices</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted </span><span class="s3">= </span><span class="s1">exhausted</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
            <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

            <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'end'</span><span class="s3">)</span>

            <span class="s1">exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">as_bool_bit</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">))</span>
            <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exhausted</span><span class="s3">):</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

            <span class="s1">indices </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                         <span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">,</span>
                                                         <span class="s1">dim</span><span class="s3">))</span>
                       <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)]</span>
            <span class="s2">for </span><span class="s1">load </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">:</span>
                <span class="s1">mark_positive</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">load</span><span class="s3">)</span>

            <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>

            <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">_increment_indices</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">,</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">)</span>

            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">NdIndexIter</span>


<span class="s2">def </span><span class="s1">_make_flattening_iter_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">kind </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'flat'</span><span class="s3">, </span><span class="s4">'ndenumerate'</span><span class="s3">)</span>

    <span class="s1">array_type </span><span class="s3">= </span><span class="s1">flatiterty</span><span class="s3">.</span><span class="s1">array_type</span>

    <span class="s2">if </span><span class="s1">array_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'C'</span><span class="s3">:</span>
        <span class="s2">class </span><span class="s1">CContiguousFlatIter</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)):</span>
            <span class="s0">&quot;&quot;&quot; 
            .flat() / .ndenumerate() implementation for C-contiguous arrays. 
            &quot;&quot;&quot;</span>

            <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
                <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
                <span class="s6"># We can't trust strides[-1] to always contain the right</span>
                <span class="s6"># step value, see</span>
                <span class="s6"># http://docs.scipy.org/doc/numpy-dev/release.html#npy-relaxed-strides-checking    # noqa: E501</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">stride </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">itemsize</span>

                <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'ndenumerate'</span><span class="s3">:</span>
                    <span class="s6"># Zero-initialize the indices array.</span>
                    <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span>
                        <span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,</span>
                        <span class="s1">size</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>

                    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
                        <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>

                    <span class="s1">self</span><span class="s3">.</span><span class="s1">indices </span><span class="s3">= </span><span class="s1">indices</span>

            <span class="s6"># NOTE: Using gep() instead of explicit pointer addition helps</span>
            <span class="s6"># LLVM vectorize the loop (since the stride is known and</span>
            <span class="s6"># constant).  This is not possible in the non-contiguous case,</span>
            <span class="s6"># where the strides are unknown at compile-time.</span>

            <span class="s2">def </span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
                <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s1">nitems </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">nitems</span>

                <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
                <span class="s1">is_valid </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">nitems</span><span class="s3">)</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s1">is_valid</span><span class="s3">)</span>

                <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_likely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">is_valid</span><span class="s3">):</span>
                    <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">index</span><span class="s3">])</span>
                    <span class="s1">value </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'flat'</span><span class="s3">:</span>
                        <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s6"># ndenumerate(): fetch and increment indices</span>
                        <span class="s1">indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span>
                        <span class="s1">idxvals </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                                     <span class="s1">indices</span><span class="s3">,</span>
                                                                     <span class="s1">dim</span><span class="s3">))</span>
                                   <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)]</span>
                        <span class="s1">idxtuple </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxvals</span><span class="s3">)</span>
                        <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span>
                            <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">make_anonymous_struct</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                          <span class="s3">[</span><span class="s1">idxtuple</span><span class="s3">, </span><span class="s1">value</span><span class="s3">]))</span>
                        <span class="s1">_increment_indices_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">,</span>
                                                 <span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>

                    <span class="s1">index </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">getitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">index</span><span class="s3">])</span>
                <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">index</span><span class="s3">])</span>
                <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">CContiguousFlatIter</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">class </span><span class="s1">FlatIter</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)):</span>
            <span class="s0">&quot;&quot;&quot; 
            Generic .flat() / .ndenumerate() implementation for 
            non-contiguous arrays. 
            It keeps track of pointers along each dimension in order to 
            minimize computations. 
            &quot;&quot;&quot;</span>

            <span class="s2">def </span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
                <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span>
                <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>

                <span class="s1">indices </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                                                  <span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
                <span class="s1">pointers </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,</span>
                                                                  <span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
                <span class="s1">exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                      <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">false_byte</span><span class="s3">)</span>

                <span class="s6"># Initialize indices and pointers with their start values.</span>
                <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
                    <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                    <span class="s1">ptrptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pointers</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptrptr</span><span class="s3">)</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>
                    <span class="s6"># 0-sized dimensions really indicate an empty array,</span>
                    <span class="s6"># but we have to catch that condition early to avoid</span>
                    <span class="s6"># a bug inside the iteration logic (see issue #846).</span>
                    <span class="s1">dim_size </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
                    <span class="s1">dim_is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">dim_size</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
                    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dim_is_empty</span><span class="s3">):</span>
                        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_byte</span><span class="s3">, </span><span class="s1">exhausted</span><span class="s3">)</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">indices </span><span class="s3">= </span><span class="s1">indices</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">pointers </span><span class="s3">= </span><span class="s1">pointers</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted </span><span class="s3">= </span><span class="s1">exhausted</span>

            <span class="s2">def </span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
                <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
                <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
                <span class="s1">indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span>
                <span class="s1">pointers </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pointers</span>

                <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

                <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'end'</span><span class="s3">)</span>

                <span class="s6"># Catch already computed iterator exhaustion</span>
                <span class="s1">is_exhausted </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">as_bool_bit</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">))</span>
                <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">is_exhausted</span><span class="s3">):</span>
                    <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>
                <span class="s1">result</span><span class="s3">.</span><span class="s1">set_valid</span><span class="s3">(</span><span class="s2">True</span><span class="s3">)</span>

                <span class="s6"># Current pointer inside last dimension</span>
                <span class="s1">last_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pointers</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">last_ptr</span><span class="s3">)</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'flat'</span><span class="s3">:</span>
                    <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s6"># ndenumerate() =&gt; yield (indices, value)</span>
                    <span class="s1">idxvals </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                                 <span class="s1">indices</span><span class="s3">,</span>
                                                                 <span class="s1">dim</span><span class="s3">))</span>
                               <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)]</span>
                    <span class="s1">idxtuple </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idxvals</span><span class="s3">)</span>
                    <span class="s1">result</span><span class="s3">.</span><span class="s1">yield_</span><span class="s3">(</span>
                        <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">make_anonymous_struct</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                      <span class="s3">[</span><span class="s1">idxtuple</span><span class="s3">, </span><span class="s1">value</span><span class="s3">]))</span>

                <span class="s6"># Update indices and pointers by walking from inner</span>
                <span class="s6"># dimension to outer.</span>
                <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)):</span>
                    <span class="s1">idxptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                    <span class="s1">idx </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                  <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">idxptr</span><span class="s3">))</span>

                    <span class="s1">count </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
                    <span class="s1">stride </span><span class="s3">= </span><span class="s1">strides</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
                    <span class="s1">in_bounds </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>
                    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_likely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">in_bounds</span><span class="s3">):</span>
                        <span class="s6"># Index is valid =&gt; pointer can simply be incremented.</span>
                        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>
                        <span class="s1">ptrptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pointers</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
                        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ptrptr</span><span class="s3">)</span>
                        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pointer_add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">)</span>
                        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">ptrptr</span><span class="s3">)</span>
                        <span class="s6"># Reset pointers in inner dimensions</span>
                        <span class="s2">for </span><span class="s1">inner_dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">dim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">):</span>
                            <span class="s1">ptrptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                          <span class="s1">pointers</span><span class="s3">,</span>
                                                          <span class="s1">inner_dim</span><span class="s3">)</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">ptrptr</span><span class="s3">)</span>
                        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>
                    <span class="s6"># Reset index and continue with next dimension</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">idxptr</span><span class="s3">)</span>

                <span class="s6"># End of array</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_byte</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exhausted</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

                <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">_ptr_for_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
                <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">ndim</span><span class="s3">)</span>
                <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">ndim</span><span class="s3">)</span>

                <span class="s6"># First convert the flattened index into a regular n-dim index</span>
                <span class="s1">indices </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)):</span>
                    <span class="s1">indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">urem</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]))</span>
                    <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">udiv</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">])</span>
                <span class="s1">indices</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>

                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                                                <span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">,</span>
                                                <span class="s1">indices</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">ptr</span>

            <span class="s2">def </span><span class="s1">getitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ptr_for_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ptr_for_index</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">FlatIter</span>


<span class="s3">@</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;flat&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">make_array_flatiter</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s1">flatitercls </span><span class="s3">= </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">))</span>
    <span class="s1">flatiter </span><span class="s3">= </span><span class="s1">flatitercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">flatiter</span><span class="s3">.</span><span class="s1">array </span><span class="s3">= </span><span class="s1">arr</span>

    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'array'</span><span class="s3">))</span>

    <span class="s1">flatiter</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">), </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_flatiter</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">flatiterty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">flatiter</span><span class="s3">] = </span><span class="s1">args</span>

    <span class="s1">flatitercls </span><span class="s3">= </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)</span>
    <span class="s1">flatiter </span><span class="s3">= </span><span class="s1">flatitercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">)</span>

    <span class="s1">arrty </span><span class="s3">= </span><span class="s1">flatiterty</span><span class="s3">.</span><span class="s1">array_type</span>
    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">flatiter</span><span class="s3">.</span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">flatiterty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">flatiter</span><span class="s3">, </span><span class="s1">index </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s1">flatitercls </span><span class="s3">= </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)</span>
    <span class="s1">flatiter </span><span class="s3">= </span><span class="s1">flatitercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">)</span>

    <span class="s1">arrty </span><span class="s3">= </span><span class="s1">flatiterty</span><span class="s3">.</span><span class="s1">array_type</span>
    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">setitem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">,</span>
               <span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_getitem_any</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">flatiterty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">flatiter</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s1">flatitercls </span><span class="s3">= </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)</span>
    <span class="s1">flatiter </span><span class="s3">= </span><span class="s1">flatitercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">)</span>

    <span class="s1">arrty </span><span class="s3">= </span><span class="s1">flatiterty</span><span class="s3">.</span><span class="s1">array_type</span>
    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">flatiter</span><span class="s3">.</span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">len</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyFlatType</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_getitem_flat</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">flatiterty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">flatitercls </span><span class="s3">= </span><span class="s1">make_array_flat_cls</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">)</span>
    <span class="s1">flatiter </span><span class="s3">= </span><span class="s1">flatitercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">flatiterty</span><span class="s3">.</span><span class="s1">array_type</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">flatiter</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">nitems</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndenumerate</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">make_array_ndenumerate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">arrty</span><span class="s3">, = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">arr</span><span class="s3">, = </span><span class="s1">args</span>
    <span class="s1">nditercls </span><span class="s3">= </span><span class="s1">make_array_ndenumerate_cls</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdEnumerateType</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">))</span>
    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">array </span><span class="s3">= </span><span class="s1">arr</span>

    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s4">'array'</span><span class="s3">))</span>

    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdEnumerateType</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_nditer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">nditerty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">nditer</span><span class="s3">] = </span><span class="s1">args</span>

    <span class="s1">nditercls </span><span class="s3">= </span><span class="s1">make_array_ndenumerate_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)</span>
    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">nditer</span><span class="s3">)</span>

    <span class="s1">arrty </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">array_type</span>
    <span class="s1">arrcls </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">arrcls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">pndindex</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">VarArg</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">))</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">VarArg</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">make_array_ndindex</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;ndindex(*shape)&quot;&quot;&quot;</span>
    <span class="s1">shape </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">argty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
             <span class="s2">for </span><span class="s1">argty</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)]</span>

    <span class="s1">nditercls </span><span class="s3">= </span><span class="s1">make_ndindex_cls</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdIndexType</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)))</span>
    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">pndindex</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">make_array_ndindex_tuple</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;ndindex(shape)&quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">idxty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">dtype</span>
        <span class="s1">tup </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">shape </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">idxty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
                 <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">shape </span><span class="s3">= []</span>

    <span class="s1">nditercls </span><span class="s3">= </span><span class="s1">make_ndindex_cls</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdIndexType</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)))</span>
    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdIndexType</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_ndindex</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">nditerty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">nditer</span><span class="s3">] = </span><span class="s1">args</span>

    <span class="s1">nditercls </span><span class="s3">= </span><span class="s1">make_ndindex_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)</span>
    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">nditercls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">nditer</span><span class="s3">)</span>

    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">make_array_nditer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    nditer(...) 
    &quot;&quot;&quot;</span>
    <span class="s1">nditerty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">arrtys </span><span class="s3">= </span><span class="s1">nditerty</span><span class="s3">.</span><span class="s1">arrays</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s1">arrays </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">arrays </span><span class="s3">= [</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>

    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">make_nditer_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">init_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">nditer</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">nditerty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NumpyNdIterType</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">iternext_numpy_nditer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
    <span class="s3">[</span><span class="s1">nditerty</span><span class="s3">] = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s3">[</span><span class="s1">nditer</span><span class="s3">] = </span><span class="s1">args</span>

    <span class="s1">nditer </span><span class="s3">= </span><span class="s1">make_nditer_cls</span><span class="s3">(</span><span class="s1">nditerty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">nditer</span><span class="s3">)</span>
    <span class="s1">nditer</span><span class="s3">.</span><span class="s1">iternext_specific</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">dtype_eq_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">arg1</span><span class="s3">, </span><span class="s1">arg2 </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s5">1</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">arg1 </span><span class="s3">== </span><span class="s1">arg2</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Numpy array constructors</span>

<span class="s2">def </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Utility function used for allocating a new array during LLVM code 
    generation (lowering).  Given a target context, builder, array 
    type, and a tuple or list of lowered dimension sizes, returns a 
    LLVM value pointing at a Numba runtime allocated array. 
    &quot;&quot;&quot;</span>
    <span class="s1">arycls </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrtype</span><span class="s3">)</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">arycls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">datatype </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">))</span>

    <span class="s6"># compute array length</span>
    <span class="s1">arrlen </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">overflow </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s5">1</span><span class="s3">), </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">shapes</span><span class="s3">:</span>
        <span class="s1">arrlen_mult </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">smul_with_overflow</span><span class="s3">(</span><span class="s1">arrlen</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
        <span class="s1">arrlen </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">arrlen_mult</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">overflow </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span>
            <span class="s1">overflow</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">arrlen_mult</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">strides </span><span class="s3">= ()</span>
    <span class="s2">elif </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'C'</span><span class="s3">:</span>
        <span class="s1">strides </span><span class="s3">= [</span><span class="s1">itemsize</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">dimension_size </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]):</span>
            <span class="s1">strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dimension_size</span><span class="s3">))</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">))</span>
    <span class="s2">elif </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">:</span>
        <span class="s1">strides </span><span class="s3">= [</span><span class="s1">itemsize</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">dimension_size </span><span class="s2">in </span><span class="s1">shapes</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]:</span>
            <span class="s1">strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dimension_size</span><span class="s3">))</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
            <span class="s4">&quot;Don't know how to allocate array with layout '{0}'.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">arrtype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">))</span>

    <span class="s6"># Check overflow, numpy also does this after checking order</span>
    <span class="s1">allocsize_mult </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">smul_with_overflow</span><span class="s3">(</span><span class="s1">arrlen</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)</span>
    <span class="s1">allocsize </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">allocsize_mult</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">overflow </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">overflow</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">allocsize_mult</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">overflow</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6"># Raise same error as numpy, see:</span>
        <span class="s6"># https://github.com/numpy/numpy/blob/2a488fe76a0f732dc418d03b452caace161673da/numpy/core/src/multiarray/ctors.c#L1095-L1101    # noqa: E501</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">,</span>
            <span class="s3">(</span><span class="s4">&quot;array is too big; `arr.size * arr.dtype.itemsize` is larger than&quot;</span>
             <span class="s4">&quot; the maximum possible size.&quot;</span><span class="s3">,)</span>
        <span class="s3">)</span>

    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">align_val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_preferred_array_alignment</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">align </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">uint32</span><span class="s3">, </span><span class="s1">align_val</span><span class="s3">)</span>
    <span class="s1">args </span><span class="s3">= (</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_dummy_value</span><span class="s3">(), </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>

    <span class="s1">mip </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemInfoPointer</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">voidptr</span><span class="s3">)</span>
    <span class="s1">arytypeclass </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">TypeRef</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">arrtype</span><span class="s3">))</span>
    <span class="s1">argtypes </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">mip</span><span class="s3">, </span><span class="s1">arytypeclass</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">uint32</span><span class="s3">)</span>

    <span class="s1">meminfo </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">_call_allocator</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">meminfo_data</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">meminfo</span><span class="s3">)</span>

    <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">shape_array </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">=</span><span class="s1">intp_t</span><span class="s3">)</span>
    <span class="s1">strides_array </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">=</span><span class="s1">intp_t</span><span class="s3">)</span>

    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()),</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape_array</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides_array</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">meminfo</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ary</span>


<span class="s3">@</span><span class="s1">overload_classmethod</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">&quot;_allocate&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_ol_array_allocate</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Implements a Numba-only default target (cpu) classmethod on the array 
    type. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">intrin_alloc</span><span class="s3">(</span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_call_allocator</span><span class="s3">(</span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">align</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Trampoline to call the intrinsic used for allocation 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">arrtype</span><span class="s3">.</span><span class="s1">_allocate</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">intrin_alloc</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Intrinsic to call into the allocator for Array 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s3">[</span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">] = </span><span class="s1">args</span>
        <span class="s1">meminfo </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">meminfo_alloc_aligned</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">meminfo</span>

    <span class="s1">mip </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MemInfoPointer</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">voidptr</span><span class="s3">)    </span><span class="s6"># return untyped pointer</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">mip</span><span class="s3">, </span><span class="s1">allocsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s2">def </span><span class="s1">_parse_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse the shape argument to an array constructor. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">safecast_intp</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_t</span><span class="s3">, </span><span class="s1">src</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Cast src to intp only if value can be maintained&quot;&quot;&quot;</span>
        <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">intp_width </span><span class="s3">= </span><span class="s1">intp_t</span><span class="s3">.</span><span class="s1">width</span>
        <span class="s1">intp_ir </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">intp_width</span><span class="s3">)</span>
        <span class="s1">maxval </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intp_ir</span><span class="s3">, ((</span><span class="s5">1 </span><span class="s3">&lt;&lt; </span><span class="s1">intp_width </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">src_t</span><span class="s3">.</span><span class="s1">width </span><span class="s3">&lt; </span><span class="s1">intp_width</span><span class="s3">:</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sext</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">intp_ir</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">src_t</span><span class="s3">.</span><span class="s1">width </span><span class="s3">&gt;= </span><span class="s1">intp_width</span><span class="s3">:</span>
            <span class="s1">is_larger </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">&quot;&gt;&quot;</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">maxval</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_larger</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
                <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">,</span>
                    <span class="s3">(</span><span class="s4">&quot;Cannot safely convert value to intp&quot;</span><span class="s3">,)</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">src_t</span><span class="s3">.</span><span class="s1">width </span><span class="s3">&gt; </span><span class="s1">intp_width</span><span class="s3">:</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">trunc</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">intp_ir</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">src</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s1">passed_shapes </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">count</span>
        <span class="s1">passed_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s1">shapes </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">passed_shapes</span><span class="s3">:</span>
        <span class="s1">shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">safecast_intp</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">s</span><span class="s3">))</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant_generic</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s1">is_neg </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">], </span><span class="s1">zero</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">is_neg</span><span class="s3">):</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span>
                <span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s4">&quot;negative dimensions not allowed&quot;</span><span class="s3">,)</span>
            <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">shapes</span>


<span class="s2">def </span><span class="s1">_parse_empty_args</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse the arguments of a np.empty(), np.zeros() or np.ones() call. 
    &quot;&quot;&quot;</span>
    <span class="s1">arrshapetype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">arrshape </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">arrtype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s2">return </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">_parse_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrshapetype</span><span class="s3">, </span><span class="s1">arrshape</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_parse_empty_like_args</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse the arguments of a np.empty_like(), np.zeros_like() or 
    np.ones_like() call. 
    &quot;&quot;&quot;</span>
    <span class="s1">arytype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">arytype</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">shapes</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, ()</span>


<span class="s2">def </span><span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UnicodeType</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;If np.</span><span class="s2">{</span><span class="s1">fname</span><span class="s2">} </span><span class="s4">dtype is a string it must be a string constant.&quot;</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">numpy_empty_nd</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">ty_shape</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">, </span><span class="s1">ty_retty_ref</span><span class="s3">):</span>
    <span class="s1">ty_retty </span><span class="s3">= </span><span class="s1">ty_retty_ref</span><span class="s3">.</span><span class="s1">instance_type</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ty_retty</span><span class="s3">(</span><span class="s1">ty_shape</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">, </span><span class="s1">ty_retty_ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">):</span>
        <span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes </span><span class="s3">= </span><span class="s1">_parse_empty_args</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">)</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;empty&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">float </span><span class="s2">or</span>
        <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">typing_key </span><span class="s2">is </span><span class="s1">float</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)): </span><span class="s6">#default</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">double</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">ty_parse_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">nb_dtype </span><span class="s2">is not None and </span><span class="s1">ndim </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">nb_dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">numpy_empty_nd</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;Cannot parse input types to function np.empty(</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">, </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">)&quot;</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">numpy_empty_like_nd</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">ty_prototype</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">, </span><span class="s1">ty_retty_ref</span><span class="s3">):</span>
    <span class="s1">ty_retty </span><span class="s3">= </span><span class="s1">ty_retty_ref</span><span class="s3">.</span><span class="s1">instance_type</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ty_retty</span><span class="s3">(</span><span class="s1">ty_prototype</span><span class="s3">, </span><span class="s1">ty_dtype</span><span class="s3">, </span><span class="s1">ty_retty_ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">):</span>
        <span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes </span><span class="s3">= </span><span class="s1">_parse_empty_like_args</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">)</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_empty_like</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;empty_like&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">arr</span>
    <span class="s2">if </span><span class="s1">nb_dtype </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
            <span class="s1">layout </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s4">'A' </span><span class="s2">else </span><span class="s4">'C'</span>
            <span class="s1">retty </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">nb_dtype</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">nb_dtype</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Cannot parse input types to function &quot;</span>
               <span class="s4">f&quot;np.empty_like(</span><span class="s2">{</span><span class="s1">arr</span><span class="s2">}</span><span class="s4">, </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy_empty_like_nd</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_zero_fill_array_method</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">):</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">):</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])(</span><span class="s1">cgctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">llargs</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">),</span>
                       <span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'_zero_fill'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_array_zero_fill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Adds a `._zero_fill` method to zero fill an array using memset.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">_zero_fill_array_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;zeros&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">arr</span><span class="s3">.</span><span class="s1">_zero_fill</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_zeros_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;zeros_like&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s6"># NumPy uses 'a' as the arg name for the array-like</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">arr</span><span class="s3">.</span><span class="s1">_zero_fill</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_ones_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;ones_like&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s6"># NumPy uses 'a' as the arg name for the array-like</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">arr_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_flat</span><span class="s3">)):</span>
            <span class="s1">arr_flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_full</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;full&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">fill_value</span>

    <span class="s2">def </span><span class="s1">full</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">nb_dtype</span><span class="s3">)</span>
        <span class="s1">arr_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_flat</span><span class="s3">)):</span>
            <span class="s1">arr_flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">fill_value</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">full</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_full_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;full_like&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">arr_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_flat</span><span class="s3">)):</span>
            <span class="s1">arr_flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">fill_value</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">return </span><span class="s1">full_like</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_np_ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6"># for some reason the NumPy default for dtype is None in the source but</span>
    <span class="s6"># ends up as np.float64 by definition.</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;ones&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">arr_flat </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flat</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_flat</span><span class="s3">)):</span>
            <span class="s1">arr_flat</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">identity</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_identity</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;identity&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">double</span>

    <span class="s2">def </span><span class="s1">identity</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">nb_dtype</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">identity</span>


<span class="s2">def </span><span class="s1">_eye_none_handler</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_eye_none_handler</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_eye_none_handler_impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">N</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">M</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_eye</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)):</span>
        <span class="s6"># dtype or instance of dtype</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">_M </span><span class="s3">= </span><span class="s1">_eye_none_handler</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">N</span><span class="s3">, </span><span class="s1">_M</span><span class="s3">), </span><span class="s1">dt</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">d </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">_M </span><span class="s3">- </span><span class="s1">k</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
                <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">d </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">N </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">, </span><span class="s1">_M</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
                <span class="s1">arr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_diag</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;v&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">ndim </span><span class="s2">not in </span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s4">&quot;Input must be 1- or 2-d.&quot;</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">diag_impl</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k</span><span class="s3">):</span>
                        <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">):</span>
                        <span class="s1">ret</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">return </span><span class="s1">ret</span>
            <span class="s2">else</span><span class="s3">:  </span><span class="s6"># 2-d</span>
                <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">rows </span><span class="s3">= </span><span class="s1">rows </span><span class="s3">+ </span><span class="s1">k</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">cols </span><span class="s3">= </span><span class="s1">cols </span><span class="s3">- </span><span class="s1">k</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">rows</span><span class="s3">, </span><span class="s1">cols</span><span class="s3">), </span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">return </span><span class="s1">diag_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_indices</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;dimensions&quot; must be a tuple of integers'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;dimensions&quot; must be a tuple of integers'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">,) * </span><span class="s1">N</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">dimensions</span><span class="s3">):</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">N</span><span class="s3">,) + </span><span class="s1">dimensions</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">dimensions</span><span class="s3">:</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span>
                <span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">res</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">idx</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diagflat</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_diagflat</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;v&quot; must be array-like'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;k&quot; must be an integer'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
        <span class="s1">abs_k </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">s </span><span class="s3">+ </span><span class="s1">abs_k</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">v</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
            <span class="s1">res</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s1">t</span><span class="s3">, </span><span class="s1">j </span><span class="s3">+ </span><span class="s1">t</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">t</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'take'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_take</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">take_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">indices </span><span class="s3">&gt; (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">indices </span><span class="s3">&lt; -</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">IndexError</span><span class="s3">(</span><span class="s4">&quot;Index out of bounds&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()[</span><span class="s1">indices</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">take_impl</span>

    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">]):</span>
        <span class="s1">F_order </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F'</span>

        <span class="s2">def </span><span class="s1">take_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">F_order</span><span class="s3">:</span>
                <span class="s1">walker </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s6"># get C order</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">walker </span><span class="s3">= </span><span class="s1">indices</span>
            <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">walker</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">flat </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt; (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">x </span><span class="s3">&lt; -</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">IndexError</span><span class="s3">(</span><span class="s4">&quot;Index out of bounds&quot;</span><span class="s3">)</span>
                <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">flat</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">take_impl</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">\</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)):</span>
        <span class="s2">def </span><span class="s1">take_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
            <span class="s1">convert </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">convert</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">convert</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">flat </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt; (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">x </span><span class="s3">&lt; -</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">IndexError</span><span class="s3">(</span><span class="s4">&quot;Index out of bounds&quot;</span><span class="s3">)</span>
                <span class="s1">ret</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">flat</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">convert</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">take_impl</span>


<span class="s2">def </span><span class="s1">_arange_dtype</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">bounds </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args </span><span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">)]</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">bounds</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex128</span>
    <span class="s2">elif </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">bounds</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># `np.arange(10).dtype` is always `np.dtype(int)`, aka `np.int_`, which</span>
        <span class="s6"># in all released versions of numpy corresponds to the C `long` type.</span>
        <span class="s6"># Windows 64 is broken by default here because Numba (as of 0.47) does</span>
        <span class="s6"># not differentiate between Python and NumPy integers, so a `typeof(1)`</span>
        <span class="s6"># on w64 is `int64`, i.e. `intp`. This means an arange(&lt;some int&gt;) will</span>
        <span class="s6"># be typed as arange(int64) and the following will yield int64 opposed</span>
        <span class="s6"># to int32. Example: without a load of analysis to work out of the args</span>
        <span class="s6"># were wrapped in NumPy int*() calls it's not possible to detect the</span>
        <span class="s6"># difference between `np.arange(10)` and `np.arange(np.int64(10)`.</span>
        <span class="s1">NPY_TY </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">types</span><span class="s3">, </span><span class="s4">&quot;int%s&quot; </span><span class="s3">% (</span><span class="s5">8 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">).</span><span class="s1">itemsize</span><span class="s3">))</span>

        <span class="s6"># unliteral these types such that `max` works.</span>
        <span class="s1">unliteral_bounds </span><span class="s3">= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">unliteral</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">bounds</span><span class="s3">]</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">unliteral_bounds </span><span class="s3">+ [</span><span class="s1">NPY_TY</span><span class="s3">,])</span>

    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_arange</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, / ,</span><span class="s1">stop</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">step</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">stop</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">step </span><span class="s3">= </span><span class="s1">step</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s2">if </span><span class="s1">stop </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span>
    <span class="s2">if </span><span class="s1">step </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">step </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">) </span><span class="s2">or</span>
        <span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)) </span><span class="s2">or</span>
        <span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">)) </span><span class="s2">or</span>
            <span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">))):</span>

        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">):</span>
        <span class="s1">true_dtype </span><span class="s3">= </span><span class="s1">_arange_dtype</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">true_dtype </span><span class="s3">= </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">use_complex </span><span class="s3">= </span><span class="s1">any</span><span class="s3">([</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)</span>
                       <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">)])</span>

    <span class="s1">start_value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s4">&quot;literal_value&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">stop_value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s4">&quot;literal_value&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">step_value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">step</span><span class="s3">, </span><span class="s4">&quot;literal_value&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, /, </span><span class="s1">stop</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">step</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6"># Allow for improved performance if given literal arguments.</span>
        <span class="s1">lit_start </span><span class="s3">= </span><span class="s1">start_value </span><span class="s2">if </span><span class="s1">start_value </span><span class="s2">is not None else </span><span class="s1">start</span>
        <span class="s1">lit_stop </span><span class="s3">= </span><span class="s1">stop_value </span><span class="s2">if </span><span class="s1">stop_value </span><span class="s2">is not None else </span><span class="s1">stop</span>
        <span class="s1">lit_step </span><span class="s3">= </span><span class="s1">step_value </span><span class="s2">if </span><span class="s1">step_value </span><span class="s2">is not None else </span><span class="s1">step</span>

        <span class="s1">_step </span><span class="s3">= </span><span class="s1">lit_step </span><span class="s2">if </span><span class="s1">lit_step </span><span class="s2">is not None else </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">lit_stop </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">_start</span><span class="s3">, </span><span class="s1">_stop </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lit_start</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">_start</span><span class="s3">, </span><span class="s1">_stop </span><span class="s3">= </span><span class="s1">lit_start</span><span class="s3">, </span><span class="s1">lit_stop</span>

        <span class="s2">if </span><span class="s1">_step </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Maximum allowed size exceeded&quot;</span><span class="s3">)</span>

        <span class="s1">nitems_c </span><span class="s3">= (</span><span class="s1">_stop </span><span class="s3">- </span><span class="s1">_start</span><span class="s3">) / </span><span class="s1">_step</span>
        <span class="s1">nitems_r </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">nitems_c</span><span class="s3">.</span><span class="s1">real</span><span class="s3">))</span>

        <span class="s6"># Binary operator needed for compiler branch pruning.</span>
        <span class="s2">if </span><span class="s1">use_complex </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">nitems_i </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">nitems_c</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">))</span>
            <span class="s1">nitems </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">nitems_i</span><span class="s3">, </span><span class="s1">nitems_r</span><span class="s3">), </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">nitems </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">nitems_r</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">true_dtype</span><span class="s3">)</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">_start</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nitems</span><span class="s3">):</span>
            <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">val </span><span class="s3">+ (</span><span class="s1">i </span><span class="s3">* </span><span class="s1">_step</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">]):</span>
        <span class="s2">return</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;num&quot; must be an integer'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">]):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">complex128</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span>

    <span class="s6"># Implementation based on https://github.com/numpy/numpy/blob/v1.20.0/numpy/core/function_base.py#L24 # noqa: E501</span>
    <span class="s2">def </span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s6"># The multiply by 1.0 mirrors</span>
        <span class="s6"># https://github.com/numpy/numpy/blob/v1.20.0/numpy/core/function_base.py#L125-L128  # noqa: E501</span>
        <span class="s6"># the side effect of this is important... start and stop become the same</span>
        <span class="s6"># type as `dtype` i.e. 64/128 bits wide (float/complex). This is</span>
        <span class="s6"># important later when used in the `np.divide`.</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">start </span><span class="s3">* </span><span class="s5">1.0</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">stop </span><span class="s3">* </span><span class="s5">1.0</span>
        <span class="s2">if </span><span class="s1">num </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">arr</span>
        <span class="s1">div </span><span class="s3">= </span><span class="s1">num </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">div </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">delta </span><span class="s3">= </span><span class="s1">stop </span><span class="s3">- </span><span class="s1">start</span>
            <span class="s1">step </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">delta</span><span class="s3">, </span><span class="s1">div</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">num</span><span class="s3">):</span>
                <span class="s1">arr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">start </span><span class="s3">+ (</span><span class="s1">i </span><span class="s3">* </span><span class="s1">step</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">arr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">start</span>
        <span class="s2">if </span><span class="s1">num </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">arr</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">stop</span>
        <span class="s2">return </span><span class="s1">arr</span>
    <span class="s2">return </span><span class="s1">linspace</span>


<span class="s2">def </span><span class="s1">_array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Array copy. 
    &quot;&quot;&quot;</span>
    <span class="s1">arytype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s1">rettype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">rettype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>

    <span class="s1">src_data </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">dest_data </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s2">assert </span><span class="s1">rettype</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">in </span><span class="s4">&quot;CF&quot;</span>
    <span class="s2">if </span><span class="s1">arytype</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">rettype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">:</span>
        <span class="s6"># Fast path: memcpy</span>
        <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">raw_memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest_data</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">,</span>
                           <span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">src_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
        <span class="s1">dest_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
        <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s1">src_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">,</span>
                                                <span class="s1">shapes</span><span class="s3">, </span><span class="s1">src_strides</span><span class="s3">,</span>
                                                <span class="s1">arytype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">dest_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest_data</span><span class="s3">,</span>
                                                 <span class="s1">shapes</span><span class="s3">, </span><span class="s1">dest_strides</span><span class="s3">,</span>
                                                 <span class="s1">rettype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">src_ptr</span><span class="s3">), </span><span class="s1">dest_ptr</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_array_copy_intrinsic</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s4">'F' </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F' </span><span class="s2">else </span><span class="s4">'C'</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">readonly</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">_array_copy</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.copy&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">_array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_numpy_copy</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">numpy_copy</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_array_copy_intrinsic</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">numpy_copy</span>


<span class="s2">def </span><span class="s1">_as_layout_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">output_layout</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Common logic for layout conversion function; 
    e.g. ascontiguousarray and asfortranarray 
    &quot;&quot;&quot;</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">assert </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">output_layout</span><span class="s3">, </span><span class="s4">'return-type has incorrect layout'</span>

    <span class="s2">if </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># 0-dim input =&gt; asfortranarray() returns a 1-dim array</span>
        <span class="s2">assert </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

        <span class="s1">shape </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant_generic</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (</span><span class="s5">1</span><span class="s3">,),</span>
        <span class="s3">)</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                     <span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">),</span>
                                     <span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,))</span>
        <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                       <span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>

    <span class="s2">elif </span><span class="s3">(</span><span class="s1">retty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout</span>
            <span class="s2">or </span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">in </span><span class="s4">'CF'</span><span class="s3">)):</span>
        <span class="s6"># 1-dim contiguous input =&gt; return the same array</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'A'</span><span class="s3">:</span>
            <span class="s6"># There's still chance the array is in contiguous layout,</span>
            <span class="s6"># just that we don't know at compile time.</span>
            <span class="s6"># We can do a runtime check.</span>

            <span class="s6"># Prepare and call is_contiguous or is_fortran</span>
            <span class="s2">assert </span><span class="s1">output_layout </span><span class="s2">in </span><span class="s4">'CF'</span>
            <span class="s1">check_func </span><span class="s3">= </span><span class="s1">is_contiguous </span><span class="s2">if </span><span class="s1">output_layout </span><span class="s3">== </span><span class="s4">'C' </span><span class="s2">else </span><span class="s1">is_fortran</span>
            <span class="s1">is_contig </span><span class="s3">= </span><span class="s1">_call_contiguous_check</span><span class="s3">(</span><span class="s1">check_func</span><span class="s3">,</span>
                                               <span class="s1">context</span><span class="s3">,</span>
                                               <span class="s1">builder</span><span class="s3">,</span>
                                               <span class="s1">aryty</span><span class="s3">,</span>
                                               <span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_contig</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">then</span><span class="s3">, </span><span class="s1">orelse</span><span class="s3">):</span>
                <span class="s6"># If the array is already contiguous, just return it</span>
                <span class="s2">with </span><span class="s1">then</span><span class="s3">:</span>
                    <span class="s1">out_then </span><span class="s3">= </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">,</span>
                                                 <span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                    <span class="s1">then_blk </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">block</span>
                <span class="s6"># Otherwise, copy to a new contiguous region</span>
                <span class="s2">with </span><span class="s1">orelse</span><span class="s3">:</span>
                    <span class="s1">out_orelse </span><span class="s3">= </span><span class="s1">_array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s1">orelse_blk </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">block</span>
            <span class="s6"># Phi node for the return value</span>
            <span class="s1">ret_phi </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">phi</span><span class="s3">(</span><span class="s1">out_then</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s1">ret_phi</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">out_then</span><span class="s3">, </span><span class="s1">then_blk</span><span class="s3">)</span>
            <span class="s1">ret_phi</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">out_orelse</span><span class="s3">, </span><span class="s1">orelse_blk</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret_phi</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Return a copy with the right layout</span>
            <span class="s2">return </span><span class="s1">_array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_as_layout_array_intrinsic</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">output_layout</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output_layout</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">RequireLiteralValue</span><span class="s3">(</span><span class="s1">output_layout</span><span class="s3">)</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s1">output_layout</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">max</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">output_layout</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s2">lambda </span><span class="s1">c</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">a</span><span class="s3">: </span><span class="s1">_as_layout_array</span><span class="s3">(</span>
        <span class="s1">c</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">output_layout</span><span class="s3">=</span><span class="s1">output_layout</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ascontiguousarray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_ascontiguousarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">,)):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ascontiguousarray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_as_layout_array_intrinsic</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_asfortranarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;a&quot; must be array-like'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">,)):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_as_layout_array_intrinsic</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s4">'F'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.astype&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.astype&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_astype</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">arytype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s1">rettype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">rettype</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>

    <span class="s1">src_data </span><span class="s3">= </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">dest_data </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s1">src_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">dest_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>
    <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
        <span class="s1">src_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">src_data</span><span class="s3">,</span>
                                            <span class="s1">shapes</span><span class="s3">, </span><span class="s1">src_strides</span><span class="s3">,</span>
                                            <span class="s1">arytype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
        <span class="s1">dest_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dest_data</span><span class="s3">,</span>
                                             <span class="s1">shapes</span><span class="s3">, </span><span class="s1">dest_strides</span><span class="s3">,</span>
                                             <span class="s1">rettype</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
        <span class="s1">item </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arytype</span><span class="s3">, </span><span class="s1">src_ptr</span><span class="s3">)</span>
        <span class="s1">item </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">arytype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">rettype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">rettype</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">dest_ptr</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_frombuffer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">):</span>
    <span class="s1">ty </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">instance_type</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">bufty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>

        <span class="s1">buf </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">bufty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">out_ary_ty </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)</span>
        <span class="s1">out_ary </span><span class="s3">= </span><span class="s1">out_ary_ty</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">out_datamodel </span><span class="s3">= </span><span class="s1">out_ary</span><span class="s3">.</span><span class="s1">_datamodel</span>

        <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">)</span>
        <span class="s1">ll_itemsize </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)</span>
        <span class="s1">nbytes </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">, </span><span class="s1">buf</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">)</span>

        <span class="s6"># Check that the buffer size is compatible</span>
        <span class="s1">rem </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">srem</span><span class="s3">(</span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">ll_itemsize</span><span class="s3">)</span>
        <span class="s1">is_incompatible </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_not_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">rem</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_incompatible</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;buffer size must be a multiple of element size&quot;</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

        <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sdiv</span><span class="s3">(</span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">ll_itemsize</span><span class="s3">)])</span>
        <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, [</span><span class="s1">ll_itemsize</span><span class="s3">])</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span>
            <span class="s1">buf</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">out_datamodel</span><span class="s3">.</span><span class="s1">get_type</span><span class="s3">(</span><span class="s4">'data'</span><span class="s3">))</span>
        <span class="s3">)</span>

        <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">out_ary</span><span class="s3">,</span>
                       <span class="s1">data</span><span class="s3">=</span><span class="s1">data</span><span class="s3">,</span>
                       <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">,</span>
                       <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                       <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ll_itemsize</span><span class="s3">,</span>
                       <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">buf</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                       <span class="s1">parent</span><span class="s3">=</span><span class="s1">buf</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">,)</span>

        <span class="s1">res </span><span class="s3">= </span><span class="s1">out_ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">frombuffer</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_frombuffer</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;frombuffer&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">or </span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s4">'C'</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f'Argument &quot;buffer&quot; must be buffer-like. Got </span><span class="s2">{</span><span class="s1">buffer</span><span class="s2">}</span><span class="s4">'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">float </span><span class="s2">or</span>
        <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">typing_key </span><span class="s2">is </span><span class="s1">float</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)): </span><span class="s6">#default</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">double</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">nb_dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">nb_dtype </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">nb_dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">,</span>
                            <span class="s1">readonly</span><span class="s3">=</span><span class="s2">not </span><span class="s1">buffer</span><span class="s3">.</span><span class="s1">mutable</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Cannot parse input types to function &quot;</span>
               <span class="s4">f&quot;np.frombuffer(</span><span class="s2">{</span><span class="s1">buffer</span><span class="s2">}</span><span class="s4">, </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np_frombuffer</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">carray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_carray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">intrinsic_cfarray </span><span class="s3">= </span><span class="s1">get_cfarray_intrinsic</span><span class="s3">(</span><span class="s4">'C'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">intrinsic_cfarray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">):</span>
        <span class="s1">intrinsic_cfarray </span><span class="s3">= </span><span class="s1">get_cfarray_intrinsic</span><span class="s3">(</span><span class="s4">'C'</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">intrinsic_cfarray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">farray</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_farray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">intrinsic_cfarray </span><span class="s3">= </span><span class="s1">get_cfarray_intrinsic</span><span class="s3">(</span><span class="s4">'F'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">intrinsic_cfarray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">):</span>
        <span class="s1">intrinsic_cfarray </span><span class="s3">= </span><span class="s1">get_cfarray_intrinsic</span><span class="s3">(</span><span class="s4">'F'</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">intrinsic_cfarray</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">get_cfarray_intrinsic</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">dtype_</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">intrinsic</span>
    <span class="s2">def </span><span class="s1">intrinsic_cfarray</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">ptr </span><span class="s2">is </span><span class="s1">types</span><span class="s3">.</span><span class="s1">voidptr</span><span class="s3">:</span>
            <span class="s1">ptr_dtype </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">):</span>
            <span class="s1">ptr_dtype </span><span class="s3">= </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;pointer argument expected, got '</span><span class="s2">{</span><span class="s1">ptr</span><span class="s2">}</span><span class="s4">'&quot;</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">dtype_ </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">ptr_dtype </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;explicit dtype required for void* argument&quot;</span>
                <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">ptr_dtype</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype_</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DTypeSpec</span><span class="s3">):</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">dtype_</span><span class="s3">.</span><span class="s1">dtype</span>
            <span class="s2">if </span><span class="s1">ptr_dtype </span><span class="s2">is not None and </span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">ptr_dtype</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;mismatching dtype '</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">' for pointer type '</span><span class="s2">{</span><span class="s1">ptr</span><span class="s2">}</span><span class="s4">'&quot;</span>
                <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;invalid dtype spec '</span><span class="s2">{</span><span class="s1">dtype_</span><span class="s2">}</span><span class="s4">'&quot;</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">ty_parse_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ndim </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;invalid shape '</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">'&quot;</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">retty </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">np_cfarray</span>
    <span class="s2">return </span><span class="s1">intrinsic_cfarray</span>


<span class="s2">def </span><span class="s1">np_cfarray</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    numba.numpy_support.carray(...) and 
    numba.numpy_support.farray(...). 
    &quot;&quot;&quot;</span>
    <span class="s1">ptrty</span><span class="s3">, </span><span class="s1">shapety </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">]</span>
    <span class="s1">ptr</span><span class="s3">, </span><span class="s1">shape </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">]</span>

    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s2">assert </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">in </span><span class="s4">'CF'</span>

    <span class="s1">out_ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">get_itemsize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">)</span>
    <span class="s1">ll_itemsize </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shapety</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">shapety </span><span class="s3">= (</span><span class="s1">shapety</span><span class="s3">,)</span>
        <span class="s1">shapes </span><span class="s3">= (</span><span class="s1">shape</span><span class="s3">,)</span>
    <span class="s1">shapes </span><span class="s3">= [</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
              <span class="s2">for </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">shapety</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)]</span>

    <span class="s1">off </span><span class="s3">= </span><span class="s1">ll_itemsize</span>
    <span class="s1">strides </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F'</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">shapes</span><span class="s3">:</span>
            <span class="s1">strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">off</span><span class="s3">)</span>
            <span class="s1">off </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">off</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">):</span>
            <span class="s1">strides</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">off</span><span class="s3">)</span>
            <span class="s1">off </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">off</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
        <span class="s1">strides</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>

    <span class="s1">data </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">,</span>
                           <span class="s1">context</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">as_pointer</span><span class="s3">())</span>

    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">out_ary</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shapes</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ll_itemsize</span><span class="s3">,</span>
                   <span class="s6"># Array is not memory-managed</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">out_ary</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_get_seq_size</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">))</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
        <span class="s1">len_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">len</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">,))</span>
        <span class="s2">return </span><span class="s1">len_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">seq</span><span class="s3">,))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s5">0</span>


<span class="s2">def </span><span class="s1">_get_borrowing_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a getitem() implementation that doesn't incref its result. 
    &quot;&quot;&quot;</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">getitem_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span><span class="s3">,</span>
                                        <span class="s1">signature</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">getitem_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">decref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">return </span><span class="s1">wrap</span>


<span class="s2">def </span><span class="s1">compute_sequence_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the likely shape of a nested sequence (possibly 0d). 
    &quot;&quot;&quot;</span>
    <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_first_item</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">return None</span><span class="s3">, </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">seqty</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">getitem_impl </span><span class="s3">= </span><span class="s1">_get_borrowing_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">seqty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">getitem_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">))</span>

    <span class="s6"># Compute shape by traversing the first element of each nested</span>
    <span class="s6"># sequence</span>
    <span class="s1">shapes </span><span class="s3">= []</span>
    <span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner </span><span class="s3">= </span><span class="s1">get_first_item</span><span class="s3">(</span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">)</span>
        <span class="s1">shapes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_get_seq_size</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_sequence_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the nested sequence matches the given *shapes*. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_fail</span><span class="s3">():</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">,</span>
                                          <span class="s3">(</span><span class="s4">&quot;incompatible sequence shape&quot;</span><span class="s3">,))</span>

    <span class="s2">def </span><span class="s1">check_seq_size</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s1">_get_seq_size</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">)</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">mismatch </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'!='</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">mismatch</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">_fail</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
            <span class="s1">getitem_impl </span><span class="s3">= </span><span class="s1">_get_borrowing_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">size</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop</span><span class="s3">:</span>
                <span class="s1">innerty </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">.</span><span class="s1">dtype</span>
                <span class="s1">inner </span><span class="s3">= </span><span class="s1">getitem_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">))</span>
                <span class="s1">check_seq_size</span><span class="s3">(</span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">)):</span>
                <span class="s1">innerty </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">inner </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">check_seq_size</span><span class="s3">(</span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s5">0</span><span class="s3">, </span><span class="s1">seqty</span>

    <span class="s1">check_seq_size</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">assign_sequence_to_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                             <span class="s1">arrty</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Assign a nested sequence contents to an array.  The shape must match 
    the sequence's structure. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">assign_item</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">,</span>
                                        <span class="s1">arrty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">assign</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">assert not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">))</span>
            <span class="s1">assign_item</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s1">size </span><span class="s3">= </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
            <span class="s1">getitem_impl </span><span class="s3">= </span><span class="s1">_get_borrowing_getitem</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">size</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop</span><span class="s3">:</span>
                <span class="s1">innerty </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">.</span><span class="s1">dtype</span>
                <span class="s1">inner </span><span class="s3">= </span><span class="s1">getitem_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">))</span>
                <span class="s1">assign</span><span class="s3">(</span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">indices </span><span class="s3">+ (</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,))</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">)):</span>
                <span class="s1">innerty </span><span class="s3">= </span><span class="s1">seqty</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">inner </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s1">assign</span><span class="s3">(</span><span class="s1">innerty</span><span class="s3">, </span><span class="s1">inner</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">indices </span><span class="s3">+ (</span><span class="s1">index</span><span class="s3">,))</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s5">0</span><span class="s3">, </span><span class="s1">seqty</span>

    <span class="s1">assign</span><span class="s3">(</span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, ())</span>


<span class="s2">def </span><span class="s1">np_array_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">object</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s1">ndim</span><span class="s3">, </span><span class="s1">seq_dtype </span><span class="s3">= </span><span class="s1">_parse_nested_sequence</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">seq_dtype</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>
    <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s4">'C'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_array</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;array&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">np_array_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">arrty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">seqty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">seq </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">shapes </span><span class="s3">= </span><span class="s1">compute_sequence_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">) == </span><span class="s1">ndim</span>

        <span class="s1">check_sequence_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">)</span>
        <span class="s1">assign_sequence_to_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">,</span>
                                 <span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">seqty</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                                <span class="s1">arr</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_array</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">_check_const_str_dtype</span><span class="s3">(</span><span class="s4">&quot;array&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The argument &quot;object&quot; must '</span>
                                 <span class="s4">'be array-like'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">and </span><span class="s1">ty_parse_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;dtype&quot; must be a data-type if it is provided'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np_array</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_normalize_axis</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">ll_ndim </span><span class="s3">= </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s6"># Normalize negative axis</span>
    <span class="s1">is_neg_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_neg_axis</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ll_ndim</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s6"># Check axis for bounds</span>
    <span class="s1">axis_out_of_bounds </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">),</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ll_ndim</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">axis_out_of_bounds</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;%s(): axis out of bounds&quot; </span><span class="s3">% </span><span class="s1">func_name</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>

    <span class="s2">return </span><span class="s1">axis</span>


<span class="s2">def </span><span class="s1">_insert_axis_in_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">orig_shape</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute shape with the new axis inserted 
    e.g. given original shape (2, 3, 4) and axis=2, 
    the returned new shape is (2, 3, 1, 4). 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">orig_shape</span><span class="s3">) == </span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span>

    <span class="s1">ll_shty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shty</span><span class="s3">)</span>

    <span class="s1">one </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s6"># 1. copy original sizes at appropriate places</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">ll_dim </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">after_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">sh </span><span class="s3">= </span><span class="s1">orig_shape</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">after_axis</span><span class="s3">,</span>
                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">one</span><span class="s3">),</span>
                             <span class="s1">ll_dim</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">))</span>

    <span class="s6"># 2. insert new size (1) at axis dimension</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">one</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">shapes</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_insert_axis_in_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">orig_strides</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Same as _insert_axis_in_shape(), but with a strides array. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">orig_strides</span><span class="s3">) == </span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span>

    <span class="s1">ll_shty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shty</span><span class="s3">)</span>

    <span class="s1">one </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s6"># 1. copy original strides at appropriate places</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">ll_dim </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">after_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">after_axis</span><span class="s3">,</span>
                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">one</span><span class="s3">),</span>
                             <span class="s1">ll_dim</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">orig_strides</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">],</span>
                      <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">))</span>

    <span class="s6"># 2. insert new stride at axis dimension</span>
    <span class="s6"># (the value is indifferent for a 1-sized dimension, we use 0)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.expand_dims() with the given axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">arrty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s1">arr </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>

    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>

    <span class="s1">new_shapes </span><span class="s3">= </span><span class="s1">_insert_axis_in_shape</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">new_strides </span><span class="s3">= </span><span class="s1">_insert_axis_in_strides</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">new_shapes</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">new_strides</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s1">parent</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_expand_dims</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s5">1 </span><span class="s2">else </span><span class="s4">'A'</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">_normalize_axis</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">&quot;np.expand_dims&quot;</span><span class="s3">,</span>
                               <span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s1">ret </span><span class="s3">= </span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_expand_dims</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f'First argument &quot;a&quot; must be an array. Got </span><span class="s2">{</span><span class="s1">a</span><span class="s2">}</span><span class="s4">'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">f'Argument &quot;axis&quot; must be an integer. Got </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">}</span><span class="s4">'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np_expand_dims</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_atleast_nd</span><span class="s3">(</span><span class="s1">minimum</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">intrinsic</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">typingcontext</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">arrtys </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">rettys </span><span class="s3">= [</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">max</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">minimum</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>

        <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">transform </span><span class="s3">= </span><span class="s1">_atleast_nd_transform</span><span class="s3">(</span><span class="s1">minimum</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>
            <span class="s1">arrs </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

            <span class="s1">rets </span><span class="s3">= [</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">retty </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">rettys</span><span class="s3">)]</span>

            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">rets</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">rets</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ret </span><span class="s3">= </span><span class="s1">rets</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">(</span><span class="s1">rettys</span><span class="s3">) </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">rettys</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">rettys</span><span class="s3">[</span><span class="s5">0</span><span class="s3">],</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">StarArgTuple</span><span class="s3">.</span><span class="s1">from_types</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)), </span><span class="s1">codegen</span>

    <span class="s2">return lambda </span><span class="s3">*</span><span class="s1">args</span><span class="s3">: </span><span class="s1">impl</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_atleast_nd_transform</span><span class="s3">(</span><span class="s1">min_ndim</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a callback successively inserting 1-sized dimensions at the 
    following axes. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">min_ndim </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">min_ndim</span><span class="s3">):</span>
            <span class="s1">ndim </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s1">ndim</span><span class="s3">:</span>
                <span class="s1">axis </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
                <span class="s1">newarrty </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">arr </span><span class="s3">= </span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                  <span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">newarrty</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">), (</span><span class="s1">arr</span><span class="s3">,),</span>
                                  <span class="s1">axis</span><span class="s3">)</span>
                <span class="s1">arrty </span><span class="s3">= </span><span class="s1">newarrty</span>

        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">return </span><span class="s1">transform</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_atleast_1d</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_atleast_nd</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_atleast_2d</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_atleast_nd</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_3d</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_atleast_3d</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_atleast_nd</span><span class="s3">(</span><span class="s5">3</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">_do_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                    <span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">arr_shapes</span><span class="s3">, </span><span class="s1">arr_strides</span><span class="s3">,</span>
                    <span class="s1">retty</span><span class="s3">, </span><span class="s1">ret_shapes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Concatenate arrays along the given axis. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_shapes</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arr_strides</span><span class="s3">)</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s6"># Allocate return array</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_empty_nd_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret_shapes</span><span class="s3">)</span>
    <span class="s1">ret_strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">)</span>

    <span class="s6"># Compute the offset by which to bump the destination pointer</span>
    <span class="s6"># after copying each input array.</span>
    <span class="s6"># Morally, we need to copy each input array at different start indices</span>
    <span class="s6"># into the destination array; bumping the destination pointer</span>
    <span class="s6"># is simply easier than offsetting all destination indices.</span>
    <span class="s1">copy_offsets </span><span class="s3">= []</span>

    <span class="s2">for </span><span class="s1">arr_sh </span><span class="s2">in </span><span class="s1">arr_shapes</span><span class="s3">:</span>
        <span class="s6"># offset = ret_strides[axis] * input_shape[axis]</span>
        <span class="s1">offset </span><span class="s3">= </span><span class="s1">zero</span>
        <span class="s2">for </span><span class="s1">dim</span><span class="s3">, (</span><span class="s1">size</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arr_sh</span><span class="s3">, </span><span class="s1">ret_strides</span><span class="s3">)):</span>
            <span class="s1">is_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s1">addend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">)</span>
            <span class="s1">offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_axis</span><span class="s3">,</span>
                                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">, </span><span class="s1">addend</span><span class="s3">),</span>
                                    <span class="s1">offset</span><span class="s3">)</span>
        <span class="s1">copy_offsets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">)</span>

    <span class="s6"># Copy input arrays into the return array</span>
    <span class="s1">ret_data </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s2">for </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arr_sh</span><span class="s3">, </span><span class="s1">arr_st</span><span class="s3">, </span><span class="s1">offset </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">arr_shapes</span><span class="s3">,</span>
                                                  <span class="s1">arr_strides</span><span class="s3">, </span><span class="s1">copy_offsets</span><span class="s3">):</span>
        <span class="s1">arr_data </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">data</span>

        <span class="s6"># Do the copy loop</span>
        <span class="s6"># Note the loop nesting is optimized for the destination layout</span>
        <span class="s1">loop_nest </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr_sh</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">,</span>
                                      <span class="s1">order</span><span class="s3">=</span><span class="s1">retty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">loop_nest </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s1">src_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr_data</span><span class="s3">,</span>
                                                <span class="s1">arr_sh</span><span class="s3">, </span><span class="s1">arr_st</span><span class="s3">,</span>
                                                <span class="s1">arrty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">load_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">src_ptr</span><span class="s3">)</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">dest_ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret_data</span><span class="s3">,</span>
                                                 <span class="s1">ret_shapes</span><span class="s3">, </span><span class="s1">ret_strides</span><span class="s3">,</span>
                                                 <span class="s1">retty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)</span>
            <span class="s1">store_item</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">dest_ptr</span><span class="s3">)</span>

        <span class="s6"># Bump destination pointer</span>
        <span class="s1">ret_data </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">pointer_add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret_data</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_np_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s1">arrs </span><span class="s3">= [</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">aty</span><span class="s3">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">)]</span>

    <span class="s1">axis </span><span class="s3">= </span><span class="s1">_normalize_axis</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">&quot;np.concatenate&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s6"># Get input shapes</span>
    <span class="s1">arr_shapes </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrs</span><span class="s3">]</span>
    <span class="s1">arr_strides </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrs</span><span class="s3">]</span>

    <span class="s6"># Compute return shape:</span>
    <span class="s6"># - the dimension for the concatenation axis is summed over all inputs</span>
    <span class="s6"># - other dimensions must match exactly for each input</span>
    <span class="s1">ret_shapes </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sh</span><span class="s3">)</span>
                  <span class="s2">for </span><span class="s1">sh </span><span class="s2">in </span><span class="s1">arr_shapes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]]</span>

    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s1">is_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">ret_shape_ptr </span><span class="s3">= </span><span class="s1">ret_shapes</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
        <span class="s1">ret_sh </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ret_shape_ptr</span><span class="s3">)</span>
        <span class="s1">other_shapes </span><span class="s3">= [</span><span class="s1">sh</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">] </span><span class="s2">for </span><span class="s1">sh </span><span class="s2">in </span><span class="s1">arr_shapes</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]]</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_axis</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">on_axis</span><span class="s3">, </span><span class="s1">on_other_dim</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">on_axis</span><span class="s3">:</span>
                <span class="s1">sh </span><span class="s3">= </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">,</span>
                    <span class="s1">other_shapes </span><span class="s3">+ [</span><span class="s1">ret_sh</span><span class="s3">])</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">, </span><span class="s1">ret_shape_ptr</span><span class="s3">)</span>

            <span class="s2">with </span><span class="s1">on_other_dim</span><span class="s3">:</span>
                <span class="s1">is_ok </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_bit</span>
                <span class="s2">for </span><span class="s1">sh </span><span class="s2">in </span><span class="s1">other_shapes</span><span class="s3">:</span>
                    <span class="s1">is_ok </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">and_</span><span class="s3">(</span><span class="s1">is_ok</span><span class="s3">,</span>
                                         <span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">sh</span><span class="s3">, </span><span class="s1">ret_sh</span><span class="s3">))</span>
                <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">is_ok</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
                    <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span>
                        <span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">,</span>
                        <span class="s3">(</span><span class="s4">&quot;np.concatenate(): input sizes over &quot;</span>
                         <span class="s4">&quot;dimension %d do not match&quot; </span><span class="s3">% </span><span class="s1">dim</span><span class="s3">,))</span>

    <span class="s1">ret_shapes </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">) </span><span class="s2">for </span><span class="s1">sh </span><span class="s2">in </span><span class="s1">ret_shapes</span><span class="s3">]</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_do_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                          <span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">arr_shapes</span><span class="s3">, </span><span class="s1">arr_strides</span><span class="s3">,</span>
                          <span class="s1">retty</span><span class="s3">, </span><span class="s1">ret_shapes</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s2">def </span><span class="s1">_np_stack</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">ll_narrays </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">))</span>

    <span class="s1">arrs </span><span class="s3">= [</span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">a</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">aty</span><span class="s3">, </span><span class="s1">a </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">)]</span>

    <span class="s1">axis </span><span class="s3">= </span><span class="s1">_normalize_axis</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">&quot;np.stack&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s6"># Check input arrays have the same shape</span>
    <span class="s1">orig_shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrs</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]:</span>
        <span class="s1">is_ok </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">true_bit</span>
        <span class="s2">for </span><span class="s1">sh</span><span class="s3">, </span><span class="s1">orig_sh </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">),</span>
                               <span class="s1">orig_shape</span><span class="s3">):</span>
            <span class="s1">is_ok </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">and_</span><span class="s3">(</span><span class="s1">is_ok</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">sh</span><span class="s3">, </span><span class="s1">orig_sh</span><span class="s3">))</span>
            <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">is_ok</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
                <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span>
                    <span class="s1">builder</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">,</span>
                    <span class="s3">(</span><span class="s4">&quot;np.stack(): all input arrays must have the same shape&quot;</span><span class="s3">,))</span>

    <span class="s1">orig_strides </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrs</span><span class="s3">]</span>

    <span class="s6"># Compute input shapes and return shape with the new axis inserted</span>
    <span class="s6"># e.g. given 5 input arrays of shape (2, 3, 4) and axis=1,</span>
    <span class="s6"># corrected input shape is (2, 1, 3, 4) and return shape is (2, 5, 3, 4).</span>
    <span class="s1">ll_shty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s1">input_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shty</span><span class="s3">)</span>
    <span class="s1">ret_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shty</span><span class="s3">)</span>

    <span class="s6"># 1. copy original sizes at appropriate places</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">ll_dim </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">after_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">sh </span><span class="s3">= </span><span class="s1">orig_shape</span><span class="s3">[</span><span class="s1">dim</span><span class="s3">]</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">after_axis</span><span class="s3">,</span>
                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">one</span><span class="s3">),</span>
                             <span class="s1">ll_dim</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">input_shapes</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">sh</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ret_shapes</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">))</span>

    <span class="s6"># 2. insert new size at axis dimension</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">one</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">input_shapes</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ll_narrays</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                   <span class="s1">ret_shapes</span><span class="s3">,</span>
                                                   <span class="s5">0</span><span class="s3">,</span>
                                                   <span class="s1">axis</span><span class="s3">))</span>

    <span class="s1">input_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">input_shapes</span><span class="s3">))</span>
    <span class="s1">input_shapes </span><span class="s3">= [</span><span class="s1">input_shapes</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">)</span>
    <span class="s1">ret_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ret_shapes</span><span class="s3">))</span>

    <span class="s6"># Compute input strides for each array with the new axis inserted</span>
    <span class="s1">input_strides </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ll_shty</span><span class="s3">)</span>
                     <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">))]</span>

    <span class="s6"># 1. copy original strides at appropriate places</span>
    <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">ll_dim </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">dim</span><span class="s3">)</span>
        <span class="s1">after_axis </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">after_axis</span><span class="s3">,</span>
                             <span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">ll_dim</span><span class="s3">, </span><span class="s1">one</span><span class="s3">),</span>
                             <span class="s1">ll_dim</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">)):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">orig_strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s1">dim</span><span class="s3">],</span>
                          <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">input_strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s5">0</span><span class="s3">,</span>
                                               <span class="s1">idx</span><span class="s3">))</span>

    <span class="s6"># 2. insert new stride at axis dimension</span>
    <span class="s6"># (the value is indifferent for a 1-sized dimension, we put 0)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">arrs</span><span class="s3">)):</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">input_strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s5">0</span><span class="s3">,</span>
                                                 <span class="s1">axis</span><span class="s3">))</span>

    <span class="s1">input_strides </span><span class="s3">= [</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">st</span><span class="s3">))</span>
                     <span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">input_strides</span><span class="s3">]</span>

    <span class="s6"># Create concatenated array</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_do_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                          <span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">, </span><span class="s1">input_shapes</span><span class="s3">, </span><span class="s1">input_strides</span><span class="s3">,</span>
                          <span class="s1">retty</span><span class="s3">, </span><span class="s1">ret_shapes</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s2">def </span><span class="s1">np_concatenate_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s6"># Note Numpy allows axis=None, but it isn't documented:</span>
        <span class="s6"># https://github.com/numpy/numpy/issues/7968</span>
        <span class="s2">return</span>

    <span class="s6"># does type checking</span>
    <span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">= </span><span class="s1">_sequence_of_arrays</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">,</span>
                                      <span class="s4">&quot;np.concatenate&quot;</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;zero-dimensional arrays cannot be concatenated&quot;</span><span class="s3">)</span>

    <span class="s1">layout </span><span class="s3">= </span><span class="s1">_choose_concatenation_layout</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_concatenate</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">np_concatenate_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_np_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                               <span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]),</span>
                               <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]),</span>
                               <span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                               <span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np_concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_column_stack_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">):</span>
    <span class="s6"># column_stack() allows stacking 1-d and 2-d arrays together</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;np.column_stack() is only defined on &quot;</span>
                            <span class="s4">&quot;1-d and 2-d arrays&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">2</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_column_stack</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">= </span><span class="s1">_sequence_of_arrays</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">,</span>
                                      <span class="s4">&quot;np.column_stack&quot;</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">,</span>
                                      <span class="s1">dim_chooser</span><span class="s3">=</span><span class="s1">_column_stack_dims</span><span class="s3">)</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s1">_choose_concatenation_layout</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">orig_arrtys </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">orig_arrs </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

        <span class="s1">arrtys </span><span class="s3">= []</span>
        <span class="s1">arrs </span><span class="s3">= []</span>

        <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">arrty</span><span class="s3">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">orig_arrtys</span><span class="s3">, </span><span class="s1">orig_arrs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
                <span class="s1">arrtys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arrty</span><span class="s3">)</span>
                <span class="s1">arrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># Convert 1d array to 2d column array: np.expand_dims(a, 1)</span>
                <span class="s2">assert </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span>
                <span class="s1">newty </span><span class="s3">= </span><span class="s1">arrty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
                <span class="s1">expand_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">, </span><span class="s1">arrty</span><span class="s3">)</span>
                <span class="s1">newarr </span><span class="s3">= </span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">expand_sig</span><span class="s3">, (</span><span class="s1">arr</span><span class="s3">,), </span><span class="s1">axis</span><span class="s3">)</span>

                <span class="s1">arrtys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">)</span>
                <span class="s1">arrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newarr</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">_np_concatenate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">arrtys</span><span class="s3">, </span><span class="s1">arrs</span><span class="s3">,</span>
                               <span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">column_stack</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_column_stack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np_column_stack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.stack() with the given axis value. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_np_stack</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                     <span class="s1">list</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]),</span>
                     <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]),</span>
                     <span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                     <span class="s1">axis</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">np_stack_common</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s6"># does type checking</span>
    <span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">= </span><span class="s1">_sequence_of_arrays</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">,</span>
                                      <span class="s4">&quot;np.stack&quot;</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s4">'F' </span><span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'F' </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">) </span><span class="s2">else </span><span class="s4">'C'</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_stack</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np_stack_common</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">NdStack_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">ndim_min</span><span class="s3">):</span>
    <span class="s6"># does type checking</span>
    <span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim </span><span class="s3">= </span><span class="s1">_sequence_of_arrays</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">)</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">ndim_min</span><span class="s3">)</span>
    <span class="s1">layout </span><span class="s3">= </span><span class="s1">_choose_concatenation_layout</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">)</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_np_hstack</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">NdStack_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s4">&quot;np.hstack&quot;</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">tupty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim</span>

        <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s6"># hstack() on 0-d arrays returns a 1-d array</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># As a special case, dimension 0 of 1-dimensional arrays</span>
            <span class="s6"># is &quot;horizontal&quot;</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">else </span><span class="s5">1</span>

            <span class="s2">def </span><span class="s1">np_hstack_impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">np_hstack_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_hstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_np_hstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_np_vstack</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">NdStack_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s4">&quot;np.vstack&quot;</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">tupty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim</span>

        <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_vstack_impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">), </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># np.stack(arrays, axis=0)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_vstack_impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">np_vstack_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_vstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_np_vstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&gt;= (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">row_stack</span><span class="s3">)(</span><span class="s1">impl_np_vstack</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_np_dstack</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">NdStack_typer</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s4">&quot;np.dstack&quot;</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">tupty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">tupty</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">ndim</span>

        <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_vstack_impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">np_vstack_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># np.expand_dims(np.stack(arrays, axis=1), axis=0)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">stack_retty </span><span class="s3">= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">retty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">stack_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">stack_retty</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">stack_ret </span><span class="s3">= </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">stack_sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                                         <span class="s1">axis</span><span class="s3">)</span>

            <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">expand_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">, </span><span class="s1">stack_retty</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">expand_sig</span><span class="s3">, (</span><span class="s1">stack_ret</span><span class="s3">,), </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s6"># np.stack(arrays, axis=2)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_np_stack_common</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">np_vstack_impl</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">np_vstack_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dstack</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_dstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_np_dstack</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'fill'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">arr_fill</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">fill_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">arr</span><span class="s3">[:] = </span><span class="s1">val</span>
        <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">fill_impl</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload_method</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s4">'dot'</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_dot</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">dot_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">dot_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">fliplr</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_flip_lr</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;Cannot np.fliplr on %s type&quot; </span><span class="s3">% </span><span class="s1">m</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s6"># this handling is superfluous/dead as &lt; 2d array cannot be indexed as</span>
        <span class="s6"># present below and so typing fails. If the typing doesn't fail due to</span>
        <span class="s6"># some future change, this will catch it.</span>
        <span class="s2">if </span><span class="s1">A</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Input must be &gt;= 2-d.'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">A</span><span class="s3">[::, ::-</span><span class="s5">1</span><span class="s3">, ...]</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flipud</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_flip_ud</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>

    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;Cannot np.flipud on %s type&quot; </span><span class="s3">% </span><span class="s1">m</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s6"># this handling is superfluous/dead as a 0d array cannot be indexed as</span>
        <span class="s6"># present below and so typing fails. If the typing doesn't fail due to</span>
        <span class="s6"># some future change, this will catch it.</span>
        <span class="s2">if </span><span class="s1">A</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Input must be &gt;= 1-d.'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">A</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">, ...]</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s2">def </span><span class="s1">_build_flip_slice_tuple</span><span class="s3">(</span><span class="s1">tyctx</span><span class="s3">, </span><span class="s1">sz</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; Creates a tuple of slices for np.flip indexing like 
    `(slice(None, None, -1),) * sz` &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">RequireLiteralValue</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">)</span>
    <span class="s1">size </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">)</span>
    <span class="s1">tuple_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">types</span><span class="s3">.</span><span class="s1">slice3_type</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">tuple_type</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">length</span><span class="s3">, </span><span class="s1">empty_tuple</span><span class="s3">):</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">empty_tuple</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">length</span><span class="s3">):</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">inner_argtypes </span><span class="s3">= [</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">tuple_type</span><span class="s3">]</span>
        <span class="s1">inner_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">tuple_type</span><span class="s3">, *</span><span class="s1">inner_argtypes</span><span class="s3">)</span>
        <span class="s1">ll_idx_type </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s6"># Allocate an empty tuple</span>
        <span class="s1">empty_tuple </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant_undef</span><span class="s3">(</span><span class="s1">tuple_type</span><span class="s3">)</span>
        <span class="s1">inner_args </span><span class="s3">= [</span><span class="s1">ll_idx_type</span><span class="s3">(</span><span class="s1">size</span><span class="s3">), </span><span class="s1">empty_tuple</span><span class="s3">]</span>

        <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">inner_sig</span><span class="s3">, </span><span class="s1">inner_args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">return </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">codegen</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_flip</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
    <span class="s6"># a constant value is needed for the tuple slice, types.Array.ndim can</span>
    <span class="s6"># provide this and so at presnet only type.Array is support</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;Cannot np.flip on %s type&quot; </span><span class="s3">% </span><span class="s1">m</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">sl </span><span class="s3">= </span><span class="s1">_build_flip_slice_tuple</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">m</span><span class="s3">[</span><span class="s1">sl</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array_split</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_array_split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ListType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">)):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array_split</span><span class="s3">(</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">),</span>
                <span class="s1">indices_or_sections</span><span class="s3">,</span>
                <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">l</span><span class="s3">, </span><span class="s1">rem </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">], </span><span class="s1">indices_or_sections</span><span class="s3">)</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                <span class="s3">[</span><span class="s1">l </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] * </span><span class="s1">rem </span><span class="s3">+</span>
                <span class="s3">[</span><span class="s1">l</span><span class="s3">] * (</span><span class="s1">indices_or_sections </span><span class="s3">- </span><span class="s1">rem </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s3">))</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array_split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">elif </span><span class="s3">(</span>
        <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IterableType</span><span class="s3">)</span>
        <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">indices_or_sections</span><span class="s3">.</span><span class="s1">iterator_type</span><span class="s3">.</span><span class="s1">yield_type</span><span class="s3">,</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span>
        <span class="s3">)</span>
    <span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">slice_tup </span><span class="s3">= </span><span class="s1">build_full_slice_tuple</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;np.split&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s1">out </span><span class="s3">= []</span>
            <span class="s1">prev </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">cur </span><span class="s2">in </span><span class="s1">indices_or_sections</span><span class="s3">:</span>
                <span class="s1">idx </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">slice_tup</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">prev</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">))</span>
                <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>
                <span class="s1">prev </span><span class="s3">= </span><span class="s1">cur</span>
            <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">[</span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">slice_tup</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">cur</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))])</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">elif </span><span class="s3">(</span>
        <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Tuple</span><span class="s3">)</span>
        <span class="s2">and </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">indices_or_sections</span><span class="s3">.</span><span class="s1">types</span><span class="s3">)</span>
    <span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">slice_tup </span><span class="s3">= </span><span class="s1">build_full_slice_tuple</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;np.split&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s1">out </span><span class="s3">= []</span>
            <span class="s1">prev </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">cur </span><span class="s2">in </span><span class="s1">literal_unroll</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">):</span>
                <span class="s1">idx </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">slice_tup</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">prev</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">))</span>
                <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>
                <span class="s1">prev </span><span class="s3">= </span><span class="s1">cur</span>
            <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">[</span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">slice_tup</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">cur</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))])</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">np_split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6"># This is just a wrapper of array_split, but with an extra error if</span>
    <span class="s6"># indices is an int.</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ListType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">)):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">), </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">_</span><span class="s3">, </span><span class="s1">rem </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">], </span><span class="s1">indices_or_sections</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">rem </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;array split does not result in an equal division&quot;</span>
                <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array_split</span><span class="s3">(</span>
                <span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np_array_split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vsplit</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_vsplit</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;ary&quot; must be an array'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,</span>
                                            <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'The argument &quot;indices_or_sections&quot; must be int or 1d-array'</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span><span class="s4">'vsplit only works on '</span>
                              <span class="s4">'arrays of 2 or more dimensions'</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">hsplit</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_hsplit</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;ary&quot; must be an array'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,</span>
                                            <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'The argument &quot;indices_or_sections&quot; must be int or 1d-array'</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span><span class="s4">'hsplit only works on '</span>
                              <span class="s4">'arrays of 1 or more dimensions'</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dsplit</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_dsplit</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">'The argument &quot;ary&quot; must be an array'</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices_or_sections</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">,</span>
                                            <span class="s1">types</span><span class="s3">.</span><span class="s1">List</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'The argument &quot;indices_or_sections&quot; must be int or 1d-array'</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">3</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'dsplit only works on arrays of 3 or more '</span>
                             <span class="s4">'dimensions'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s6"># -----------------------------------------------------------------------------</span>
<span class="s6"># Sorting</span>

<span class="s1">_sorts </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">default_lt</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trivial comparison function between two keys. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span>


<span class="s2">def </span><span class="s1">get_sort_func</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">lt_impl</span><span class="s3">, </span><span class="s1">is_argsort</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get a sort implementation of the given kind. 
    &quot;&quot;&quot;</span>
    <span class="s1">key </span><span class="s3">= </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">lt_impl</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">is_argsort</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_sorts</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'quicksort'</span><span class="s3">:</span>
            <span class="s1">sort </span><span class="s3">= </span><span class="s1">quicksort</span><span class="s3">.</span><span class="s1">make_jit_quicksort</span><span class="s3">(</span>
                <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt_impl</span><span class="s3">,</span>
                <span class="s1">is_argsort</span><span class="s3">=</span><span class="s1">is_argsort</span><span class="s3">,</span>
                <span class="s1">is_np_array</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">sort</span><span class="s3">.</span><span class="s1">run_quicksort</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'mergesort'</span><span class="s3">:</span>
            <span class="s1">sort </span><span class="s3">= </span><span class="s1">mergesort</span><span class="s3">.</span><span class="s1">make_jit_mergesort</span><span class="s3">(</span>
                <span class="s1">lt</span><span class="s3">=</span><span class="s1">lt_impl</span><span class="s3">,</span>
                <span class="s1">is_argsort</span><span class="s3">=</span><span class="s1">is_argsort</span><span class="s3">)</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">sort</span><span class="s3">.</span><span class="s1">run_mergesort</span>
        <span class="s1">_sorts</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">func</span>
        <span class="s2">return </span><span class="s1">func</span>


<span class="s2">def </span><span class="s1">lt_implementation</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">lt_floats</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">lt_complex</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">default_lt</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.sort&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_sort</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">arytype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s1">sort_func </span><span class="s3">= </span><span class="s1">get_sort_func</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">=</span><span class="s4">'quicksort'</span><span class="s3">,</span>
                              <span class="s1">lt_impl</span><span class="s3">=</span><span class="s1">lt_implementation</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">array_sort_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s6"># Note we clobber the return value</span>
        <span class="s1">sort_func</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_sort_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_np_sort</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'Argument &quot;a&quot; must '</span>
                                 <span class="s4">'be array-like'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">np_sort_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">res</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">return </span><span class="s1">np_sort_impl</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">&quot;array.argsort&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">StringLiteral</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_argsort</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">arytype</span><span class="s3">, </span><span class="s1">kind </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>

    <span class="s1">sort_func </span><span class="s3">= </span><span class="s1">get_sort_func</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">=</span><span class="s1">kind</span><span class="s3">.</span><span class="s1">literal_value</span><span class="s3">,</span>
                              <span class="s1">lt_impl</span><span class="s3">=</span><span class="s1">lt_implementation</span><span class="s3">(</span><span class="s1">arytype</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">),</span>
                              <span class="s1">is_argsort</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">array_argsort_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">sort_func</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s1">innersig </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">args</span><span class="s3">=</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[:</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">innerargs </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">array_argsort_impl</span><span class="s3">,</span>
                                    <span class="s1">innersig</span><span class="s3">, </span><span class="s1">innerargs</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Implicit cast</span>

<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_to_array</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s6"># Type inference should have prevented illegal array casting.</span>
    <span class="s2">assert </span><span class="s1">fromty</span><span class="s3">.</span><span class="s1">mutable </span><span class="s3">!= </span><span class="s1">toty</span><span class="s3">.</span><span class="s1">mutable </span><span class="s2">or </span><span class="s1">toty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s4">'A'</span>
    <span class="s2">return </span><span class="s1">val</span>


<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UnicodeCharSeq</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Boolean</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPTimedelta</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NPDatetime</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array0d_to_scalar</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s6"># a is an array(T, 0d, O), T is type, O is order</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">toty</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, [</span><span class="s1">val</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UnicodeCharSeq</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array_to_unichrseq</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[()])</span>

    <span class="s1">sig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">toty</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, [</span><span class="s1">val</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s6"># ------------------------------------------------------------------------------</span>
<span class="s6"># Stride tricks</span>

<span class="s2">def </span><span class="s1">reshape_unchecked</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    An intrinsic returning a derived array with the given shape and strides. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">type_callable</span><span class="s3">(</span><span class="s1">reshape_unchecked</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">type_reshape_unchecked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">check_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">) </span><span class="s2">and</span>
                <span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">typer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
            <span class="s2">return</span>
        <span class="s2">if not </span><span class="s1">check_shape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">check_shape</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">):</span>
            <span class="s2">return</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">layout</span><span class="s3">=</span><span class="s4">'A'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">typer</span>


<span class="s3">@</span><span class="s1">lower_builtin</span><span class="s3">(</span><span class="s1">reshape_unchecked</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">BaseTuple</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">impl_shape_unchecked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s1">aryty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">retty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>

    <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aryty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])</span>

    <span class="s1">populate_array</span><span class="s3">(</span><span class="s1">out</span><span class="s3">,</span>
                   <span class="s1">data</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                   <span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">,</span>
                   <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                   <span class="s1">itemsize</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">,</span>
                   <span class="s1">meminfo</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">meminfo</span><span class="s3">,</span>
                   <span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">stride_tricks</span><span class="s3">.</span><span class="s1">as_strided</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">as_strided</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">shape </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">shape</span>

    <span class="s2">if </span><span class="s1">strides </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s6"># When *strides* is not passed, as_strided() does a non-size-checking</span>
        <span class="s6"># reshape(), possibly changing the original strides.  This is too</span>
        <span class="s6"># cumbersome to support right now, and a Web search shows all example</span>
        <span class="s6"># use cases of as_strided() pass explicit *strides*.</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;as_strided() strides argument is mandatory&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_strides</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">strides</span>

    <span class="s2">def </span><span class="s1">as_strided_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">reshape_unchecked</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">get_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">), </span><span class="s1">get_strides</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">return </span><span class="s1">as_strided_impl</span>


<span class="s3">@</span><span class="s1">extending</span><span class="s3">.</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">stride_tricks</span><span class="s3">.</span><span class="s1">sliding_window_view</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">sliding_window_view</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s6"># Window shape must be given as either an integer or tuple of integers.</span>
    <span class="s6"># We also need to generate buffer tuples we can modify to contain the</span>
    <span class="s6"># final shape and strides (reshape_unchecked does not accept lists).</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s1">shape_buffer </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">stride_buffer </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">))</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_window_shape</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">,)</span>

    <span class="s2">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s1">shape_buffer </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">)))</span>
        <span class="s1">stride_buffer </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">)))</span>

        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_window_shape</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">window_shape</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
            <span class="s4">&quot;window_shape must be an integer or tuple of integers&quot;</span>
        <span class="s3">)</span>

    <span class="s6"># Axis must be integer, tuple of integers, or None for all axes.</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_axis</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">))</span>

    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_axis</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">[</span>
                <span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;sliding_window_view&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s3">]</span>

    <span class="s2">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">get_axis</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;sliding_window_view&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">axis</span><span class="s3">]</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
            <span class="s4">&quot;axis must be None, an integer or tuple of integers&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">sliding_window_view_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">window_shape </span><span class="s3">= </span><span class="s1">get_window_shape</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">)</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">get_axis</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">window_shape</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Must provide matching length window_shape and axis&quot;</span>
            <span class="s3">)</span>

        <span class="s6"># Initialise view details with shape and strides of x.</span>
        <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">shape_buffer</span>
        <span class="s1">out_strides </span><span class="s3">= </span><span class="s1">stride_buffer</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
            <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s1">out_strides </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out_strides</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

        <span class="s6"># Trim the dimensions being windowed and set the window shape and</span>
        <span class="s6"># strides. Note: the same axis can be windowed repeatedly.</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">for </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">window_shape</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">dim </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;`window_shape` cannot contain negative values&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">out_shape</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] &lt; </span><span class="s1">dim</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;window_shape cannot be larger than input array shape&quot;</span>
                <span class="s3">)</span>

            <span class="s1">trimmed </span><span class="s3">= </span><span class="s1">out_shape</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] - </span><span class="s1">dim </span><span class="s3">+ </span><span class="s5">1</span>
            <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">trimmed</span><span class="s3">)</span>
            <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">dim</span><span class="s3">)</span>
            <span class="s1">out_strides </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">out_strides</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">])</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s6"># The NumPy version calls as_strided, but our implementation of</span>
        <span class="s6"># as_strided is effectively a wrapper for reshape_unchecked.</span>
        <span class="s1">view </span><span class="s3">= </span><span class="s1">reshape_unchecked</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">out_strides</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">view</span>

    <span class="s2">return </span><span class="s1">sliding_window_view_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">bool</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_bool</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">return False </span><span class="s6"># this is deprecated</span>
            <span class="s2">elif </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;The truth value of an array with more than one element &quot;</span>
                       <span class="s4">&quot;is ambiguous. Use a.any() or a.all()&quot;</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">numpy_swapaxes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis1</span><span class="s3">, </span><span class="s1">axis2</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis1</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The second argument &quot;axis1&quot; must be an '</span>
                                 <span class="s4">'integer'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis2</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The third argument &quot;axis2&quot; must be an '</span>
                                 <span class="s4">'integer'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;a&quot; must be an array'</span><span class="s3">)</span>

    <span class="s6"># create tuple list for transpose</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">axes_list </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">ndim</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis1</span><span class="s3">, </span><span class="s1">axis2</span><span class="s3">):</span>
        <span class="s1">axis1 </span><span class="s3">= </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;np.swapaxes&quot;</span><span class="s3">, </span><span class="s4">&quot;axis1&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis1</span><span class="s3">)</span>
        <span class="s1">axis2 </span><span class="s3">= </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;np.swapaxes&quot;</span><span class="s3">, </span><span class="s4">&quot;axis2&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis2</span><span class="s3">)</span>

        <span class="s6"># to ensure tuple_setitem support of negative values</span>
        <span class="s2">if </span><span class="s1">axis1 </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis1 </span><span class="s3">+= </span><span class="s1">ndim</span>
        <span class="s2">if </span><span class="s1">axis2 </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis2 </span><span class="s3">+= </span><span class="s1">ndim</span>

        <span class="s1">axes_tuple </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">axes_list</span><span class="s3">, </span><span class="s1">axis1</span><span class="s3">, </span><span class="s1">axis2</span><span class="s3">)</span>
        <span class="s1">axes_tuple </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">axes_tuple</span><span class="s3">, </span><span class="s1">axis2</span><span class="s3">, </span><span class="s1">axis1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes_tuple</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_take_along_axis_impl</span><span class="s3">(</span>
        <span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">Ni_orig</span><span class="s3">, </span><span class="s1">Nk_orig</span><span class="s3">, </span><span class="s1">indices_broadcast_shape</span>
<span class="s3">):</span>
    <span class="s6"># Based on example code in</span>
    <span class="s6"># https://github.com/numpy/numpy/blob/623bc1fae1d47df24e7f1e29321d0c0ba2771ce0/numpy/lib/shape_base.py#L90-L103</span>
    <span class="s6"># With addition of pre-broadcasting:</span>
    <span class="s6"># https://github.com/numpy/numpy/issues/19704</span>

    <span class="s6"># Wrap axis, it's used in tuple_setitem so must be (axis &gt;= 0) to ensure</span>
    <span class="s6"># the GEP is in bounds.</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis</span><span class="s3">(</span><span class="s4">&quot;np.take_along_axis&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s6"># Broadcast the two arrays to matching shapes:</span>
    <span class="s1">arr_shape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">arr_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">d1</span><span class="s3">, </span><span class="s1">d2</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">arr_shape</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">d1 </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">new_val </span><span class="s3">= </span><span class="s1">d2</span>
        <span class="s2">elif </span><span class="s1">d2 </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">new_val </span><span class="s3">= </span><span class="s1">d1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">d1 </span><span class="s3">!= </span><span class="s1">d2</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;`arr` and `indices` dimensions don't match&quot;</span>
                <span class="s3">)</span>
            <span class="s1">new_val </span><span class="s3">= </span><span class="s1">d1</span>
        <span class="s1">indices_broadcast_shape </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span>
            <span class="s1">indices_broadcast_shape</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">new_val</span>
        <span class="s3">)</span>
    <span class="s1">arr_broadcast_shape </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span>
        <span class="s1">indices_broadcast_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arr_broadcast_shape</span><span class="s3">)</span>
    <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indices_broadcast_shape</span><span class="s3">)</span>

    <span class="s1">Ni </span><span class="s3">= </span><span class="s1">Ni_orig</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">Ni_orig</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">Ni</span><span class="s3">)):</span>
            <span class="s1">Ni </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">Ni</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
    <span class="s1">Nk </span><span class="s3">= </span><span class="s1">Nk_orig</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">Nk_orig</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">Nk</span><span class="s3">)):</span>
            <span class="s1">Nk </span><span class="s3">= </span><span class="s1">tuple_setitem</span><span class="s3">(</span><span class="s1">Nk</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis </span><span class="s3">+ </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">])</span>

    <span class="s1">J </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]  </span><span class="s6"># Need not equal M</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Ni </span><span class="s3">+ (</span><span class="s1">J</span><span class="s3">,) + </span><span class="s1">Nk</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">np_s_ </span><span class="s3">= (</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),)</span>

    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">Ni</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">kk </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndindex</span><span class="s3">(</span><span class="s1">Nk</span><span class="s3">):</span>
            <span class="s1">a_1d </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">ii </span><span class="s3">+ </span><span class="s1">np_s_ </span><span class="s3">+ </span><span class="s1">kk</span><span class="s3">]</span>
            <span class="s1">indices_1d </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">[</span><span class="s1">ii </span><span class="s3">+ </span><span class="s1">np_s_ </span><span class="s3">+ </span><span class="s1">kk</span><span class="s3">]</span>
            <span class="s1">out_1d </span><span class="s3">= </span><span class="s1">out</span><span class="s3">[</span><span class="s1">ii </span><span class="s3">+ </span><span class="s1">np_s_ </span><span class="s3">+ </span><span class="s1">kk</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">J</span><span class="s3">):</span>
                <span class="s1">out_1d</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">a_1d</span><span class="s3">[</span><span class="s1">indices_1d</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]]</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">take_along_axis</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">arr_take_along_axis</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The first argument &quot;arr&quot; must be an array'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
            <span class="s4">'The second argument &quot;indices&quot; must be an array'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">'The indices array must contain integers'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s1">arr_ndim </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">arr_ndim </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">arr_ndim </span><span class="s3">!= </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s6"># Matches NumPy error:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
            <span class="s4">&quot;`indices` and `arr` must have the same number of dimensions&quot;</span>
        <span class="s3">)</span>

    <span class="s1">indices_broadcast_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">take_along_axis_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_take_along_axis_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">(), </span><span class="s1">indices</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, (), (),</span>
                                         <span class="s1">indices_broadcast_shape</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">check_is_integer</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">IntegerLiteral</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s4">&quot;axis must be a literal value&quot;</span><span class="s3">)</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span><span class="s3">.</span><span class="s1">literal_value</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">axis</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">&gt;= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">NumbaValueError</span><span class="s3">(</span><span class="s4">&quot;axis is out of bounds&quot;</span><span class="s3">)</span>

        <span class="s1">Ni </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))</span>
        <span class="s1">Nk </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">axis </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>

        <span class="s2">def </span><span class="s1">take_along_axis_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_take_along_axis_impl</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">Ni</span><span class="s3">, </span><span class="s1">Nk</span><span class="s3">,</span>
                                         <span class="s1">indices_broadcast_shape</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">take_along_axis_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">nan_to_num_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Number</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s6"># Integers do not have nans or infs</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">x</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">nan</span>
                <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isneginf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)).</span><span class="s1">min</span>
                <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isposinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)).</span><span class="s1">max</span>
                <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s1">nan</span><span class="s3">)</span>
                <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s1">nan</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">complex</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">c</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
                <span class="s4">&quot;Only Integer, Float, and Complex values are accepted&quot;</span>
            <span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">type_can_asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
            <span class="s6"># Integers do not have nans or infs</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s1">min_inf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">min</span>
                <span class="s1">max_inf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">max</span>

                <span class="s1">x_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">x_</span><span class="s3">) </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">x_</span>

                <span class="s1">output_flat </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">flat</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]):</span>
                        <span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">nan</span>
                    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isneginf</span><span class="s3">(</span><span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]):</span>
                        <span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">min_inf</span>
                    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isposinf</span><span class="s3">(</span><span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]):</span>
                        <span class="s1">output_flat</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">max_inf</span>
                <span class="s2">return </span><span class="s1">output</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
                <span class="s1">x_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">x_</span><span class="s3">) </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">x_</span>

                <span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s1">nan</span><span class="s3">)</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">=</span><span class="s1">nan</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">output</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span>
                <span class="s4">&quot;Only Integer, Float, and Complex values are accepted&quot;</span>
            <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s4">&quot;The first argument must be a scalar or an &quot;</span>
                                 <span class="s4">&quot;array-like&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl</span>
</pre>
</body>
</html>