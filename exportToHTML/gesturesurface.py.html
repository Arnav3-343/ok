<html>
<head>
<title>gesturesurface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gesturesurface.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Gesture Surface 
=============== 
 
.. versionadded:: 
    1.9.0 
 
.. warning:: 
 
    This is experimental and subject to change as long as this warning notice 
    is present. 
 
See :file:`kivy/examples/demo/multistroke/main.py` for a complete application 
example. 
'''</span>
<span class="s1">__all__ </span><span class="s2">= (</span><span class="s3">'GestureSurface'</span><span class="s2">, </span><span class="s3">'GestureContainer'</span><span class="s2">)</span>

<span class="s4">from </span><span class="s1">random </span><span class="s4">import </span><span class="s1">random</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">event </span><span class="s4">import </span><span class="s1">EventDispatcher</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">clock </span><span class="s4">import </span><span class="s1">Clock</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">vector </span><span class="s4">import </span><span class="s1">Vector</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">uix</span><span class="s2">.</span><span class="s1">floatlayout </span><span class="s4">import </span><span class="s1">FloatLayout</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">graphics </span><span class="s4">import </span><span class="s1">Color</span><span class="s2">, </span><span class="s1">Line</span><span class="s2">, </span><span class="s1">Rectangle</span>
<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">properties </span><span class="s4">import </span><span class="s2">(</span><span class="s1">NumericProperty</span><span class="s2">, </span><span class="s1">BooleanProperty</span><span class="s2">,</span>
                             <span class="s1">DictProperty</span><span class="s2">, </span><span class="s1">ColorProperty</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">colorsys </span><span class="s4">import </span><span class="s1">hsv_to_rgb</span>

<span class="s5"># Clock undershoot margin, FIXME: this is probably too high?</span>
<span class="s1">UNDERSHOOT_MARGIN </span><span class="s2">= </span><span class="s6">0.1</span>


<span class="s4">class </span><span class="s1">GestureContainer</span><span class="s2">(</span><span class="s1">EventDispatcher</span><span class="s2">):</span>
    <span class="s0">'''Container object that stores information about a gesture. It has 
    various properties that are updated by `GestureSurface` as drawing 
    progresses. 
 
    :Arguments: 
        `touch` 
            Touch object (as received by on_touch_down) used to initialize 
            the gesture container. Required. 
 
    :Properties: 
        `active` 
            Set to False once the gesture is complete (meets 
            `max_stroke` setting or `GestureSurface.temporal_window`) 
 
            :attr:`active` is a 
            :class:`~kivy.properties.BooleanProperty` 
 
        `active_strokes` 
            Number of strokes currently active in the gesture, ie 
            concurrent touches associated with this gesture. 
 
            :attr:`active_strokes` is a 
            :class:`~kivy.properties.NumericProperty` 
 
        `max_strokes` 
            Max number of strokes allowed in the gesture. This 
            is set by `GestureSurface.max_strokes` but can 
            be overridden for example from `on_gesture_start`. 
 
            :attr:`max_strokes` is a 
            :class:`~kivy.properties.NumericProperty` 
 
        `was_merged` 
            Indicates that this gesture has been merged with another 
            gesture and should be considered discarded. 
 
            :attr:`was_merged` is a 
            :class:`~kivy.properties.BooleanProperty` 
 
        `bbox` 
            Dictionary with keys minx, miny, maxx, maxy. Represents the size 
            of the gesture bounding box. 
 
            :attr:`bbox` is a 
            :class:`~kivy.properties.DictProperty` 
 
        `width` 
            Represents the width of the gesture. 
 
            :attr:`width` is a 
            :class:`~kivy.properties.NumericProperty` 
 
        `height` 
            Represents the height of the gesture. 
 
            :attr:`height` is a 
            :class:`~kivy.properties.NumericProperty` 
    '''</span>
    <span class="s1">active </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">active_strokes </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">max_strokes </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">was_merged </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">bbox </span><span class="s2">= </span><span class="s1">DictProperty</span><span class="s2">({</span><span class="s3">'minx'</span><span class="s2">: </span><span class="s1">float</span><span class="s2">(</span><span class="s3">'inf'</span><span class="s2">), </span><span class="s3">'miny'</span><span class="s2">: </span><span class="s1">float</span><span class="s2">(</span><span class="s3">'inf'</span><span class="s2">),</span>
                         <span class="s3">'maxx'</span><span class="s2">: </span><span class="s1">float</span><span class="s2">(</span><span class="s3">'-inf'</span><span class="s2">), </span><span class="s3">'maxy'</span><span class="s2">: </span><span class="s1">float</span><span class="s2">(</span><span class="s3">'-inf'</span><span class="s2">)})</span>
    <span class="s1">width </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">height </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s5"># The color is applied to all canvas items of this gesture</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">color </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'color'</span><span class="s2">, [</span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">])</span>

        <span class="s1">super</span><span class="s2">(</span><span class="s1">GestureContainer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s5"># This is the touch.uid of the oldest touch represented</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">id </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">)</span>

        <span class="s5"># Store various timestamps for decision making</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_create_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cleanup_time </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache_time </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s5"># We can cache the candidate here to save zip()/Vector instantiation</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_vectors </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s5"># Key is touch.uid; value is a kivy.graphics.Line(); it's used even</span>
        <span class="s5"># if line_width is 0 (i.e. not actually drawn anywhere)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes </span><span class="s2">= {}</span>

        <span class="s5"># Make sure the bbox is up to date with the first touch position</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">update_bbox</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">get_vectors</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">'''Return strokes in a format that is acceptable for 
        `kivy.multistroke.Recognizer` as a gesture candidate or template. The 
        result is cached automatically; the cache is invalidated at the start 
        and end of a stroke and if `update_bbox` is called. If you are going 
        to analyze a gesture mid-stroke, you may need to set the `no_cache` 
        argument to True.'''</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cache_time </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s4">and </span><span class="s1">\</span>
                <span class="s4">not </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">'no_cache'</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_vectors</span>

        <span class="s1">vecs </span><span class="s2">= []</span>
        <span class="s1">append </span><span class="s2">= </span><span class="s1">vecs</span><span class="s2">.</span><span class="s1">append</span>
        <span class="s4">for </span><span class="s1">tuid</span><span class="s2">, </span><span class="s1">l </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">lpts </span><span class="s2">= </span><span class="s1">l</span><span class="s2">.</span><span class="s1">points</span>
            <span class="s1">append</span><span class="s2">([</span><span class="s1">Vector</span><span class="s2">(*</span><span class="s1">pts</span><span class="s2">) </span><span class="s4">for </span><span class="s1">pts </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">lpts</span><span class="s2">[::</span><span class="s6">2</span><span class="s2">], </span><span class="s1">lpts</span><span class="s2">[</span><span class="s6">1</span><span class="s2">::</span><span class="s6">2</span><span class="s2">])])</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_vectors </span><span class="s2">= </span><span class="s1">vecs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache_time </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time</span>
        <span class="s4">return </span><span class="s1">vecs</span>

    <span class="s4">def </span><span class="s1">handles</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''Returns True if this container handles the given touch'''</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">active</span><span class="s2">:</span>
            <span class="s4">return False</span>
        <span class="s4">return </span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">) </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes</span>

    <span class="s4">def </span><span class="s1">accept_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">count</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s0">'''Returns True if this container can accept `count` new strokes'''</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_strokes</span><span class="s2">:</span>
            <span class="s4">return True</span>
        <span class="s4">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">) + </span><span class="s1">count </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_strokes</span>

    <span class="s4">def </span><span class="s1">update_bbox</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''Update gesture bbox from a touch coordinate'''</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">y</span>
        <span class="s1">bb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">bbox</span>
        <span class="s4">if </span><span class="s1">x </span><span class="s2">&lt; </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">]:</span>
            <span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">] = </span><span class="s1">x</span>
        <span class="s4">if </span><span class="s1">y </span><span class="s2">&lt; </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]:</span>
            <span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">] = </span><span class="s1">y</span>
        <span class="s4">if </span><span class="s1">x </span><span class="s2">&gt; </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">]:</span>
            <span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] = </span><span class="s1">x</span>
        <span class="s4">if </span><span class="s1">y </span><span class="s2">&gt; </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">]:</span>
            <span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] = </span><span class="s1">y</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">width </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">height </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">add_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">, </span><span class="s1">line</span><span class="s2">):</span>
        <span class="s0">'''Associate a list of points with a touch.uid; the line itself is 
        created by the caller, but subsequent move/up events look it 
        up via us. This is done to avoid problems during merge.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">[</span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">)] = </span><span class="s1">line</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">active_strokes </span><span class="s2">+= </span><span class="s6">1</span>

    <span class="s4">def </span><span class="s1">complete_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Called on touch up events to keep track of how many strokes 
        are active in the gesture (we only want to dispatch event when 
        the *last* stroke in the gesture is released)'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">active_strokes </span><span class="s2">-= </span><span class="s6">1</span>

    <span class="s4">def </span><span class="s1">single_points_test</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''Returns True if the gesture consists only of single-point strokes, 
        we must discard it in this case, or an exception will be raised'''</span>
        <span class="s4">for </span><span class="s1">tuid</span><span class="s2">, </span><span class="s1">l </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">l</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) &gt; </span><span class="s6">2</span><span class="s2">:</span>
                <span class="s4">return False</span>
        <span class="s4">return True</span>


<span class="s4">class </span><span class="s1">GestureSurface</span><span class="s2">(</span><span class="s1">FloatLayout</span><span class="s2">):</span>
    <span class="s0">'''Simple gesture surface to track/draw touch movements. Typically used 
    to gather user input suitable for :class:`kivy.multistroke.Recognizer`. 
 
    :Properties: 
        `temporal_window` 
            Time to wait from the last touch_up event before attempting 
            to recognize the gesture. If you set this to 0, the 
            `on_gesture_complete` event is not fired unless the 
            :attr:`max_strokes` condition is met. 
 
            :attr:`temporal_window` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 2.0 
 
        `max_strokes` 
            Max number of strokes in a single gesture; if this is reached, 
            recognition will start immediately on the final touch_up event. 
            If this is set to 0, the `on_gesture_complete` event is not 
            fired unless the :attr:`temporal_window` expires. 
 
            :attr:`max_strokes` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 2.0 
 
        `bbox_margin` 
            Bounding box margin for detecting gesture collisions, in 
            pixels. 
 
            :attr:`bbox_margin` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 30 
 
        `draw_timeout` 
            Number of seconds to keep lines/bbox on canvas after the 
            `on_gesture_complete` event is fired. If this is set to 0, 
            gestures are immediately removed from the surface when 
            complete. 
 
            :attr:`draw_timeout` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 3.0 
 
        `color` 
            Color used to draw the gesture, in RGB. This option does not 
            have an effect if :attr:`use_random_color` is True. 
 
            :attr:`color` is a 
            :class:`~kivy.properties.ColorProperty` and defaults to 
            [1, 1, 1, 1] (white) 
 
            .. versionchanged:: 2.0.0 
                Changed from :class:`~kivy.properties.ListProperty` to 
                :class:`~kivy.properties.ColorProperty`. 
 
        `use_random_color` 
            Set to True to pick a random color for each gesture, if you do 
            this then `color` is ignored. Defaults to False. 
 
            :attr:`use_random_color` is a 
            :class:`~kivy.properties.BooleanProperty` and defaults to False 
 
        `line_width` 
            Line width used for tracing touches on the surface. Set to 0 
            if you only want to detect gestures without drawing anything. 
            If you use 1.0, OpenGL GL_LINE is used for drawing; values &gt; 1 
            will use an internal drawing method based on triangles (less 
            efficient), see :mod:`kivy.graphics`. 
 
            :attr:`line_width` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 2 
 
        `draw_bbox` 
            Set to True if you want to draw bounding box behind gestures. 
            This only works if `line_width` &gt;= 1. Default is False. 
 
            :attr:`draw_bbox` is a 
            :class:`~kivy.properties.BooleanProperty` and defaults to True 
 
        `bbox_alpha` 
            Opacity for bounding box if `draw_bbox` is True. Default 0.1 
 
            :attr:`bbox_alpha` is a 
            :class:`~kivy.properties.NumericProperty` and defaults to 0.1 
 
    :Events: 
        `on_gesture_start` :class:`GestureContainer` 
            Fired when a new gesture is initiated on the surface, i.e. the 
            first on_touch_down that does not collide with an existing 
            gesture on the surface. 
 
        `on_gesture_extend` :class:`GestureContainer` 
            Fired when a touch_down event occurs within an existing gesture. 
 
        `on_gesture_merge` :class:`GestureContainer`, :class:`GestureContainer` 
            Fired when two gestures collide and get merged to one gesture. 
            The first argument is the gesture that has been merged (no longer 
            valid); the second is the combined (resulting) gesture. 
 
        `on_gesture_complete` :class:`GestureContainer` 
            Fired when a set of strokes is considered a complete gesture, 
            this happens when `temporal_window` expires or `max_strokes` 
            is reached. Typically you will bind to this event and use 
            the provided `GestureContainer` get_vectors() method to 
            match against your gesture database. 
 
        `on_gesture_cleanup` :class:`GestureContainer` 
            Fired `draw_timeout` seconds after `on_gesture_complete`, 
            The gesture will be removed from the canvas (if line_width &gt; 0 or 
            draw_bbox is True) and the internal gesture list before this. 
 
        `on_gesture_discard` :class:`GestureContainer` 
            Fired when a gesture does not meet the minimum size requirements 
            for recognition (width/height &lt; 5, or consists only of single- 
            point strokes). 
    '''</span>

    <span class="s1">temporal_window </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">2.0</span><span class="s2">)</span>
    <span class="s1">draw_timeout </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">3.0</span><span class="s2">)</span>
    <span class="s1">max_strokes </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">4</span><span class="s2">)</span>
    <span class="s1">bbox_margin </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">30</span><span class="s2">)</span>

    <span class="s1">line_width </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">2</span><span class="s2">)</span>
    <span class="s1">color </span><span class="s2">= </span><span class="s1">ColorProperty</span><span class="s2">([</span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">])</span>
    <span class="s1">use_random_color </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">draw_bbox </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">bbox_alpha </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s6">0.1</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">GestureSurface</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s5"># A list of GestureContainer objects (all gestures on the surface)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_start'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_extend'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_merge'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_complete'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_cleanup'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">register_event_type</span><span class="s2">(</span><span class="s3">'on_gesture_discard'</span><span class="s2">)</span>

<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># Touch Events</span>
<span class="s5"># -----------------------------------------------------------------------------</span>
    <span class="s4">def </span><span class="s1">on_touch_down</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''When a new touch is registered, the first thing we do is to test if 
        it collides with the bounding box of another known gesture. If so, it 
        is assumed to be part of that gesture. 
        '''</span>
        <span class="s5"># If the touch originates outside the surface, ignore it.</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">collide_point</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">y</span><span class="s2">):</span>
            <span class="s4">return</span>

        <span class="s1">touch</span><span class="s2">.</span><span class="s1">grab</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s5"># Add the stroke to existing gesture, or make a new one</span>
        <span class="s1">g </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find_colliding_gesture</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">if </span><span class="s1">g </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">g </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">init_gesture</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
            <span class="s1">new </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s5"># We now belong to a gesture (new or old); start a new stroke.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">init_stroke</span><span class="s2">(</span><span class="s1">g</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">new</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_start'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_extend'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">)</span>

        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">on_touch_move</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''When a touch moves, we add a point to the line on the canvas so the 
        path is updated. We must also check if the new point collides with the 
        bounding box of another gesture - if so, they should be merged.'''</span>
        <span class="s4">if </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">grab_current </span><span class="s4">is not </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">collide_point</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">y</span><span class="s2">):</span>
            <span class="s4">return</span>

        <span class="s5"># Retrieve the GestureContainer object that handles this touch, and</span>
        <span class="s5"># test for colliding gestures. If found, merge them to one.</span>
        <span class="s1">g </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_gesture</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s1">collision </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find_colliding_gesture</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">collision </span><span class="s4">is not None and </span><span class="s1">g</span><span class="s2">.</span><span class="s1">accept_stroke</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">collision</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">)):</span>
            <span class="s1">merge </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">merge_gestures</span><span class="s2">(</span><span class="s1">g</span><span class="s2">, </span><span class="s1">collision</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">was_merged</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_merge'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">collision</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_merge'</span><span class="s2">, </span><span class="s1">collision</span><span class="s2">, </span><span class="s1">g</span><span class="s2">)</span>
            <span class="s1">g </span><span class="s2">= </span><span class="s1">merge</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">g</span><span class="s2">.</span><span class="s1">update_bbox</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>

        <span class="s5"># Add the new point to gesture stroke list and update the canvas line</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">[</span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">)].</span><span class="s1">points </span><span class="s2">+= (</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">y</span><span class="s2">)</span>

        <span class="s5"># Draw the gesture bounding box; if it is a single press that</span>
        <span class="s5"># does not trigger a move event, we would miss it otherwise.</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">draw_bbox</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_canvas_bbox</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">on_touch_up</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">grab_current </span><span class="s4">is not </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s1">touch</span><span class="s2">.</span><span class="s1">ungrab</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s1">g </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_gesture</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">complete_stroke</span><span class="s2">()</span>

        <span class="s5"># If this stroke hit the maximum limit, dispatch immediately</span>
        <span class="s4">if not </span><span class="s1">g</span><span class="s2">.</span><span class="s1">accept_stroke</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_complete_dispatcher</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s5"># dispatch later only if we have a window</span>
        <span class="s4">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">temporal_window </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">Clock</span><span class="s2">.</span><span class="s1">schedule_once</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_complete_dispatcher</span><span class="s2">,</span>
                                    <span class="s1">self</span><span class="s2">.</span><span class="s1">temporal_window</span><span class="s2">)</span>

<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># Gesture related methods</span>
<span class="s5"># -----------------------------------------------------------------------------</span>
    <span class="s4">def </span><span class="s1">init_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''Create a new gesture from touch, i.e. it's the first on 
        surface, or was not close enough to any existing gesture (yet)'''</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">color</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">use_random_color</span><span class="s2">:</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">hsv_to_rgb</span><span class="s2">(</span><span class="s1">random</span><span class="s2">(), </span><span class="s6">1.</span><span class="s2">, </span><span class="s6">1.</span><span class="s2">)</span>

        <span class="s1">g </span><span class="s2">= </span><span class="s1">GestureContainer</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">, </span><span class="s1">max_strokes</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_strokes</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s1">col</span><span class="s2">)</span>

        <span class="s5"># Create the bounding box Rectangle for the gesture</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">draw_bbox</span><span class="s2">:</span>
            <span class="s1">bb </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">bbox</span>
            <span class="s4">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">canvas</span><span class="s2">:</span>
                <span class="s1">Color</span><span class="s2">(</span><span class="s1">col</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">bbox_alpha</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'rgba'</span><span class="s2">,</span>
                      <span class="s1">group</span><span class="s2">=</span><span class="s1">g</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>

                <span class="s1">g</span><span class="s2">.</span><span class="s1">_bbrect </span><span class="s2">= </span><span class="s1">Rectangle</span><span class="s2">(</span>
                    <span class="s1">group</span><span class="s2">=</span><span class="s1">g</span><span class="s2">.</span><span class="s1">id</span><span class="s2">,</span>
                    <span class="s1">pos</span><span class="s2">=(</span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">], </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]),</span>
                    <span class="s1">size</span><span class="s2">=(</span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">],</span>
                          <span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]))</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">g</span>

    <span class="s4">def </span><span class="s1">init_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= [</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">y</span><span class="s2">]</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">color</span>

        <span class="s1">new_line </span><span class="s2">= </span><span class="s1">Line</span><span class="s2">(</span>
            <span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
            <span class="s1">width</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">line_width</span><span class="s2">,</span>
            <span class="s1">group</span><span class="s2">=</span><span class="s1">g</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">[</span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">)] = </span><span class="s1">new_line</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">line_width</span><span class="s2">:</span>
            <span class="s1">canvas_add </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">canvas</span><span class="s2">.</span><span class="s1">add</span>
            <span class="s1">canvas_add</span><span class="s2">(</span><span class="s1">Color</span><span class="s2">(</span><span class="s1">col</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'rgb'</span><span class="s2">, </span><span class="s1">group</span><span class="s2">=</span><span class="s1">g</span><span class="s2">.</span><span class="s1">id</span><span class="s2">))</span>
            <span class="s1">canvas_add</span><span class="s2">(</span><span class="s1">new_line</span><span class="s2">)</span>

        <span class="s5"># Update the bbox in case; this will normally be done in on_touch_move,</span>
        <span class="s5"># but we want to update it also for a single press, force that here:</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">update_bbox</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">draw_bbox</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_canvas_bbox</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>

        <span class="s5"># Register the stroke in GestureContainer so we can look it up later</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">add_stroke</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">, </span><span class="s1">new_line</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">get_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''Returns GestureContainer associated with given touch'''</span>
        <span class="s4">for </span><span class="s1">g </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">active </span><span class="s4">and </span><span class="s1">g</span><span class="s2">.</span><span class="s1">handles</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">g</span>
        <span class="s4">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s3">'get_gesture() failed to identify ' </span><span class="s2">+ </span><span class="s1">str</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">uid</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">find_colliding_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">):</span>
        <span class="s0">'''Checks if a touch x/y collides with the bounding box of an existing 
        gesture. If so, return it (otherwise returns None) 
        '''</span>
        <span class="s1">touch_x</span><span class="s2">, </span><span class="s1">touch_y </span><span class="s2">= </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">pos</span>
        <span class="s4">for </span><span class="s1">g </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">active </span><span class="s4">and not </span><span class="s1">g</span><span class="s2">.</span><span class="s1">handles</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">) </span><span class="s4">and </span><span class="s1">g</span><span class="s2">.</span><span class="s1">accept_stroke</span><span class="s2">():</span>
                <span class="s1">bb </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">bbox</span>
                <span class="s1">margin </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">bbox_margin</span>
                <span class="s1">minx </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">] - </span><span class="s1">margin</span>
                <span class="s1">miny </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">] - </span><span class="s1">margin</span>
                <span class="s1">maxx </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] + </span><span class="s1">margin</span>
                <span class="s1">maxy </span><span class="s2">= </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] + </span><span class="s1">margin</span>
                <span class="s4">if </span><span class="s1">minx </span><span class="s2">&lt;= </span><span class="s1">touch_x </span><span class="s2">&lt;= </span><span class="s1">maxx </span><span class="s4">and </span><span class="s1">miny </span><span class="s2">&lt;= </span><span class="s1">touch_y </span><span class="s2">&lt;= </span><span class="s1">maxy</span><span class="s2">:</span>
                    <span class="s4">return </span><span class="s1">g</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">merge_gestures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">'''Merges two gestures together, the oldest one is retained and the 
        newer one gets the `GestureContainer.was_merged` flag raised.'''</span>
        <span class="s5"># Swap order depending on gesture age (the merged gesture gets</span>
        <span class="s5"># the color from the oldest one of the two).</span>
        <span class="s1">swap </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_create_time </span><span class="s2">&lt; </span><span class="s1">g</span><span class="s2">.</span><span class="s1">_create_time</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">swap </span><span class="s4">and </span><span class="s1">other </span><span class="s4">or </span><span class="s1">g</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">swap </span><span class="s4">and </span><span class="s1">g </span><span class="s4">or </span><span class="s1">other</span>

        <span class="s5"># Apply the outer limits of bbox to the merged gesture</span>
        <span class="s1">abbox </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">bbox</span>
        <span class="s1">bbbox </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">bbox</span>
        <span class="s4">if </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">] &lt; </span><span class="s1">abbox</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">]:</span>
            <span class="s1">abbox</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">] = </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">] &lt; </span><span class="s1">abbox</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]:</span>
            <span class="s1">abbox</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">] = </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] &gt; </span><span class="s1">abbox</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">]:</span>
            <span class="s1">abbox</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] = </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] &gt; </span><span class="s1">abbox</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">]:</span>
            <span class="s1">abbox</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] = </span><span class="s1">bbbox</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">]</span>

        <span class="s5"># Now transfer the coordinates from old to new gesture;</span>
        <span class="s5"># FIXME: This can probably be copied more efficiently?</span>
        <span class="s1">astrokes </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">_strokes</span>
        <span class="s1">lw </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">line_width</span>
        <span class="s1">a_id </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">id</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">color</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">canvas</span><span class="s2">.</span><span class="s1">remove_group</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
        <span class="s1">canv_add </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">canvas</span><span class="s2">.</span><span class="s1">add</span>
        <span class="s4">for </span><span class="s1">uid</span><span class="s2">, </span><span class="s1">old </span><span class="s4">in </span><span class="s1">b</span><span class="s2">.</span><span class="s1">_strokes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s5"># FIXME: Can't figure out how to change group= for existing Line()</span>
            <span class="s1">new_line </span><span class="s2">= </span><span class="s1">Line</span><span class="s2">(</span>
                <span class="s1">points</span><span class="s2">=</span><span class="s1">old</span><span class="s2">.</span><span class="s1">points</span><span class="s2">,</span>
                <span class="s1">width</span><span class="s2">=</span><span class="s1">old</span><span class="s2">.</span><span class="s1">width</span><span class="s2">,</span>
                <span class="s1">group</span><span class="s2">=</span><span class="s1">a_id</span><span class="s2">)</span>
            <span class="s1">astrokes</span><span class="s2">[</span><span class="s1">uid</span><span class="s2">] = </span><span class="s1">new_line</span>
            <span class="s4">if </span><span class="s1">lw</span><span class="s2">:</span>
                <span class="s1">canv_add</span><span class="s2">(</span><span class="s1">Color</span><span class="s2">(</span><span class="s1">col</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'rgb'</span><span class="s2">, </span><span class="s1">group</span><span class="s2">=</span><span class="s1">a_id</span><span class="s2">))</span>
                <span class="s1">canv_add</span><span class="s2">(</span><span class="s1">new_line</span><span class="s2">)</span>

        <span class="s1">b</span><span class="s2">.</span><span class="s1">active </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s1">b</span><span class="s2">.</span><span class="s1">was_merged </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s1">a</span><span class="s2">.</span><span class="s1">active_strokes </span><span class="s2">+= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">active_strokes</span>
        <span class="s1">a</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">()</span>
        <span class="s4">return </span><span class="s1">a</span>

    <span class="s4">def </span><span class="s1">_update_canvas_bbox</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">g</span><span class="s2">):</span>
        <span class="s5"># If draw_bbox is changed while two gestures are active,</span>
        <span class="s5"># we might not have a bbrect member</span>
        <span class="s4">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">g</span><span class="s2">, </span><span class="s3">'_bbrect'</span><span class="s2">):</span>
            <span class="s4">return</span>

        <span class="s1">bb </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">bbox</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">_bbrect</span><span class="s2">.</span><span class="s1">pos </span><span class="s2">= (</span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">], </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">])</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">_bbrect</span><span class="s2">.</span><span class="s1">size </span><span class="s2">= (</span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxx'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'minx'</span><span class="s2">],</span>
                          <span class="s1">bb</span><span class="s2">[</span><span class="s3">'maxy'</span><span class="s2">] - </span><span class="s1">bb</span><span class="s2">[</span><span class="s3">'miny'</span><span class="s2">])</span>

<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># Timeout callbacks</span>
<span class="s5"># -----------------------------------------------------------------------------</span>
    <span class="s4">def </span><span class="s1">_complete_dispatcher</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
        <span class="s0">'''This method is scheduled on all touch up events. It will dispatch 
        the `on_gesture_complete` event for all completed gestures, and remove 
        merged gestures from the internal gesture list.'''</span>
        <span class="s1">need_cleanup </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s1">gest </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures</span>
        <span class="s1">timeout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">draw_timeout</span>
        <span class="s1">twin </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">temporal_window</span>
        <span class="s1">get_time </span><span class="s2">= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span>

        <span class="s4">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">g </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">gest</span><span class="s2">):</span>
            <span class="s5"># Gesture is part of another gesture, just delete it</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">was_merged</span><span class="s2">:</span>
                <span class="s4">del </span><span class="s1">gest</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
                <span class="s4">continue</span>

            <span class="s5"># Not active == already handled, or has active strokes (it cannot</span>
            <span class="s5"># possibly be complete). Proceed to next gesture on surface.</span>
            <span class="s4">if not </span><span class="s1">g</span><span class="s2">.</span><span class="s1">active </span><span class="s4">or </span><span class="s1">g</span><span class="s2">.</span><span class="s1">active_strokes </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s4">continue</span>

            <span class="s1">t1 </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">_update_time </span><span class="s2">+ </span><span class="s1">twin</span>
            <span class="s1">t2 </span><span class="s2">= </span><span class="s1">get_time</span><span class="s2">() + </span><span class="s1">UNDERSHOOT_MARGIN</span>

            <span class="s5"># max_strokes reached, or temporal window has expired. The gesture</span>
            <span class="s5"># is complete; need to dispatch _complete or _discard event.</span>
            <span class="s4">if not </span><span class="s1">g</span><span class="s2">.</span><span class="s1">accept_stroke</span><span class="s2">() </span><span class="s4">or </span><span class="s1">t1 </span><span class="s2">&lt;= </span><span class="s1">t2</span><span class="s2">:</span>
                <span class="s1">discard </span><span class="s2">= </span><span class="s4">False</span>
                <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">width </span><span class="s2">&lt; </span><span class="s6">5 </span><span class="s4">and </span><span class="s1">g</span><span class="s2">.</span><span class="s1">height </span><span class="s2">&lt; </span><span class="s6">5</span><span class="s2">:</span>
                    <span class="s1">discard </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">elif </span><span class="s1">g</span><span class="s2">.</span><span class="s1">single_points_test</span><span class="s2">():</span>
                    <span class="s1">discard </span><span class="s2">= </span><span class="s4">True</span>

                <span class="s1">need_cleanup </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s1">g</span><span class="s2">.</span><span class="s1">active </span><span class="s2">= </span><span class="s4">False</span>
                <span class="s1">g</span><span class="s2">.</span><span class="s1">_cleanup_time </span><span class="s2">= </span><span class="s1">get_time</span><span class="s2">() + </span><span class="s1">timeout</span>

                <span class="s4">if </span><span class="s1">discard</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_discard'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_complete'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">need_cleanup</span><span class="s2">:</span>
            <span class="s1">Clock</span><span class="s2">.</span><span class="s1">schedule_once</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cleanup</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_cleanup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
        <span class="s0">'''This method is scheduled from _complete_dispatcher to clean up the 
        canvas and internal gesture list after a gesture is completed.'''</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">UNDERSHOOT_MARGIN</span>
        <span class="s1">rg </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">canvas</span><span class="s2">.</span><span class="s1">remove_group</span>
        <span class="s1">gestures </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_gestures</span>
        <span class="s4">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">g </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">gestures</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">_cleanup_time </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">g</span><span class="s2">.</span><span class="s1">_cleanup_time </span><span class="s2">&lt;= </span><span class="s1">Clock</span><span class="s2">.</span><span class="s1">get_time</span><span class="s2">() + </span><span class="s1">m</span><span class="s2">:</span>
                <span class="s1">rg</span><span class="s2">(</span><span class="s1">g</span><span class="s2">.</span><span class="s1">id</span><span class="s2">)</span>
                <span class="s4">del </span><span class="s1">gestures</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">(</span><span class="s3">'on_gesture_cleanup'</span><span class="s2">, </span><span class="s1">g</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">on_gesture_start</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">on_gesture_extend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">on_gesture_merge</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">on_gesture_complete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">on_gesture_discard</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">on_gesture_cleanup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">l</span><span class="s2">):</span>
        <span class="s4">pass</span>
</pre>
</body>
</html>