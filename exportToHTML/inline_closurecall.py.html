<html>
<head>
<title>inline_closurecall.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inline_closurecall.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">types </span><span class="s0">as </span><span class="s1">pytypes  </span><span class="s2"># avoid confusion with numba.types</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">ctypes</span>
<span class="s0">import </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">analysis</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s3">(</span><span class="s1">types</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">, </span><span class="s1">rewrites</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">ir_utils</span><span class="s3">,</span>
                        <span class="s1">cgutils</span><span class="s3">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">internal_prange</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">ir_utils </span><span class="s0">import </span><span class="s3">(</span>
    <span class="s1">next_label</span><span class="s3">,</span>
    <span class="s1">add_offset_to_labels</span><span class="s3">,</span>
    <span class="s1">replace_vars</span><span class="s3">,</span>
    <span class="s1">remove_dels</span><span class="s3">,</span>
    <span class="s1">rename_labels</span><span class="s3">,</span>
    <span class="s1">find_topo_order</span><span class="s3">,</span>
    <span class="s1">merge_adjacent_blocks</span><span class="s3">,</span>
    <span class="s1">GuardException</span><span class="s3">,</span>
    <span class="s1">require</span><span class="s3">,</span>
    <span class="s1">guard</span><span class="s3">,</span>
    <span class="s1">get_definition</span><span class="s3">,</span>
    <span class="s1">find_callname</span><span class="s3">,</span>
    <span class="s1">find_build_sequence</span><span class="s3">,</span>
    <span class="s1">get_np_ufunc_typ</span><span class="s3">,</span>
    <span class="s1">get_ir_of_code</span><span class="s3">,</span>
    <span class="s1">simplify_CFG</span><span class="s3">,</span>
    <span class="s1">canonicalize_array_math</span><span class="s3">,</span>
    <span class="s1">dead_code_elimination</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">analysis </span><span class="s0">import </span><span class="s3">(</span>
    <span class="s1">compute_cfg_from_blocks</span><span class="s3">,</span>
    <span class="s1">compute_use_defs</span><span class="s3">,</span>
    <span class="s1">compute_live_variables</span><span class="s3">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">imputils </span><span class="s0">import </span><span class="s1">impl_ret_untracked</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s0">import </span><span class="s1">intrinsic</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">cpython</span><span class="s3">.</span><span class="s1">listobj </span><span class="s0">import </span><span class="s1">ListIterInstance</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">cpython</span><span class="s3">.</span><span class="s1">rangeobj </span><span class="s0">import </span><span class="s1">range_impl_map</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arrayobj </span><span class="s0">import </span><span class="s1">make_array</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">postproc</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unsafe</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s0">import </span><span class="s1">empty_inferred </span><span class="s0">as </span><span class="s1">unsafe_empty_inferred</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">special</span>

<span class="s4">&quot;&quot;&quot; 
Variable enable_inline_arraycall is only used for testing purpose. 
&quot;&quot;&quot;</span>
<span class="s1">enable_inline_arraycall </span><span class="s3">= </span><span class="s0">True</span>


<span class="s0">def </span><span class="s1">callee_ir_validator</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Checks the IR of a callee is supported for inlining 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Yield</span><span class="s3">):</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The use of yield in a closure is unsupported.&quot;</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_created_inlined_var_name</span><span class="s3">(</span><span class="s1">function_name</span><span class="s3">, </span><span class="s1">var_name</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Creates a name for an inlined variable based on the function name and the 
    variable name. It does this &quot;safely&quot; to avoid the use of characters that are 
    illegal in python variable names as there are occasions when function 
    generation needs valid python name tokens.&quot;&quot;&quot;</span>
    <span class="s1">inlined_name </span><span class="s3">= </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">function_name</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">var_name</span><span class="s0">}</span><span class="s4">'</span>
    <span class="s2"># Replace angle brackets, e.g. &quot;&lt;locals&gt;&quot; is replaced with &quot;_locals_&quot;</span>
    <span class="s1">new_name </span><span class="s3">= </span><span class="s1">inlined_name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'&gt;'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">)</span>
    <span class="s2"># The version &quot;version&quot; of the closure function e.g. foo$2 (id 2) is</span>
    <span class="s2"># rewritten as &quot;foo_v2&quot;. Further &quot;.&quot; is also replaced with &quot;_&quot;.</span>
    <span class="s1">new_name </span><span class="s3">= </span><span class="s1">new_name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'$'</span><span class="s3">, </span><span class="s4">'_v'</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">new_name</span>


<span class="s0">class </span><span class="s1">InlineClosureCallPass</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;InlineClosureCallPass class looks for direct calls to locally defined 
    closures, and inlines the body of the closure function to the call site. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">parallel_options</span><span class="s3">, </span><span class="s1">swapped</span><span class="s3">={}, </span><span class="s1">typed</span><span class="s3">=</span><span class="s0">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir </span><span class="s3">= </span><span class="s1">func_ir</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">parallel_options </span><span class="s3">= </span><span class="s1">parallel_options</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">swapped </span><span class="s3">= </span><span class="s1">swapped</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processed_stencils </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typed </span><span class="s3">= </span><span class="s1">typed</span>

    <span class="s0">def </span><span class="s1">run</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Run inline closure call pass. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Analysis relies on ir.Del presence, strip out later</span>
        <span class="s1">pp </span><span class="s3">= </span><span class="s1">postproc</span><span class="s3">.</span><span class="s1">PostProcessor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">)</span>
        <span class="s1">pp</span><span class="s3">.</span><span class="s1">run</span><span class="s3">(</span><span class="s0">True</span><span class="s3">)</span>

        <span class="s1">modified </span><span class="s3">= </span><span class="s0">False</span>
        <span class="s1">work_list </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
        <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;InlineClosureCallPass&quot;</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;START&quot;</span><span class="s3">)</span>
        <span class="s0">while </span><span class="s1">work_list</span><span class="s3">:</span>
            <span class="s1">_label</span><span class="s3">, </span><span class="s1">block </span><span class="s3">= </span><span class="s1">work_list</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">instr </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                    <span class="s1">expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">:</span>
                        <span class="s1">call_name </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">)</span>
                        <span class="s1">func_def </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">get_definition</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">,</span>
                                         <span class="s1">expr</span><span class="s3">.</span><span class="s1">func</span><span class="s3">)</span>

                        <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_inline_reduction</span><span class="s3">,</span>
                                 <span class="s1">work_list</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">call_name</span><span class="s3">):</span>
                            <span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>
                            <span class="s0">break </span><span class="s2"># because block structure changed</span>

                        <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_inline_closure</span><span class="s3">,</span>
                                 <span class="s1">work_list</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">):</span>
                            <span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>
                            <span class="s0">break </span><span class="s2"># because block structure changed</span>

                        <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_inline_stencil</span><span class="s3">,</span>
                                 <span class="s1">instr</span><span class="s3">, </span><span class="s1">call_name</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">):</span>
                            <span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">enable_inline_arraycall</span><span class="s3">:</span>
            <span class="s2"># Identify loop structure</span>
            <span class="s0">if </span><span class="s1">modified</span><span class="s3">:</span>
                <span class="s2"># Need to do some cleanups if closure inlining kicked in</span>
                <span class="s1">merge_adjacent_blocks</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
            <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
            <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;start inline arraycall&quot;</span><span class="s3">)</span>
            <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">)</span>
            <span class="s1">loops </span><span class="s3">= </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">loops</span><span class="s3">()</span>
            <span class="s1">sized_loops </span><span class="s3">= [(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loops</span><span class="s3">[</span><span class="s1">k</span><span class="s3">].</span><span class="s1">body</span><span class="s3">)) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">loops</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()]</span>
            <span class="s1">visited </span><span class="s3">= []</span>
            <span class="s2"># We go over all loops, bigger loops first (outer first)</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">sized_loops</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s0">lambda </span><span class="s1">tup</span><span class="s3">: </span><span class="s1">tup</span><span class="s3">[</span><span class="s6">1</span><span class="s3">],</span>
                               <span class="s1">reverse</span><span class="s3">=</span><span class="s0">True</span><span class="s3">):</span>
                <span class="s1">visited</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">_inline_arraycall</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">cfg</span><span class="s3">, </span><span class="s1">visited</span><span class="s3">,</span>
                         <span class="s1">loops</span><span class="s3">[</span><span class="s1">k</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">swapped</span><span class="s3">,</span>
                         <span class="s1">self</span><span class="s3">.</span><span class="s1">parallel_options</span><span class="s3">.</span><span class="s1">comprehension</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typed</span><span class="s3">):</span>
                    <span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">modified</span><span class="s3">:</span>
                <span class="s1">_fix_nested_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s1">modified</span><span class="s3">:</span>
            <span class="s2"># clean up now dead/unreachable blocks, e.g. unconditionally raising</span>
            <span class="s2"># an exception in an inlined function would render some parts of the</span>
            <span class="s2"># inliner unreachable</span>
            <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
            <span class="s0">for </span><span class="s1">dead </span><span class="s0">in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">dead_nodes</span><span class="s3">():</span>
                <span class="s0">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">dead</span><span class="s3">]</span>

            <span class="s2"># run dead code elimination</span>
            <span class="s1">dead_code_elimination</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">)</span>
            <span class="s2"># do label renaming</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">rename_labels</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>

        <span class="s2"># inlining done, strip dels</span>
        <span class="s1">remove_dels</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>

        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;END&quot;</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">_inline_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">work_list</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">call_name</span><span class="s3">):</span>
        <span class="s2"># only inline reduction in sequential execution, parallel handling</span>
        <span class="s2"># is done in ParforPass.</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s0">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">parallel_options</span><span class="s3">.</span><span class="s1">reduction</span><span class="s3">)</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">call_name </span><span class="s3">== (</span><span class="s4">'reduce'</span><span class="s3">, </span><span class="s4">'builtins'</span><span class="s3">) </span><span class="s0">or</span>
                <span class="s1">call_name </span><span class="s3">== (</span><span class="s4">'reduce'</span><span class="s3">, </span><span class="s4">'_functools'</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">) </span><span class="s0">not in </span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;invalid reduce call, &quot;</span>
                            <span class="s4">&quot;two arguments are required (optional initial &quot;</span>
                            <span class="s4">&quot;value can also be specified)&quot;</span><span class="s3">)</span>
        <span class="s1">check_reduce_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>

        <span class="s0">def </span><span class="s1">reduce_func</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">=</span><span class="s0">None</span><span class="s3">):</span>
            <span class="s1">it </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">v </span><span class="s0">is not None</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">v</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">it</span><span class="s3">)</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">it</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
            <span class="s0">return </span><span class="s1">s</span>

        <span class="s1">inline_closure_call</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span><span class="s3">,</span>
            <span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">reduce_func</span><span class="s3">, </span><span class="s1">work_list</span><span class="s3">=</span><span class="s1">work_list</span><span class="s3">,</span>
            <span class="s1">callee_validator</span><span class="s3">=</span><span class="s1">callee_ir_validator</span>
        <span class="s3">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_inline_stencil</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">, </span><span class="s1">call_name</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">stencils</span><span class="s3">.</span><span class="s1">stencil </span><span class="s0">import </span><span class="s1">StencilFunc</span>
        <span class="s1">lhs </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2"># We keep the escaping variables of the stencil kernel</span>
        <span class="s2"># alive by adding them to the actual kernel call as extra</span>
        <span class="s2"># keyword arguments, which is ignored anyway.</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s1">func_def</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'stencil' </span><span class="s0">and</span>
                <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">StencilFunc</span><span class="s3">)):</span>
            <span class="s0">if </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">:</span>
                <span class="s1">expr</span><span class="s3">.</span><span class="s1">kws </span><span class="s3">+= </span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">kws</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s1">expr</span><span class="s3">.</span><span class="s1">kws </span><span class="s3">= </span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">kws</span>
            <span class="s0">return True</span>
        <span class="s2"># Otherwise we proceed to check if it is a call to numba.stencil</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">call_name </span><span class="s3">== (</span><span class="s4">'stencil'</span><span class="s3">, </span><span class="s4">'numba.stencils.stencil'</span><span class="s3">) </span><span class="s0">or</span>
                <span class="s1">call_name </span><span class="s3">== (</span><span class="s4">'stencil'</span><span class="s3">, </span><span class="s4">'numba'</span><span class="s3">))</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">expr </span><span class="s0">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processed_stencils</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processed_stencils</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">)</span>
        <span class="s0">if not </span><span class="s1">len</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;As a minimum Stencil requires&quot;</span>
                             <span class="s4">&quot; a kernel as an argument&quot;</span><span class="s3">)</span>
        <span class="s1">stencil_def </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">get_definition</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stencil_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s1">stencil_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">&quot;make_function&quot;</span><span class="s3">)</span>
        <span class="s1">kernel_ir </span><span class="s3">= </span><span class="s1">get_ir_of_code</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span><span class="s3">,</span>
                                   <span class="s1">stencil_def</span><span class="s3">.</span><span class="s1">code</span><span class="s3">)</span>
        <span class="s1">options </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s4">'neighborhood' </span><span class="s0">in </span><span class="s1">options</span><span class="s3">:</span>
            <span class="s1">fixed </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_stencil_neighborhood</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
            <span class="s0">if not </span><span class="s1">fixed</span><span class="s3">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;stencil neighborhood option should be a tuple&quot;</span>
                    <span class="s4">&quot; with constant structure such as ((-w, w),)&quot;</span>
                <span class="s3">)</span>
        <span class="s0">if </span><span class="s4">'index_offsets' </span><span class="s0">in </span><span class="s1">options</span><span class="s3">:</span>
            <span class="s1">fixed </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_stencil_index_offsets</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
            <span class="s0">if not </span><span class="s1">fixed</span><span class="s3">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;stencil index_offsets option should be a tuple&quot;</span>
                    <span class="s4">&quot; with constant structure such as (offset, )&quot;</span>
                <span class="s3">)</span>
        <span class="s1">sf </span><span class="s3">= </span><span class="s1">StencilFunc</span><span class="s3">(</span><span class="s1">kernel_ir</span><span class="s3">, </span><span class="s4">'constant'</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
        <span class="s1">sf</span><span class="s3">.</span><span class="s1">kws </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">kws </span><span class="s2"># hack to keep variables live</span>
        <span class="s1">sf_global </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'stencil'</span><span class="s3">, </span><span class="s1">sf</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">lhs</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = [</span><span class="s1">sf_global</span><span class="s3">]</span>
        <span class="s1">instr</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">sf_global</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_fix_stencil_neighborhood</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">options</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Extract the two-level tuple representing the stencil neighborhood 
        from the program IR to provide a tuple to StencilFunc. 
        &quot;&quot;&quot;</span>
        <span class="s2"># build_tuple node with neighborhood for each dimension</span>
        <span class="s1">dims_build_tuple </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">options</span><span class="s3">[</span><span class="s4">'neighborhood'</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">dims_build_tuple</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">))</span>
        <span class="s1">res </span><span class="s3">= []</span>
        <span class="s0">for </span><span class="s1">window_var </span><span class="s0">in </span><span class="s1">dims_build_tuple</span><span class="s3">.</span><span class="s1">items</span><span class="s3">:</span>
            <span class="s1">win_build_tuple </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">window_var</span><span class="s3">)</span>
            <span class="s1">require</span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">win_build_tuple</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">))</span>
            <span class="s1">res</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">win_build_tuple</span><span class="s3">.</span><span class="s1">items</span><span class="s3">))</span>
        <span class="s1">options</span><span class="s3">[</span><span class="s4">'neighborhood'</span><span class="s3">] = </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">res</span><span class="s3">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_fix_stencil_index_offsets</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">options</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Extract the tuple representing the stencil index offsets 
        from the program IR to provide to StencilFunc. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset_tuple </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">options</span><span class="s3">[</span><span class="s4">'index_offsets'</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">offset_tuple</span><span class="s3">, </span><span class="s4">'items'</span><span class="s3">))</span>
        <span class="s1">options</span><span class="s3">[</span><span class="s4">'index_offsets'</span><span class="s3">] = </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">offset_tuple</span><span class="s3">.</span><span class="s1">items</span><span class="s3">)</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_inline_closure</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">work_list</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">):</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s1">func_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">&quot;make_function&quot;</span><span class="s3">)</span>
        <span class="s1">inline_closure_call</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">,</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__globals__</span><span class="s3">,</span>
                            <span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">, </span><span class="s1">work_list</span><span class="s3">=</span><span class="s1">work_list</span><span class="s3">,</span>
                            <span class="s1">callee_validator</span><span class="s3">=</span><span class="s1">callee_ir_validator</span><span class="s3">)</span>
        <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">check_reduce_func</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">func_var</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Checks the function at func_var in func_ir to make sure it's amenable 
    for inlining. Returns the function itself&quot;&quot;&quot;</span>
    <span class="s1">reduce_func </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">get_definition</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">func_var</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">reduce_func </span><span class="s0">is None</span><span class="s3">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Reduce function cannot be found for njit </span><span class="s0">\ 
                            </span><span class="s4">analysis&quot;</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">reduce_func</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">)):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">reduce_func</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                          <span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">CPUDispatcher</span><span class="s3">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid reduction function&quot;</span><span class="s3">)</span>
        <span class="s2"># pull out the python function for inlining</span>
        <span class="s1">reduce_func </span><span class="s3">= </span><span class="s1">reduce_func</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">py_func</span>
    <span class="s0">elif not </span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">reduce_func</span><span class="s3">, </span><span class="s4">'code'</span><span class="s3">)</span>
              <span class="s0">or </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">reduce_func</span><span class="s3">, </span><span class="s4">'__code__'</span><span class="s3">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid reduction function&quot;</span><span class="s3">)</span>
    <span class="s1">f_code </span><span class="s3">= (</span><span class="s1">reduce_func</span><span class="s3">.</span><span class="s1">code</span>
              <span class="s0">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">reduce_func</span><span class="s3">, </span><span class="s4">'code'</span><span class="s3">)</span>
              <span class="s0">else </span><span class="s1">reduce_func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">)</span>
    <span class="s0">if not </span><span class="s1">f_code</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Reduction function should take 2 arguments&quot;</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">reduce_func</span>


<span class="s0">class </span><span class="s1">InlineWorker</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; A worker class for inlining, this is a more advanced version of 
    `inline_closure_call` in that it permits inlining from function type, Numba 
    IR and code object. It also, runs the entire untyped compiler pipeline on 
    the inlinee to ensure that it is transformed as though it were compiled 
    directly. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">,</span>
                 <span class="s1">typingctx</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">targetctx</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">locals</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">pipeline</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">flags</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">validator</span><span class="s3">=</span><span class="s1">callee_ir_validator</span><span class="s3">,</span>
                 <span class="s1">typemap</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                 <span class="s1">calltypes</span><span class="s3">=</span><span class="s0">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Instantiate a new InlineWorker, all arguments are optional though some 
        must be supplied together for certain use cases. The methods will refuse 
        to run if the object isn't configured in the manner needed. Args are the 
        same as those in a numba.core.Compiler.state, except the validator which 
        is a function taking Numba IR and validating it for use when inlining 
        (this is optional and really to just provide better error messages about 
        things which the inliner cannot handle like yield in closure). 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is None</span><span class="s3">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;{} must not be None&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">DefaultPassBuilder</span>

        <span class="s2"># check the stuff needed to run the more advanced compilation pipeline</span>
        <span class="s2"># is valid if any of it is provided</span>
        <span class="s1">compiler_args </span><span class="s3">= (</span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">locals</span><span class="s3">, </span><span class="s1">pipeline</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">)</span>
        <span class="s1">compiler_group </span><span class="s3">= [</span><span class="s1">x </span><span class="s0">is not None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">compiler_args</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">compiler_group</span><span class="s3">) </span><span class="s0">and not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">compiler_group</span><span class="s3">):</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">targetctx</span><span class="s3">, </span><span class="s4">'targetctx'</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">locals</span><span class="s3">, </span><span class="s4">'locals'</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">pipeline</span><span class="s3">, </span><span class="s4">'pipeline'</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">, </span><span class="s4">'flags'</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s1">all</span><span class="s3">(</span><span class="s1">compiler_group</span><span class="s3">):</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s4">'typingctx'</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_compiler_pipeline </span><span class="s3">= </span><span class="s1">DefaultPassBuilder</span><span class="s3">.</span><span class="s1">define_untyped_pipeline</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx </span><span class="s3">= </span><span class="s1">typingctx</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">targetctx </span><span class="s3">= </span><span class="s1">targetctx</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">locals </span><span class="s3">= </span><span class="s1">locals</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pipeline </span><span class="s3">= </span><span class="s1">pipeline</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">flags</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validator </span><span class="s3">= </span><span class="s1">validator</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;InlineWorker&quot;</span><span class="s3">)</span>

        <span class="s2"># check whether this inliner can also support typemap and calltypes</span>
        <span class="s2"># update and if what's provided is valid</span>
        <span class="s1">pair </span><span class="s3">= (</span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">)</span>
        <span class="s1">pair_is_none </span><span class="s3">= [</span><span class="s1">x </span><span class="s0">is None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">pair</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">pair_is_none</span><span class="s3">) </span><span class="s0">and not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">pair_is_none</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;typemap and calltypes must both be either None or have a &quot;</span>
                   <span class="s4">&quot;value, got: %s, %s&quot;</span><span class="s3">)</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">pair</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_permit_update_type_and_call_maps </span><span class="s3">= </span><span class="s0">not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">pair_is_none</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typemap </span><span class="s3">= </span><span class="s1">typemap</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes </span><span class="s3">= </span><span class="s1">calltypes</span>

    <span class="s0">def </span><span class="s1">inline_ir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">caller_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">callee_freevars</span><span class="s3">,</span>
                  <span class="s1">arg_typs</span><span class="s3">=</span><span class="s0">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Inlines the callee_ir in the caller_ir at statement index i of block 
        `block`, callee_freevars are the free variables for the callee_ir. If 
        the callee_ir is derived from a function `func` then this is 
        `func.__code__.co_freevars`. If `arg_typs` is given and the InlineWorker 
        instance was initialized with a typemap and calltypes then they will be 
        appropriately updated based on the arg_typs. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Always copy the callee IR, it gets mutated</span>
        <span class="s0">def </span><span class="s1">copy_ir</span><span class="s3">(</span><span class="s1">the_ir</span><span class="s3">):</span>
            <span class="s1">kernel_copy </span><span class="s3">= </span><span class="s1">the_ir</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">kernel_copy</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= {}</span>
            <span class="s0">for </span><span class="s1">block_label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">the_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s1">new_block </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">the_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">block_label</span><span class="s3">])</span>
                <span class="s1">kernel_copy</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">block_label</span><span class="s3">] = </span><span class="s1">new_block</span>
            <span class="s0">return </span><span class="s1">kernel_copy</span>

        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">copy_ir</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

        <span class="s2"># check that the contents of the callee IR is something that can be</span>
        <span class="s2"># inlined if a validator is present</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">validator </span><span class="s0">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">validator</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

        <span class="s2"># save an unmutated copy of the callee_ir to return</span>
        <span class="s1">callee_ir_original </span><span class="s3">= </span><span class="s1">copy_ir</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>
        <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
        <span class="s1">instr </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">call_expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span>

        <span class="s2"># 1. relabel callee_ir by adding an offset</span>
        <span class="s1">max_label </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span>
            <span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">next</span><span class="s3">(),</span>
            <span class="s1">max</span><span class="s3">(</span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()),</span>
        <span class="s3">)</span>
        <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">add_offset_to_labels</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">max_label </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">simplify_CFG</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
        <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">callee_blocks</span>
        <span class="s1">min_label </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
        <span class="s1">max_label </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
        <span class="s2">#    reset globals in ir_utils before we use it</span>
        <span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">max_label</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After relabel&quot;</span><span class="s3">)</span>
        <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

        <span class="s2"># 2. rename all local variables in callee_ir with new locals created in</span>
        <span class="s2"># caller_ir</span>
        <span class="s1">callee_scopes </span><span class="s3">= </span><span class="s1">_get_all_scopes</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;callee_scopes = &quot;</span><span class="s3">, </span><span class="s1">callee_scopes</span><span class="s3">)</span>
        <span class="s2">#    one function should only have one local scope</span>
        <span class="s0">assert </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">callee_scopes</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">callee_scope </span><span class="s3">= </span><span class="s1">callee_scopes</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">var_dict </span><span class="s3">= {}</span>
        <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">callee_scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">.</span><span class="s1">_con</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()):</span>
            <span class="s0">if not </span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">callee_freevars</span><span class="s3">):</span>
                <span class="s1">inlined_name </span><span class="s3">= </span><span class="s1">_created_inlined_var_name</span><span class="s3">(</span>
                    <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">unique_name</span><span class="s3">, </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2"># Update the caller scope with the new names</span>
                <span class="s1">new_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s1">inlined_name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">var</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s2"># Also update the callee scope with the new names. Should the</span>
                <span class="s2"># type and call maps need updating (which requires SSA form) the</span>
                <span class="s2"># transformation to SSA is valid as the IR object is internally</span>
                <span class="s2"># consistent.</span>
                <span class="s1">callee_scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s1">inlined_name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">var</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s1">var_dict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">new_var</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;var_dict = &quot;</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
        <span class="s1">replace_vars</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After local var rename&quot;</span><span class="s3">)</span>
        <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

        <span class="s2"># 3. replace formal parameters with actual arguments</span>
        <span class="s1">callee_func </span><span class="s3">= </span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">func</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">_get_callee_args</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">, </span><span class="s1">callee_func</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">loc</span><span class="s3">,</span>
                                <span class="s1">caller_ir</span><span class="s3">)</span>

        <span class="s2"># 4. Update typemap</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_permit_update_type_and_call_maps</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">arg_typs </span><span class="s0">is None</span><span class="s3">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'arg_typs should have a value not None'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">update_type_and_call_maps</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">)</span>
            <span class="s2"># update_type_and_call_maps replaces blocks</span>
            <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After arguments rename: &quot;</span><span class="s3">)</span>
        <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

        <span class="s1">_replace_args_with</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2"># 5. split caller blocks into two</span>
        <span class="s1">new_blocks </span><span class="s3">= []</span>
        <span class="s1">new_block </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">new_block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">:]</span>
        <span class="s1">new_label </span><span class="s3">= </span><span class="s1">next_label</span><span class="s3">()</span>
        <span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">new_label</span><span class="s3">] = </span><span class="s1">new_block</span>
        <span class="s1">new_blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">new_label</span><span class="s3">, </span><span class="s1">new_block</span><span class="s3">))</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">min_label</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># 6. replace Return with assignment to LHS</span>
        <span class="s1">topo_order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
        <span class="s1">_replace_returns</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">new_label</span><span class="s3">)</span>

        <span class="s2"># remove the old definition of instr.target too</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">_definitions</span>
                <span class="s0">and </span><span class="s1">call_expr </span><span class="s0">in </span><span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]):</span>
            <span class="s2"># NOTE: target can have multiple definitions due to control flow</span>
            <span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">)</span>

        <span class="s2"># 7. insert all new blocks, and add back definitions</span>
        <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">topo_order</span><span class="s3">:</span>
            <span class="s2"># block scope must point to parent's</span>
            <span class="s1">block </span><span class="s3">= </span><span class="s1">callee_blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">= </span><span class="s1">scope</span>
            <span class="s1">_add_definitions</span><span class="s3">(</span><span class="s1">caller_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">)</span>
            <span class="s1">caller_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">block</span>
            <span class="s1">new_blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">label</span><span class="s3">, </span><span class="s1">block</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After merge in&quot;</span><span class="s3">)</span>
        <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">caller_ir</span><span class="s3">)</span>

        <span class="s0">return </span><span class="s1">callee_ir_original</span><span class="s3">, </span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">, </span><span class="s1">new_blocks</span>

    <span class="s0">def </span><span class="s1">inline_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">caller_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">=</span><span class="s0">None</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Inlines the function in the caller_ir at statement index i of block 
        `block`. If `arg_typs` is given and the InlineWorker instance was 
        initialized with a typemap and calltypes then they will be appropriately 
        updated based on the arg_typs. 
        &quot;&quot;&quot;</span>
        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">run_untyped_passes</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">freevars </span><span class="s3">= </span><span class="s1">function</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_freevars</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">inline_ir</span><span class="s3">(</span><span class="s1">caller_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">freevars</span><span class="s3">,</span>
                              <span class="s1">arg_typs</span><span class="s3">=</span><span class="s1">arg_typs</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">run_untyped_passes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">enable_ssa</span><span class="s3">=</span><span class="s0">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Run the compiler frontend's untyped passes over the given Python 
        function, and return the function's canonical Numba IR. 
 
        Disable SSA transformation by default, since the call site won't be in 
        SSA form and self.inline_ir depends on this being the case. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">compiler </span><span class="s0">import </span><span class="s1">StateDict</span><span class="s3">, </span><span class="s1">_CompileStatus</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">untyped_passes </span><span class="s0">import </span><span class="s1">ExtractByteCode</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">bytecode</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">parfors</span><span class="s3">.</span><span class="s1">parfor </span><span class="s0">import </span><span class="s1">ParforDiagnostics</span>
        <span class="s1">state </span><span class="s3">= </span><span class="s1">StateDict</span><span class="s3">()</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">targetctx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">targetctx</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">locals </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">locals</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">pipeline </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pipeline</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">enable_ssa </span><span class="s3">= </span><span class="s1">enable_ssa</span>

        <span class="s1">state</span><span class="s3">.</span><span class="s1">func_id </span><span class="s3">= </span><span class="s1">bytecode</span><span class="s3">.</span><span class="s1">FunctionIdentity</span><span class="s3">.</span><span class="s1">from_function</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>

        <span class="s1">state</span><span class="s3">.</span><span class="s1">typemap </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">calltypes </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">type_annotation </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">status </span><span class="s3">= </span><span class="s1">_CompileStatus</span><span class="s3">(</span><span class="s0">False</span><span class="s3">)</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">return_type </span><span class="s3">= </span><span class="s0">None</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">parfor_diagnostics </span><span class="s3">= </span><span class="s1">ParforDiagnostics</span><span class="s3">()</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">metadata </span><span class="s3">= {}</span>

        <span class="s1">ExtractByteCode</span><span class="s3">().</span><span class="s1">run_pass</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
        <span class="s2"># This is a lie, just need *some* args for the case where an obj mode</span>
        <span class="s2"># with lift is needed</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">state</span><span class="s3">.</span><span class="s1">bc</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">pysig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">) * (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">pyobject</span><span class="s3">,)</span>

        <span class="s1">pm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compiler_pipeline</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>

        <span class="s1">pm</span><span class="s3">.</span><span class="s1">finalize</span><span class="s3">()</span>
        <span class="s1">pm</span><span class="s3">.</span><span class="s1">run</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s1">state</span><span class="s3">.</span><span class="s1">func_ir</span>

    <span class="s0">def </span><span class="s1">update_type_and_call_maps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Updates the type and call maps based on calling callee_ir with 
        arguments from arg_typs&quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">ssa </span><span class="s0">import </span><span class="s1">reconstruct_ssa</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typed_passes </span><span class="s0">import </span><span class="s1">PreLowerStripPhis</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_permit_update_type_and_call_maps</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;InlineWorker instance not configured correctly, typemap or &quot;</span>
                   <span class="s4">&quot;calltypes missing in initialization.&quot;</span><span class="s3">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typed_passes</span>
        <span class="s2"># call branch pruning to simplify IR and avoid inference errors</span>
        <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
        <span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">analysis</span><span class="s3">.</span><span class="s1">dead_branch_prune</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">)</span>
        <span class="s2"># callee's typing may require SSA</span>
        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">reconstruct_ssa</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>
        <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
        <span class="s3">[</span><span class="s1">f_typemap</span><span class="s3">,</span>
         <span class="s1">_f_return_type</span><span class="s3">,</span>
         <span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">_</span><span class="s3">] = </span><span class="s1">typed_passes</span><span class="s3">.</span><span class="s1">type_inference_stage</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">, </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">PreLowerStripPhis</span><span class="s3">().</span><span class="s1">_strip_phi_nodes</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>
        <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
        <span class="s1">canonicalize_array_math</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">f_typemap</span><span class="s3">,</span>
                                <span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">)</span>
        <span class="s2"># remove argument entries like arg.a from typemap</span>
        <span class="s1">arg_names </span><span class="s3">= [</span><span class="s1">vname </span><span class="s0">for </span><span class="s1">vname </span><span class="s0">in </span><span class="s1">f_typemap </span><span class="s0">if </span><span class="s1">vname</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;arg.&quot;</span><span class="s3">)]</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arg_names</span><span class="s3">:</span>
            <span class="s1">f_typemap</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typemap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_typemap</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">calltypes</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_calltypes</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">inline_closure_call</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                        <span class="s1">targetctx</span><span class="s3">=</span><span class="s0">None</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">=</span><span class="s0">None</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                        <span class="s1">calltypes</span><span class="s3">=</span><span class="s0">None</span><span class="s3">, </span><span class="s1">work_list</span><span class="s3">=</span><span class="s0">None</span><span class="s3">, </span><span class="s1">callee_validator</span><span class="s3">=</span><span class="s0">None</span><span class="s3">,</span>
                        <span class="s1">replace_freevars</span><span class="s3">=</span><span class="s0">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Inline the body of `callee` at its callsite (`i`-th instruction of 
    `block`) 
 
    `func_ir` is the func_ir object of the caller function and `glbls` is its 
    global variable environment (func_ir.func_id.func.__globals__). 
    `block` is the IR block of the callsite and `i` is the index of the 
    callsite's node. `callee` is either the called function or a 
    make_function node. `typingctx`, `typemap` and `calltypes` are typing 
    data structures of the caller, available if we are in a typed pass. 
    `arg_typs` includes the types of the arguments at the callsite. 
    `callee_validator` is an optional callable which can be used to validate the 
    IR of the callee to ensure that it contains IR supported for inlining, it 
    takes one argument, the func_ir of the callee 
 
    Returns IR blocks of the callee and the variable renaming dictionary used 
    for them to facilitate further processing of new blocks. 
    &quot;&quot;&quot;</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s1">instr </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">call_expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
    <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;inline_closure_call&quot;</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;Found closure call: &quot;</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">, </span><span class="s4">&quot; with callee = &quot;</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">)</span>
    <span class="s2"># support both function object and make_function Expr</span>
    <span class="s1">callee_code </span><span class="s3">= </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">code </span><span class="s0">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s4">'code'</span><span class="s3">) </span><span class="s0">else </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">__code__</span>
    <span class="s1">callee_closure </span><span class="s3">= (</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">closure</span>
                      <span class="s0">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s4">'closure'</span><span class="s3">) </span><span class="s0">else </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">__closure__</span><span class="s3">)</span>
    <span class="s2"># first, get the IR of the callee</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">compiler</span>
        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">compiler</span><span class="s3">.</span><span class="s1">run_frontend</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">inline_closures</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s1">callee_ir </span><span class="s3">= </span><span class="s1">get_ir_of_code</span><span class="s3">(</span><span class="s1">glbls</span><span class="s3">, </span><span class="s1">callee_code</span><span class="s3">)</span>

    <span class="s2"># check that the contents of the callee IR is something that can be inlined</span>
    <span class="s2"># if a validator is supplied</span>
    <span class="s0">if </span><span class="s1">callee_validator </span><span class="s0">is not None</span><span class="s3">:</span>
        <span class="s1">callee_validator</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

    <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span>

    <span class="s2"># 1. relabel callee_ir by adding an offset</span>
    <span class="s1">max_label </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">next</span><span class="s3">(), </span><span class="s1">max</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()))</span>
    <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">add_offset_to_labels</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">max_label </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">callee_blocks </span><span class="s3">= </span><span class="s1">simplify_CFG</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
    <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks </span><span class="s3">= </span><span class="s1">callee_blocks</span>
    <span class="s1">min_label </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s1">max_label </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s2">#    reset globals in ir_utils before we use it</span>
    <span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">_the_max_label</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">max_label</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After relabel&quot;</span><span class="s3">)</span>
    <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

    <span class="s2"># 2. rename all local variables in callee_ir with new locals created in</span>
    <span class="s2">#    func_ir</span>
    <span class="s1">callee_scopes </span><span class="s3">= </span><span class="s1">_get_all_scopes</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;callee_scopes = &quot;</span><span class="s3">, </span><span class="s1">callee_scopes</span><span class="s3">)</span>
    <span class="s2">#    one function should only have one local scope</span>
    <span class="s0">assert </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">callee_scopes</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">callee_scope </span><span class="s3">= </span><span class="s1">callee_scopes</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s1">var_dict </span><span class="s3">= {}</span>
    <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">callee_scope</span><span class="s3">.</span><span class="s1">localvars</span><span class="s3">.</span><span class="s1">_con</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
        <span class="s0">if not </span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">callee_code</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">):</span>
            <span class="s1">inlined_name </span><span class="s3">= </span><span class="s1">_created_inlined_var_name</span><span class="s3">(</span>
                <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">func_id</span><span class="s3">.</span><span class="s1">unique_name</span><span class="s3">, </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">new_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s1">inlined_name</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">var</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">var_dict</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">new_var</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;var_dict = &quot;</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
    <span class="s1">replace_vars</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">var_dict</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After local var rename&quot;</span><span class="s3">)</span>
    <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

    <span class="s2"># 3. replace formal parameters with actual arguments</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">_get_callee_args</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">)</span>

    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After arguments rename: &quot;</span><span class="s3">)</span>
    <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

    <span class="s2"># 4. replace freevar with actual closure var</span>
    <span class="s0">if </span><span class="s1">callee_closure </span><span class="s0">and </span><span class="s1">replace_freevars</span><span class="s3">:</span>
        <span class="s1">closure </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">callee_closure</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;callee's closure = &quot;</span><span class="s3">, </span><span class="s1">closure</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">closure</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">cellget </span><span class="s3">= </span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">pythonapi</span><span class="s3">.</span><span class="s1">PyCell_Get</span>
            <span class="s1">cellget</span><span class="s3">.</span><span class="s1">restype </span><span class="s3">= </span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">py_object</span>
            <span class="s1">cellget</span><span class="s3">.</span><span class="s1">argtypes </span><span class="s3">= (</span><span class="s1">ctypes</span><span class="s3">.</span><span class="s1">py_object</span><span class="s3">,)</span>
            <span class="s1">items </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">cellget</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">closure</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s0">assert </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">closure</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">)</span>
                    <span class="s0">and </span><span class="s1">closure</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'build_tuple'</span><span class="s3">)</span>
            <span class="s1">items </span><span class="s3">= </span><span class="s1">closure</span><span class="s3">.</span><span class="s1">items</span>
        <span class="s0">assert </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">callee_code</span><span class="s3">.</span><span class="s1">co_freevars</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">))</span>
        <span class="s1">_replace_freevars</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">items</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After closure rename&quot;</span><span class="s3">)</span>
        <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">)</span>

    <span class="s0">if </span><span class="s1">typingctx</span><span class="s3">:</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typed_passes</span>
        <span class="s2"># call branch pruning to simplify IR and avoid inference errors</span>
        <span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">_definitions </span><span class="s3">= </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">build_definitions</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">)</span>
        <span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">analysis</span><span class="s3">.</span><span class="s1">dead_branch_prune</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">)</span>
        <span class="s0">try</span><span class="s3">:</span>
            <span class="s3">[</span><span class="s1">f_typemap</span><span class="s3">, </span><span class="s1">f_return_type</span><span class="s3">,</span>
             <span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">_</span><span class="s3">] = </span><span class="s1">typed_passes</span><span class="s3">.</span><span class="s1">type_inference_stage</span><span class="s3">(</span>
                <span class="s1">typingctx</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s3">:</span>
            <span class="s3">[</span><span class="s1">f_typemap</span><span class="s3">, </span><span class="s1">f_return_type</span><span class="s3">,</span>
             <span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">_</span><span class="s3">] = </span><span class="s1">typed_passes</span><span class="s3">.</span><span class="s1">type_inference_stage</span><span class="s3">(</span>
                <span class="s1">typingctx</span><span class="s3">, </span><span class="s1">targetctx</span><span class="s3">, </span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">arg_typs</span><span class="s3">, </span><span class="s0">None</span><span class="s3">)</span>
        <span class="s1">canonicalize_array_math</span><span class="s3">(</span><span class="s1">callee_ir</span><span class="s3">, </span><span class="s1">f_typemap</span><span class="s3">,</span>
                                <span class="s1">f_calltypes</span><span class="s3">, </span><span class="s1">typingctx</span><span class="s3">)</span>
        <span class="s2"># remove argument entries like arg.a from typemap</span>
        <span class="s1">arg_names </span><span class="s3">= [</span><span class="s1">vname </span><span class="s0">for </span><span class="s1">vname </span><span class="s0">in </span><span class="s1">f_typemap </span><span class="s0">if </span><span class="s1">vname</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;arg.&quot;</span><span class="s3">)]</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arg_names</span><span class="s3">:</span>
            <span class="s1">f_typemap</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">typemap</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_typemap</span><span class="s3">)</span>
        <span class="s1">calltypes</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f_calltypes</span><span class="s3">)</span>

    <span class="s1">_replace_args_with</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2"># 5. split caller blocks into two</span>
    <span class="s1">new_blocks </span><span class="s3">= []</span>
    <span class="s1">new_block </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Block</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">block</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">new_block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">:]</span>
    <span class="s1">new_label </span><span class="s3">= </span><span class="s1">next_label</span><span class="s3">()</span>
    <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">new_label</span><span class="s3">] = </span><span class="s1">new_block</span>
    <span class="s1">new_blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">new_label</span><span class="s3">, </span><span class="s1">new_block</span><span class="s3">))</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">min_label</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2"># 6. replace Return with assignment to LHS</span>
    <span class="s1">topo_order </span><span class="s3">= </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">)</span>
    <span class="s1">_replace_returns</span><span class="s3">(</span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">new_label</span><span class="s3">)</span>

    <span class="s2"># remove the old definition of instr.target too</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span>
            <span class="s0">and </span><span class="s1">call_expr </span><span class="s0">in </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]):</span>
        <span class="s2"># NOTE: target can have multiple definitions due to control flow</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">)</span>

    <span class="s2"># 7. insert all new blocks, and add back definitions</span>
    <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">topo_order</span><span class="s3">:</span>
        <span class="s2"># block scope must point to parent's</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">callee_blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s1">block</span><span class="s3">.</span><span class="s1">scope </span><span class="s3">= </span><span class="s1">scope</span>
        <span class="s1">_add_definitions</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">)</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">block</span>
        <span class="s1">new_blocks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">label</span><span class="s3">, </span><span class="s1">block</span><span class="s3">))</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;After merge in&quot;</span><span class="s3">)</span>
    <span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">)</span>

    <span class="s0">if </span><span class="s1">work_list </span><span class="s0">is not None</span><span class="s3">:</span>
        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">new_blocks</span><span class="s3">:</span>
            <span class="s1">work_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">block</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">callee_blocks</span><span class="s3">, </span><span class="s1">var_dict</span>


<span class="s0">def </span><span class="s1">_get_callee_args</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Get arguments for calling 'callee', including the default arguments. 
    keyword arguments are currently only handled when 'callee' is a function. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">vararg</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Calling a closure with *args is unsupported.&quot;</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">UnsupportedError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0">elif </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'getattr'</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= [</span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">]</span>
    <span class="s0">elif </span><span class="s1">ir_utils</span><span class="s3">.</span><span class="s1">is_operator_or_getitem</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">()</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Unsupported ir.Expr.{}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">op</span><span class="s3">))</span>

    <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;inline_closure_call default handling&quot;</span><span class="s3">)</span>

    <span class="s2"># handle defaults and kw arguments using pysignature if callee is function</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">pytypes</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
        <span class="s1">pysig </span><span class="s3">= </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">pysignature</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">)</span>
        <span class="s1">normal_handler </span><span class="s3">= </span><span class="s0">lambda </span><span class="s1">index</span><span class="s3">, </span><span class="s1">param</span><span class="s3">, </span><span class="s1">default</span><span class="s3">: </span><span class="s1">default</span>
        <span class="s1">default_handler </span><span class="s3">= </span><span class="s0">lambda </span><span class="s1">index</span><span class="s3">, </span><span class="s1">param</span><span class="s3">, </span><span class="s1">default</span><span class="s3">: </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">default</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>

        <span class="s2"># Throw error for stararg</span>
        <span class="s2"># TODO: handle stararg</span>
        <span class="s0">def </span><span class="s1">stararg_handler</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">param</span><span class="s3">, </span><span class="s1">default</span><span class="s3">):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                <span class="s4">&quot;Stararg not supported in inliner for arg {} {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                    <span class="s1">index</span><span class="s3">, </span><span class="s1">param</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">:</span>
            <span class="s1">kws </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">call_expr</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">kws </span><span class="s3">= {}</span>
        <span class="s0">return </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">fold_arguments</span><span class="s3">(</span>
            <span class="s1">pysig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kws</span><span class="s3">, </span><span class="s1">normal_handler</span><span class="s3">, </span><span class="s1">default_handler</span><span class="s3">,</span>
            <span class="s1">stararg_handler</span><span class="s3">)</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s2"># TODO: handle arguments for make_function case similar to function</span>
        <span class="s2"># case above</span>
        <span class="s1">callee_defaults </span><span class="s3">= (</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">defaults </span><span class="s0">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s4">'defaults'</span><span class="s3">)</span>
                           <span class="s0">else </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">__defaults__</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">callee_defaults</span><span class="s3">:</span>
            <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;defaults = &quot;</span><span class="s3">, </span><span class="s1">callee_defaults</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_defaults</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):  </span><span class="s2"># Python 3.5</span>
                <span class="s1">defaults_list </span><span class="s3">= []</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">callee_defaults</span><span class="s3">:</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                        <span class="s1">defaults_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                    <span class="s0">else</span><span class="s3">:</span>
                        <span class="s2"># this branch is predominantly for kwargs from</span>
                        <span class="s2"># inlinable functions</span>
                        <span class="s1">defaults_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">x</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">))</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">args </span><span class="s3">+ </span><span class="s1">defaults_list</span>
            <span class="s0">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_defaults</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)</span>
                    <span class="s0">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_defaults</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)):</span>
                <span class="s1">default_tuple </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">callee_defaults</span><span class="s3">)</span>
                <span class="s0">assert </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">default_tuple</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">))</span>
                <span class="s0">assert </span><span class="s3">(</span><span class="s1">default_tuple</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">&quot;build_tuple&quot;</span><span class="s3">)</span>
                <span class="s1">const_vals </span><span class="s3">= [</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s0">for</span>
                              <span class="s1">x </span><span class="s0">in </span><span class="s1">default_tuple</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">args </span><span class="s3">+ </span><span class="s1">const_vals</span>
            <span class="s0">else</span><span class="s3">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                    <span class="s4">&quot;Unsupported defaults to make_function: {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">callee_defaults</span><span class="s3">))</span>
        <span class="s0">return </span><span class="s1">args</span>


<span class="s0">def </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">):</span>
    <span class="s0">def </span><span class="s1">debug_print</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_INLINE_CLOSURE</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s1">prefix </span><span class="s3">+ </span><span class="s4">&quot;: &quot; </span><span class="s3">+ </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args</span><span class="s3">))</span>
    <span class="s0">return </span><span class="s1">debug_print</span>


<span class="s0">def </span><span class="s1">_debug_dump</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s0">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">DEBUG_INLINE_CLOSURE</span><span class="s3">:</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">()</span>


<span class="s0">def </span><span class="s1">_get_all_scopes</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Get all block-local scopes from an IR. 
    &quot;&quot;&quot;</span>
    <span class="s1">all_scopes </span><span class="s3">= []</span>
    <span class="s0">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s0">if not </span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope </span><span class="s0">in </span><span class="s1">all_scopes</span><span class="s3">):</span>
            <span class="s1">all_scopes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">all_scopes</span>


<span class="s0">def </span><span class="s1">_replace_args_with</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Replace ir.Arg(...) with real arguments from call site 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">assigns </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">assigns</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Arg</span><span class="s3">):</span>
                <span class="s1">idx </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index</span>
                <span class="s0">assert </span><span class="s3">(</span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>
                <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>


<span class="s0">def </span><span class="s1">_replace_freevars</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Replace ir.FreeVar(...) with real variables from parent function 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">assigns </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">assigns</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FreeVar</span><span class="s3">):</span>
                <span class="s1">idx </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">index</span>
                <span class="s0">assert </span><span class="s3">(</span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                    <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>
                <span class="s0">else</span><span class="s3">:</span>
                    <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">], </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_replace_returns</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">return_label</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return return statement by assigning directly to target, and a jump. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">casts </span><span class="s3">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)):</span>
            <span class="s1">stmt </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">):</span>
                <span class="s0">assert </span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">))</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Jump</span><span class="s3">(</span><span class="s1">return_label</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">))</span>
                <span class="s2"># remove cast of the returned value</span>
                <span class="s0">for </span><span class="s1">cast </span><span class="s0">in </span><span class="s1">casts</span><span class="s3">:</span>
                    <span class="s0">if </span><span class="s1">cast</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                        <span class="s1">cast</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s0">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s0">and</span>
                    <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
                    <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'cast'</span><span class="s3">):</span>
                <span class="s1">casts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_add_definitions</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Add variable definitions found in a block to parent func_ir. 
    &quot;&quot;&quot;</span>
    <span class="s1">definitions </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span>
    <span class="s1">assigns </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">)</span>
    <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">assigns</span><span class="s3">:</span>
        <span class="s1">definitions</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_find_arraycall</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Look for statement like &quot;x = numpy.array(y)&quot; or &quot;x[..] = y&quot; 
    immediately after the closure call that creates list y (the i-th 
    statement in block).  Return the statement index if found, or 
    raise GuardException. 
    &quot;&quot;&quot;</span>
    <span class="s1">array_var </span><span class="s3">= </span><span class="s0">None</span>
    <span class="s1">list_var_dead_after_array_call </span><span class="s3">= </span><span class="s0">False</span>
    <span class="s1">list_var </span><span class="s3">= </span><span class="s0">None</span>

    <span class="s1">i </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s0">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">):</span>
        <span class="s1">instr </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">):</span>
            <span class="s2"># Stop the process if list_var becomes dead</span>
            <span class="s0">if </span><span class="s1">list_var </span><span class="s0">and </span><span class="s1">array_var </span><span class="s0">and </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value </span><span class="s3">== </span><span class="s1">list_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                <span class="s1">list_var_dead_after_array_call </span><span class="s3">= </span><span class="s0">True</span>
                <span class="s0">break</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s2"># Found array_var = array(list_var)</span>
            <span class="s1">lhs </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span>
            <span class="s1">expr </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">) == (</span><span class="s4">'array'</span><span class="s3">, </span><span class="s4">'numpy'</span><span class="s3">) </span><span class="s0">and</span>
                    <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">)):</span>
                <span class="s1">list_var </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s1">array_var </span><span class="s3">= </span><span class="s1">lhs</span>
                <span class="s1">array_stmt_index </span><span class="s3">= </span><span class="s1">i</span>
                <span class="s1">array_kws </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">kws</span><span class="s3">)</span>
        <span class="s0">elif </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">) </span><span class="s0">and</span>
              <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">) </span><span class="s0">and</span>
              <span class="s0">not </span><span class="s1">list_var</span><span class="s3">):</span>
            <span class="s1">list_var </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s2"># Found array_var[..] = list_var, the case for nested array</span>
            <span class="s1">array_var </span><span class="s3">= </span><span class="s1">instr</span><span class="s3">.</span><span class="s1">target</span>
            <span class="s1">array_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">array_var</span><span class="s3">)</span>
            <span class="s1">require</span><span class="s3">(</span><span class="s1">guard</span><span class="s3">(</span><span class="s1">_find_unsafe_empty_inferred</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">array_def</span><span class="s3">))</span>
            <span class="s1">array_stmt_index </span><span class="s3">= </span><span class="s1">i</span>
            <span class="s1">array_kws </span><span class="s3">= {}</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s2"># Bail out otherwise</span>
            <span class="s0">break</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span>
    <span class="s2"># require array_var is found, and list_var is dead after array_call.</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">array_var </span><span class="s0">and </span><span class="s1">list_var_dead_after_array_call</span><span class="s3">)</span>
    <span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;find_array_call&quot;</span><span class="s3">)(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">array_stmt_index</span><span class="s3">])</span>
    <span class="s0">return </span><span class="s1">list_var</span><span class="s3">, </span><span class="s1">array_stmt_index</span><span class="s3">, </span><span class="s1">array_kws</span>


<span class="s0">def </span><span class="s1">_find_iter_range</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_iter_var</span><span class="s3">, </span><span class="s1">swapped</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Find the iterator's actual range if it is either range(n), or 
    range(m, n), otherwise return raise GuardException. 
    &quot;&quot;&quot;</span>
    <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;find_iter_range&quot;</span><span class="s3">)</span>
    <span class="s1">range_iter_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_iter_var</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;range_iter_var = &quot;</span><span class="s3">, </span><span class="s1">range_iter_var</span><span class="s3">, </span><span class="s4">&quot; def = &quot;</span><span class="s3">, </span><span class="s1">range_iter_def</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">range_iter_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
            <span class="s1">range_iter_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'getiter'</span><span class="s3">)</span>
    <span class="s1">range_var </span><span class="s3">= </span><span class="s1">range_iter_def</span><span class="s3">.</span><span class="s1">value</span>
    <span class="s1">range_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_var</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;range_var = &quot;</span><span class="s3">, </span><span class="s1">range_var</span><span class="s3">, </span><span class="s4">&quot; range_def = &quot;</span><span class="s3">, </span><span class="s1">range_def</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">range_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">)</span>
    <span class="s1">func_var </span><span class="s3">= </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">func</span>
    <span class="s1">func_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">func_var</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;func_var = &quot;</span><span class="s3">, </span><span class="s1">func_var</span><span class="s3">, </span><span class="s4">&quot; func_def = &quot;</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">) </span><span class="s0">and</span>
            <span class="s3">(</span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">value </span><span class="s3">== </span><span class="s1">range </span><span class="s0">or</span>
             <span class="s1">func_def</span><span class="s3">.</span><span class="s1">value </span><span class="s3">== </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">prange</span><span class="s3">))</span>
    <span class="s1">nargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">swapping </span><span class="s3">= [(</span><span class="s4">'&quot;array comprehension&quot;'</span><span class="s3">, </span><span class="s4">'closure of'</span><span class="s3">), </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">]</span>
    <span class="s0">if </span><span class="s1">nargs </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">swapped</span><span class="s3">[</span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">swapping</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">lhs_only</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">func_def</span><span class="s3">)</span>
    <span class="s0">elif </span><span class="s1">nargs </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">swapped</span><span class="s3">[</span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">swapping</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">lhs_only</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">range_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">lhs_only</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">)</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s0">raise </span><span class="s1">GuardException</span>


<span class="s3">@</span><span class="s1">intrinsic</span>
<span class="s0">def </span><span class="s1">length_of_iterator</span><span class="s3">(</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    An implementation of len(iter) for internal use. 
    Primary use is for array comprehensions (see inline_closurecall). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">RangeIteratorType</span><span class="s3">):</span>
        <span class="s1">val_type </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">yield_type</span>

        <span class="s0">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">value</span><span class="s3">,) = </span><span class="s1">args</span>
            <span class="s1">iter_type </span><span class="s3">= </span><span class="s1">range_impl_map</span><span class="s3">[</span><span class="s1">val_type</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">iter_type</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                                             <span class="s1">value</span><span class="s3">)</span>
            <span class="s1">int_type </span><span class="s3">= </span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">count</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">int_type</span><span class="s3">,</span>
                                      <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">count</span><span class="s3">))</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">val_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">), </span><span class="s1">codegen</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ListIter</span><span class="s3">):</span>
        <span class="s0">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">value</span><span class="s3">,) = </span><span class="s1">args</span>
            <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">ListIterInstance</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">val</span><span class="s3">), </span><span class="s1">codegen</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayIterator</span><span class="s3">):</span>
        <span class="s0">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">iterty</span><span class="s3">,) = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
            <span class="s3">(</span><span class="s1">value</span><span class="s3">,) = </span><span class="s1">args</span>
            <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">arrayty </span><span class="s3">= </span><span class="s1">iterty</span><span class="s3">.</span><span class="s1">array_type</span>
            <span class="s1">ary </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">arrayty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">array</span><span class="s3">)</span>
            <span class="s1">shape </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s2"># array iterates along the outer dimension</span>
            <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">val</span><span class="s3">), </span><span class="s1">codegen</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTupleIter</span><span class="s3">):</span>
        <span class="s0">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">iterty</span><span class="s3">,) = </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
            <span class="s1">tuplety </span><span class="s3">= </span><span class="s1">iterty</span><span class="s3">.</span><span class="s1">container</span>
            <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">count_const </span><span class="s3">= </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">tuplety</span><span class="s3">.</span><span class="s1">count</span><span class="s3">)</span>
            <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">count_const</span><span class="s3">)</span>

        <span class="s0">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">val</span><span class="s3">), </span><span class="s1">codegen</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ListTypeIteratorType</span><span class="s3">):</span>
        <span class="s0">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">value</span><span class="s3">,) = </span><span class="s1">args</span>
            <span class="s1">intp_t </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s0">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">typed</span><span class="s3">.</span><span class="s1">listobject </span><span class="s0">import </span><span class="s1">ListIterInstance</span>
            <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">ListIterInstance</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">iterobj</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">val</span><span class="s3">), </span><span class="s1">codegen</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'Unsupported iterator found in array comprehension, try '</span>
               <span class="s4">'preallocating the array and filling manually.'</span><span class="s3">)</span>
        <span class="s0">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_inline_arraycall</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">cfg</span><span class="s3">, </span><span class="s1">visited</span><span class="s3">, </span><span class="s1">loop</span><span class="s3">, </span><span class="s1">swapped</span><span class="s3">, </span><span class="s1">enable_prange</span><span class="s3">=</span><span class="s0">False</span><span class="s3">,</span>
                      <span class="s1">typed</span><span class="s3">=</span><span class="s0">False</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Look for array(list) call in the exit block of a given loop, and turn 
    list operations into array operations in the loop if the following 
    conditions are met: 
      1. The exit block contains an array call on the list; 
      2. The list variable is no longer live after array call; 
      3. The list is created in the loop entry block; 
      4. The loop is created from an range iterator whose length is known prior 
         to the loop; 
      5. There is only one list_append operation on the list variable in the 
         loop body; 
      6. The block that contains list_append dominates the loop head, which 
         ensures list length is the same as loop length; 
    If any condition check fails, no modification will be made to the incoming 
    IR. 
    &quot;&quot;&quot;</span>
    <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;inline_arraycall&quot;</span><span class="s3">)</span>
    <span class="s2"># There should only be one loop exit</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">exits</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">exit_block </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">exits</span><span class="s3">))</span>
    <span class="s1">list_var</span><span class="s3">, </span><span class="s1">array_call_index</span><span class="s3">, </span><span class="s1">array_kws </span><span class="s3">= </span><span class="s1">_find_arraycall</span><span class="s3">(</span>
        <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">exit_block</span><span class="s3">],</span>
    <span class="s3">)</span>

    <span class="s2"># check if dtype is present in array call</span>
    <span class="s1">dtype_def </span><span class="s3">= </span><span class="s0">None</span>
    <span class="s1">dtype_mod_def </span><span class="s3">= </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s4">'dtype' </span><span class="s0">in </span><span class="s1">array_kws</span><span class="s3">:</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array_kws</span><span class="s3">[</span><span class="s4">'dtype'</span><span class="s3">], </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">))</span>
        <span class="s2"># We require that dtype argument to be a constant of getattr Expr, and</span>
        <span class="s2"># we'll remember its definition for later use.</span>
        <span class="s1">dtype_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">array_kws</span><span class="s3">[</span><span class="s4">'dtype'</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">dtype_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'getattr'</span><span class="s3">)</span>
        <span class="s1">dtype_mod_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">dtype_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s1">list_var_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">list_var</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;list_var = &quot;</span><span class="s3">, </span><span class="s1">list_var</span><span class="s3">, </span><span class="s4">&quot; def = &quot;</span><span class="s3">, </span><span class="s1">list_var_def</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">list_var_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">list_var_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'cast'</span><span class="s3">:</span>
        <span class="s1">list_var_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">list_var_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2"># Check if the definition is a build_list</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">list_var_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
            <span class="s1">list_var_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'build_list'</span><span class="s3">)</span>
    <span class="s2"># The build_list must be empty</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">list_var_def</span><span class="s3">.</span><span class="s1">items</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2"># Look for list_append in &quot;last&quot; block in loop body, which should be a block</span>
    <span class="s2"># that is a post-dominator of the loop header.</span>
    <span class="s1">list_append_stmts </span><span class="s3">= []</span>
    <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">loop</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
        <span class="s2"># We have to consider blocks of this loop, but not sub-loops.</span>
        <span class="s2"># To achieve this, we require the set of &quot;in_loops&quot; of &quot;label&quot; to be</span>
        <span class="s2"># visited loops.</span>
        <span class="s1">in_visited_loops </span><span class="s3">= [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">header </span><span class="s0">in </span><span class="s1">visited </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">in_loops</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)]</span>
        <span class="s0">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">in_visited_loops</span><span class="s3">):</span>
            <span class="s0">continue</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;check loop body block &quot;</span><span class="s3">, </span><span class="s1">label</span><span class="s3">)</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s1">expr </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">:</span>
                <span class="s1">func_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">func</span><span class="s3">)</span>
                <span class="s0">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'getattr'</span>
                        <span class="s0">and </span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">== </span><span class="s4">'append'</span><span class="s3">):</span>
                    <span class="s1">list_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">func_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;list_def = &quot;</span><span class="s3">, </span><span class="s1">list_def</span><span class="s3">,</span>
                                <span class="s1">list_def </span><span class="s0">is </span><span class="s1">list_var_def</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">list_def </span><span class="s0">is </span><span class="s1">list_var_def</span><span class="s3">:</span>
                        <span class="s2"># found matching append call</span>
                        <span class="s1">list_append_stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">label</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">))</span>

    <span class="s2"># Require only one list_append, otherwise we won't know the indices</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">list_append_stmts</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">append_block_label</span><span class="s3">, </span><span class="s1">append_block</span><span class="s3">, </span><span class="s1">append_stmt </span><span class="s3">= </span><span class="s1">list_append_stmts</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2"># Check if append_block (besides loop entry) dominates loop header.</span>
    <span class="s2"># Since CFG doesn't give us this info without loop entry, we approximate</span>
    <span class="s2"># by checking if the predecessor set of the header block is the same</span>
    <span class="s2"># as loop_entries plus append_block, which is certainly more restrictive</span>
    <span class="s2"># than necessary, and can be relaxed if needed.</span>
    <span class="s1">preds </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">l </span><span class="s0">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">predecessors</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">header</span><span class="s3">))</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;preds = &quot;</span><span class="s3">, </span><span class="s1">preds</span><span class="s3">, (</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">entries </span><span class="s3">| </span><span class="s1">set</span><span class="s3">([</span><span class="s1">append_block_label</span><span class="s3">])))</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">preds </span><span class="s3">== (</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">entries </span><span class="s3">| </span><span class="s1">set</span><span class="s3">([</span><span class="s1">append_block_label</span><span class="s3">])))</span>

    <span class="s2"># Find iterator in loop header</span>
    <span class="s1">iter_vars </span><span class="s3">= []</span>
    <span class="s1">iter_first_vars </span><span class="s3">= []</span>
    <span class="s1">loop_header </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">header</span><span class="s3">]</span>
    <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">loop_header</span><span class="s3">.</span><span class="s1">find_insts</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'iternext'</span><span class="s3">:</span>
                <span class="s1">iter_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
                <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;iter_def = &quot;</span><span class="s3">, </span><span class="s1">iter_def</span><span class="s3">)</span>
                <span class="s1">iter_vars</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s0">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'pair_first'</span><span class="s3">:</span>
                <span class="s1">iter_first_vars</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>

    <span class="s2"># Require only one iterator in loop header</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">iter_vars</span><span class="s3">) == </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">iter_first_vars</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s2"># variable that holds the iterator object</span>
    <span class="s1">iter_var </span><span class="s3">= </span><span class="s1">iter_vars</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s2"># variable that holds the value out of iterator</span>
    <span class="s1">iter_first_var </span><span class="s3">= </span><span class="s1">iter_first_vars</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2"># Final requirement: only one loop entry, and we're going to modify it by:</span>
    <span class="s2"># 1. replacing the list definition with an array definition;</span>
    <span class="s2"># 2. adding a counter for the array iteration.</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">loop_entry </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">))]</span>
    <span class="s1">terminator </span><span class="s3">= </span><span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">terminator</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s3">= </span><span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">loc</span>
    <span class="s1">stmts </span><span class="s3">= []</span>
    <span class="s1">removed </span><span class="s3">= []</span>

    <span class="s0">def </span><span class="s1">is_removed</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">removed</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">removed</span><span class="s3">:</span>
                <span class="s0">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s1">val</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                    <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s2"># Skip list construction and skip terminator, add the rest to stmts</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s1">stmt </span><span class="s3">= </span><span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">list_def </span><span class="s0">or </span><span class="s1">is_removed</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">removed</span><span class="s3">))):</span>
            <span class="s1">removed</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>
    <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;removed variables: &quot;</span><span class="s3">, </span><span class="s1">removed</span><span class="s3">)</span>

    <span class="s2"># Define an index_var to index the array.</span>
    <span class="s2"># If the range happens to be single step ranges like range(n), or</span>
    <span class="s2"># range(m, n), then the index_var correlates to iterator index; otherwise</span>
    <span class="s2"># we'll have to define a new counter.</span>
    <span class="s1">range_def </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">_find_iter_range</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">iter_var</span><span class="s3">, </span><span class="s1">swapped</span><span class="s3">)</span>
    <span class="s1">index_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">range_def </span><span class="s0">and </span><span class="s1">range_def</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2"># iterator starts with 0, index_var can just be iter_first_var</span>
        <span class="s1">index_var </span><span class="s3">= </span><span class="s1">iter_first_var</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s2"># index_var = -1 # starting the index with -1 since it will incremented</span>
        <span class="s2"># in loop header</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">,</span>
                                     <span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2"># Insert statement to get the size of the loop iterator</span>
    <span class="s1">size_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;size&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">range_def</span><span class="s3">:</span>
        <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">range_func_def </span><span class="s3">= </span><span class="s1">range_def</span>
        <span class="s0">if </span><span class="s1">start </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">size_val </span><span class="s3">= </span><span class="s1">stop</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s1">size_val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">=</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">=</span><span class="s1">start</span><span class="s3">,</span>
                                     <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2"># we can parallelize this loop if enable_prange = True, by changing</span>
        <span class="s2"># range function from range, to prange.</span>
        <span class="s0">if </span><span class="s1">enable_prange </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">range_func_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">):</span>
            <span class="s1">range_func_def</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s4">'internal_prange'</span>
            <span class="s1">range_func_def</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">internal_prange</span>

    <span class="s0">else</span><span class="s3">:</span>
        <span class="s2"># this doesn't work in objmode as it's effectively untyped</span>
        <span class="s0">if </span><span class="s1">typed</span><span class="s3">:</span>
            <span class="s1">len_func_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;len_func&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">len_func_var</span><span class="s3">,</span>
                                         <span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'length_of_iterator'</span><span class="s3">,</span>
                                                   <span class="s1">length_of_iterator</span><span class="s3">,</span>
                                                   <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">),</span>
                                         <span class="s1">loc</span><span class="s3">))</span>
            <span class="s1">size_val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">len_func_var</span><span class="s3">, (</span><span class="s1">iter_var</span><span class="s3">,), (), </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s0">raise </span><span class="s1">GuardException</span>

    <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">size_val</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s1">size_tuple_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;size_tuple&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">size_tuple_var</span><span class="s3">,</span>
                 <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">build_tuple</span><span class="s3">(</span><span class="s1">items</span><span class="s3">=[</span><span class="s1">size_var</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2"># Insert array allocation</span>
    <span class="s1">array_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;array&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s1">empty_func </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;empty_func&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s1">dtype_def </span><span class="s0">and </span><span class="s1">dtype_mod_def</span><span class="s3">:</span>
        <span class="s2"># when dtype is present, we'll call empty with dtype</span>
        <span class="s1">dtype_mod_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;dtype_mod&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">dtype_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span>
            <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">dtype_mod_var</span><span class="s3">, </span><span class="s1">dtype_mod_def</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span>
            <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">dtype_var</span><span class="s3">,</span>
            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype_mod_var</span><span class="s3">, </span><span class="s1">dtype_def</span><span class="s3">.</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span>
            <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">empty_func</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'empty'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s1">array_kws </span><span class="s3">= [(</span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s1">dtype_var</span><span class="s3">)]</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s2"># this doesn't work in objmode as it's effectively untyped</span>
        <span class="s0">if </span><span class="s1">typed</span><span class="s3">:</span>
            <span class="s2"># otherwise we'll call unsafe_empty_inferred</span>
            <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span>
                <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">empty_func</span><span class="s3">,</span>
                <span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'unsafe_empty_inferred'</span><span class="s3">, </span><span class="s1">unsafe_empty_inferred</span><span class="s3">,</span>
                          <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">),</span>
                <span class="s1">loc</span><span class="s3">))</span>
            <span class="s1">array_kws </span><span class="s3">= []</span>
        <span class="s0">else</span><span class="s3">:</span>
            <span class="s0">raise </span><span class="s1">GuardException</span>

    <span class="s2"># array_var = empty_func(size_tuple_var)</span>
    <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">array_var</span><span class="s3">,</span>
                 <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">empty_func</span><span class="s3">, (</span><span class="s1">size_tuple_var</span><span class="s3">,), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">array_kws</span><span class="s3">),</span>
                              <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2"># Add back removed just in case they are used by something else</span>
    <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">removed</span><span class="s3">:</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">array_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>

    <span class="s2"># Add back terminator</span>
    <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">terminator</span><span class="s3">)</span>
    <span class="s2"># Modify loop_entry</span>
    <span class="s1">loop_entry</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">stmts</span>

    <span class="s0">if </span><span class="s1">range_def</span><span class="s3">:</span>
        <span class="s0">if </span><span class="s1">range_def</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] != </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2"># when range doesn't start from 0, index_var becomes loop index</span>
            <span class="s2"># (iter_first_var) minus an offset (range_def[0])</span>
            <span class="s1">terminator </span><span class="s3">= </span><span class="s1">loop_header</span><span class="s3">.</span><span class="s1">terminator</span>
            <span class="s0">assert </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">terminator</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Branch</span><span class="s3">))</span>
            <span class="s2"># find the block in the loop body that header jumps to</span>
            <span class="s1">block_id </span><span class="s3">= </span><span class="s1">terminator</span><span class="s3">.</span><span class="s1">truebr</span>
            <span class="s1">blk </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">block_id</span><span class="s3">]</span>
            <span class="s1">loc </span><span class="s3">= </span><span class="s1">blk</span><span class="s3">.</span><span class="s1">loc</span>
            <span class="s1">blk</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span>
                <span class="s6">0</span><span class="s3">,</span>
                <span class="s1">_new_definition</span><span class="s3">(</span>
                    <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">,</span>
                    <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">=</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">iter_first_var</span><span class="s3">,</span>
                                  <span class="s1">rhs</span><span class="s3">=</span><span class="s1">range_def</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">),</span>
                    <span class="s1">loc</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
    <span class="s0">else</span><span class="s3">:</span>
        <span class="s2"># Insert index_var increment to the end of loop header</span>
        <span class="s1">loc </span><span class="s3">= </span><span class="s1">loop_header</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s1">terminator </span><span class="s3">= </span><span class="s1">loop_header</span><span class="s3">.</span><span class="s1">terminator</span>
        <span class="s1">stmts </span><span class="s3">= </span><span class="s1">loop_header</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">next_index_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;next_index&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">one </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;one&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s2"># one = 1</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">one</span><span class="s3">,</span>
                     <span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2"># next_index_var = index_var + 1</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">next_index_var</span><span class="s3">,</span>
                     <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">binop</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">=</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">add</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">=</span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">=</span><span class="s1">one</span><span class="s3">,</span>
                                   <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s2"># index_var = next_index_var</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">next_index_var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">terminator</span><span class="s3">)</span>
        <span class="s1">loop_header</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">stmts</span>

    <span class="s2"># In append_block, change list_append into array assign</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">append_block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">)):</span>
        <span class="s0">if </span><span class="s1">append_block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s0">is </span><span class="s1">append_stmt</span><span class="s3">:</span>
            <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;Replace append with SetItem&quot;</span><span class="s3">)</span>
            <span class="s1">append_block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">(</span>
                <span class="s1">target</span><span class="s3">=</span><span class="s1">array_var</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index_var</span><span class="s3">,</span>
                <span class="s1">value</span><span class="s3">=</span><span class="s1">append_stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">append_stmt</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">)</span>

    <span class="s2"># replace array call, by changing &quot;a = array(b)&quot; to &quot;a = b&quot;</span>
    <span class="s1">stmt </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">exit_block</span><span class="s3">].</span><span class="s1">body</span><span class="s3">[</span><span class="s1">array_call_index</span><span class="s3">]</span>
    <span class="s2"># stmt can be either array call or SetItem, we only replace array call</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">array_var</span>
        <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = [</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">]</span>

    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_find_unsafe_empty_inferred</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">):</span>
    <span class="s1">unsafe_empty_inferred</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call'</span><span class="s3">)</span>
    <span class="s1">callee </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">func</span>
    <span class="s1">callee_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">)</span>
    <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">))</span>
    <span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;_find_unsafe_empty_inferred&quot;</span><span class="s3">)(</span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">callee_def</span><span class="s3">.</span><span class="s1">value </span><span class="s3">== </span><span class="s1">unsafe_empty_inferred</span>


<span class="s0">def </span><span class="s1">_fix_nested_array</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Look for assignment like: a[..] = b, where both a and b are numpy arrays, 
    and try to eliminate array b by expanding a with an extra dimension. 
    &quot;&quot;&quot;</span>
    <span class="s1">blocks </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span>
    <span class="s1">cfg </span><span class="s3">= </span><span class="s1">compute_cfg_from_blocks</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">usedefs </span><span class="s3">= </span><span class="s1">compute_use_defs</span><span class="s3">(</span><span class="s1">blocks</span><span class="s3">)</span>
    <span class="s1">empty_deadmap </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">([(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">set</span><span class="s3">()) </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()])</span>
    <span class="s1">livemap </span><span class="s3">= </span><span class="s1">compute_live_variables</span><span class="s3">(</span><span class="s1">cfg</span><span class="s3">, </span><span class="s1">blocks</span><span class="s3">, </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">defmap</span><span class="s3">, </span><span class="s1">empty_deadmap</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">find_array_def</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Find numpy array definition such as 
            arr = numba.unsafe.ndarray.empty_inferred(...). 
        If it is arr = b[...], find array definition of b recursively. 
        &quot;&quot;&quot;</span>
        <span class="s1">arr_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>
        <span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;find_array_def&quot;</span><span class="s3">)(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">arr_def</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">_find_unsafe_empty_inferred</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">arr_def</span><span class="s3">):</span>
                <span class="s0">return </span><span class="s1">arr_def</span>
            <span class="s0">elif </span><span class="s1">arr_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'getitem'</span><span class="s3">:</span>
                <span class="s0">return </span><span class="s1">find_array_def</span><span class="s3">(</span><span class="s1">arr_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s0">raise </span><span class="s1">GuardException</span>

    <span class="s0">def </span><span class="s1">fix_dependencies</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">, </span><span class="s1">varlist</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Double check if all variables in varlist are defined before 
        expr is used. Try to move constant definition when the check fails. 
        Bails out by raising GuardException if it can't be moved. 
        &quot;&quot;&quot;</span>
        <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;fix_dependencies&quot;</span><span class="s3">)</span>
        <span class="s0">for </span><span class="s1">label</span><span class="s3">, </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>
            <span class="s1">body </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span>
            <span class="s1">defined </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">body</span><span class="s3">)):</span>
                <span class="s1">inst </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
                    <span class="s1">defined</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s0">if </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">expr</span><span class="s3">:</span>
                        <span class="s1">new_varlist </span><span class="s3">= []</span>
                        <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">varlist</span><span class="s3">:</span>
                            <span class="s2"># var must be defined before this inst, or live</span>
                            <span class="s2"># and not later defined.</span>
                            <span class="s0">if </span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">defined </span><span class="s0">or</span>
                                <span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">livemap</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] </span><span class="s0">and</span>
                                 <span class="s0">not </span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">usedefs</span><span class="s3">.</span><span class="s1">defmap</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]))):</span>
                                <span class="s1">debug_print</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot; already defined&quot;</span><span class="s3">)</span>
                                <span class="s1">new_varlist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
                            <span class="s0">else</span><span class="s3">:</span>
                                <span class="s1">debug_print</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot; not yet defined&quot;</span><span class="s3">)</span>
                                <span class="s1">var_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                                <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">var_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">):</span>
                                    <span class="s1">loc </span><span class="s3">= </span><span class="s1">var</span><span class="s3">.</span><span class="s1">loc</span>
                                    <span class="s1">new_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;new_var&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
                                    <span class="s1">new_const </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">var_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
                                    <span class="s1">new_vardef </span><span class="s3">= </span><span class="s1">_new_definition</span><span class="s3">(</span>
                                        <span class="s1">func_ir</span><span class="s3">, </span><span class="s1">new_var</span><span class="s3">, </span><span class="s1">new_const</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
                                    <span class="s1">new_body </span><span class="s3">= []</span>
                                    <span class="s1">new_body</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">body</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">])</span>
                                    <span class="s1">new_body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">new_vardef</span><span class="s3">)</span>
                                    <span class="s1">new_body</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">body</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:])</span>
                                    <span class="s1">block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">new_body</span>
                                    <span class="s1">new_varlist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">new_var</span><span class="s3">)</span>
                                <span class="s0">else</span><span class="s3">:</span>
                                    <span class="s0">raise </span><span class="s1">GuardException</span>
                        <span class="s0">return </span><span class="s1">new_varlist</span>
        <span class="s2"># when expr is not found in block</span>
        <span class="s0">raise </span><span class="s1">GuardException</span>

    <span class="s0">def </span><span class="s1">fix_array_assign</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;For assignment like lhs[idx] = rhs, where both lhs and rhs are 
        arrays, do the following: 
        1. find the definition of rhs, which has to be a call to 
           numba.unsafe.ndarray.empty_inferred 
        2. find the source array creation for lhs, insert an extra dimension of 
           size of b. 
        3. replace the definition of 
           rhs = numba.unsafe.ndarray.empty_inferred(...) with rhs = lhs[idx] 
        &quot;&quot;&quot;</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">))</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">))</span>
        <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;fix_array_assign&quot;</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;found SetItem: &quot;</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">)</span>
        <span class="s1">lhs </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s2"># Find the source array creation of lhs</span>
        <span class="s1">lhs_def </span><span class="s3">= </span><span class="s1">find_array_def</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;found lhs_def: &quot;</span><span class="s3">, </span><span class="s1">lhs_def</span><span class="s3">)</span>
        <span class="s1">rhs_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;found rhs_def: &quot;</span><span class="s3">, </span><span class="s1">rhs_def</span><span class="s3">)</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'cast'</span><span class="s3">:</span>
            <span class="s1">rhs_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rhs_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">))</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">_find_unsafe_empty_inferred</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">rhs_def</span><span class="s3">))</span>
        <span class="s2"># Find the array dimension of rhs</span>
        <span class="s1">dim_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dim_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and </span><span class="s1">dim_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'build_tuple'</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;dim_def = &quot;</span><span class="s3">, </span><span class="s1">dim_def</span><span class="s3">)</span>
        <span class="s1">extra_dims </span><span class="s3">= [</span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lhs_only</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
                      <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dim_def</span><span class="s3">.</span><span class="s1">items </span><span class="s3">]</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;extra_dims = &quot;</span><span class="s3">, </span><span class="s1">extra_dims</span><span class="s3">)</span>
        <span class="s2"># Expand size tuple when creating lhs_def with extra_dims</span>
        <span class="s1">size_tuple_def </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">lhs_def</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">size_tuple_def</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s1">size_tuple_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'build_tuple'</span><span class="s3">)</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;size_tuple_def = &quot;</span><span class="s3">, </span><span class="s1">size_tuple_def</span><span class="s3">)</span>
        <span class="s1">extra_dims </span><span class="s3">= </span><span class="s1">fix_dependencies</span><span class="s3">(</span><span class="s1">size_tuple_def</span><span class="s3">, </span><span class="s1">extra_dims</span><span class="s3">)</span>
        <span class="s1">size_tuple_def</span><span class="s3">.</span><span class="s1">items </span><span class="s3">+= </span><span class="s1">extra_dims</span>
        <span class="s2"># In-place modify rhs_def to be getitem</span>
        <span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">op </span><span class="s3">= </span><span class="s4">'getitem'</span>
        <span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">fn </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">getitem</span>
        <span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">get_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">lhs_only</span><span class="s3">=</span><span class="s0">True</span><span class="s3">)</span>
        <span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">index</span>
        <span class="s0">del </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s4">'func'</span><span class="s3">]</span>
        <span class="s0">del </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s4">'args'</span><span class="s3">]</span>
        <span class="s0">del </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s4">'vararg'</span><span class="s3">]</span>
        <span class="s0">del </span><span class="s1">rhs_def</span><span class="s3">.</span><span class="s1">_kws</span><span class="s3">[</span><span class="s4">'kws'</span><span class="s3">]</span>
        <span class="s2"># success</span>
        <span class="s0">return True</span>

    <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">find_topo_order</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">):</span>
        <span class="s1">block </span><span class="s3">= </span><span class="s1">func_ir</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>
        <span class="s0">for </span><span class="s1">stmt </span><span class="s0">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
            <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">fix_array_assign</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">):</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">)</span>


<span class="s0">def </span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">):</span>
    <span class="s1">func_ir</span><span class="s3">.</span><span class="s1">_definitions</span><span class="s3">[</span><span class="s1">var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = [</span><span class="s1">value</span><span class="s3">]</span>
    <span class="s0">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">, </span><span class="s1">target</span><span class="s3">=</span><span class="s1">var</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">rewrites</span><span class="s3">.</span><span class="s1">register_rewrite</span><span class="s3">(</span><span class="s4">'after-inference'</span><span class="s3">)</span>
<span class="s0">class </span><span class="s1">RewriteArrayOfConsts</span><span class="s3">(</span><span class="s1">rewrites</span><span class="s3">.</span><span class="s1">Rewrite</span><span class="s3">):</span>
    <span class="s5">'''The RewriteArrayOfConsts class is responsible for finding 
    1D array creations from a constant list, and rewriting it into 
    direct initialization of array elements without creating the list. 
    '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">typingctx</span>
        <span class="s1">super</span><span class="s3">(</span><span class="s1">RewriteArrayOfConsts</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>

    <span class="s0">def </span><span class="s1">match</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">calltypes</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s0">return False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">crnt_block </span><span class="s3">= </span><span class="s1">block</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">new_body </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">_inline_const_arraycall</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">,</span>
                              <span class="s1">self</span><span class="s3">.</span><span class="s1">typingctx</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">new_body </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">crnt_block</span><span class="s3">.</span><span class="s1">body </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">new_body</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">crnt_block</span>


<span class="s0">def </span><span class="s1">_inline_const_arraycall</span><span class="s3">(</span><span class="s1">block</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">typemap</span><span class="s3">, </span><span class="s1">calltypes</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Look for array(list) call where list is a constant list created by 
    build_list, and turn them into direct array creation and initialization, if 
    the following conditions are met: 
      1. The build_list call immediate precedes the array call; 
      2. The list variable is no longer live after array call; 
    If any condition check fails, no modification will be made. 
    &quot;&quot;&quot;</span>
    <span class="s1">debug_print </span><span class="s3">= </span><span class="s1">_make_debug_print</span><span class="s3">(</span><span class="s4">&quot;inline_const_arraycall&quot;</span><span class="s3">)</span>
    <span class="s1">scope </span><span class="s3">= </span><span class="s1">block</span><span class="s3">.</span><span class="s1">scope</span>

    <span class="s0">def </span><span class="s1">inline_array</span><span class="s3">(</span><span class="s1">array_var</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">stmts</span><span class="s3">, </span><span class="s1">list_vars</span><span class="s3">, </span><span class="s1">dels</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Check to see if the given &quot;array_var&quot; is created from a list 
        of constants, and try to inline the list definition as array 
        initialization. 
 
        Extra statements produced with be appended to &quot;stmts&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">callname </span><span class="s3">= </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">find_callname</span><span class="s3">, </span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">)</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">callname </span><span class="s0">and </span><span class="s1">callname</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s4">'numpy' </span><span class="s0">and </span><span class="s1">callname</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">'array'</span><span class="s3">)</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">name </span><span class="s0">in </span><span class="s1">list_vars</span><span class="s3">)</span>
        <span class="s1">ret_type </span><span class="s3">= </span><span class="s1">calltypes</span><span class="s3">[</span><span class="s1">expr</span><span class="s3">].</span><span class="s1">return_type</span>
        <span class="s1">require</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ArrayCompatible</span><span class="s3">) </span><span class="s0">and</span>
                <span class="s1">ret_type</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">loc </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">loc</span>
        <span class="s1">list_var </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2"># Get the type of the array to be created.</span>
        <span class="s1">array_typ </span><span class="s3">= </span><span class="s1">typemap</span><span class="s3">[</span><span class="s1">array_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s1">debug_print</span><span class="s3">(</span><span class="s4">&quot;inline array_var = &quot;</span><span class="s3">, </span><span class="s1">array_var</span><span class="s3">, </span><span class="s4">&quot; list_var = &quot;</span><span class="s3">, </span><span class="s1">list_var</span><span class="s3">)</span>
        <span class="s2"># Get the element type of the array to be created.</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">array_typ</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2"># Get the sequence of operations to provide values to the new array.</span>
        <span class="s1">seq</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">find_build_sequence</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">list_var</span><span class="s3">)</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">seq</span><span class="s3">)</span>
        <span class="s2"># Create a tuple to pass to empty below to specify the new array size.</span>
        <span class="s1">size_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;size&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">size_tuple_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;size_tuple&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">size_typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
        <span class="s1">size_tuple_typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">UniTuple</span><span class="s3">(</span><span class="s1">size_typ</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">size_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">size_typ</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">size_tuple_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">size_tuple_typ</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">size_var</span><span class="s3">,</span>
                            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">size_tuple_var</span><span class="s3">,</span>
                            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">build_tuple</span><span class="s3">(</span><span class="s1">items</span><span class="s3">=[</span><span class="s1">size_var</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">),</span>
                            <span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># The general approach is to create an empty array and then fill</span>
        <span class="s2"># the elements in one-by-one from their specification.</span>

        <span class="s2"># Get the numpy type to pass to empty.</span>
        <span class="s1">nptype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">DType</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2"># Create a variable to hold the numpy empty function.</span>
        <span class="s1">empty_func </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;empty_func&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">get_np_ufunc_typ</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">)</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">resolve_function_type</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">, (</span><span class="s1">size_typ</span><span class="s3">,), {</span><span class="s4">'dtype'</span><span class="s3">: </span><span class="s1">nptype</span><span class="s3">})</span>

        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">empty_func</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">fnty</span>

        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">empty_func</span><span class="s3">,</span>
                            <span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'empty'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># We pass two arguments to empty, first the size tuple and second</span>
        <span class="s2"># the dtype of the new array.  Here, we created typ_var which is</span>
        <span class="s2"># the dtype argument of the new array.  typ_var in turn is created</span>
        <span class="s2"># by getattr of the dtype string on the numpy module.</span>

        <span class="s2"># Create var for numpy module.</span>
        <span class="s1">g_np_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;$np_g_var&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">g_np_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">types</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">(</span><span class="s1">np</span><span class="s3">)</span>
        <span class="s1">g_np </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Global</span><span class="s3">(</span><span class="s4">'np'</span><span class="s3">, </span><span class="s1">np</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">g_np</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># Create var for result of numpy.&lt;dtype&gt;.</span>
        <span class="s1">typ_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;$np_typ_var&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">typemap</span><span class="s3">[</span><span class="s1">typ_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">nptype</span>
        <span class="s1">dtype_str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s1">dtype_str </span><span class="s3">== </span><span class="s4">'bool'</span><span class="s3">:</span>
            <span class="s1">dtype_str </span><span class="s3">= </span><span class="s4">'bool_'</span>
        <span class="s2"># Get dtype attribute of numpy module.</span>
        <span class="s1">np_typ_getattr </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">g_np_var</span><span class="s3">, </span><span class="s1">dtype_str</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">typ_var</span><span class="s3">, </span><span class="s1">np_typ_getattr</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># Create the call to numpy.empty passing the size tuple and dtype var.</span>
        <span class="s1">empty_call </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">empty_func</span><span class="s3">, [</span><span class="s1">size_var</span><span class="s3">, </span><span class="s1">typ_var</span><span class="s3">], {}, </span><span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">)</span>
        <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">empty_call</span><span class="s3">] = </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">array_typ</span><span class="s3">, </span><span class="s1">size_typ</span><span class="s3">, </span><span class="s1">nptype</span><span class="s3">)</span>
        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">array_var</span><span class="s3">, </span><span class="s1">empty_call</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">))</span>

        <span class="s2"># Fill in the new empty array one-by-one.</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">index_var </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">redefine</span><span class="s3">(</span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">index_typ </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span>
            <span class="s1">typemap</span><span class="s3">[</span><span class="s1">index_var</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">index_typ</span>
            <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s1">_new_definition</span><span class="s3">(</span><span class="s1">func_ir</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Const</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">), </span><span class="s1">loc</span><span class="s3">))</span>
            <span class="s1">setitem </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">SetItem</span><span class="s3">(</span><span class="s1">array_var</span><span class="s3">, </span><span class="s1">index_var</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">loc</span><span class="s3">)</span>
            <span class="s1">calltypes</span><span class="s3">[</span><span class="s1">setitem</span><span class="s3">] = </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, </span><span class="s1">array_typ</span><span class="s3">,</span>
                                                  <span class="s1">index_typ</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">setitem</span><span class="s3">)</span>

        <span class="s1">stmts</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">dels</span><span class="s3">)</span>
        <span class="s0">return True</span>

    <span class="s0">class </span><span class="s1">State</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        This class is used to hold the state in the following loop so as to make 
        it easy to reset the state of the variables tracking the various 
        statement kinds 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s2"># list_vars keep track of the variable created from the latest</span>
            <span class="s2"># build_list instruction, as well as its synonyms.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">list_vars </span><span class="s3">= []</span>
            <span class="s2"># dead_vars keep track of those in list_vars that are considered</span>
            <span class="s2"># dead.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dead_vars </span><span class="s3">= []</span>
            <span class="s2"># list_items keep track of the elements used in build_list.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">list_items </span><span class="s3">= []</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">stmts </span><span class="s3">= []</span>
            <span class="s2"># dels keep track of the deletion of list_items, which will need to</span>
            <span class="s2"># be moved after array initialization.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dels </span><span class="s3">= []</span>
            <span class="s2"># tracks if a modification has taken place</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modified </span><span class="s3">= </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Resets the internal state of the variables used for tracking 
            &quot;&quot;&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">list_vars </span><span class="s3">= []</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dead_vars </span><span class="s3">= []</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">list_items </span><span class="s3">= []</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dels </span><span class="s3">= []</span>

        <span class="s0">def </span><span class="s1">list_var_used</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">):</span>
            <span class="s5">&quot;&quot;&quot; 
            Returns True if the list being analysed is used between the 
            build_list and the array call. 
            &quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">any</span><span class="s3">([</span><span class="s1">x</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">list_vars </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">()])</span>

    <span class="s1">state </span><span class="s3">= </span><span class="s1">State</span><span class="s3">()</span>

    <span class="s0">for </span><span class="s1">inst </span><span class="s0">in </span><span class="s1">block</span><span class="s3">.</span><span class="s1">body</span><span class="s3">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Var</span><span class="s3">):</span>
                <span class="s0">if </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">:</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                    <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Expr</span><span class="s3">):</span>
                <span class="s1">expr </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
                <span class="s0">if </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'build_list'</span><span class="s3">:</span>
                    <span class="s2"># new build_list encountered, reset state</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">list_items </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">name </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">items</span><span class="s3">]</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars </span><span class="s3">= [</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                    <span class="s0">continue</span>
                <span class="s0">elif </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">op </span><span class="s3">== </span><span class="s4">'call' </span><span class="s0">and </span><span class="s1">expr </span><span class="s0">in </span><span class="s1">calltypes</span><span class="s3">:</span>
                    <span class="s0">if </span><span class="s1">guard</span><span class="s3">(</span><span class="s1">inline_array</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">,</span>
                             <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">, </span><span class="s1">state</span><span class="s3">.</span><span class="s1">dels</span><span class="s3">):</span>
                        <span class="s1">state</span><span class="s3">.</span><span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>
                        <span class="s0">continue</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">):</span>
            <span class="s1">removed_var </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s0">if </span><span class="s1">removed_var </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_items</span><span class="s3">:</span>
                <span class="s1">state</span><span class="s3">.</span><span class="s1">dels</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">removed_var </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">:</span>
                <span class="s2"># one of the list_vars is considered dead.</span>
                <span class="s1">state</span><span class="s3">.</span><span class="s1">dead_vars</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">removed_var</span><span class="s3">)</span>
                <span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">removed_var</span><span class="s3">)</span>
                <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                <span class="s0">if </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_vars </span><span class="s3">== []:</span>
                    <span class="s2"># if all list_vars are considered dead, we need to filter</span>
                    <span class="s2"># them out from existing stmts to completely remove</span>
                    <span class="s2"># build_list.</span>
                    <span class="s2"># Note that if a translation didn't take place, dead_vars</span>
                    <span class="s2"># will also be empty when we reach this point.</span>
                    <span class="s1">body </span><span class="s3">= []</span>
                    <span class="s0">for </span><span class="s1">inst </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">:</span>
                        <span class="s0">if </span><span class="s3">((</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Assign</span><span class="s3">) </span><span class="s0">and</span>
                             <span class="s1">inst</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">name </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">dead_vars</span><span class="s3">) </span><span class="s0">or</span>
                            <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Del</span><span class="s3">) </span><span class="s0">and</span>
                             <span class="s1">inst</span><span class="s3">.</span><span class="s1">value </span><span class="s0">in </span><span class="s1">state</span><span class="s3">.</span><span class="s1">dead_vars</span><span class="s3">)):</span>
                            <span class="s0">continue</span>
                        <span class="s1">body</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts </span><span class="s3">= </span><span class="s1">body</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">dead_vars </span><span class="s3">= []</span>
                    <span class="s1">state</span><span class="s3">.</span><span class="s1">modified </span><span class="s3">= </span><span class="s0">True</span>
                    <span class="s0">continue</span>
        <span class="s1">state</span><span class="s3">.</span><span class="s1">stmts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>

        <span class="s2"># If the list is used in any capacity between build_list and array</span>
        <span class="s2"># call, then we must call off the translation for this list because</span>
        <span class="s2"># it could be mutated and list_items would no longer be applicable.</span>
        <span class="s0">if </span><span class="s1">state</span><span class="s3">.</span><span class="s1">list_var_used</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">):</span>
            <span class="s1">state</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>

    <span class="s0">return </span><span class="s1">state</span><span class="s3">.</span><span class="s1">stmts </span><span class="s0">if </span><span class="s1">state</span><span class="s3">.</span><span class="s1">modified </span><span class="s0">else None</span>
</pre>
</body>
</html>