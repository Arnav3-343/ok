<html>
<head>
<title>numpy_support.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
numpy_support.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">ctypes</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">types</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">templates </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">npdatetime_helpers</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">TypingError</span>

<span class="s3"># re-export</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">cgutils </span><span class="s0">import </span><span class="s1">is_nonelike   </span><span class="s3"># noqa: F401</span>


<span class="s1">numpy_version </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s4">'.'</span><span class="s2">)[:</span><span class="s5">2</span><span class="s2">]))</span>


<span class="s1">FROM_DTYPE </span><span class="s2">= {</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'bool'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">boolean</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'int8'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'int16'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int16</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'int32'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'int64'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">,</span>

    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'uint8'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'uint16'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint16</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'uint32'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'uint64'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">,</span>

    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'float32'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'float64'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'float16'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float16</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'complex64'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">,</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'complex128'</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">,</span>

    <span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">): </span><span class="s1">types</span><span class="s2">.</span><span class="s1">pyobject</span><span class="s2">,</span>
<span class="s2">}</span>

<span class="s1">re_typestr </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s4">r'[&lt;&gt;=\|]([a-z])(\d+)?$'</span><span class="s2">, </span><span class="s1">re</span><span class="s2">.</span><span class="s1">I</span><span class="s2">)</span>
<span class="s1">re_datetimestr </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s4">r'[&lt;&gt;=\|]([mM])8?(\[([a-z]+)\])?$'</span><span class="s2">, </span><span class="s1">re</span><span class="s2">.</span><span class="s1">I</span><span class="s2">)</span>

<span class="s1">sizeof_unicode_char </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'U1'</span><span class="s2">).</span><span class="s1">itemsize</span>


<span class="s0">def </span><span class="s1">_from_str_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">re_typestr</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">str</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">m</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">groups </span><span class="s2">= </span><span class="s1">m</span><span class="s2">.</span><span class="s1">groups</span><span class="s2">()</span>
    <span class="s1">typecode </span><span class="s2">= </span><span class="s1">groups</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">typecode </span><span class="s2">== </span><span class="s4">'U'</span><span class="s2">:</span>
        <span class="s3"># unicode</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s0">not in </span><span class="s4">'=|'</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;Does not support non-native &quot;</span>
                                      <span class="s4">&quot;byteorder&quot;</span><span class="s2">)</span>
        <span class="s1">count </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">// </span><span class="s1">sizeof_unicode_char</span>
        <span class="s0">assert </span><span class="s1">count </span><span class="s2">== </span><span class="s1">int</span><span class="s2">(</span><span class="s1">groups</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]), </span><span class="s4">&quot;Unicode char size mismatch&quot;</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UnicodeCharSeq</span><span class="s2">(</span><span class="s1">count</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">typecode </span><span class="s2">== </span><span class="s4">'S'</span><span class="s2">:</span>
        <span class="s3"># char</span>
        <span class="s1">count </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span>
        <span class="s0">assert </span><span class="s1">count </span><span class="s2">== </span><span class="s1">int</span><span class="s2">(</span><span class="s1">groups</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]), </span><span class="s4">&quot;Char size mismatch&quot;</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">CharSeq</span><span class="s2">(</span><span class="s1">count</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_from_datetime_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">re_datetimestr</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">str</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">m</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">groups </span><span class="s2">= </span><span class="s1">m</span><span class="s2">.</span><span class="s1">groups</span><span class="s2">()</span>
    <span class="s1">typecode </span><span class="s2">= </span><span class="s1">groups</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">unit </span><span class="s2">= </span><span class="s1">groups</span><span class="s2">[</span><span class="s5">2</span><span class="s2">] </span><span class="s0">or </span><span class="s4">''</span>
    <span class="s0">if </span><span class="s1">typecode </span><span class="s2">== </span><span class="s4">'m'</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">typecode </span><span class="s2">== </span><span class="s4">'M'</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a Numba Type instance corresponding to the given Numpy *dtype*. 
    NotImplementedError is raised on unsupported Numpy dtypes. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">) </span><span class="s0">is </span><span class="s1">type </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">generic</span><span class="s2">):</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s4">&quot;fields&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">from_struct_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">FROM_DTYPE</span><span class="s2">[</span><span class="s1">dtype</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">char </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
    <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s4">'SU'</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_from_str_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s4">'mM'</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_from_datetime_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">char </span><span class="s0">in </span><span class="s4">'V' </span><span class="s0">and </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">subdtype </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">subtype </span><span class="s2">= </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">subdtype</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
            <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NestedArray</span><span class="s2">(</span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s1">_as_dtype_letters </span><span class="s2">= {</span>
    <span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">: </span><span class="s4">'M8'</span><span class="s2">,</span>
    <span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">: </span><span class="s4">'m8'</span><span class="s2">,</span>
    <span class="s1">types</span><span class="s2">.</span><span class="s1">CharSeq</span><span class="s2">: </span><span class="s4">'S'</span><span class="s2">,</span>
    <span class="s1">types</span><span class="s2">.</span><span class="s1">UnicodeCharSeq</span><span class="s2">: </span><span class="s4">'U'</span><span class="s2">,</span>
<span class="s2">}</span>


<span class="s0">def </span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a numpy dtype instance corresponding to the given Numba type. 
    NotImplementedError is if no correspondence is known. 
    &quot;&quot;&quot;</span>
    <span class="s1">nbtype </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">unliteral</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Complex</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Float</span><span class="s2">)):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">nbtype </span><span class="s0">is </span><span class="s1">types</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'?'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">)):</span>
        <span class="s1">letter </span><span class="s2">= </span><span class="s1">_as_dtype_letters</span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">)]</span>
        <span class="s0">if </span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'%s[%s]' </span><span class="s2">% (</span><span class="s1">letter</span><span class="s2">, </span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">letter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">CharSeq</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UnicodeCharSeq</span><span class="s2">)):</span>
        <span class="s1">letter </span><span class="s2">= </span><span class="s1">_as_dtype_letters</span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">)]</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">'%s%d' </span><span class="s2">% (</span><span class="s1">letter</span><span class="s2">, </span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">count</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Record</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">as_struct_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">EnumMember</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">npytypes</span><span class="s2">.</span><span class="s1">DType</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NumberClass</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NestedArray</span><span class="s2">):</span>
        <span class="s1">spec </span><span class="s2">= (</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">spec</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nbtype</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">PyObject</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>

    <span class="s1">msg </span><span class="s2">= </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">nbtype</span><span class="s0">} </span><span class="s4">cannot be represented as a NumPy dtype&quot;</span>
    <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">as_struct_dtype</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Convert Numba Record type to NumPy structured dtype 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Record</span><span class="s2">)</span>
    <span class="s1">names </span><span class="s2">= []</span>
    <span class="s1">formats </span><span class="s2">= []</span>
    <span class="s1">offsets </span><span class="s2">= []</span>
    <span class="s1">titles </span><span class="s2">= []</span>
    <span class="s3"># Fill the fields if they are not a title.</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">rec</span><span class="s2">.</span><span class="s1">members</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">rec</span><span class="s2">.</span><span class="s1">is_title</span><span class="s2">(</span><span class="s1">k</span><span class="s2">):</span>
            <span class="s1">names</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s1">formats</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">t</span><span class="s2">))</span>
            <span class="s1">offsets</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">(</span><span class="s1">k</span><span class="s2">))</span>
            <span class="s1">titles</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">[</span><span class="s1">k</span><span class="s2">].</span><span class="s1">title</span><span class="s2">)</span>

    <span class="s1">fields </span><span class="s2">= {</span>
        <span class="s4">'names'</span><span class="s2">: </span><span class="s1">names</span><span class="s2">,</span>
        <span class="s4">'formats'</span><span class="s2">: </span><span class="s1">formats</span><span class="s2">,</span>
        <span class="s4">'offsets'</span><span class="s2">: </span><span class="s1">offsets</span><span class="s2">,</span>
        <span class="s4">'itemsize'</span><span class="s2">: </span><span class="s1">rec</span><span class="s2">.</span><span class="s1">size</span><span class="s2">,</span>
        <span class="s4">'titles'</span><span class="s2">: </span><span class="s1">titles</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s1">_check_struct_alignment</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s1">rec</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_check_struct_alignment</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Check alignment compatibility with Numpy&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">rec</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">[</span><span class="s4">'names'</span><span class="s2">], </span><span class="s1">fields</span><span class="s2">[</span><span class="s4">'formats'</span><span class="s2">]):</span>
            <span class="s1">llvm_align </span><span class="s2">= </span><span class="s1">rec</span><span class="s2">.</span><span class="s1">alignof</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s1">npy_align </span><span class="s2">= </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">alignment</span>
            <span class="s0">if </span><span class="s1">llvm_align </span><span class="s0">is not None and </span><span class="s1">npy_align </span><span class="s2">!= </span><span class="s1">llvm_align</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= (</span>
                    <span class="s4">'NumPy is using a different alignment ({}) '</span>
                    <span class="s4">'than Numba/LLVM ({}) for {}. '</span>
                    <span class="s4">'This is likely a NumPy bug.'</span>
                <span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">npy_align</span><span class="s2">, </span><span class="s1">llvm_align</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">map_arrayscalar_type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">generic</span><span class="s2">):</span>
        <span class="s3"># We can't blindly call np.dtype() as it loses information</span>
        <span class="s3"># on some types, e.g. datetime64 and timedelta64.</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">val</span><span class="s2">.</span><span class="s1">dtype</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">))</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;no corresponding numpy dtype &quot;</span>
                                      <span class="s4">&quot;for %r&quot; </span><span class="s2">% </span><span class="s1">type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">is_array</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">map_layout</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">val</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">[</span><span class="s4">'C_CONTIGUOUS'</span><span class="s2">]:</span>
        <span class="s1">layout </span><span class="s2">= </span><span class="s4">'C'</span>
    <span class="s0">elif </span><span class="s1">val</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">[</span><span class="s4">'F_CONTIGUOUS'</span><span class="s2">]:</span>
        <span class="s1">layout </span><span class="s2">= </span><span class="s4">'F'</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">layout </span><span class="s2">= </span><span class="s4">'A'</span>
    <span class="s0">return </span><span class="s1">layout</span>


<span class="s0">def </span><span class="s1">select_array_wrapper</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Given the array-compatible input types to an operation (e.g. ufunc), 
    select the appropriate input for wrapping the operation output, 
    according to each input's __array_priority__. 
 
    An index into *inputs* is returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">max_prio </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s4">'-inf'</span><span class="s2">)</span>
    <span class="s1">selected_index </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ty </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">):</span>
        <span class="s3"># Ties are broken by choosing the first winner, as in Numpy</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ArrayCompatible</span><span class="s2">) </span><span class="s0">and</span>
                <span class="s1">ty</span><span class="s2">.</span><span class="s1">array_priority </span><span class="s2">&gt; </span><span class="s1">max_prio</span><span class="s2">):</span>
            <span class="s1">selected_index </span><span class="s2">= </span><span class="s1">index</span>
            <span class="s1">max_prio </span><span class="s2">= </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">array_priority</span>

    <span class="s0">assert </span><span class="s1">selected_index </span><span class="s0">is not None</span>
    <span class="s0">return </span><span class="s1">selected_index</span>


<span class="s0">def </span><span class="s1">resolve_output_type</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">formal_output</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Given the array-compatible input types to an operation (e.g. ufunc), 
    and the operation's formal output type (a types.Array instance), 
    resolve the actual output type using the typing *context*. 
 
    This uses a mechanism compatible with Numpy's __array_priority__ / 
    __array_wrap__. 
    &quot;&quot;&quot;</span>
    <span class="s1">selected_input </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s1">select_array_wrapper</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">)]</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">selected_input</span><span class="s2">, </span><span class="s1">formal_output</span>
    <span class="s1">sig </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">resolve_function_type</span><span class="s2">(</span><span class="s4">'__array_wrap__'</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, {})</span>
    <span class="s0">if </span><span class="s1">sig </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">selected_input</span><span class="s2">.</span><span class="s1">array_priority </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">array_priority</span><span class="s2">:</span>
            <span class="s3"># If it's the same priority as a regular array, assume we</span>
            <span class="s3"># should return the output unchanged.</span>
            <span class="s3"># (we can't define __array_wrap__ explicitly for types.Buffer,</span>
            <span class="s3">#  as that would be inherited by most array-compatible objects)</span>
            <span class="s0">return </span><span class="s1">formal_output</span>
        <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s4">&quot;__array_wrap__ failed for %s&quot; </span><span class="s2">% (</span><span class="s1">args</span><span class="s2">,))</span>
    <span class="s0">return </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span>


<span class="s0">def </span><span class="s1">supported_ufunc_loop</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Return whether the *loop* for the *ufunc* is supported -in nopython-. 
 
    *loop* should be a UFuncLoopSpec instance, and *ufunc* a numpy ufunc. 
 
    For ufuncs implemented using the ufunc_db, it is supported if the ufunc_db 
    contains a lowering definition for 'loop' in the 'ufunc' entry. 
 
    For other ufuncs, it is type based. The loop will be considered valid if it 
    only contains the following letter types: '?bBhHiIlLqQfd'. Note this is 
    legacy and when implementing new ufuncs the ufunc_db should be preferred, 
    as it allows for a more fine-grained incremental support. 
    &quot;&quot;&quot;</span>
    <span class="s3"># NOTE: Assuming ufunc for the CPUContext</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">ufunc_db</span>
    <span class="s1">loop_sig </span><span class="s2">= </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">ufunc_sig</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s3"># check if the loop has a codegen description in the</span>
        <span class="s3"># ufunc_db. If so, we can proceed.</span>

        <span class="s3"># note that as of now not all ufuncs have an entry in the</span>
        <span class="s3"># ufunc_db</span>
        <span class="s1">supported_loop </span><span class="s2">= </span><span class="s1">loop_sig </span><span class="s0">in </span><span class="s1">ufunc_db</span><span class="s2">.</span><span class="s1">get_ufunc_info</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s3"># for ufuncs not in ufunc_db, base the decision of whether the</span>
        <span class="s3"># loop is supported on its types</span>
        <span class="s1">loop_types </span><span class="s2">= [</span><span class="s1">x</span><span class="s2">.</span><span class="s1">char </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">numpy_inputs </span><span class="s2">+ </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">numpy_outputs</span><span class="s2">]</span>
        <span class="s1">supported_types </span><span class="s2">= </span><span class="s4">'?bBhHiIlLqQfd'</span>
        <span class="s3"># check if all the types involved in the ufunc loop are</span>
        <span class="s3"># supported in this mode</span>
        <span class="s1">supported_loop </span><span class="s2">= </span><span class="s1">all</span><span class="s2">(</span><span class="s1">t </span><span class="s0">in </span><span class="s1">supported_types </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">loop_types</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">supported_loop</span>


<span class="s0">class </span><span class="s1">UFuncLoopSpec</span><span class="s2">(</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s4">'_UFuncLoopSpec'</span><span class="s2">,</span>
                                           <span class="s2">(</span><span class="s4">'inputs'</span><span class="s2">, </span><span class="s4">'outputs'</span><span class="s2">, </span><span class="s4">'ufunc_sig'</span><span class="s2">))):</span>
    <span class="s6">&quot;&quot;&quot; 
    An object describing a ufunc loop's inner types.  Properties: 
    - inputs: the inputs' Numba types 
    - outputs: the outputs' Numba types 
    - ufunc_sig: the string representing the ufunc's type signature, in 
      Numpy format (e.g. &quot;ii-&gt;i&quot;) 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">numpy_inputs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">inputs</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">numpy_outputs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">outputs</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_ufunc_loop_sig</span><span class="s2">(</span><span class="s1">out_tys</span><span class="s2">, </span><span class="s1">in_tys</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">out_tys</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">out_tys</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], *</span><span class="s1">in_tys</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">(</span><span class="s1">out_tys</span><span class="s2">), *</span><span class="s1">in_tys</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">ufunc_can_cast</span><span class="s2">(</span><span class="s1">from_</span><span class="s2">, </span><span class="s1">to</span><span class="s2">, </span><span class="s1">has_mixed_inputs</span><span class="s2">, </span><span class="s1">casting</span><span class="s2">=</span><span class="s4">'safe'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    A variant of np.can_cast() that can allow casting any integer to 
    any real or complex type, in case the operation has mixed-kind 
    inputs. 
 
    For example we want `np.power(float32, int32)` to be computed using 
    SP arithmetic and return `float32`. 
    However, `np.sqrt(int32)` should use DP arithmetic and return `float64`. 
    &quot;&quot;&quot;</span>
    <span class="s1">from_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">from_</span><span class="s2">)</span>
    <span class="s1">to </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">to</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">has_mixed_inputs </span><span class="s0">and </span><span class="s1">from_</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'iu' </span><span class="s0">and </span><span class="s1">to</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'cf'</span><span class="s2">:</span>
        <span class="s3"># Decide that all integers can cast to any real or complex type.</span>
        <span class="s0">return True</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">can_cast</span><span class="s2">(</span><span class="s1">from_</span><span class="s2">, </span><span class="s1">to</span><span class="s2">, </span><span class="s1">casting</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">ufunc_find_matching_loop</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">arg_types</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Find the appropriate loop to be used for a ufunc based on the types 
    of the operands 
 
    ufunc        - The ufunc we want to check 
    arg_types    - The tuple of arguments to the ufunc, including any 
                   explicit output(s). 
    return value - A UFuncLoopSpec identifying the loop, or None 
                   if no matching loop is found. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Separate logical input from explicit output arguments</span>
    <span class="s1">input_types </span><span class="s2">= </span><span class="s1">arg_types</span><span class="s2">[:</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span><span class="s2">]</span>
    <span class="s1">output_types </span><span class="s2">= </span><span class="s1">arg_types</span><span class="s2">[</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span><span class="s2">:]</span>
    <span class="s0">assert </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">input_types</span><span class="s2">) == </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span><span class="s2">)</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">np_input_types </span><span class="s2">= [</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">input_types</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
        <span class="s0">return None</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">np_output_types </span><span class="s2">= [</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output_types</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
        <span class="s0">return None</span>

    <span class="s3"># Whether the inputs are mixed integer / floating-point</span>
    <span class="s1">has_mixed_inputs </span><span class="s2">= (</span>
        <span class="s1">any</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'iu' </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np_input_types</span><span class="s2">) </span><span class="s0">and</span>
        <span class="s1">any</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'cf' </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np_input_types</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">choose_types</span><span class="s2">(</span><span class="s1">numba_types</span><span class="s2">, </span><span class="s1">ufunc_letters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Return a list of Numba types representing *ufunc_letters*, 
        except when the letter designates a datetime64 or timedelta64, 
        in which case the type is taken from *numba_types*. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ufunc_letters</span><span class="s2">) &gt;= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">numba_types</span><span class="s2">)</span>
        <span class="s1">types </span><span class="s2">= [</span><span class="s1">tp </span><span class="s0">if </span><span class="s1">letter </span><span class="s0">in </span><span class="s4">'mM' </span><span class="s0">else </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">letter</span><span class="s2">))</span>
                 <span class="s0">for </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">letter </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">numba_types</span><span class="s2">, </span><span class="s1">ufunc_letters</span><span class="s2">)]</span>
        <span class="s3"># Add missing types (presumably implicit outputs)</span>
        <span class="s1">types </span><span class="s2">+= [</span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">letter</span><span class="s2">))</span>
                  <span class="s0">for </span><span class="s1">letter </span><span class="s0">in </span><span class="s1">ufunc_letters</span><span class="s2">[</span><span class="s1">len</span><span class="s2">(</span><span class="s1">numba_types</span><span class="s2">):]]</span>
        <span class="s0">return </span><span class="s1">types</span>

    <span class="s0">def </span><span class="s1">set_output_dt_units</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">ufunc_inputs</span><span class="s2">, </span><span class="s1">ufunc_name</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Sets the output unit of a datetime type based on the input units 
 
        Timedelta is a special dtype that requires the time unit to be 
        specified (day, month, etc). Not every operation with timedelta inputs 
        leads to an output of timedelta output. However, for those that do, 
        the unit of output must be inferred based on the units of the inputs. 
 
        At the moment this function takes care of two cases: 
        a) where all inputs are timedelta with the same unit (mm), and 
        therefore the output has the same unit. 
        This case is used for arr.sum, and for arr1+arr2 where all arrays 
        are timedeltas. 
        If in the future this needs to be extended to a case with mixed units, 
        the rules should be implemented in `npdatetime_helpers` and called 
        from this function to set the correct output unit. 
        b) where left operand is a timedelta, i.e. the &quot;m?&quot; case. This case 
        is used for division, eg timedelta / int. 
 
        At the time of writing, Numba does not support addition of timedelta 
        and other types, so this function does not consider the case &quot;?m&quot;, 
        i.e. where timedelta is the right operand to a non-timedelta left 
        operand. To extend it in the future, just add another elif clause. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">make_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">):</span>
            <span class="s1">new_outputs </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">out </span><span class="s0">in </span><span class="s1">outputs</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">out</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">) </span><span class="s0">and </span><span class="s1">out</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;&quot;</span><span class="s2">:</span>
                    <span class="s1">new_outputs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_outputs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">new_outputs</span>

        <span class="s0">def </span><span class="s1">make_datetime_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">dt_unit</span><span class="s2">, </span><span class="s1">td_unit</span><span class="s2">):</span>
            <span class="s1">new_outputs </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">out </span><span class="s0">in </span><span class="s1">outputs</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">out</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">) </span><span class="s0">and </span><span class="s1">out</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;&quot;</span><span class="s2">:</span>
                    <span class="s1">unit </span><span class="s2">= </span><span class="s1">npdatetime_helpers</span><span class="s2">.</span><span class="s1">combine_datetime_timedelta_units</span><span class="s2">(</span>
                        <span class="s1">dt_unit</span><span class="s2">, </span><span class="s1">td_unit</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">unit </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;ufunc '</span><span class="s0">{</span><span class="s1">ufunc_name</span><span class="s0">}</span><span class="s4">' is not &quot; </span><span class="s2">+</span>
                                        <span class="s4">&quot;supported between &quot; </span><span class="s2">+</span>
                                        <span class="s4">f&quot;datetime64[</span><span class="s0">{</span><span class="s1">dt_unit</span><span class="s0">}</span><span class="s4">] &quot; </span><span class="s2">+</span>
                                        <span class="s4">f&quot;and timedelta64[</span><span class="s0">{</span><span class="s1">td_unit</span><span class="s0">}</span><span class="s4">]&quot;</span>
                                        <span class="s2">)</span>
                    <span class="s1">new_outputs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_outputs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">new_outputs</span>

        <span class="s0">if </span><span class="s1">ufunc_inputs </span><span class="s2">== </span><span class="s4">'mm'</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">inp</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">unit </span><span class="s0">for </span><span class="s1">inp </span><span class="s0">in </span><span class="s1">inputs</span><span class="s2">):</span>
                <span class="s3"># Case with operation on same units. Operations on different</span>
                <span class="s3"># units not adjusted for now but might need to be</span>
                <span class="s3"># added in the future</span>
                <span class="s1">unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">unit</span>
                <span class="s1">new_outputs </span><span class="s2">= </span><span class="s1">make_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">outputs</span>
            <span class="s0">return </span><span class="s1">new_outputs</span>
        <span class="s0">elif </span><span class="s1">ufunc_inputs </span><span class="s2">== </span><span class="s4">'mM'</span><span class="s2">:</span>
            <span class="s3"># case where the left operand has timedelta type</span>
            <span class="s3"># and the right operand has datetime</span>
            <span class="s1">td_unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">unit</span>
            <span class="s1">dt_unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">1</span><span class="s2">].</span><span class="s1">unit</span>
            <span class="s0">return </span><span class="s1">make_datetime_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">dt_unit</span><span class="s2">, </span><span class="s1">td_unit</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">ufunc_inputs </span><span class="s2">== </span><span class="s4">'Mm'</span><span class="s2">:</span>
            <span class="s3"># case where the right operand has timedelta type</span>
            <span class="s3"># and the left operand has datetime</span>
            <span class="s1">dt_unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">unit</span>
            <span class="s1">td_unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">1</span><span class="s2">].</span><span class="s1">unit</span>
            <span class="s0">return </span><span class="s1">make_datetime_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">dt_unit</span><span class="s2">, </span><span class="s1">td_unit</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">ufunc_inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s4">'m'</span><span class="s2">:</span>
            <span class="s3"># case where the left operand has timedelta type</span>
            <span class="s1">unit </span><span class="s2">= </span><span class="s1">inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">unit</span>
            <span class="s1">new_outputs </span><span class="s2">= </span><span class="s1">make_specific</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">new_outputs</span>

    <span class="s3"># In NumPy, the loops are evaluated from first to last. The first one</span>
    <span class="s3"># that is viable is the one used. One loop is viable if it is possible</span>
    <span class="s3"># to cast every input operand to the one expected by the ufunc.</span>
    <span class="s3"># Also under NumPy 1.10+ the output must be able to be cast back</span>
    <span class="s3"># to a close enough type (&quot;same_kind&quot;).</span>

    <span class="s0">for </span><span class="s1">candidate </span><span class="s0">in </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">types</span><span class="s2">:</span>
        <span class="s1">ufunc_inputs </span><span class="s2">= </span><span class="s1">candidate</span><span class="s2">[:</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nin</span><span class="s2">]</span>
        <span class="s1">ufunc_outputs </span><span class="s2">= </span><span class="s1">candidate</span><span class="s2">[-</span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout</span><span class="s2">:] </span><span class="s0">if </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout </span><span class="s0">else </span><span class="s2">[]</span>

        <span class="s0">if </span><span class="s4">'e' </span><span class="s0">in </span><span class="s1">ufunc_inputs</span><span class="s2">:</span>
            <span class="s3"># Skip float16 arrays since we don't have implementation for them</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s4">'O' </span><span class="s0">in </span><span class="s1">ufunc_inputs</span><span class="s2">:</span>
            <span class="s3"># Skip object arrays</span>
            <span class="s0">continue</span>
        <span class="s1">found </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s3"># Skip if any input or output argument is mismatching</span>
        <span class="s0">for </span><span class="s1">outer</span><span class="s2">, </span><span class="s1">inner </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">np_input_types</span><span class="s2">, </span><span class="s1">ufunc_inputs</span><span class="s2">):</span>
            <span class="s3"># (outer is a dtype instance, inner is a type char)</span>
            <span class="s0">if </span><span class="s1">outer</span><span class="s2">.</span><span class="s1">char </span><span class="s0">in </span><span class="s4">'mM' </span><span class="s0">or </span><span class="s1">inner </span><span class="s0">in </span><span class="s4">'mM'</span><span class="s2">:</span>
                <span class="s3"># For datetime64 and timedelta64, we want to retain</span>
                <span class="s3"># precise typing (i.e. the units); therefore we look for</span>
                <span class="s3"># an exact match.</span>
                <span class="s0">if </span><span class="s1">outer</span><span class="s2">.</span><span class="s1">char </span><span class="s2">!= </span><span class="s1">inner</span><span class="s2">:</span>
                    <span class="s1">found </span><span class="s2">= </span><span class="s0">False</span>
                    <span class="s0">break</span>
            <span class="s0">elif not </span><span class="s1">ufunc_can_cast</span><span class="s2">(</span><span class="s1">outer</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">inner</span><span class="s2">,</span>
                                    <span class="s1">has_mixed_inputs</span><span class="s2">, </span><span class="s4">'safe'</span><span class="s2">):</span>
                <span class="s1">found </span><span class="s2">= </span><span class="s0">False</span>
                <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">found</span><span class="s2">:</span>
            <span class="s3"># Can we cast the inner result to the outer result type?</span>
            <span class="s0">for </span><span class="s1">outer</span><span class="s2">, </span><span class="s1">inner </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">np_output_types</span><span class="s2">, </span><span class="s1">ufunc_outputs</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">outer</span><span class="s2">.</span><span class="s1">char </span><span class="s0">not in </span><span class="s4">'mM' </span><span class="s0">and not</span>
                    <span class="s1">ufunc_can_cast</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">, </span><span class="s1">outer</span><span class="s2">.</span><span class="s1">char</span><span class="s2">,</span>
                                   <span class="s1">has_mixed_inputs</span><span class="s2">, </span><span class="s4">'same_kind'</span><span class="s2">)):</span>
                    <span class="s1">found </span><span class="s2">= </span><span class="s0">False</span>
                    <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">found</span><span class="s2">:</span>
            <span class="s3"># Found: determine the Numba types for the loop's inputs and</span>
            <span class="s3"># outputs.</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">inputs </span><span class="s2">= </span><span class="s1">choose_types</span><span class="s2">(</span><span class="s1">input_types</span><span class="s2">, </span><span class="s1">ufunc_inputs</span><span class="s2">)</span>
                <span class="s1">outputs </span><span class="s2">= </span><span class="s1">choose_types</span><span class="s2">(</span><span class="s1">output_types</span><span class="s2">, </span><span class="s1">ufunc_outputs</span><span class="s2">)</span>
                <span class="s3"># if the left operand or both are timedeltas, or the first</span>
                <span class="s3"># argument is datetime and the second argument is timedelta,</span>
                <span class="s3"># then the output units need to be determined.</span>
                <span class="s0">if </span><span class="s1">ufunc_inputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s4">'m' </span><span class="s0">or </span><span class="s1">ufunc_inputs </span><span class="s2">== </span><span class="s4">'Mm'</span><span class="s2">:</span>
                    <span class="s1">outputs </span><span class="s2">= </span><span class="s1">set_output_dt_units</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">,</span>
                                                  <span class="s1">ufunc_inputs</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>

            <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
                <span class="s3"># One of the selected dtypes isn't supported by Numba</span>
                <span class="s3"># (e.g. float16), try other candidates</span>
                <span class="s0">continue</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">UFuncLoopSpec</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">candidate</span><span class="s2">)</span>

    <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">_is_aligned_struct</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">isalignedstruct</span>


<span class="s0">def </span><span class="s1">from_struct_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Convert a NumPy structured dtype to Numba Record type 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">hasobject</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Do not support dtype containing object&quot;</span><span class="s2">)</span>

    <span class="s1">fields </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">info </span><span class="s0">in </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s3"># *info* may have 3 element</span>
        <span class="s2">[</span><span class="s1">elemdtype</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">] = </span><span class="s1">info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">]</span>
        <span class="s1">title </span><span class="s2">= </span><span class="s1">info</span><span class="s2">[</span><span class="s5">2</span><span class="s2">] </span><span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">info</span><span class="s2">) == </span><span class="s5">3 </span><span class="s0">else None</span>

        <span class="s1">ty </span><span class="s2">= </span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">elemdtype</span><span class="s2">)</span>
        <span class="s1">infos </span><span class="s2">= {</span>
            <span class="s4">'type'</span><span class="s2">: </span><span class="s1">ty</span><span class="s2">,</span>
            <span class="s4">'offset'</span><span class="s2">: </span><span class="s1">offset</span><span class="s2">,</span>
            <span class="s4">'title'</span><span class="s2">: </span><span class="s1">title</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s1">fields</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">name</span><span class="s2">, </span><span class="s1">infos</span><span class="s2">))</span>

    <span class="s3"># Note: dtype.alignment is not consistent.</span>
    <span class="s3">#       It is different after passing into a recarray.</span>
    <span class="s3">#       recarray(N, dtype=mydtype).dtype.alignment != mydtype.alignment</span>
    <span class="s1">size </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span>
    <span class="s1">aligned </span><span class="s2">= </span><span class="s1">_is_aligned_struct</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Record</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">aligned</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_bytes_buffer</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">nbytes</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Get a ctypes array of *nbytes* starting at *ptr*. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">):</span>
        <span class="s1">ptr </span><span class="s2">= </span><span class="s1">ptr</span><span class="s2">.</span><span class="s1">value</span>
    <span class="s1">arrty </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_byte </span><span class="s2">* </span><span class="s1">nbytes</span>
    <span class="s0">return </span><span class="s1">arrty</span><span class="s2">.</span><span class="s1">from_address</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_array_from_ptr</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">nbytes</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">frombuffer</span><span class="s2">(</span><span class="s1">_get_bytes_buffer</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">nbytes</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">carray</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a Numpy array view over the data pointed to by *ptr* with the 
    given *shape*, in C order.  If *dtype* is given, it is used as the 
    array's dtype, otherwise the array's dtype is inferred from *ptr*'s type. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ctypes_utils </span><span class="s0">import </span><span class="s1">from_ctypes</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s3"># Use ctypes parameter protocol if available</span>
        <span class="s1">ptr </span><span class="s2">= </span><span class="s1">ptr</span><span class="s2">.</span><span class="s1">_as_parameter_</span>
    <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s3"># Normalize dtype, to accept e.g. &quot;int64&quot; or np.int64</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;explicit dtype required for void* argument&quot;</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">ptr</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">_Pointer</span><span class="s2">):</span>
        <span class="s1">ptrty </span><span class="s2">= </span><span class="s1">from_ctypes</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ptrty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">CPointer</span><span class="s2">)</span>
        <span class="s1">ptr_dtype </span><span class="s2">= </span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">ptrty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None and </span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">ptr_dtype</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;mismatching dtype '%s' for pointer %s&quot;</span>
                            <span class="s2">% (</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">))</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">ptr_dtype</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;expected a ctypes pointer, got %r&quot; </span><span class="s2">% (</span><span class="s1">ptr</span><span class="s2">,))</span>

    <span class="s1">nbytes </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_get_array_from_ptr</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">nbytes</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">farray</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a Numpy array view over the data pointed to by *ptr* with the 
    given *shape*, in Fortran order.  If *dtype* is given, it is used as the 
    array's dtype, otherwise the array's dtype is inferred from *ptr*'s type. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">shape</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">carray</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">T</span>


<span class="s0">def </span><span class="s1">is_contiguous</span><span class="s2">(</span><span class="s1">dims</span><span class="s2">, </span><span class="s1">strides</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Is the given shape, strides, and itemsize of C layout? 
 
    Note: The code is usable as a numba-compiled function 
    &quot;&quot;&quot;</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dims</span><span class="s2">)</span>
    <span class="s3"># Check and skip 1s or 0s in inner dims</span>
    <span class="s1">innerax </span><span class="s2">= </span><span class="s1">nd </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s0">while </span><span class="s1">innerax </span><span class="s2">&gt; -</span><span class="s5">1 </span><span class="s0">and </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">innerax</span><span class="s2">] &lt;= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">innerax </span><span class="s2">-= </span><span class="s5">1</span>

    <span class="s3"># Early exit if all axis are 1s or 0s</span>
    <span class="s0">if </span><span class="s1">innerax </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">return True</span>

    <span class="s3"># Check itemsize matches innermost stride</span>
    <span class="s0">if </span><span class="s1">itemsize </span><span class="s2">!= </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">innerax</span><span class="s2">]:</span>
        <span class="s0">return False</span>

    <span class="s3"># Check and skip 1s or 0s in outer dims</span>
    <span class="s1">outerax </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s0">while </span><span class="s1">outerax </span><span class="s2">&lt; </span><span class="s1">innerax </span><span class="s0">and </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">outerax</span><span class="s2">] &lt;= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">outerax </span><span class="s2">+= </span><span class="s5">1</span>

    <span class="s3"># Check remaining strides to be contiguous</span>
    <span class="s1">ax </span><span class="s2">= </span><span class="s1">innerax</span>
    <span class="s0">while </span><span class="s1">ax </span><span class="s2">&gt; </span><span class="s1">outerax</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] * </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] != </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">ax </span><span class="s2">- </span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">return False</span>
        <span class="s1">ax </span><span class="s2">-= </span><span class="s5">1</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">is_fortran</span><span class="s2">(</span><span class="s1">dims</span><span class="s2">, </span><span class="s1">strides</span><span class="s2">, </span><span class="s1">itemsize</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Is the given shape, strides, and itemsize of F layout? 
 
    Note: The code is usable as a numba-compiled function 
    &quot;&quot;&quot;</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dims</span><span class="s2">)</span>
    <span class="s3"># Check and skip 1s or 0s in inner dims</span>
    <span class="s1">firstax </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s0">while </span><span class="s1">firstax </span><span class="s2">&lt; </span><span class="s1">nd </span><span class="s0">and </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">firstax</span><span class="s2">] &lt;= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">firstax </span><span class="s2">+= </span><span class="s5">1</span>

    <span class="s3"># Early exit if all axis are 1s or 0s</span>
    <span class="s0">if </span><span class="s1">firstax </span><span class="s2">&gt;= </span><span class="s1">nd</span><span class="s2">:</span>
        <span class="s0">return True</span>

    <span class="s3"># Check itemsize matches innermost stride</span>
    <span class="s0">if </span><span class="s1">itemsize </span><span class="s2">!= </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">firstax</span><span class="s2">]:</span>
        <span class="s0">return False</span>

    <span class="s3"># Check and skip 1s or 0s in outer dims</span>
    <span class="s1">lastax </span><span class="s2">= </span><span class="s1">nd </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s0">while </span><span class="s1">lastax </span><span class="s2">&gt; </span><span class="s1">firstax </span><span class="s0">and </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">lastax</span><span class="s2">] &lt;= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">lastax </span><span class="s2">-= </span><span class="s5">1</span>

    <span class="s3"># Check remaining strides to be contiguous</span>
    <span class="s1">ax </span><span class="s2">= </span><span class="s1">firstax</span>
    <span class="s0">while </span><span class="s1">ax </span><span class="s2">&lt; </span><span class="s1">lastax</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] * </span><span class="s1">dims</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] != </span><span class="s1">strides</span><span class="s2">[</span><span class="s1">ax </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">return False</span>
        <span class="s1">ax </span><span class="s2">+= </span><span class="s5">1</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">type_can_asarray</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; Returns True if the type of 'arr' is supported by the Numba `np.asarray` 
    implementation, False otherwise. 
    &quot;&quot;&quot;</span>

    <span class="s1">ok </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Array</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">StringLiteral</span><span class="s2">,</span>
          <span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">containers</span><span class="s2">.</span><span class="s1">ListType</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">type_is_scalar</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; Returns True if the type of 'typ' is a scalar type, according to 
    NumPy rules. False otherwise. 
    https://numpy.org/doc/stable/reference/arrays.scalars.html#built-in-scalar-types 
    &quot;&quot;&quot;</span>

    <span class="s1">ok </span><span class="s2">= (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Boolean</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UnicodeType</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">StringLiteral</span><span class="s2">,</span>
          <span class="s1">types</span><span class="s2">.</span><span class="s1">NPTimedelta</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NPDatetime</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">check_is_integer</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Raises TypingError if the value is not an integer.&quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypingError</span><span class="s2">(</span><span class="s4">'{} must be an integer'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">lt_floats</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s3"># Adapted from NumPy commit 717c7acf which introduced the behavior of</span>
    <span class="s3"># putting NaNs at the end.</span>
    <span class="s3"># The code is later moved to numpy/core/src/npysort/npysort_common.h</span>
    <span class="s3"># This info is gathered as of NumPy commit d8c09c50</span>
    <span class="s0">return </span><span class="s1">a </span><span class="s2">&lt; </span><span class="s1">b </span><span class="s0">or </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">a</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">lt_complex</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">real</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">):</span>
                <span class="s0">return False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">):</span>
                    <span class="s0">return True</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">&lt; </span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return False</span>

    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span><span class="s2">):</span>
            <span class="s0">return True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real </span><span class="s2">&lt; </span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">):</span>
                    <span class="s0">return True</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real </span><span class="s2">&lt; </span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span><span class="s2">:</span>
                        <span class="s0">return True</span>
                    <span class="s0">elif </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real </span><span class="s2">== </span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">&lt; </span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span>
                    <span class="s0">return False</span>
</pre>
</body>
</html>