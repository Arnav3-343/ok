<html>
<head>
<title>linalg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
linalg.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of linear algebra operations. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">llvmlite </span><span class="s2">import </span><span class="s1">ir</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">imputils </span><span class="s2">import </span><span class="s3">(</span><span class="s1">lower_builtin</span><span class="s3">, </span><span class="s1">impl_ret_borrowed</span><span class="s3">,</span>
                                    <span class="s1">impl_ret_new_ref</span><span class="s3">, </span><span class="s1">impl_ret_untracked</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">extending </span><span class="s2">import </span><span class="s1">intrinsic</span><span class="s3">, </span><span class="s1">overload</span><span class="s3">, </span><span class="s1">register_jitable</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">cgutils</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">TypingError</span><span class="s3">, </span><span class="s1">NumbaTypeError</span><span class="s3">, </span><span class="s1">\</span>
    <span class="s1">NumbaPerformanceWarning</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">arrayobj </span><span class="s2">import </span><span class="s1">make_array</span><span class="s3">, </span><span class="s1">_empty_nd_impl</span><span class="s3">, </span><span class="s1">array_copy</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">np </span><span class="s2">import </span><span class="s1">numpy_support </span><span class="s2">as </span><span class="s1">np_support</span>

<span class="s1">ll_char </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>
<span class="s1">ll_char_p </span><span class="s3">= </span><span class="s1">ll_char</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>
<span class="s1">ll_void_p </span><span class="s3">= </span><span class="s1">ll_char_p</span>
<span class="s1">ll_intc </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">32</span><span class="s3">)</span>
<span class="s1">ll_intc_p </span><span class="s3">= </span><span class="s1">ll_intc</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>
<span class="s1">intp_t </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span>
<span class="s1">ll_intp_p </span><span class="s3">= </span><span class="s1">intp_t</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>


<span class="s5"># fortran int type, this needs to match the F_INT C declaration in</span>
<span class="s5"># _lapack.c and is present to accommodate potential future 64bit int</span>
<span class="s5"># based LAPACK use.</span>
<span class="s1">F_INT_nptype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
<span class="s1">F_INT_nbtype </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">int32</span>

<span class="s5"># BLAS kinds as letters</span>
<span class="s1">_blas_kinds </span><span class="s3">= {</span>
    <span class="s1">types</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">: </span><span class="s6">'s'</span><span class="s3">,</span>
    <span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">: </span><span class="s6">'d'</span><span class="s3">,</span>
    <span class="s1">types</span><span class="s3">.</span><span class="s1">complex64</span><span class="s3">: </span><span class="s6">'c'</span><span class="s3">,</span>
    <span class="s1">types</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">: </span><span class="s6">'z'</span><span class="s3">,</span>
<span class="s3">}</span>


<span class="s2">def </span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">=</span><span class="s6">&quot;&lt;BLAS function&gt;&quot;</span><span class="s3">):</span>
    <span class="s1">kind </span><span class="s3">= </span><span class="s1">_blas_kinds</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kind </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s6">&quot;unsupported dtype for %s()&quot; </span><span class="s3">% (</span><span class="s1">func_name</span><span class="s3">,))</span>
    <span class="s2">return </span><span class="s1">kind</span>


<span class="s2">def </span><span class="s1">ensure_blas</span><span class="s3">():</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cython_blas</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s6">&quot;scipy 0.16+ is required for linear algebra&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ensure_lapack</span><span class="s3">():</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cython_lapack</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s6">&quot;scipy 0.16+ is required for linear algebra&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_constant_slot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">const </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant_generic</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">const</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_BLAS</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Functions to return type signatures for wrapped 
    BLAS functions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">ensure_blas</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_xxnrm2</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">rtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># x</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># incx</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">rtype</span><span class="s3">))  </span><span class="s5"># returned</span>

        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_xxnrm2&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_xxgemm</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># transa</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># transb</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># m</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># k</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># alpha</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># b</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># ldb</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># beta</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># c</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp              </span><span class="s5"># ldc</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_xxgemm&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_LAPACK</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Functions to return type signatures for wrapped 
    LAPACK functions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_xxgetrf</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,                   </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                   </span><span class="s5"># m</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                   </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),        </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                   </span><span class="s5"># lda</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">F_INT_nbtype</span><span class="s3">)  </span><span class="s5"># ipiv</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_xxgetrf&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_xxgetri</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,                   </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                   </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),        </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                   </span><span class="s5"># lda</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">F_INT_nbtype</span><span class="s3">)  </span><span class="s5"># ipiv</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_xxgetri&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_rgeev</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobvl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobvr</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># wr</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># wi</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># vl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># ldvl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># vr</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp              </span><span class="s5"># ldvr</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_rgeev&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_cgeev</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobvl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobvr</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># w</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># vl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># ldvl</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># vr</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp              </span><span class="s5"># ldvr</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_cgeev&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_xxxevd</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">wtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobz</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># uplo</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">wtype</span><span class="s3">),  </span><span class="s5"># w</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_xxxevd&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_xxpotrf</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># uplo</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
                         <span class="s1">types</span><span class="s3">.</span><span class="s1">intp              </span><span class="s5"># lda</span>
                         <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_xxpotrf&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">stype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># jobz</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># m</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">stype</span><span class="s3">),  </span><span class="s5"># s</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># u</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># ldu</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># vt</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp              </span><span class="s5"># ldvt</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_gesdd&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_geqrf</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># m</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># tau</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_geqrf&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_xxgqr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,             </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># m</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># k</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,             </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),  </span><span class="s5"># tau</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_xxgqr&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_ez_gelsd</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">rtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,                 </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                 </span><span class="s5"># m</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                 </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                 </span><span class="s5"># nrhs</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),      </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                 </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),      </span><span class="s5"># b</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                 </span><span class="s5"># ldb</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">rtype</span><span class="s3">),      </span><span class="s5"># S</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">,              </span><span class="s5"># rcond</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">)  </span><span class="s5"># rank</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_ez_gelsd&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">numba_xgesv</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">(</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">char</span><span class="s3">,                    </span><span class="s5"># kind</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                    </span><span class="s5"># n</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                    </span><span class="s5"># nhrs</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),         </span><span class="s5"># a</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">,                    </span><span class="s5"># lda</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">F_INT_nbtype</span><span class="s3">),  </span><span class="s5"># ipiv</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">CPointer</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">),         </span><span class="s5"># b</span>
            <span class="s1">types</span><span class="s3">.</span><span class="s1">intp                     </span><span class="s5"># ldb</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_xgesv&quot;</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">make_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Ensure that all array arguments are contiguous, if necessary by 
    copying them. 
    A new (sig, args) tuple is yielded. 
    &quot;&quot;&quot;</span>
    <span class="s1">newtys </span><span class="s3">= []</span>
    <span class="s1">newargs </span><span class="s3">= []</span>
    <span class="s1">copies </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">or </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">in </span><span class="s6">'CF'</span><span class="s3">:</span>
            <span class="s1">newty</span><span class="s3">, </span><span class="s1">newval </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">newty </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">=</span><span class="s6">'C'</span><span class="s3">)</span>
            <span class="s1">copysig </span><span class="s3">= </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">)</span>
            <span class="s1">newval </span><span class="s3">= </span><span class="s1">array_copy</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">copysig</span><span class="s3">, (</span><span class="s1">val</span><span class="s3">,))</span>
            <span class="s1">copies</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">newty</span><span class="s3">, </span><span class="s1">newval</span><span class="s3">))</span>
        <span class="s1">newtys</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newty</span><span class="s3">)</span>
        <span class="s1">newargs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newval</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, *</span><span class="s1">newtys</span><span class="s3">), </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">newargs</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">copies</span><span class="s3">:</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">decref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether *n* fits in a C `int`. 
    &quot;&quot;&quot;</span>
    <span class="s1">_maxint </span><span class="s3">= </span><span class="s4">2</span><span class="s3">**</span><span class="s4">31 </span><span class="s3">- </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s1">_maxint</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">OverflowError</span><span class="s3">(</span><span class="s6">&quot;array size too large to fit in C int&quot;</span><span class="s3">)</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">,</span>
                             <span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">), (</span><span class="s1">n</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">check_blas_return</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the integer error return from one of the BLAS wrappers in 
    _helperlib.c. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_not_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5"># Those errors shouldn't happen, it's easier to just abort the process</span>
        <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">gil_ensure</span><span class="s3">()</span>
        <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">fatal_error</span><span class="s3">(</span><span class="s6">&quot;BLAS wrapper returned with an error&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_lapack_return</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the integer error return from one of the LAPACK wrappers in 
    _helperlib.c. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_not_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5"># Those errors shouldn't happen, it's easier to just abort the process</span>
        <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">gil_ensure</span><span class="s3">()</span>
        <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">fatal_error</span><span class="s3">(</span><span class="s6">&quot;LAPACK wrapper returned with an error&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">call_xxdot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">,</span>
               <span class="s1">n</span><span class="s3">, </span><span class="s1">a_data</span><span class="s3">, </span><span class="s1">b_data</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call the BLAS vector * vector product function for the given arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">32</span><span class="s3">),</span>
                           <span class="s3">[</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,    </span><span class="s5"># kind, conjugate, n</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">,  </span><span class="s5"># a, b, out</span>
                            <span class="s3">])</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s6">&quot;numba_xxdot&quot;</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">kind_val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">))</span>
    <span class="s1">conjugate </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">conjugate</span><span class="s3">))</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, (</span><span class="s1">kind_val</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">a_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">b_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">out_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">)))</span>
    <span class="s1">check_blas_return</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">call_xxgemv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">do_trans</span><span class="s3">,</span>
                <span class="s1">m_type</span><span class="s3">, </span><span class="s1">m_shapes</span><span class="s3">, </span><span class="s1">m_data</span><span class="s3">, </span><span class="s1">v_data</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call the BLAS matrix * vector product function for the given arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">32</span><span class="s3">),</span>
                           <span class="s3">[</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ll_char</span><span class="s3">,                 </span><span class="s5"># kind, trans</span>
                            <span class="s1">intp_t</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,                   </span><span class="s5"># m, n</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,     </span><span class="s5"># alpha, a, lda</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">,  </span><span class="s5"># x, beta, y</span>
                            <span class="s3">])</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s6">&quot;numba_xxgemv&quot;</span><span class="s3">)</span>

    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">m_type</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s1">make_constant_slot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">)</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">make_constant_slot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">m_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'F'</span><span class="s3">:</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">m_shapes</span>
        <span class="s1">lda </span><span class="s3">= </span><span class="s1">m_shapes</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">m_shapes</span>
        <span class="s1">lda </span><span class="s3">= </span><span class="s1">m_shapes</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">kind_val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">))</span>
    <span class="s1">trans </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'t'</span><span class="s3">) </span><span class="s2">if </span><span class="s1">do_trans </span><span class="s2">else </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'n'</span><span class="s3">))</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, (</span><span class="s1">kind_val</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">m_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">), </span><span class="s1">lda</span><span class="s3">,</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">v_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">beta</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">out_data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">)))</span>
    <span class="s1">check_blas_return</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">call_xxgemm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                <span class="s1">x_type</span><span class="s3">, </span><span class="s1">x_shapes</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">,</span>
                <span class="s1">y_type</span><span class="s3">, </span><span class="s1">y_shapes</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">,</span>
                <span class="s1">out_type</span><span class="s3">, </span><span class="s1">out_shapes</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call the BLAS matrix * matrix product function for the given arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">32</span><span class="s3">),</span>
                           <span class="s3">[</span><span class="s1">ll_char</span><span class="s3">,                       </span><span class="s5"># kind</span>
                            <span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ll_char</span><span class="s3">,              </span><span class="s5"># transa, transb</span>
                            <span class="s1">intp_t</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,        </span><span class="s5"># m, n, k</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,  </span><span class="s5"># alpha, a, lda</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">,  </span><span class="s5"># b, ldb, beta</span>
                            <span class="s1">ll_void_p</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">,             </span><span class="s5"># c, ldc</span>
                            <span class="s3">])</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s6">&quot;numba_xxgemm&quot;</span><span class="s3">)</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">x_shapes</span>
    <span class="s1">_k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">y_shapes</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">x_type</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s1">make_constant_slot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">)</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">make_constant_slot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">)</span>

    <span class="s1">trans </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'t'</span><span class="s3">))</span>
    <span class="s1">notrans </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'n'</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">get_array_param</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">shapes</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s5"># Transpose if layout different from result's</span>
            <span class="s1">notrans </span><span class="s2">if </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">out_type</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">else </span><span class="s1">trans</span><span class="s3">,</span>
            <span class="s5"># Size of the inner dimension in physical array order</span>
            <span class="s1">shapes</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] </span><span class="s2">if </span><span class="s1">ty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'C' </span><span class="s2">else </span><span class="s1">shapes</span><span class="s3">[</span><span class="s4">0</span><span class="s3">],</span>
            <span class="s5"># The data pointer, unit-less</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
        <span class="s3">)</span>

    <span class="s1">transa</span><span class="s3">, </span><span class="s1">lda</span><span class="s3">, </span><span class="s1">data_a </span><span class="s3">= </span><span class="s1">get_array_param</span><span class="s3">(</span><span class="s1">y_type</span><span class="s3">, </span><span class="s1">y_shapes</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">)</span>
    <span class="s1">transb</span><span class="s3">, </span><span class="s1">ldb</span><span class="s3">, </span><span class="s1">data_b </span><span class="s3">= </span><span class="s1">get_array_param</span><span class="s3">(</span><span class="s1">x_type</span><span class="s3">, </span><span class="s1">x_shapes</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">)</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">ldc</span><span class="s3">, </span><span class="s1">data_c </span><span class="s3">= </span><span class="s1">get_array_param</span><span class="s3">(</span><span class="s1">out_type</span><span class="s3">, </span><span class="s1">out_shapes</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">kind_val </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ll_char</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">))</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, (</span><span class="s1">kind_val</span><span class="s3">, </span><span class="s1">transa</span><span class="s3">, </span><span class="s1">transb</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">,</span>
                            <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">), </span><span class="s1">data_a</span><span class="s3">, </span><span class="s1">lda</span><span class="s3">,</span>
                            <span class="s1">data_b</span><span class="s3">, </span><span class="s1">ldb</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">beta</span><span class="s3">, </span><span class="s1">ll_void_p</span><span class="s3">),</span>
                            <span class="s1">data_c</span><span class="s3">, </span><span class="s1">ldc</span><span class="s3">))</span>
    <span class="s1">check_blas_return</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_2_mm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(matrix, matrix) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">dot_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">_k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dot_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_2_vm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(vector, matrix) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">dot_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">m</span><span class="s3">, = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">_m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, ), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, ), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dot_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_2_mv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(matrix, vector) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">dot_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">_n</span><span class="s3">, = </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, ), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, ), </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dot_impl</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_2_vv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(vector, vector) 
    np.vdot(vector, vector) 
    &quot;&quot;&quot;</span>
    <span class="s1">aty</span><span class="s3">, </span><span class="s1">bty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">aty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">bty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">n</span><span class="s3">, = </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">check_args</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">m</span><span class="s3">, = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">n</span><span class="s3">, = </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s3">!= </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible array sizes for np.dot(a, b) &quot;</span>
                             <span class="s6">&quot;(vector * vector)&quot;</span><span class="s3">)</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">check_args</span><span class="s3">,</span>
                             <span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">), </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s1">call_xxdot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">b</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">dot_2</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">dot_2_impl</span><span class="s3">(</span><span class="s6">'np.dot()'</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">matmul</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">matmul_2</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    a @ b 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">dot_2_impl</span><span class="s3">(</span><span class="s6">&quot;'@'&quot;</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_2_impl</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">intrinsic</span>
        <span class="s2">def </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">typingcontext</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
            <span class="s1">ndims </span><span class="s3">= (</span><span class="s1">left</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">right</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">_dot2_codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
                <span class="s1">ensure_blas</span><span class="s3">()</span>

                <span class="s2">with </span><span class="s1">make_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                        <span class="s2">return </span><span class="s1">dot_2_mm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                        <span class="s2">return </span><span class="s1">dot_2_mv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                        <span class="s2">return </span><span class="s1">dot_2_vm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                        <span class="s2">return </span><span class="s1">dot_2_vv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s6">'unreachable'</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span>
                    <span class="s6">&quot;%s arguments must all have the same dtype&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s6">'C'</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">(</span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s6">'C'</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== (</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">return_type </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">((</span><span class="s6">&quot;%s: inputs must have compatible &quot;</span>
                                   <span class="s6">&quot;dimensions&quot;</span><span class="s3">) % </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">), </span><span class="s1">_dot2_codegen</span>

        <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF' </span><span class="s2">or </span><span class="s1">right</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF'</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s6">&quot;%s is faster on contiguous arrays, called on %s&quot; </span><span class="s3">% (</span>
                    <span class="s1">name</span><span class="s3">, (</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">),), </span><span class="s1">NumbaPerformanceWarning</span><span class="s3">)</span>

        <span class="s2">return lambda </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">: </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vdot</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">vdot</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.vdot(a, b) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">intrinsic</span>
        <span class="s2">def </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">typingcontext</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
                <span class="s1">ensure_blas</span><span class="s3">()</span>

                <span class="s2">with </span><span class="s1">make_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) </span><span class="s2">as</span><span class="s1">\</span>
                        <span class="s3">(</span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">dot_2_vv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">right</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;np.vdot() only supported on 1-D arrays&quot;</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span>
                    <span class="s6">&quot;np.vdot() arguments must all have the same dtype&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">), </span><span class="s1">codegen</span>

        <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF' </span><span class="s2">or </span><span class="s1">right</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF'</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s6">&quot;np.vdot() is faster on contiguous arrays, called on %s&quot;</span>
                <span class="s3">% ((</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">),), </span><span class="s1">NumbaPerformanceWarning</span><span class="s3">)</span>

        <span class="s2">return lambda </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">: </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_3_vm_check_args</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s1">m</span><span class="s3">, = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">_m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">!= </span><span class="s1">_m</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible array sizes for &quot;</span>
                         <span class="s6">&quot;np.dot(a, b) (vector * matrix)&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">n</span><span class="s3">,):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible output array size for &quot;</span>
                         <span class="s6">&quot;np.dot(a, b, out) (vector * matrix)&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_3_mv_check_args</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">_n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">n</span><span class="s3">, = </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">!= </span><span class="s1">_n</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible array sizes for np.dot(a, b) &quot;</span>
                         <span class="s6">&quot;(matrix * vector)&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">m</span><span class="s3">,):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible output array size for &quot;</span>
                         <span class="s6">&quot;np.dot(a, b, out) (matrix * vector)&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dot_3_vm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(vector, matrix, out) 
    np.dot(matrix, vector, out) 
    &quot;&quot;&quot;</span>
    <span class="s1">xty</span><span class="s3">, </span><span class="s1">yty</span><span class="s3">, </span><span class="s1">outty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s2">assert </span><span class="s1">outty </span><span class="s3">== </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xty</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">xty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">yty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">outty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">x_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">y_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">xty</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s1">yty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s5"># Vector * matrix</span>
        <span class="s5"># Asked for x * y, we will compute y.T * x</span>
        <span class="s1">mty </span><span class="s3">= </span><span class="s1">yty</span>
        <span class="s1">m_shapes </span><span class="s3">= </span><span class="s1">y_shapes</span>
        <span class="s1">v_shape </span><span class="s3">= </span><span class="s1">x_shapes</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">lda </span><span class="s3">= </span><span class="s1">m_shapes</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">do_trans </span><span class="s3">= </span><span class="s1">yty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'F'</span>
        <span class="s1">m_data</span><span class="s3">, </span><span class="s1">v_data </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">check_args </span><span class="s3">= </span><span class="s1">dot_3_vm_check_args</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># Matrix * vector</span>
        <span class="s5"># We will compute x * y</span>
        <span class="s1">mty </span><span class="s3">= </span><span class="s1">xty</span>
        <span class="s1">m_shapes </span><span class="s3">= </span><span class="s1">x_shapes</span>
        <span class="s1">v_shape </span><span class="s3">= </span><span class="s1">y_shapes</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">lda </span><span class="s3">= </span><span class="s1">m_shapes</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">do_trans </span><span class="s3">= </span><span class="s1">xty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'C'</span>
        <span class="s1">m_data</span><span class="s3">, </span><span class="s1">v_data </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">check_args </span><span class="s3">= </span><span class="s1">dot_3_mv_check_args</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">check_args</span><span class="s3">,</span>
                             <span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">), </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">m_shapes</span><span class="s3">:</span>
        <span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">both_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">v_shape</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">matrix_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">lda</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">both_empty</span><span class="s3">, </span><span class="s1">matrix_empty</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">empty</span><span class="s3">, </span><span class="s1">nonempty</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                           <span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">nonempty</span><span class="s3">:</span>
            <span class="s1">call_xxgemv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">do_trans</span><span class="s3">, </span><span class="s1">mty</span><span class="s3">, </span><span class="s1">m_shapes</span><span class="s3">, </span><span class="s1">m_data</span><span class="s3">,</span>
                        <span class="s1">v_data</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                             <span class="s1">out</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s2">def </span><span class="s1">dot_3_mm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(matrix, matrix, out) 
    &quot;&quot;&quot;</span>
    <span class="s1">xty</span><span class="s3">, </span><span class="s1">yty</span><span class="s3">, </span><span class="s1">outty </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span>
    <span class="s2">assert </span><span class="s1">outty </span><span class="s3">== </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xty</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">xty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">yty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">make_array</span><span class="s3">(</span><span class="s1">outty</span><span class="s3">)(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">x_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">y_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out_shapes </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">x_shapes</span>
    <span class="s1">_k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">y_shapes</span>

    <span class="s5"># The only case Numpy supports</span>
    <span class="s2">assert </span><span class="s1">outty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'C'</span>

    <span class="s2">def </span><span class="s1">check_args</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">_k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">!= </span><span class="s1">_k</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible array sizes for np.dot(a, b) &quot;</span>
                             <span class="s6">&quot;(matrix * matrix)&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">out</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;incompatible output array size for &quot;</span>
                             <span class="s6">&quot;np.dot(a, b, out) (matrix * matrix)&quot;</span><span class="s3">)</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">compile_internal</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">check_args</span><span class="s3">,</span>
                             <span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">, *</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">), </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s1">check_c_int</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">x_data </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">y_data </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">out_data </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s5"># If eliminated dimension is zero, set all entries to zero and return</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">both_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">x_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">y_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">)</span>
    <span class="s1">is_empty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">both_empty</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">x_empty</span><span class="s3">, </span><span class="s1">y_empty</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_empty</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">empty</span><span class="s3">, </span><span class="s1">nonempty</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
                           <span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">nitems</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">nonempty</span><span class="s3">:</span>
            <span class="s5"># Check if any of the operands is really a 1-d vector represented</span>
            <span class="s5"># as a (1, k) or (k, 1) 2-d array.  In those cases, it is pessimal</span>
            <span class="s5"># to call the generic matrix * matrix product BLAS function.</span>
            <span class="s1">one </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">is_left_vec </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">one</span><span class="s3">)</span>
            <span class="s1">is_right_vec </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s6">'=='</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">one</span><span class="s3">)</span>

            <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_right_vec</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">r_vec</span><span class="s3">, </span><span class="s1">r_mat</span><span class="s3">):</span>
                <span class="s2">with </span><span class="s1">r_vec</span><span class="s3">:</span>
                    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_left_vec</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">v_v</span><span class="s3">, </span><span class="s1">m_v</span><span class="s3">):</span>
                        <span class="s2">with </span><span class="s1">v_v</span><span class="s3">:</span>
                            <span class="s5"># V * V</span>
                            <span class="s1">call_xxdot</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">,</span>
                                       <span class="s1">k</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">)</span>
                        <span class="s2">with </span><span class="s1">m_v</span><span class="s3">:</span>
                            <span class="s5"># M * V</span>
                            <span class="s1">do_trans </span><span class="s3">= </span><span class="s1">xty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s1">outty</span><span class="s3">.</span><span class="s1">layout</span>
                            <span class="s1">call_xxgemv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">do_trans</span><span class="s3">,</span>
                                        <span class="s1">xty</span><span class="s3">, </span><span class="s1">x_shapes</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">)</span>
                <span class="s2">with </span><span class="s1">r_mat</span><span class="s3">:</span>
                    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_left_vec</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">v_m</span><span class="s3">, </span><span class="s1">m_m</span><span class="s3">):</span>
                        <span class="s2">with </span><span class="s1">v_m</span><span class="s3">:</span>
                            <span class="s5"># V * M</span>
                            <span class="s1">do_trans </span><span class="s3">= </span><span class="s1">yty</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">!= </span><span class="s1">outty</span><span class="s3">.</span><span class="s1">layout</span>
                            <span class="s1">call_xxgemv</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">do_trans</span><span class="s3">,</span>
                                        <span class="s1">yty</span><span class="s3">, </span><span class="s1">y_shapes</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">)</span>
                        <span class="s2">with </span><span class="s1">m_m</span><span class="s3">:</span>
                            <span class="s5"># M * M</span>
                            <span class="s1">call_xxgemm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                        <span class="s1">xty</span><span class="s3">, </span><span class="s1">x_shapes</span><span class="s3">, </span><span class="s1">x_data</span><span class="s3">,</span>
                                        <span class="s1">yty</span><span class="s3">, </span><span class="s1">y_shapes</span><span class="s3">, </span><span class="s1">y_data</span><span class="s3">,</span>
                                        <span class="s1">outty</span><span class="s3">, </span><span class="s1">out_shapes</span><span class="s3">, </span><span class="s1">out_data</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">,</span>
                             <span class="s1">out</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">dot_3</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    np.dot(a, b, out) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">) </span><span class="s2">and</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)):</span>
        <span class="s3">@</span><span class="s1">intrinsic</span>
        <span class="s2">def </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">typingcontext</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">codegen</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
                <span class="s1">ensure_blas</span><span class="s3">()</span>

                <span class="s2">with </span><span class="s1">make_contiguous</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">sig</span><span class="s3">,</span>
                                                                      <span class="s1">args</span><span class="s3">):</span>
                    <span class="s1">ndims </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[:</span><span class="s4">2</span><span class="s3">])</span>
                    <span class="s2">if </span><span class="s1">ndims </span><span class="s3">== {</span><span class="s4">2</span><span class="s3">}:</span>
                        <span class="s2">return </span><span class="s1">dot_3_mm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">ndims </span><span class="s3">== {</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">}:</span>
                        <span class="s2">return </span><span class="s1">dot_3_vm</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s6">'unreachable'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">or </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span>
                    <span class="s6">&quot;np.dot() arguments must all have the same dtype&quot;</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">out</span><span class="s3">), </span><span class="s1">codegen</span>

        <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF' </span><span class="s2">or </span><span class="s1">right</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s6">'CF' </span><span class="s2">or </span><span class="s1">out</span><span class="s3">.</span><span class="s1">layout\</span>
            <span class="s2">not in </span><span class="s6">'CF'</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s6">&quot;np.vdot() is faster on contiguous arrays, called on %s&quot;</span>
                <span class="s3">% ((</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">),), </span><span class="s1">NumbaPerformanceWarning</span><span class="s3">)</span>

        <span class="s2">return lambda </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">out</span><span class="s3">: </span><span class="s1">_impl</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>


<span class="s1">fatal_error_func </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ExternalFunction</span><span class="s3">(</span><span class="s6">&quot;numba_fatal_error&quot;</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()):</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span>
                <span class="s6">&quot;Array must not contain infs or NaNs.&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5"># la_prefix is present as some functions, e.g. np.trace()</span>
    <span class="s5"># are documented under &quot;linear algebra&quot; but aren't in the</span>
    <span class="s5"># module</span>
    <span class="s1">prefix </span><span class="s3">= </span><span class="s6">&quot;np.linalg&quot; </span><span class="s2">if </span><span class="s1">la_prefix </span><span class="s2">else </span><span class="s6">&quot;np&quot;</span>
    <span class="s1">interp </span><span class="s3">= (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
    <span class="s5"># Unpack optional type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;%s.%s() only supported for array types&quot; </span><span class="s3">% </span><span class="s1">interp</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;%s.%s() only supported on 2-D arrays.&quot; </span><span class="s3">% </span><span class="s1">interp</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;%s.%s() only supported on &quot;</span><span class="s1">\</span>
            <span class="s6">&quot;float and complex arrays.&quot; </span><span class="s3">% </span><span class="s1">interp</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_homogeneous_types</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">, *</span><span class="s1">types</span><span class="s3">):</span>
    <span class="s1">t0 </span><span class="s3">= </span><span class="s1">types</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">dtype</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:]:</span>
        <span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">t0</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;np.linalg.%s() only supports inputs that have homogeneous dtypes.&quot; </span><span class="s3">% </span><span class="s1">func_name</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_copy_to_fortran_order</span><span class="s3">():</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_copy_to_fortran_order</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">ol_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s5"># This function copies the array 'a' into a new array with fortran order.</span>
    <span class="s5"># This exists because the copy routines don't take order flags yet.</span>
    <span class="s1">F_layout </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'F'</span>
    <span class="s1">A_layout </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'A'</span>
    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">F_layout</span><span class="s3">:</span>
            <span class="s5"># it's F ordered at compile time, just copy</span>
            <span class="s1">acpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">A_layout</span><span class="s3">:</span>
            <span class="s5"># decide based on runtime value</span>
            <span class="s1">flag_f </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">f_contiguous</span>
            <span class="s2">if </span><span class="s1">flag_f</span><span class="s3">:</span>
                <span class="s5"># it's already F ordered, so copy but in a round about way to</span>
                <span class="s5"># ensure that the copy is also F ordered</span>
                <span class="s1">acpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">T</span><span class="s3">).</span><span class="s1">T</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># it's something else ordered, so let asfortranarray deal with</span>
                <span class="s5"># copying and making it fortran ordered</span>
                <span class="s1">acpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># it's C ordered at compile time, asfortranarray it.</span>
            <span class="s1">acpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">acpy</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_inv_err_handler</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">r </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fatal_error_func</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s4">0   </span><span class="s5"># unreachable</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span>
                <span class="s6">&quot;Matrix is singular to machine precision.&quot;</span><span class="s3">)</span>

<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_dummy_liveness_func</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;pass a list of variables to be preserved through dead code elimination&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">inv</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">inv_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;inv&quot;</span><span class="s3">)</span>

    <span class="s1">numba_xxgetrf </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_xxgetrf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">numba_xxgetri </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_xxgetri</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;inv&quot;</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">inv_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">acpy</span>

        <span class="s1">ipiv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">F_INT_nptype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xxgetrf</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">)</span>
        <span class="s1">_inv_err_handler</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xxgetri</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">)</span>
        <span class="s1">_inv_err_handler</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">acpy</span>

    <span class="s2">return </span><span class="s1">inv_impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">r </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fatal_error_func</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s4">0   </span><span class="s5"># unreachable</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Internal algorithm failed to converge.&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_linalg_1_or_2d_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5"># la_prefix is present as some functions, e.g. np.trace()</span>
    <span class="s5"># are documented under &quot;linear algebra&quot; but aren't in the</span>
    <span class="s5"># module</span>
    <span class="s1">prefix </span><span class="s3">= </span><span class="s6">&quot;np.linalg&quot; </span><span class="s2">if </span><span class="s1">la_prefix </span><span class="s2">else </span><span class="s6">&quot;np&quot;</span>
    <span class="s1">interp </span><span class="s3">= (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
    <span class="s5"># checks that a matrix is 1 or 2D</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;%s.%s() only supported for array types &quot;</span>
                          <span class="s3">% </span><span class="s1">interp</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s4">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;%s.%s() only supported on 1 and 2-D arrays &quot;</span>
                          <span class="s3">% </span><span class="s1">interp</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Float</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;%s.%s() only supported on &quot;</span>
                          <span class="s6">&quot;float and complex arrays.&quot; </span><span class="s3">% </span><span class="s1">interp</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cholesky</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">cho_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;cholesky&quot;</span><span class="s3">)</span>

    <span class="s1">numba_xxpotrf </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_xxpotrf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;cholesky&quot;</span><span class="s3">))</span>
    <span class="s1">UP </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'U'</span><span class="s3">)</span>
    <span class="s1">LO </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'L'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">cho_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s5"># The output is allocated in C order</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s5"># Pass UP since xxpotrf() operates in F order</span>
        <span class="s5"># The semantics ensure this works fine</span>
        <span class="s5"># (out is really its Hermitian in F order, but UP instructs</span>
        <span class="s5">#  xxpotrf to compute the Hermitian of the upper triangle</span>
        <span class="s5">#  =&gt; they cancel each other)</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xxpotrf</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">UP</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">fatal_error_func</span><span class="s3">()</span>
                <span class="s2">assert </span><span class="s4">0   </span><span class="s5"># unreachable</span>
            <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span>
                    <span class="s6">&quot;Matrix is not positive definite.&quot;</span><span class="s3">)</span>
        <span class="s5"># Zero out upper triangle, in F order</span>
        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[:</span><span class="s1">col</span><span class="s3">, </span><span class="s1">col</span><span class="s3">] = </span><span class="s4">0</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">return </span><span class="s1">cho_impl</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">eig</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">eig_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;eig&quot;</span><span class="s3">)</span>

    <span class="s1">numba_ez_rgeev </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_rgeev</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">numba_ez_cgeev </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_cgeev</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;eig&quot;</span><span class="s3">))</span>

    <span class="s1">JOBVL </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'N'</span><span class="s3">)</span>
    <span class="s1">JOBVR </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'V'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">real_eig_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        eig() implementation for real arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldvl </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">ldvr </span><span class="s3">= </span><span class="s1">n</span>
        <span class="s1">wr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">wi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vl </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">ldvl</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">ldvr</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">wr</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_rgeev</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,</span>
                            <span class="s1">JOBVL</span><span class="s3">,</span>
                            <span class="s1">JOBVR</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">wr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">wi</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">vl</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvl</span><span class="s3">,</span>
                            <span class="s1">vr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvr</span><span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># By design numba does not support dynamic return types, however,</span>
        <span class="s5"># Numpy does. Numpy uses this ability in the case of returning</span>
        <span class="s5"># eigenvalues/vectors of a real matrix. The return type of</span>
        <span class="s5"># np.linalg.eig(), when operating on a matrix in real space</span>
        <span class="s5"># depends on the values present in the matrix itself (recalling</span>
        <span class="s5"># that eigenvalues are the roots of the characteristic polynomial</span>
        <span class="s5"># of the system matrix, which will by construction depend on the</span>
        <span class="s5"># values present in the system matrix). As numba cannot handle</span>
        <span class="s5"># the case of a runtime decision based domain change relative to</span>
        <span class="s5"># the input type, if it is required numba raises as below.</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">wi</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s6">&quot;eig() argument must not cause a domain change.&quot;</span><span class="s3">)</span>

        <span class="s5"># put these in to help with liveness analysis,</span>
        <span class="s5"># `.ctypes` doesn't keep the vars alive</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">wr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">wi</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">wr</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">cmplx_eig_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        eig() implementation for complex arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldvl </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">ldvr </span><span class="s3">= </span><span class="s1">n</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vl </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">ldvl</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">ldvr</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_cgeev</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,</span>
                            <span class="s1">JOBVL</span><span class="s3">,</span>
                            <span class="s1">JOBVR</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">w</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">vl</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvl</span><span class="s3">,</span>
                            <span class="s1">vr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvr</span><span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># put these in to help with liveness analysis,</span>
        <span class="s5"># `.ctypes` doesn't keep the vars alive</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">scalars</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">cmplx_eig_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">real_eig_impl</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">eigvals</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">eigvals_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;eigvals&quot;</span><span class="s3">)</span>

    <span class="s1">numba_ez_rgeev </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_rgeev</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">numba_ez_cgeev </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_cgeev</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;eigvals&quot;</span><span class="s3">))</span>

    <span class="s1">JOBVL </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'N'</span><span class="s3">)</span>
    <span class="s1">JOBVR </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'N'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">real_eigvals_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        eigvals() implementation for real arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldvl </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">ldvr </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">wr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">wr</span>

        <span class="s1">wi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s5"># not referenced but need setting for MKL null check</span>
        <span class="s1">vl </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_rgeev</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,</span>
                            <span class="s1">JOBVL</span><span class="s3">,</span>
                            <span class="s1">JOBVR</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">wr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">wi</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">vl</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvl</span><span class="s3">,</span>
                            <span class="s1">vr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvr</span><span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># By design numba does not support dynamic return types, however,</span>
        <span class="s5"># Numpy does. Numpy uses this ability in the case of returning</span>
        <span class="s5"># eigenvalues/vectors of a real matrix. The return type of</span>
        <span class="s5"># np.linalg.eigvals(), when operating on a matrix in real space</span>
        <span class="s5"># depends on the values present in the matrix itself (recalling</span>
        <span class="s5"># that eigenvalues are the roots of the characteristic polynomial</span>
        <span class="s5"># of the system matrix, which will by construction depend on the</span>
        <span class="s5"># values present in the system matrix). As numba cannot handle</span>
        <span class="s5"># the case of a runtime decision based domain change relative to</span>
        <span class="s5"># the input type, if it is required numba raises as below.</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">wi</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s6">&quot;eigvals() argument must not cause a domain change.&quot;</span><span class="s3">)</span>

        <span class="s5"># put these in to help with liveness analysis,</span>
        <span class="s5"># `.ctypes` doesn't keep the vars alive</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">wr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">wi</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">wr</span>

    <span class="s2">def </span><span class="s1">cmplx_eigvals_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        eigvals() implementation for complex arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldvl </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">ldvr </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">w</span>

        <span class="s1">vl </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">vr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_cgeev</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,</span>
                            <span class="s1">JOBVL</span><span class="s3">,</span>
                            <span class="s1">JOBVR</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">n</span><span class="s3">,</span>
                            <span class="s1">w</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">vl</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvl</span><span class="s3">,</span>
                            <span class="s1">vr</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,</span>
                            <span class="s1">ldvr</span><span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># put these in to help with liveness analysis,</span>
        <span class="s5"># `.ctypes` doesn't keep the vars alive</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">w</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">scalars</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">cmplx_eigvals_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">real_eigvals_impl</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">eigh</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">eigh_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;eigh&quot;</span><span class="s3">)</span>

    <span class="s5"># convert typing floats to numpy floats for use in the impl</span>
    <span class="s1">w_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">w_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">w_type</span><span class="s3">)</span>

    <span class="s1">numba_ez_xxxevd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_xxxevd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;eigh&quot;</span><span class="s3">))</span>

    <span class="s1">JOBZ </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'V'</span><span class="s3">)</span>
    <span class="s1">UPLO </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'L'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">eigh_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">w_dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_xxxevd</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
                            <span class="s1">JOBZ</span><span class="s3">,  </span><span class="s5"># jobz</span>
                            <span class="s1">UPLO</span><span class="s3">,  </span><span class="s5"># uplo</span>
                            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># n</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
                            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># lda</span>
                            <span class="s1">w</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># w</span>
                            <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">eigh_impl</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">eigvalsh</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">eigvalsh_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;eigvalsh&quot;</span><span class="s3">)</span>

    <span class="s5"># convert typing floats to numpy floats for use in the impl</span>
    <span class="s1">w_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">w_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">w_type</span><span class="s3">)</span>

    <span class="s1">numba_ez_xxxevd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_xxxevd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;eigvalsh&quot;</span><span class="s3">))</span>

    <span class="s1">JOBZ </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'N'</span><span class="s3">)</span>
    <span class="s1">UPLO </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'L'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">eigvalsh_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">w_dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">w</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_xxxevd</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
                            <span class="s1">JOBZ</span><span class="s3">,  </span><span class="s5"># jobz</span>
                            <span class="s1">UPLO</span><span class="s3">,  </span><span class="s5"># uplo</span>
                            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># n</span>
                            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
                            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># lda</span>
                            <span class="s1">w</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># w</span>
                            <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">w</span>

    <span class="s2">return </span><span class="s1">eigvalsh_impl</span>

<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">svd</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">svd_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">full_matrices</span><span class="s3">=</span><span class="s4">1</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;svd&quot;</span><span class="s3">)</span>

    <span class="s5"># convert typing floats to numpy floats for use in the impl</span>
    <span class="s1">s_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">s_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">s_type</span><span class="s3">)</span>

    <span class="s1">numba_ez_gesdd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;svd&quot;</span><span class="s3">))</span>

    <span class="s1">JOBZ_A </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'A'</span><span class="s3">)</span>
    <span class="s1">JOBZ_S </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'S'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">svd_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">full_matrices</span><span class="s3">=</span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">m </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s6">&quot;Arrays cannot be empty&quot;</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldu </span><span class="s3">= </span><span class="s1">m</span>
        <span class="s1">minmn </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">full_matrices</span><span class="s3">:</span>
            <span class="s1">JOBZ </span><span class="s3">= </span><span class="s1">JOBZ_A</span>
            <span class="s1">ucol </span><span class="s3">= </span><span class="s1">m</span>
            <span class="s1">ldvt </span><span class="s3">= </span><span class="s1">n</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">JOBZ </span><span class="s3">= </span><span class="s1">JOBZ_S</span>
            <span class="s1">ucol </span><span class="s3">= </span><span class="s1">minmn</span>
            <span class="s1">ldvt </span><span class="s3">= </span><span class="s1">minmn</span>

        <span class="s1">u </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">ucol</span><span class="s3">, </span><span class="s1">ldu</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">s_dtype</span><span class="s3">)</span>
        <span class="s1">vt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">ldvt</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
            <span class="s1">JOBZ</span><span class="s3">,  </span><span class="s5"># jobz</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># m</span>
            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># n</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># lda</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># s</span>
            <span class="s1">u</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># u</span>
            <span class="s1">ldu</span><span class="s3">,  </span><span class="s5"># ldu</span>
            <span class="s1">vt</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># vt</span>
            <span class="s1">ldvt          </span><span class="s5"># ldvt</span>
        <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vt</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">u</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">u</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">vt</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">svd_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">qr</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">qr_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;qr&quot;</span><span class="s3">)</span>

    <span class="s5"># Need two functions, the first computes R, storing it in the upper</span>
    <span class="s5"># triangle of A with the below diagonal part of A containing elementary</span>
    <span class="s5"># reflectors needed to construct Q. The second turns the below diagonal</span>
    <span class="s5"># entries of A into Q, storing Q in A (creates orthonormal columns from</span>
    <span class="s5"># the elementary reflectors).</span>

    <span class="s1">numba_ez_geqrf </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_geqrf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">numba_ez_xxgqr </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_xxgqr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;qr&quot;</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">qr_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">m </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s6">&quot;Arrays cannot be empty&quot;</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s5"># copy A as it will be destroyed</span>
        <span class="s1">q </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">lda </span><span class="s3">= </span><span class="s1">m</span>

        <span class="s1">minmn </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">tau </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">minmn</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">ret </span><span class="s3">= </span><span class="s1">numba_ez_geqrf</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># m</span>
            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># n</span>
            <span class="s1">q</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># lda</span>
            <span class="s1">tau</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># tau</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ret </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fatal_error_func</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s4">0   </span><span class="s5"># unreachable</span>

        <span class="s5"># pull out R, this is transposed because of Fortran</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">minmn</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">T</span>

        <span class="s5"># the triangle in R</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">r</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">q</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">]</span>

        <span class="s5"># and the possible square in R</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">):</span>
                <span class="s1">r</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">q</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">i</span><span class="s3">]</span>

        <span class="s1">ret </span><span class="s3">= </span><span class="s1">numba_ez_xxgqr</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># m</span>
            <span class="s1">minmn</span><span class="s3">,  </span><span class="s5"># n</span>
            <span class="s1">minmn</span><span class="s3">,  </span><span class="s5"># k</span>
            <span class="s1">q</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># lda</span>
            <span class="s1">tau</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># tau</span>
        <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">tau</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">q</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">q</span><span class="s3">[:, :</span><span class="s1">minmn</span><span class="s3">], </span><span class="s1">r</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">qr_impl</span>


<span class="s5"># helpers and jitted specialisations required for np.linalg.lstsq</span>
<span class="s5"># and np.linalg.solve. These functions have &quot;system&quot; in their name</span>
<span class="s5"># as a differentiator.</span>

<span class="s2">def </span><span class="s1">_system_copy_in_b</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Correctly copy 'b' into the 'bcpy' scratch space. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_system_copy_in_b</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_system_copy_in_b_impl</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
            <span class="s1">bcpy</span><span class="s3">[:</span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">], </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">b</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
            <span class="s1">bcpy</span><span class="s3">[:</span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">], :</span><span class="s1">nrhs</span><span class="s3">] = </span><span class="s1">b</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s2">def </span><span class="s1">_system_compute_nrhs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the number of right hand sides in the system of equations 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_system_compute_nrhs</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_system_compute_nrhs_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s2">def </span><span class="s1">_system_check_dimensionally_valid</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that AX=B style system input is dimensionally valid. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_system_check_dimensionally_valid</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_system_check_dimensionally_valid_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s1">bm </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">am </span><span class="s3">!= </span><span class="s1">bm</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span>
                    <span class="s6">&quot;Incompatible array sizes, system is not dimensionally valid.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s1">bm </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">am </span><span class="s3">!= </span><span class="s1">bm</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span>
                    <span class="s6">&quot;Incompatible array sizes, system is not dimensionally valid.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s2">def </span><span class="s1">_system_check_non_empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that AX=B style system input is not empty. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_system_check_non_empty</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_system_check_non_empty_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s1">an </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">bm </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">am </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">bm </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">an </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s6">'Arrays cannot be empty'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s1">an </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">bm </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
            <span class="s1">bn </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">am </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">bm </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">an </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">bn </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s6">'Arrays cannot be empty'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s2">def </span><span class="s1">_lstsq_residual</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the residual from the 'b' scratch space. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_lstsq_residual</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_lstsq_residual_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">real_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
            <span class="s2">def </span><span class="s1">cmplx_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
                <span class="s1">res</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:, </span><span class="s4">0</span><span class="s3">])**</span><span class="s4">2</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">res</span>
            <span class="s2">return </span><span class="s1">cmplx_impl</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
                <span class="s1">res</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:, </span><span class="s4">0</span><span class="s3">]**</span><span class="s4">2</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">res</span>
            <span class="s2">return </span><span class="s1">real_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">)):</span>
            <span class="s2">def </span><span class="s1">cmplx_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">nrhs</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nrhs</span><span class="s3">):</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:, </span><span class="s1">k</span><span class="s3">])**</span><span class="s4">2</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">res</span>
            <span class="s2">return </span><span class="s1">cmplx_impl</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">nrhs</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nrhs</span><span class="s3">):</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:, </span><span class="s1">k</span><span class="s3">]**</span><span class="s4">2</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">res</span>
            <span class="s2">return </span><span class="s1">real_impl</span>


<span class="s2">def </span><span class="s1">_lstsq_solution</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract 'x' (the lstsq solution) from the 'bcpy' scratch space. 
    Note 'b' is only used to check the system input dimension... 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_lstsq_solution</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_lstsq_solution_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">bcpy</span><span class="s3">.</span><span class="s1">T</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()[:</span><span class="s1">n</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">bcpy</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">, :].</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">lstsq</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">lstsq_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">=-</span><span class="s4">1.0</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;lstsq&quot;</span><span class="s3">)</span>

    <span class="s5"># B can be 1D or 2D.</span>
    <span class="s1">_check_linalg_1_or_2d_matrix</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s6">&quot;lstsq&quot;</span><span class="s3">)</span>

    <span class="s1">_check_homogeneous_types</span><span class="s3">(</span><span class="s6">&quot;lstsq&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s1">np_dt </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">nb_dt </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s5"># convert typing floats to np floats for use in the impl</span>
    <span class="s1">r_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">nb_dt</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">nb_dt</span><span class="s3">)</span>
    <span class="s1">real_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">r_type</span><span class="s3">)</span>

    <span class="s5"># lapack solver</span>
    <span class="s1">numba_ez_gelsd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_gelsd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">nb_dt</span><span class="s3">, </span><span class="s6">&quot;lstsq&quot;</span><span class="s3">))</span>

    <span class="s5"># The following functions select specialisations based on</span>
    <span class="s5"># information around 'b', a lot of this effort is required</span>
    <span class="s5"># as 'b' can be either 1D or 2D, and then there are</span>
    <span class="s5"># some optimisations available depending on real or complex</span>
    <span class="s5"># space.</span>

    <span class="s2">def </span><span class="s1">lstsq_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">=-</span><span class="s4">1.0</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">nrhs </span><span class="s3">= </span><span class="s1">_system_compute_nrhs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># check the systems have no inf or NaN</span>
        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># check the system is not empty</span>
        <span class="s1">_system_check_non_empty</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># check the systems are dimensionally valid</span>
        <span class="s1">_system_check_dimensionally_valid</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">minmn </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">maxmn </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s5"># a is destroyed on exit, copy it</span>
        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s5"># b is overwritten on exit with the solution, copy allocate</span>
        <span class="s1">bcpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">nrhs</span><span class="s3">, </span><span class="s1">maxmn</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_dt</span><span class="s3">).</span><span class="s1">T</span>
        <span class="s5"># specialised copy in due to b being 1 or 2D</span>
        <span class="s1">_system_copy_in_b</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">)</span>

        <span class="s5"># Allocate returns</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
        <span class="s1">rank_ptr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_gelsd</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,  </span><span class="s5"># kind</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># m</span>
            <span class="s1">n</span><span class="s3">,  </span><span class="s5"># n</span>
            <span class="s1">nrhs</span><span class="s3">,  </span><span class="s5"># nrhs</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,  </span><span class="s5"># lda</span>
            <span class="s1">bcpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">maxmn</span><span class="s3">,  </span><span class="s5"># ldb</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># s</span>
            <span class="s1">rcond</span><span class="s3">,  </span><span class="s5"># rcond</span>
            <span class="s1">rank_ptr</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># rank</span>
        <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># set rank to that which was computed</span>
        <span class="s1">rank </span><span class="s3">= </span><span class="s1">rank_ptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s5"># compute residuals</span>
        <span class="s2">if </span><span class="s1">rank </span><span class="s3">&lt; </span><span class="s1">n </span><span class="s2">or </span><span class="s1">m </span><span class="s3">&lt;= </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">0</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">real_dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># this requires additional dispatch as there's a faster</span>
            <span class="s5"># impl if the result is in the real domain (no abs() required)</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">_lstsq_residual</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">)</span>

        <span class="s5"># extract 'x', the solution</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">_lstsq_solution</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">rank_ptr</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">s</span><span class="s3">[:</span><span class="s1">minmn</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">lstsq_impl</span>


<span class="s2">def </span><span class="s1">_solve_compute_return</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract 'x' (the solution) from the 'bcpy' scratch space. 
    Note 'b' is only used to check the system input dimension... 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_solve_compute_return</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_solve_compute_return_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">bcpy</span><span class="s3">.</span><span class="s1">T</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">bcpy</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">solve_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;solve&quot;</span><span class="s3">)</span>
    <span class="s1">_check_linalg_1_or_2d_matrix</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s6">&quot;solve&quot;</span><span class="s3">)</span>

    <span class="s1">_check_homogeneous_types</span><span class="s3">(</span><span class="s6">&quot;solve&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s1">np_dt </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">nb_dt </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s5"># the lapack solver</span>
    <span class="s1">numba_xgesv </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_xgesv</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">nb_dt</span><span class="s3">, </span><span class="s6">&quot;solve&quot;</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">solve_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">nrhs </span><span class="s3">= </span><span class="s1">_system_compute_nrhs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># check the systems have no inf or NaN</span>
        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># check the systems are dimensionally valid</span>
        <span class="s1">_system_check_dimensionally_valid</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s5"># a is destroyed on exit, copy it</span>
        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s5"># b is overwritten on exit with the solution, copy allocate</span>
        <span class="s1">bcpy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">nrhs</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_dt</span><span class="s3">).</span><span class="s1">T</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_solve_compute_return</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">)</span>

        <span class="s5"># specialised copy in due to b being 1 or 2D</span>
        <span class="s1">_system_copy_in_b</span><span class="s3">(</span><span class="s1">bcpy</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">nrhs</span><span class="s3">)</span>

        <span class="s5"># allocate pivot array (needs to be fortran int size)</span>
        <span class="s1">ipiv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">F_INT_nptype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xgesv</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,        </span><span class="s5"># kind</span>
            <span class="s1">n</span><span class="s3">,           </span><span class="s5"># n</span>
            <span class="s1">nrhs</span><span class="s3">,        </span><span class="s5"># nhrs</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">n</span><span class="s3">,           </span><span class="s5"># lda</span>
            <span class="s1">ipiv</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># ipiv</span>
            <span class="s1">bcpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># b</span>
            <span class="s1">n            </span><span class="s5"># ldb</span>
        <span class="s3">)</span>
        <span class="s1">_inv_err_handler</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">_solve_compute_return</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">bcpy</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">solve_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">pinv</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">pinv_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">=</span><span class="s4">1.e-15</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;pinv&quot;</span><span class="s3">)</span>

    <span class="s5"># convert typing floats to numpy floats for use in the impl</span>
    <span class="s1">s_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">s_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">s_type</span><span class="s3">)</span>

    <span class="s1">numba_ez_gesdd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">numba_xxgemm </span><span class="s3">= </span><span class="s1">_BLAS</span><span class="s3">().</span><span class="s1">numba_xxgemm</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;pinv&quot;</span><span class="s3">))</span>
    <span class="s1">JOB </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'S'</span><span class="s3">)</span>

    <span class="s5"># need conjugate transposes</span>
    <span class="s1">TRANSA </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'C'</span><span class="s3">)</span>
    <span class="s1">TRANSB </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'C'</span><span class="s3">)</span>

    <span class="s5"># scalar constants</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">zero </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0.</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">pinv_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">=</span><span class="s4">1.e-15</span><span class="s3">):</span>

        <span class="s5"># The idea is to build the pseudo-inverse via inverting the singular</span>
        <span class="s5"># value decomposition of a matrix `A`. Mathematically, this is roughly</span>
        <span class="s5"># A = U*S*V^H        [The SV decomposition of A]</span>
        <span class="s5"># A^+ = V*(S^+)*U^H  [The inverted SV decomposition of A]</span>
        <span class="s5"># where ^+ is pseudo inversion and ^H is Hermitian transpose.</span>
        <span class="s5"># As V and U are unitary, their inverses are simply their Hermitian</span>
        <span class="s5"># transpose. S has singular values on its diagonal and zero elsewhere,</span>
        <span class="s5"># it is inverted trivially by reciprocal of the diagonal values with</span>
        <span class="s5"># the exception that zero singular values remain as zero.</span>
        <span class="s5">#</span>
        <span class="s5"># The practical implementation can take advantage of a few things to</span>
        <span class="s5"># gain a few % performance increase:</span>
        <span class="s5"># * A is destroyed by the SVD algorithm from LAPACK so a copy is</span>
        <span class="s5">#   required, this memory is exactly the right size in which to return</span>
        <span class="s5">#   the pseudo-inverse and so can be reused for this purpose.</span>
        <span class="s5"># * The pseudo-inverse of S can be applied to either V or U^H, this</span>
        <span class="s5">#   then leaves a GEMM operation to compute the inverse via either:</span>
        <span class="s5">#   A^+ = (V*(S^+))*U^H</span>
        <span class="s5">#   or</span>
        <span class="s5">#   A^+ = V*((S^+)*U^H)</span>
        <span class="s5">#   however application of S^+ to V^H or U is more convenient as they</span>
        <span class="s5">#   are the result of the SVD algorithm. The application of the</span>
        <span class="s5">#   diagonal system is just a matrix multiplication which results in a</span>
        <span class="s5">#   row/column scaling (direction depending). To save effort, this</span>
        <span class="s5">#   &quot;matrix multiplication&quot; is applied to the smallest of U or V^H and</span>
        <span class="s5">#   only up to the point of &quot;cut-off&quot; (see next note) just as a direct</span>
        <span class="s5">#   scaling.</span>
        <span class="s5"># * The cut-off level for application of S^+ can be used to reduce</span>
        <span class="s5">#   total effort, this cut-off can come via rcond or may just naturally</span>
        <span class="s5">#   be present as a result of zeros in the singular values. Regardless</span>
        <span class="s5">#   there's no need to multiply by zeros in the application of S^+ to</span>
        <span class="s5">#   V^H or U as above. Further, the GEMM operation can be shrunk in</span>
        <span class="s5">#   effort by noting that the possible zero block generated by the</span>
        <span class="s5">#   presence of zeros in S^+ has no effect apart from wasting cycles as</span>
        <span class="s5">#   it is all fmadd()s where one operand is zero. The inner dimension</span>
        <span class="s5">#   of the GEMM operation can therefore be set as shrunk accordingly!</span>

        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">T</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">).</span><span class="s1">T</span>

        <span class="s1">minmn </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s1">u </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">m</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">s_dtype</span><span class="s3">)</span>
        <span class="s1">vt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s1">minmn</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,         </span><span class="s5"># kind</span>
            <span class="s1">JOB</span><span class="s3">,          </span><span class="s5"># job</span>
            <span class="s1">m</span><span class="s3">,            </span><span class="s5"># m</span>
            <span class="s1">n</span><span class="s3">,            </span><span class="s5"># n</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,            </span><span class="s5"># lda</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,     </span><span class="s5"># s</span>
            <span class="s1">u</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,     </span><span class="s5"># u</span>
            <span class="s1">m</span><span class="s3">,            </span><span class="s5"># ldu</span>
            <span class="s1">vt</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,    </span><span class="s5"># vt</span>
            <span class="s1">minmn         </span><span class="s5"># ldvt</span>
        <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># Invert singular values under threshold. Also find the index of</span>
        <span class="s5"># the threshold value as this is the upper limit for the application</span>
        <span class="s5"># of the inverted singular values. Finding this value saves</span>
        <span class="s5"># multiplication by a block of zeros that would be created by the</span>
        <span class="s5"># application of these values to either U or V^H ahead of multiplying</span>
        <span class="s5"># them together. This is done by simply in BLAS parlance via</span>
        <span class="s5"># restricting the `k` dimension to `cut_idx` in `xgemm` whilst keeping</span>
        <span class="s5"># the leading dimensions correct.</span>

        <span class="s1">cut_at </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">rcond</span>
        <span class="s1">cut_idx </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">s</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &gt; </span><span class="s1">cut_at</span><span class="s3">:</span>
                <span class="s1">s</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s4">1. </span><span class="s3">/ </span><span class="s1">s</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">cut_idx </span><span class="s3">= </span><span class="s1">k</span>
        <span class="s1">cut_idx </span><span class="s3">+= </span><span class="s4">1</span>

        <span class="s5"># Use cut_idx so there's no scaling by 0.</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s3">&gt;= </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s5"># U is largest so apply S^+ to V^H.</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">cut_idx</span><span class="s3">):</span>
                    <span class="s1">vt</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">vt</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] * </span><span class="s1">s</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># V^H is largest so apply S^+ to U.</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">cut_idx</span><span class="s3">):</span>
                <span class="s1">s_local </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">):</span>
                    <span class="s1">u</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">u</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] * </span><span class="s1">s_local</span>

        <span class="s5"># Do (v^H)^H*U^H (obviously one of the matrices includes the S^+</span>
        <span class="s5"># scaling) and write back to acpy. Note the innner dimension of cut_idx</span>
        <span class="s5"># taking account of the possible zero block.</span>
        <span class="s5"># We can store the result in acpy, given we had to create it</span>
        <span class="s5"># for use in the SVD, and it is now redundant and the right size</span>
        <span class="s5"># but wrong shape.</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xxgemm</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,</span>
            <span class="s1">TRANSA</span><span class="s3">,       </span><span class="s5"># TRANSA</span>
            <span class="s1">TRANSB</span><span class="s3">,       </span><span class="s5"># TRANSB</span>
            <span class="s1">n</span><span class="s3">,            </span><span class="s5"># M</span>
            <span class="s1">m</span><span class="s3">,            </span><span class="s5"># N</span>
            <span class="s1">cut_idx</span><span class="s3">,      </span><span class="s5"># K</span>
            <span class="s1">one</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,   </span><span class="s5"># ALPHA</span>
            <span class="s1">vt</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,    </span><span class="s5"># A</span>
            <span class="s1">minmn</span><span class="s3">,        </span><span class="s5"># LDA</span>
            <span class="s1">u</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,     </span><span class="s5"># B</span>
            <span class="s1">m</span><span class="s3">,            </span><span class="s5"># LDB</span>
            <span class="s1">zero</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># BETA</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># C</span>
            <span class="s1">n             </span><span class="s5"># LDC</span>
        <span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s5">#acpy.size</span>
        <span class="s5">#vt.size</span>
        <span class="s5">#u.size</span>
        <span class="s5">#s.size</span>
        <span class="s5">#one.size</span>
        <span class="s5">#zero.size</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vt</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">u</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">one</span><span class="s3">.</span><span class="s1">size</span><span class="s3">,</span>
            <span class="s1">zero</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">T</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">).</span><span class="s1">T</span>

    <span class="s2">return </span><span class="s1">pinv_impl</span>


<span class="s2">def </span><span class="s1">_get_slogdet_diag_walker</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Walks the diag of a LUP decomposed matrix 
    uses that det(A) = prod(diag(lup(A))) 
    and also that log(a)+log(b) = log(a*b) 
    The return sign is adjusted based on the values found 
    such that the log(value) stays in the real domain. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Complex</span><span class="s3">):</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">cmplx_diag_walker</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">sgn</span><span class="s3">):</span>
            <span class="s5"># walk diagonal</span>
            <span class="s1">csgn </span><span class="s3">= </span><span class="s1">sgn </span><span class="s3">+ </span><span class="s4">0.j</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0.</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">absel </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">k</span><span class="s3">])</span>
                <span class="s1">csgn </span><span class="s3">= </span><span class="s1">csgn </span><span class="s3">* (</span><span class="s1">a</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] / </span><span class="s1">absel</span><span class="s3">)</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">acc </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">absel</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">csgn</span><span class="s3">, </span><span class="s1">acc</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cmplx_diag_walker</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">real_diag_walker</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">sgn</span><span class="s3">):</span>
            <span class="s5"># walk diagonal</span>
            <span class="s1">acc </span><span class="s3">= </span><span class="s4">0.</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">v </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s4">0.</span><span class="s3">:</span>
                    <span class="s1">sgn </span><span class="s3">= -</span><span class="s1">sgn</span>
                    <span class="s1">v </span><span class="s3">= -</span><span class="s1">v</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">acc </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
            <span class="s5"># sgn is a float dtype</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">sgn </span><span class="s3">+ </span><span class="s4">0.</span><span class="s3">, </span><span class="s1">acc</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">real_diag_walker</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">slogdet</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">slogdet_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;slogdet&quot;</span><span class="s3">)</span>

    <span class="s1">numba_xxgetrf </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_xxgetrf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;slogdet&quot;</span><span class="s3">))</span>

    <span class="s1">diag_walker </span><span class="s3">= </span><span class="s1">_get_slogdet_diag_walker</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">ONE </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">ZERO </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)(</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">slogdet_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">] != </span><span class="s1">n</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Last 2 dimensions of the array must be square.&quot;</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">ONE</span><span class="s3">, </span><span class="s1">ZERO</span><span class="s3">)</span>

        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ipiv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">F_INT_nptype</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_xxgetrf</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s5"># factorisation failed, return same defaults as np</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s4">0.</span><span class="s3">, -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">_inv_err_handler</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)  </span><span class="s5"># catch input-to-lapack problem</span>

        <span class="s5"># The following, prior to the call to diag_walker, is present</span>
        <span class="s5"># to account for the effect of possible permutations to the</span>
        <span class="s5"># sign of the determinant.</span>
        <span class="s5"># This is the same idea as in numpy:</span>
        <span class="s5"># File name `umath_linalg.c.src` e.g.</span>
        <span class="s5"># https://github.com/numpy/numpy/blob/master/numpy/linalg/umath_linalg.c.src</span>
        <span class="s5"># in function `@TYPE@_slogdet_single_element`.</span>
        <span class="s1">sgn </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">sgn </span><span class="s3">= </span><span class="s1">sgn </span><span class="s3">+ (</span><span class="s1">ipiv</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] != (</span><span class="s1">k </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">))</span>

        <span class="s1">sgn </span><span class="s3">= </span><span class="s1">sgn </span><span class="s3">&amp; </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">sgn </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">sgn </span><span class="s3">= -</span><span class="s4">1</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">ipiv</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">diag_walker</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">acpy</span><span class="s3">, </span><span class="s1">sgn</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">slogdet_impl</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">det</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">det_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>

    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;det&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">det_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s3">(</span><span class="s1">sgn</span><span class="s3">, </span><span class="s1">slogdet</span><span class="s3">) = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">slogdet</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sgn </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">slogdet</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">det_impl</span>


<span class="s2">def </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute singular values of *a*. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_compute_singular_values</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_compute_singular_values_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a function to compute singular values of `a` 
    &quot;&quot;&quot;</span>
    <span class="s1">numba_ez_gesdd </span><span class="s3">= </span><span class="s1">_LAPACK</span><span class="s3">().</span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;svd&quot;</span><span class="s3">))</span>

    <span class="s5"># Flag for &quot;only compute `S`&quot; to give to xgesdd</span>
    <span class="s1">JOBZ_N </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s6">'N'</span><span class="s3">)</span>

    <span class="s1">nb_ret_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">np_ret_type </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">nb_ret_type</span><span class="s3">)</span>
    <span class="s1">np_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s5"># These are not referenced in the computation but must be set</span>
    <span class="s5"># for MKL.</span>
    <span class="s1">u </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_dtype</span><span class="s3">)</span>
    <span class="s1">vt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">sv_function</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Computes singular values. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Don't use the np.linalg.svd impl instead</span>
        <span class="s5"># call LAPACK to shortcut doing the &quot;reconstruct</span>
        <span class="s5"># singular vectors from reflectors&quot; step and just</span>
        <span class="s5"># get back the singular values.</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s6">'Arrays cannot be empty'</span><span class="s3">)</span>
        <span class="s1">_check_finite_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s1">ldu </span><span class="s3">= </span><span class="s1">m</span>
        <span class="s1">minmn </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s5"># need to be &gt;=1 but aren't referenced</span>
        <span class="s1">ucol </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s1">ldvt </span><span class="s3">= </span><span class="s4">1</span>

        <span class="s1">acpy </span><span class="s3">= </span><span class="s1">_copy_to_fortran_order</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s5"># u and vt are not referenced however need to be</span>
        <span class="s5"># allocated (as done above) for MKL as it</span>
        <span class="s5"># checks for ref is nullptr.</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">minmn</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_ret_type</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">numba_ez_gesdd</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,        </span><span class="s5"># kind</span>
            <span class="s1">JOBZ_N</span><span class="s3">,      </span><span class="s5"># jobz</span>
            <span class="s1">m</span><span class="s3">,           </span><span class="s5"># m</span>
            <span class="s1">n</span><span class="s3">,           </span><span class="s5"># n</span>
            <span class="s1">acpy</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># a</span>
            <span class="s1">m</span><span class="s3">,           </span><span class="s5"># lda</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,    </span><span class="s5"># s</span>
            <span class="s1">u</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,    </span><span class="s5"># u</span>
            <span class="s1">ldu</span><span class="s3">,         </span><span class="s5"># ldu</span>
            <span class="s1">vt</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,   </span><span class="s5"># vt</span>
            <span class="s1">ldvt         </span><span class="s5"># ldvt</span>
        <span class="s3">)</span>
        <span class="s1">_handle_err_maybe_convergence_problem</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">acpy</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vt</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">u</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">return </span><span class="s1">sv_function</span>


<span class="s2">def </span><span class="s1">_oneD_norm_2</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the L2-norm of 1D-array *a*. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">_oneD_norm_2</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">_oneD_norm_2_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s1">nb_ret_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">np_ret_type </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">nb_ret_type</span><span class="s3">)</span>

    <span class="s1">xxnrm2 </span><span class="s3">= </span><span class="s1">_BLAS</span><span class="s3">().</span><span class="s1">numba_xxnrm2</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;norm&quot;</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s5"># Just ignore order, calls are guarded to only come</span>
        <span class="s5"># from cases where order=None or order=2.</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s5"># Call L2-norm routine from BLAS</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_ret_type</span><span class="s3">)</span>
        <span class="s1">jmp </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">)</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">xxnrm2</span><span class="s3">(</span>
            <span class="s1">kind</span><span class="s3">,      </span><span class="s5"># kind</span>
            <span class="s1">n</span><span class="s3">,         </span><span class="s5"># n</span>
            <span class="s1">a</span><span class="s3">.</span><span class="s1">ctypes</span><span class="s3">,  </span><span class="s5"># x</span>
            <span class="s1">jmp</span><span class="s3">,       </span><span class="s5"># incx</span>
            <span class="s1">ret</span><span class="s3">.</span><span class="s1">ctypes  </span><span class="s5"># result</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fatal_error_func</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s4">0   </span><span class="s5"># unreachable</span>

        <span class="s5"># help liveness analysis</span>
        <span class="s5">#ret.size</span>
        <span class="s5">#a.size</span>
        <span class="s1">_dummy_liveness_func</span><span class="s3">([</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">ret</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">impl</span>


<span class="s2">def </span><span class="s1">_get_norm_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord_flag</span><span class="s3">):</span>
    <span class="s5"># This function is quite involved as norm supports a large</span>
    <span class="s5"># range of values to select different norm types via kwarg `ord`.</span>
    <span class="s5"># The implementation below branches on dimension of the input</span>
    <span class="s5"># (1D or 2D). The default for `ord` is `None` which requires</span>
    <span class="s5"># special handling in numba, this is dealt with first in each of</span>
    <span class="s5"># the dimension branches. Following this the various norms are</span>
    <span class="s5"># computed via code that is in most cases simply a loop version</span>
    <span class="s5"># of a ufunc based version as found in numpy.</span>

    <span class="s5"># The following is common to both 1D and 2D cases.</span>
    <span class="s5"># Convert typing floats to numpy floats for use in the impl.</span>
    <span class="s5"># The return type is always a float, numba differs from numpy in</span>
    <span class="s5"># that it returns an input precision specific value whereas numpy</span>
    <span class="s5"># always returns np.float64.</span>
    <span class="s1">nb_ret_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">np_ret_type </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">nb_ret_type</span><span class="s3">)</span>

    <span class="s1">np_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">xxnrm2 </span><span class="s3">= </span><span class="s1">_BLAS</span><span class="s3">().</span><span class="s1">numba_xxnrm2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">kind </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">get_blas_kind</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;norm&quot;</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s5"># 1D cases</span>

        <span class="s5"># handle &quot;ord&quot; being &quot;None&quot;, must be done separately</span>
        <span class="s2">if </span><span class="s1">ord_flag </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
            <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">_oneD_norm_2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">oneD_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

                <span class="s5"># Shortcut to handle zero length arrays</span>
                <span class="s5"># this differs slightly to numpy in that</span>
                <span class="s5"># numpy raises a ValueError for kwarg ord=</span>
                <span class="s5"># +/-np.inf as the reduction operations like</span>
                <span class="s5"># max() and min() don't accept zero length</span>
                <span class="s5"># arrays</span>
                <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s4">0.0</span>

                <span class="s5"># Note: on order == 2</span>
                <span class="s5"># This is the same as for ord==&quot;None&quot; but because</span>
                <span class="s5"># we have to handle &quot;None&quot; specially this condition</span>
                <span class="s5"># is separated</span>
                <span class="s2">if </span><span class="s1">ord </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">_oneD_norm_2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">:</span>
                    <span class="s5"># max(abs(x))</span>
                    <span class="s1">ret </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">val </span><span class="s3">&gt; </span><span class="s1">ret</span><span class="s3">:</span>
                            <span class="s1">ret </span><span class="s3">= </span><span class="s1">val</span>
                    <span class="s2">return </span><span class="s1">ret</span>

                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">:</span>
                    <span class="s5"># min(abs(x))</span>
                    <span class="s1">ret </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">val </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">val </span><span class="s3">&lt; </span><span class="s1">ret</span><span class="s3">:</span>
                            <span class="s1">ret </span><span class="s3">= </span><span class="s1">val</span>
                    <span class="s2">return </span><span class="s1">ret</span>

                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s5"># sum(x != 0)</span>
                    <span class="s1">ret </span><span class="s3">= </span><span class="s4">0.0</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s2">if </span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] != </span><span class="s4">0.</span><span class="s3">:</span>
                            <span class="s1">ret </span><span class="s3">+= </span><span class="s4">1.</span>
                    <span class="s2">return </span><span class="s1">ret</span>

                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                    <span class="s5"># sum(abs(x))</span>
                    <span class="s1">ret </span><span class="s3">= </span><span class="s4">0.0</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">ret </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">])</span>
                    <span class="s2">return </span><span class="s1">ret</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s5"># sum(abs(x)**ord)**(1./ord)</span>
                    <span class="s1">ret </span><span class="s3">= </span><span class="s4">0.0</span>
                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">ret </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">])**</span><span class="s1">ord</span>
                    <span class="s2">return </span><span class="s1">ret</span><span class="s3">**(</span><span class="s4">1. </span><span class="s3">/ </span><span class="s1">ord</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">oneD_impl</span>

    <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
        <span class="s5"># 2D cases</span>

        <span class="s5"># handle &quot;ord&quot; being &quot;None&quot;</span>
        <span class="s2">if </span><span class="s1">ord_flag </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
            <span class="s5"># Force `x` to be C-order, so that we can take a contiguous</span>
            <span class="s5"># 1D view.</span>
            <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'C'</span><span class="s3">:</span>
                <span class="s3">@</span><span class="s1">register_jitable</span>
                <span class="s2">def </span><span class="s1">array_prepare</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">x</span>
            <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout </span><span class="s3">== </span><span class="s6">'F'</span><span class="s3">:</span>
                <span class="s3">@</span><span class="s1">register_jitable</span>
                <span class="s2">def </span><span class="s1">array_prepare</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s5"># Legal since L2(x) == L2(x.T)</span>
                    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">T</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s3">@</span><span class="s1">register_jitable</span>
                <span class="s2">def </span><span class="s1">array_prepare</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

            <span class="s5"># Compute the Frobenius norm, this is the L2,2 induced norm of `x`</span>
            <span class="s5"># which is the L2-norm of x.ravel() and so can be computed via BLAS</span>
            <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size</span>
                <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s5"># reshape() currently doesn't support zero-sized arrays</span>
                    <span class="s2">return </span><span class="s4">0.0</span>
                <span class="s1">x_c </span><span class="s3">= </span><span class="s1">array_prepare</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_oneD_norm_2</span><span class="s3">(</span><span class="s1">x_c</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># max value for this dtype</span>
            <span class="s1">max_val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">np_ret_type</span><span class="s3">.</span><span class="s1">type</span><span class="s3">).</span><span class="s1">max</span>

            <span class="s2">def </span><span class="s1">twoD_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">n </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>

                <span class="s5"># Shortcut to handle zero size arrays</span>
                <span class="s5"># this differs slightly to numpy in that</span>
                <span class="s5"># numpy raises errors for some ord values</span>
                <span class="s5"># and in other cases returns zero.</span>
                <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s4">0.0</span>

                <span class="s2">if </span><span class="s1">ord </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">:</span>
                    <span class="s5"># max of sum of abs across rows</span>
                    <span class="s5"># max(sum(abs(x)), axis=1)</span>
                    <span class="s1">global_max </span><span class="s3">= </span><span class="s4">0.</span>
                    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
                        <span class="s1">tmp </span><span class="s3">= </span><span class="s4">0.</span>
                        <span class="s2">for </span><span class="s1">jj </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                            <span class="s1">tmp </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, </span><span class="s1">jj</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">&gt; </span><span class="s1">global_max</span><span class="s3">:</span>
                            <span class="s1">global_max </span><span class="s3">= </span><span class="s1">tmp</span>
                    <span class="s2">return </span><span class="s1">global_max</span>

                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">:</span>
                    <span class="s5"># min of sum of abs across rows</span>
                    <span class="s5"># min(sum(abs(x)), axis=1)</span>
                    <span class="s1">global_min </span><span class="s3">= </span><span class="s1">max_val</span>
                    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
                        <span class="s1">tmp </span><span class="s3">= </span><span class="s4">0.</span>
                        <span class="s2">for </span><span class="s1">jj </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                            <span class="s1">tmp </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, </span><span class="s1">jj</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">&lt; </span><span class="s1">global_min</span><span class="s3">:</span>
                            <span class="s1">global_min </span><span class="s3">= </span><span class="s1">tmp</span>
                    <span class="s2">return </span><span class="s1">global_min</span>
                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
                    <span class="s5"># max of sum of abs across cols</span>
                    <span class="s5"># max(sum(abs(x)), axis=0)</span>
                    <span class="s1">global_max </span><span class="s3">= </span><span class="s4">0.</span>
                    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">tmp </span><span class="s3">= </span><span class="s4">0.</span>
                        <span class="s2">for </span><span class="s1">jj </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
                            <span class="s1">tmp </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">jj</span><span class="s3">, </span><span class="s1">ii</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">&gt; </span><span class="s1">global_max</span><span class="s3">:</span>
                            <span class="s1">global_max </span><span class="s3">= </span><span class="s1">tmp</span>
                    <span class="s2">return </span><span class="s1">global_max</span>

                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">:</span>
                    <span class="s5"># min of sum of abs across cols</span>
                    <span class="s5"># min(sum(abs(x)), axis=0)</span>
                    <span class="s1">global_min </span><span class="s3">= </span><span class="s1">max_val</span>
                    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                        <span class="s1">tmp </span><span class="s3">= </span><span class="s4">0.</span>
                        <span class="s2">for </span><span class="s1">jj </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
                            <span class="s1">tmp </span><span class="s3">+= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">jj</span><span class="s3">, </span><span class="s1">ii</span><span class="s3">])</span>
                        <span class="s2">if </span><span class="s1">tmp </span><span class="s3">&lt; </span><span class="s1">global_min</span><span class="s3">:</span>
                            <span class="s1">global_min </span><span class="s3">= </span><span class="s1">tmp</span>
                    <span class="s2">return </span><span class="s1">global_min</span>

                <span class="s5"># Results via SVD, singular values are sorted on return</span>
                <span class="s5"># by definition.</span>
                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s5"># max SV</span>
                    <span class="s2">return </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">ord </span><span class="s3">== -</span><span class="s4">2</span><span class="s3">:</span>
                    <span class="s5"># min SV</span>
                    <span class="s2">return </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)[-</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s5"># replicate numpy error</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Invalid norm order for matrices.&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">twoD_impl</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s4">0  </span><span class="s5"># unreachable</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">norm_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_1_or_2d_matrix</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">&quot;norm&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_get_norm_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">ord</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">cond</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">cond_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">&quot;cond&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s5"># This is extracted for performance, numpy does approximately:</span>
        <span class="s5"># `condition = norm(x) * norm(inv(x))`</span>
        <span class="s5"># in the cases of `p == 2` or `p ==-2` singular values are used</span>
        <span class="s5"># for computing norms. This costs numpy an svd of `x` then an</span>
        <span class="s5"># inversion of `x` and another svd of `x`.</span>
        <span class="s5"># Below is a different approach, which also gives a more</span>
        <span class="s5"># accurate answer as there is no inversion involved.</span>
        <span class="s5"># Recall that the singular values of an inverted matrix are the</span>
        <span class="s5"># reciprocal of singular values of the original matrix.</span>
        <span class="s5"># Therefore calling `svd(x)` once yields all the information</span>
        <span class="s5"># needed about both `x` and `inv(x)` without the cost or</span>
        <span class="s5"># potential loss of accuracy incurred through inversion.</span>
        <span class="s5"># For the case of `p == 2`, the result is just the ratio of</span>
        <span class="s5"># `largest singular value/smallest singular value`, and for the</span>
        <span class="s5"># case of `p==-2` the result is simply the</span>
        <span class="s5"># `smallest singular value/largest singular value`.</span>
        <span class="s5"># As a result of this, numba accepts non-square matrices as</span>
        <span class="s5"># input when p==+/-2 as well as when p==None.</span>
        <span class="s2">if </span><span class="s1">p </span><span class="s3">== </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">p </span><span class="s3">== -</span><span class="s4">2 </span><span class="s2">or </span><span class="s1">p </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s3">== </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">p </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">s</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">s</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s5"># cases np.inf, -np.inf, 1, -1</span>
            <span class="s1">norm_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">norm_inv_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">inv</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">norm_x </span><span class="s3">* </span><span class="s1">norm_inv_x</span>
        <span class="s5"># NumPy uses a NaN mask, if the input has a NaN, it will return NaN,</span>
        <span class="s5"># Numba calls ban NaN through the use of _check_finite_matrix but this</span>
        <span class="s5"># catches cases where NaN occurs through floating point use</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">r</span>
    <span class="s2">return </span><span class="s1">impl</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">_get_rank_from_singular_values</span><span class="s3">(</span><span class="s1">sv</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gets rank from singular values with cut-off at a given tolerance 
    &quot;&quot;&quot;</span>
    <span class="s1">rank </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sv</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">sv</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &gt; </span><span class="s1">t</span><span class="s3">:</span>
            <span class="s1">rank </span><span class="s3">= </span><span class="s1">rank </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s5"># sv is ordered big-&gt;small so break on condition not met</span>
            <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">rank</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">matrix_rank</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes rank for matrices and vectors. 
    The only issue that may arise is that because numpy uses double 
    precision lapack calls whereas numba uses type specific lapack 
    calls, some singular values may differ and therefore counting the 
    number of them above a tolerance may lead to different counts, 
    and therefore rank, in some cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">ensure_lapack</span><span class="s3">()</span>

    <span class="s1">_check_linalg_1_or_2d_matrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s6">&quot;matrix_rank&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_2d_matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">):</span>

        <span class="s5"># handle the tol==None case separately for type inference to work</span>
        <span class="s2">if </span><span class="s1">tol </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
            <span class="s1">nb_type </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">A</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s6">&quot;underlying_float&quot;</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">np_type </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">nb_type</span><span class="s3">)</span>
            <span class="s1">eps_val </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">np_type</span><span class="s3">).</span><span class="s1">eps</span>

            <span class="s2">def </span><span class="s1">_2d_tol_none_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
                <span class="s5"># replicate numpy default tolerance calculation</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
                <span class="s1">c </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">l </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">c</span><span class="s3">)</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">l </span><span class="s3">* </span><span class="s1">eps_val</span>
                <span class="s2">return </span><span class="s1">_get_rank_from_singular_values</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_2d_tol_none_impl</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">_2d_tol_not_none_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">_compute_singular_values</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">_get_rank_from_singular_values</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_2d_tol_not_none_impl</span>

    <span class="s2">def </span><span class="s1">_get_matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">):</span>
        <span class="s1">ndim </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">if </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s5"># NOTE: Technically, the numpy implementation could be argued as</span>
            <span class="s5"># incorrect for the case of a vector (1D matrix). If a tolerance</span>
            <span class="s5"># is provided and a vector with a singular value below tolerance is</span>
            <span class="s5"># encountered this should report a rank of zero, the numpy</span>
            <span class="s5"># implementation does not do this and instead elects to report that</span>
            <span class="s5"># if any value in the vector is nonzero then the rank is 1.</span>
            <span class="s5"># An example would be [0, 1e-15, 0, 2e-15] which numpy reports as</span>
            <span class="s5"># rank 1 invariant of `tol`. The singular value for this vector is</span>
            <span class="s5"># obviously sqrt(5)*1e-15 and so a tol of e.g. sqrt(6)*1e-15 should</span>
            <span class="s5"># lead to a reported rank of 0 whereas a tol of 1e-15 should lead</span>
            <span class="s5"># to a reported rank of 1, numpy reports 1 regardless.</span>
            <span class="s5"># The code below replicates the numpy behaviour.</span>
            <span class="s2">def </span><span class="s1">_1d_matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)):</span>
                    <span class="s2">if </span><span class="s1">A</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] != </span><span class="s4">0.</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s4">1</span>
                <span class="s2">return </span><span class="s4">0</span>
            <span class="s2">return </span><span class="s1">_1d_matrix_rank_impl</span>
        <span class="s2">elif </span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_2d_matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s4">0  </span><span class="s5"># unreachable</span>

    <span class="s2">return </span><span class="s1">_get_matrix_rank_impl</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">matrix_power</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">matrix_power_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes matrix power. Only integer powers are supported in numpy. 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;matrix_power&quot;</span><span class="s3">)</span>
    <span class="s1">np_dtype </span><span class="s3">= </span><span class="s1">np_support</span><span class="s3">.</span><span class="s1">as_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">nt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">&quot;Exponent must be an integer.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">matrix_power_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s5"># this should be eye() but it doesn't support</span>
            <span class="s5"># the dtype kwarg yet so do it manually to save</span>
            <span class="s5"># the copy required by eye(a.shape[0]).asdtype()</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np_dtype</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] = </span><span class="s4">1.</span>
            <span class="s2">return </span><span class="s1">A</span>

        <span class="s1">am</span><span class="s3">, </span><span class="s1">an </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">am </span><span class="s3">!= </span><span class="s1">an</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">'input must be a square array'</span><span class="s3">)</span>

        <span class="s5"># empty, return a copy</span>
        <span class="s2">if </span><span class="s1">am </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s5"># note: to be consistent over contiguousness, C order is</span>
        <span class="s5"># returned as that is what dot() produces and the most common</span>
        <span class="s5"># paths through matrix_power will involve that. Therefore</span>
        <span class="s5"># copies are made here to ensure the data ordering is</span>
        <span class="s5"># correct for paths not going via dot().</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">inv</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">:  </span><span class="s5"># return now</span>
                <span class="s2">return </span><span class="s1">A</span>
            <span class="s1">n </span><span class="s3">= -</span><span class="s1">n</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:  </span><span class="s5"># return a copy now</span>
                <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">a  </span><span class="s5"># this is safe, `a` is only read</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s4">4</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">A</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">3</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">A</span><span class="s3">), </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>

            <span class="s1">acc </span><span class="s3">= </span><span class="s1">A</span>
            <span class="s1">exp </span><span class="s3">= </span><span class="s1">n</span>

            <span class="s5"># Initialise ret, SSA cannot see the loop will execute, without this</span>
            <span class="s5"># it appears as uninitialised.</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">acc</span>
            <span class="s5"># tried a loop split and branchless using identity matrix as</span>
            <span class="s5"># input but it seems like having a &quot;first entry&quot; flag is quicker</span>
            <span class="s1">flag </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">while </span><span class="s1">exp </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">exp </span><span class="s3">&amp; </span><span class="s4">1</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">flag</span><span class="s3">:</span>
                        <span class="s1">ret </span><span class="s3">= </span><span class="s1">acc</span>
                        <span class="s1">flag </span><span class="s3">= </span><span class="s2">False</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">acc</span><span class="s3">)</span>
                <span class="s1">acc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">acc</span><span class="s3">, </span><span class="s1">acc</span><span class="s3">)</span>
                <span class="s1">exp </span><span class="s3">= </span><span class="s1">exp </span><span class="s3">&gt;&gt; </span><span class="s4">1</span>

            <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">return </span><span class="s1">matrix_power_impl</span>

<span class="s5"># This is documented under linalg despite not being in the module</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">trace</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">matrix_trace_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the trace of an array. 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_linalg_matrix</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;trace&quot;</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">, (</span><span class="s1">int</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Integer</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">NumbaTypeError</span><span class="s3">(</span><span class="s6">&quot;integer argument expected, got %s&quot; </span><span class="s3">% </span><span class="s1">offset</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">matrix_trace_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
        <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">offset</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">rows </span><span class="s3">= </span><span class="s1">rows </span><span class="s3">+ </span><span class="s1">k</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">cols </span><span class="s3">= </span><span class="s1">cols </span><span class="s3">- </span><span class="s1">k</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">rows</span><span class="s3">, </span><span class="s1">cols</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">ret </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
                <span class="s1">ret </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">return </span><span class="s1">matrix_trace_impl</span>


<span class="s2">def </span><span class="s1">_check_scalar_or_lt_2d_mat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s1">prefix </span><span class="s3">= </span><span class="s6">&quot;np.linalg&quot; </span><span class="s2">if </span><span class="s1">la_prefix </span><span class="s2">else </span><span class="s6">&quot;np&quot;</span>
    <span class="s1">interp </span><span class="s3">= (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
    <span class="s5"># checks that a matrix is 1 or 2D</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt;= </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;%s.%s() only supported on 1 and 2-D arrays &quot;</span>
                              <span class="s3">% </span><span class="s1">interp</span><span class="s3">, </span><span class="s1">highlighting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">outer_impl_none</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s1">aa </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">bb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">aa</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">aa</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)),</span>
                        <span class="s1">bb</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s1">bb</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)))</span>


<span class="s3">@</span><span class="s1">register_jitable</span>
<span class="s2">def </span><span class="s1">outer_impl_arr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s1">aa </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">bb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">aa</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">aa</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)),</span>
                <span class="s1">bb</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s1">bb</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)),</span>
                <span class="s1">out</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_get_outer_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">out </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">outer_impl_none</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">outer_impl_arr</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">outer</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">outer_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s1">_check_scalar_or_lt_2d_mat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;outer&quot;</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">_check_scalar_or_lt_2d_mat</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s6">&quot;outer&quot;</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">impl </span><span class="s3">= </span><span class="s1">_get_outer_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">outer_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">outer_impl</span>


<span class="s2">def </span><span class="s1">_kron_normaliser_impl</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s5"># makes x into a 2d array</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout </span><span class="s2">not in </span><span class="s3">(</span><span class="s6">'C'</span><span class="s3">, </span><span class="s6">'F'</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypingError</span><span class="s3">(</span><span class="s6">&quot;np.linalg.kron only supports 'C' or 'F' layout &quot;</span>
                              <span class="s6">&quot;input arrays. Received an input of &quot;</span>
                              <span class="s6">&quot;layout '{}'.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">nrm_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s1">xn </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s1">xm </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
                <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">xm</span><span class="s3">, </span><span class="s1">xn</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">nrm_shape</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">nrm_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
                <span class="s1">xn </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">xn</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">nrm_shape</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s5"># assume its a scalar</span>
        <span class="s3">@</span><span class="s1">register_jitable</span>
        <span class="s2">def </span><span class="s1">nrm_shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">x</span>
            <span class="s2">return </span><span class="s1">a</span>
        <span class="s2">return </span><span class="s1">nrm_shape</span>


<span class="s2">def </span><span class="s1">_kron_return</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s5"># transforms c into something that kron would return</span>
    <span class="s5"># based on the shapes of a and b</span>
    <span class="s1">a_is_arr </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s1">b_is_arr </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">a_is_arr </span><span class="s2">and </span><span class="s1">b_is_arr</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s5"># at least one of (a, b) is a scalar</span>
        <span class="s2">if </span><span class="s1">a_is_arr</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">elif </span><span class="s1">b_is_arr</span><span class="s3">:</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s5"># both scalars</span>
            <span class="s3">@</span><span class="s1">register_jitable</span>
            <span class="s2">def </span><span class="s1">ret</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">c</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">ret</span>


<span class="s3">@</span><span class="s1">overload</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">kron</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">kron_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>

    <span class="s1">_check_scalar_or_lt_2d_mat</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">&quot;kron&quot;</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">_check_scalar_or_lt_2d_mat</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s6">&quot;kron&quot;</span><span class="s3">, </span><span class="s1">la_prefix</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">fix_a </span><span class="s3">= </span><span class="s1">_kron_normaliser_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">fix_b </span><span class="s3">= </span><span class="s1">_kron_normaliser_impl</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">ret_c </span><span class="s3">= </span><span class="s1">_kron_return</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s5"># this is fine because the ufunc for the Hadamard product</span>
    <span class="s5"># will reject differing dtypes in a and b.</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">'dtype'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">kron_impl</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>

        <span class="s1">aa </span><span class="s3">= </span><span class="s1">fix_a</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">bb </span><span class="s3">= </span><span class="s1">fix_b</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">am </span><span class="s3">= </span><span class="s1">aa</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">an </span><span class="s3">= </span><span class="s1">aa</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">bm </span><span class="s3">= </span><span class="s1">bb</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">2</span><span class="s3">]</span>
        <span class="s1">bn </span><span class="s3">= </span><span class="s1">bb</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s1">cm </span><span class="s3">= </span><span class="s1">am </span><span class="s3">* </span><span class="s1">bm</span>
        <span class="s1">cn </span><span class="s3">= </span><span class="s1">an </span><span class="s3">* </span><span class="s1">bn</span>

        <span class="s5"># allocate c</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">cm</span><span class="s3">, </span><span class="s1">cn</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>

        <span class="s5"># In practice this is runs quicker than the more obvious</span>
        <span class="s5"># `each element of A multiplied by B and assigned to</span>
        <span class="s5"># a block in C` like alg.</span>

        <span class="s5"># loop over rows of A</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">am</span><span class="s3">):</span>
            <span class="s5"># compute the column offset into C</span>
            <span class="s1">rjmp </span><span class="s3">= </span><span class="s1">i </span><span class="s3">* </span><span class="s1">bm</span>
            <span class="s5"># loop over rows of B</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">bm</span><span class="s3">):</span>
                <span class="s5"># compute row the offset into C</span>
                <span class="s1">irjmp </span><span class="s3">= </span><span class="s1">rjmp </span><span class="s3">+ </span><span class="s1">k</span>
                <span class="s5"># slice a given row of B</span>
                <span class="s1">slc </span><span class="s3">= </span><span class="s1">bb</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, :]</span>
                <span class="s5"># loop over columns of A</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">an</span><span class="s3">):</span>
                    <span class="s5"># vectorized assignment of an element of A</span>
                    <span class="s5"># multiplied by the current row of B into</span>
                    <span class="s5"># a slice of a row of C</span>
                    <span class="s1">cjmp </span><span class="s3">= </span><span class="s1">j </span><span class="s3">* </span><span class="s1">bn</span>
                    <span class="s1">C</span><span class="s3">[</span><span class="s1">irjmp</span><span class="s3">, </span><span class="s1">cjmp</span><span class="s3">:</span><span class="s1">cjmp </span><span class="s3">+ </span><span class="s1">bn</span><span class="s3">] = </span><span class="s1">aa</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] * </span><span class="s1">slc</span>

        <span class="s2">return </span><span class="s1">ret_c</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">kron_impl</span>
</pre>
</body>
</html>