<html>
<head>
<title>soundfile.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
soundfile.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;python-soundfile is an audio library based on libsndfile, CFFI and NumPy. 
 
Sound files can be read or written directly using the functions 
`read()` and `write()`. 
To read a sound file in a block-wise fashion, use `blocks()`. 
Alternatively, sound files can be opened as `SoundFile` objects. 
 
For further information, see https://python-soundfile.readthedocs.io/. 
 
&quot;&quot;&quot;</span>
<span class="s1">__version__ </span><span class="s2">= </span><span class="s3">&quot;0.12.1&quot;</span>

<span class="s4">import </span><span class="s1">os </span><span class="s4">as </span><span class="s1">_os</span>
<span class="s4">import </span><span class="s1">sys </span><span class="s4">as </span><span class="s1">_sys</span>
<span class="s4">from </span><span class="s1">os </span><span class="s4">import </span><span class="s1">SEEK_SET</span><span class="s2">, </span><span class="s1">SEEK_CUR</span><span class="s2">, </span><span class="s1">SEEK_END</span>
<span class="s4">from </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s1">find_library </span><span class="s4">as </span><span class="s1">_find_library</span>
<span class="s4">from </span><span class="s1">_soundfile </span><span class="s4">import </span><span class="s1">ffi </span><span class="s4">as </span><span class="s1">_ffi</span>

<span class="s4">try</span><span class="s2">:</span>
    <span class="s1">_unicode </span><span class="s2">= </span><span class="s1">unicode  </span><span class="s5"># doesn't exist in Python 3.x</span>
<span class="s4">except </span><span class="s1">NameError</span><span class="s2">:</span>
    <span class="s1">_unicode </span><span class="s2">= </span><span class="s1">str</span>


<span class="s1">_str_types </span><span class="s2">= {</span>
    <span class="s3">'title'</span><span class="s2">:       </span><span class="s6">0x01</span><span class="s2">,</span>
    <span class="s3">'copyright'</span><span class="s2">:   </span><span class="s6">0x02</span><span class="s2">,</span>
    <span class="s3">'software'</span><span class="s2">:    </span><span class="s6">0x03</span><span class="s2">,</span>
    <span class="s3">'artist'</span><span class="s2">:      </span><span class="s6">0x04</span><span class="s2">,</span>
    <span class="s3">'comment'</span><span class="s2">:     </span><span class="s6">0x05</span><span class="s2">,</span>
    <span class="s3">'date'</span><span class="s2">:        </span><span class="s6">0x06</span><span class="s2">,</span>
    <span class="s3">'album'</span><span class="s2">:       </span><span class="s6">0x07</span><span class="s2">,</span>
    <span class="s3">'license'</span><span class="s2">:     </span><span class="s6">0x08</span><span class="s2">,</span>
    <span class="s3">'tracknumber'</span><span class="s2">: </span><span class="s6">0x09</span><span class="s2">,</span>
    <span class="s3">'genre'</span><span class="s2">:       </span><span class="s6">0x10</span><span class="s2">,</span>
<span class="s2">}</span>

<span class="s1">_formats </span><span class="s2">= {</span>
    <span class="s3">'WAV'</span><span class="s2">:   </span><span class="s6">0x010000</span><span class="s2">,  </span><span class="s5"># Microsoft WAV format (little endian default).</span>
    <span class="s3">'AIFF'</span><span class="s2">:  </span><span class="s6">0x020000</span><span class="s2">,  </span><span class="s5"># Apple/SGI AIFF format (big endian).</span>
    <span class="s3">'AU'</span><span class="s2">:    </span><span class="s6">0x030000</span><span class="s2">,  </span><span class="s5"># Sun/NeXT AU format (big endian).</span>
    <span class="s3">'RAW'</span><span class="s2">:   </span><span class="s6">0x040000</span><span class="s2">,  </span><span class="s5"># RAW PCM data.</span>
    <span class="s3">'PAF'</span><span class="s2">:   </span><span class="s6">0x050000</span><span class="s2">,  </span><span class="s5"># Ensoniq PARIS file format.</span>
    <span class="s3">'SVX'</span><span class="s2">:   </span><span class="s6">0x060000</span><span class="s2">,  </span><span class="s5"># Amiga IFF / SVX8 / SV16 format.</span>
    <span class="s3">'NIST'</span><span class="s2">:  </span><span class="s6">0x070000</span><span class="s2">,  </span><span class="s5"># Sphere NIST format.</span>
    <span class="s3">'VOC'</span><span class="s2">:   </span><span class="s6">0x080000</span><span class="s2">,  </span><span class="s5"># VOC files.</span>
    <span class="s3">'IRCAM'</span><span class="s2">: </span><span class="s6">0x0A0000</span><span class="s2">,  </span><span class="s5"># Berkeley/IRCAM/CARL</span>
    <span class="s3">'W64'</span><span class="s2">:   </span><span class="s6">0x0B0000</span><span class="s2">,  </span><span class="s5"># Sonic Foundry's 64 bit RIFF/WAV</span>
    <span class="s3">'MAT4'</span><span class="s2">:  </span><span class="s6">0x0C0000</span><span class="s2">,  </span><span class="s5"># Matlab (tm) V4.2 / GNU Octave 2.0</span>
    <span class="s3">'MAT5'</span><span class="s2">:  </span><span class="s6">0x0D0000</span><span class="s2">,  </span><span class="s5"># Matlab (tm) V5.0 / GNU Octave 2.1</span>
    <span class="s3">'PVF'</span><span class="s2">:   </span><span class="s6">0x0E0000</span><span class="s2">,  </span><span class="s5"># Portable Voice Format</span>
    <span class="s3">'XI'</span><span class="s2">:    </span><span class="s6">0x0F0000</span><span class="s2">,  </span><span class="s5"># Fasttracker 2 Extended Instrument</span>
    <span class="s3">'HTK'</span><span class="s2">:   </span><span class="s6">0x100000</span><span class="s2">,  </span><span class="s5"># HMM Tool Kit format</span>
    <span class="s3">'SDS'</span><span class="s2">:   </span><span class="s6">0x110000</span><span class="s2">,  </span><span class="s5"># Midi Sample Dump Standard</span>
    <span class="s3">'AVR'</span><span class="s2">:   </span><span class="s6">0x120000</span><span class="s2">,  </span><span class="s5"># Audio Visual Research</span>
    <span class="s3">'WAVEX'</span><span class="s2">: </span><span class="s6">0x130000</span><span class="s2">,  </span><span class="s5"># MS WAVE with WAVEFORMATEX</span>
    <span class="s3">'SD2'</span><span class="s2">:   </span><span class="s6">0x160000</span><span class="s2">,  </span><span class="s5"># Sound Designer 2</span>
    <span class="s3">'FLAC'</span><span class="s2">:  </span><span class="s6">0x170000</span><span class="s2">,  </span><span class="s5"># FLAC lossless file format</span>
    <span class="s3">'CAF'</span><span class="s2">:   </span><span class="s6">0x180000</span><span class="s2">,  </span><span class="s5"># Core Audio File format</span>
    <span class="s3">'WVE'</span><span class="s2">:   </span><span class="s6">0x190000</span><span class="s2">,  </span><span class="s5"># Psion WVE format</span>
    <span class="s3">'OGG'</span><span class="s2">:   </span><span class="s6">0x200000</span><span class="s2">,  </span><span class="s5"># Xiph OGG container</span>
    <span class="s3">'MPC2K'</span><span class="s2">: </span><span class="s6">0x210000</span><span class="s2">,  </span><span class="s5"># Akai MPC 2000 sampler</span>
    <span class="s3">'RF64'</span><span class="s2">:  </span><span class="s6">0x220000</span><span class="s2">,  </span><span class="s5"># RF64 WAV file</span>
    <span class="s3">'MP3'</span><span class="s2">:   </span><span class="s6">0x230000</span><span class="s2">,  </span><span class="s5"># MPEG-1/2 audio stream</span>
<span class="s2">}</span>

<span class="s1">_subtypes </span><span class="s2">= {</span>
    <span class="s3">'PCM_S8'</span><span class="s2">:         </span><span class="s6">0x0001</span><span class="s2">,  </span><span class="s5"># Signed 8 bit data</span>
    <span class="s3">'PCM_16'</span><span class="s2">:         </span><span class="s6">0x0002</span><span class="s2">,  </span><span class="s5"># Signed 16 bit data</span>
    <span class="s3">'PCM_24'</span><span class="s2">:         </span><span class="s6">0x0003</span><span class="s2">,  </span><span class="s5"># Signed 24 bit data</span>
    <span class="s3">'PCM_32'</span><span class="s2">:         </span><span class="s6">0x0004</span><span class="s2">,  </span><span class="s5"># Signed 32 bit data</span>
    <span class="s3">'PCM_U8'</span><span class="s2">:         </span><span class="s6">0x0005</span><span class="s2">,  </span><span class="s5"># Unsigned 8 bit data (WAV and RAW only)</span>
    <span class="s3">'FLOAT'</span><span class="s2">:          </span><span class="s6">0x0006</span><span class="s2">,  </span><span class="s5"># 32 bit float data</span>
    <span class="s3">'DOUBLE'</span><span class="s2">:         </span><span class="s6">0x0007</span><span class="s2">,  </span><span class="s5"># 64 bit float data</span>
    <span class="s3">'ULAW'</span><span class="s2">:           </span><span class="s6">0x0010</span><span class="s2">,  </span><span class="s5"># U-Law encoded.</span>
    <span class="s3">'ALAW'</span><span class="s2">:           </span><span class="s6">0x0011</span><span class="s2">,  </span><span class="s5"># A-Law encoded.</span>
    <span class="s3">'IMA_ADPCM'</span><span class="s2">:      </span><span class="s6">0x0012</span><span class="s2">,  </span><span class="s5"># IMA ADPCM.</span>
    <span class="s3">'MS_ADPCM'</span><span class="s2">:       </span><span class="s6">0x0013</span><span class="s2">,  </span><span class="s5"># Microsoft ADPCM.</span>
    <span class="s3">'GSM610'</span><span class="s2">:         </span><span class="s6">0x0020</span><span class="s2">,  </span><span class="s5"># GSM 6.10 encoding.</span>
    <span class="s3">'VOX_ADPCM'</span><span class="s2">:      </span><span class="s6">0x0021</span><span class="s2">,  </span><span class="s5"># OKI / Dialogix ADPCM</span>
    <span class="s3">'NMS_ADPCM_16'</span><span class="s2">:   </span><span class="s6">0x0022</span><span class="s2">,  </span><span class="s5"># 16kbs NMS G721-variant encoding.</span>
    <span class="s3">'NMS_ADPCM_24'</span><span class="s2">:   </span><span class="s6">0x0023</span><span class="s2">,  </span><span class="s5"># 24kbs NMS G721-variant encoding.</span>
    <span class="s3">'NMS_ADPCM_32'</span><span class="s2">:   </span><span class="s6">0x0024</span><span class="s2">,  </span><span class="s5"># 32kbs NMS G721-variant encoding.</span>
    <span class="s3">'G721_32'</span><span class="s2">:        </span><span class="s6">0x0030</span><span class="s2">,  </span><span class="s5"># 32kbs G721 ADPCM encoding.</span>
    <span class="s3">'G723_24'</span><span class="s2">:        </span><span class="s6">0x0031</span><span class="s2">,  </span><span class="s5"># 24kbs G723 ADPCM encoding.</span>
    <span class="s3">'G723_40'</span><span class="s2">:        </span><span class="s6">0x0032</span><span class="s2">,  </span><span class="s5"># 40kbs G723 ADPCM encoding.</span>
    <span class="s3">'DWVW_12'</span><span class="s2">:        </span><span class="s6">0x0040</span><span class="s2">,  </span><span class="s5"># 12 bit Delta Width Variable Word encoding.</span>
    <span class="s3">'DWVW_16'</span><span class="s2">:        </span><span class="s6">0x0041</span><span class="s2">,  </span><span class="s5"># 16 bit Delta Width Variable Word encoding.</span>
    <span class="s3">'DWVW_24'</span><span class="s2">:        </span><span class="s6">0x0042</span><span class="s2">,  </span><span class="s5"># 24 bit Delta Width Variable Word encoding.</span>
    <span class="s3">'DWVW_N'</span><span class="s2">:         </span><span class="s6">0x0043</span><span class="s2">,  </span><span class="s5"># N bit Delta Width Variable Word encoding.</span>
    <span class="s3">'DPCM_8'</span><span class="s2">:         </span><span class="s6">0x0050</span><span class="s2">,  </span><span class="s5"># 8 bit differential PCM (XI only)</span>
    <span class="s3">'DPCM_16'</span><span class="s2">:        </span><span class="s6">0x0051</span><span class="s2">,  </span><span class="s5"># 16 bit differential PCM (XI only)</span>
    <span class="s3">'VORBIS'</span><span class="s2">:         </span><span class="s6">0x0060</span><span class="s2">,  </span><span class="s5"># Xiph Vorbis encoding.</span>
    <span class="s3">'OPUS'</span><span class="s2">:           </span><span class="s6">0x0064</span><span class="s2">,  </span><span class="s5"># Xiph/Skype Opus encoding.</span>
    <span class="s3">'ALAC_16'</span><span class="s2">:        </span><span class="s6">0x0070</span><span class="s2">,  </span><span class="s5"># Apple Lossless Audio Codec (16 bit).</span>
    <span class="s3">'ALAC_20'</span><span class="s2">:        </span><span class="s6">0x0071</span><span class="s2">,  </span><span class="s5"># Apple Lossless Audio Codec (20 bit).</span>
    <span class="s3">'ALAC_24'</span><span class="s2">:        </span><span class="s6">0x0072</span><span class="s2">,  </span><span class="s5"># Apple Lossless Audio Codec (24 bit).</span>
    <span class="s3">'ALAC_32'</span><span class="s2">:        </span><span class="s6">0x0073</span><span class="s2">,  </span><span class="s5"># Apple Lossless Audio Codec (32 bit).</span>
    <span class="s3">'MPEG_LAYER_I'</span><span class="s2">:   </span><span class="s6">0x0080</span><span class="s2">,  </span><span class="s5"># MPEG-1 Audio Layer I.</span>
    <span class="s3">'MPEG_LAYER_II'</span><span class="s2">:  </span><span class="s6">0x0081</span><span class="s2">,  </span><span class="s5"># MPEG-1 Audio Layer II.</span>
    <span class="s3">'MPEG_LAYER_III'</span><span class="s2">: </span><span class="s6">0x0082</span><span class="s2">,  </span><span class="s5"># MPEG-2 Audio Layer III.</span>
<span class="s2">}</span>

<span class="s1">_endians </span><span class="s2">= {</span>
    <span class="s3">'FILE'</span><span class="s2">:   </span><span class="s6">0x00000000</span><span class="s2">,  </span><span class="s5"># Default file endian-ness.</span>
    <span class="s3">'LITTLE'</span><span class="s2">: </span><span class="s6">0x10000000</span><span class="s2">,  </span><span class="s5"># Force little endian-ness.</span>
    <span class="s3">'BIG'</span><span class="s2">:    </span><span class="s6">0x20000000</span><span class="s2">,  </span><span class="s5"># Force big endian-ness.</span>
    <span class="s3">'CPU'</span><span class="s2">:    </span><span class="s6">0x30000000</span><span class="s2">,  </span><span class="s5"># Force CPU endian-ness.</span>
<span class="s2">}</span>

<span class="s5"># libsndfile doesn't specify default subtypes, these are somehow arbitrary:</span>
<span class="s1">_default_subtypes </span><span class="s2">= {</span>
    <span class="s3">'WAV'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'AIFF'</span><span class="s2">:  </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'AU'</span><span class="s2">:    </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s5"># 'RAW':  # subtype must be explicit!</span>
    <span class="s3">'PAF'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'SVX'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'NIST'</span><span class="s2">:  </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'VOC'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'IRCAM'</span><span class="s2">: </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'W64'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'MAT4'</span><span class="s2">:  </span><span class="s3">'DOUBLE'</span><span class="s2">,</span>
    <span class="s3">'MAT5'</span><span class="s2">:  </span><span class="s3">'DOUBLE'</span><span class="s2">,</span>
    <span class="s3">'PVF'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'XI'</span><span class="s2">:    </span><span class="s3">'DPCM_16'</span><span class="s2">,</span>
    <span class="s3">'HTK'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'SDS'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'AVR'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'WAVEX'</span><span class="s2">: </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'SD2'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'FLAC'</span><span class="s2">:  </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'CAF'</span><span class="s2">:   </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'WVE'</span><span class="s2">:   </span><span class="s3">'ALAW'</span><span class="s2">,</span>
    <span class="s3">'OGG'</span><span class="s2">:   </span><span class="s3">'VORBIS'</span><span class="s2">,</span>
    <span class="s3">'MPC2K'</span><span class="s2">: </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'RF64'</span><span class="s2">:  </span><span class="s3">'PCM_16'</span><span class="s2">,</span>
    <span class="s3">'MP3'</span><span class="s2">:   </span><span class="s3">'MPEG_LAYER_III'</span><span class="s2">,</span>
<span class="s2">}</span>

<span class="s1">_ffi_types </span><span class="s2">= {</span>
    <span class="s3">'float64'</span><span class="s2">: </span><span class="s3">'double'</span><span class="s2">,</span>
    <span class="s3">'float32'</span><span class="s2">: </span><span class="s3">'float'</span><span class="s2">,</span>
    <span class="s3">'int32'</span><span class="s2">: </span><span class="s3">'int'</span><span class="s2">,</span>
    <span class="s3">'int16'</span><span class="s2">: </span><span class="s3">'short'</span>
<span class="s2">}</span>

<span class="s4">try</span><span class="s2">:  </span><span class="s5"># packaged lib (in _soundfile_data which should be on python path)</span>
    <span class="s4">if </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'darwin'</span><span class="s2">:</span>
        <span class="s4">from </span><span class="s1">platform </span><span class="s4">import </span><span class="s1">machine </span><span class="s4">as </span><span class="s1">_machine</span>
        <span class="s1">_packaged_libname </span><span class="s2">= </span><span class="s3">'libsndfile_' </span><span class="s2">+ </span><span class="s1">_machine</span><span class="s2">() + </span><span class="s3">'.dylib'</span>
    <span class="s4">elif </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'win32'</span><span class="s2">:</span>
        <span class="s4">from </span><span class="s1">platform </span><span class="s4">import </span><span class="s1">architecture </span><span class="s4">as </span><span class="s1">_architecture</span>
        <span class="s1">_packaged_libname </span><span class="s2">= </span><span class="s3">'libsndfile_' </span><span class="s2">+ </span><span class="s1">_architecture</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">] + </span><span class="s3">'.dll'</span>
    <span class="s4">elif </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'linux'</span><span class="s2">:</span>
        <span class="s4">from </span><span class="s1">platform </span><span class="s4">import </span><span class="s1">machine </span><span class="s4">as </span><span class="s1">_machine</span>
        <span class="s1">_packaged_libname </span><span class="s2">= </span><span class="s3">'libsndfile_' </span><span class="s2">+ </span><span class="s1">_machine</span><span class="s2">() + </span><span class="s3">'.so'</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s3">'no packaged library for this platform'</span><span class="s2">)</span>

    <span class="s4">import </span><span class="s1">_soundfile_data  </span><span class="s5"># ImportError if this doesn't exist</span>
    <span class="s1">_path </span><span class="s2">= </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">_soundfile_data</span><span class="s2">.</span><span class="s1">__file__</span><span class="s2">)  </span><span class="s5"># TypeError if __file__ is None</span>
    <span class="s1">_full_path </span><span class="s2">= </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">_path</span><span class="s2">, </span><span class="s1">_packaged_libname</span><span class="s2">)</span>
    <span class="s1">_snd </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">dlopen</span><span class="s2">(</span><span class="s1">_full_path</span><span class="s2">)  </span><span class="s5"># OSError if file doesn't exist or can't be loaded</span>

<span class="s4">except </span><span class="s2">(</span><span class="s1">OSError</span><span class="s2">, </span><span class="s1">ImportError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
    <span class="s4">try</span><span class="s2">:  </span><span class="s5"># system-wide libsndfile:</span>
        <span class="s1">_libname </span><span class="s2">= </span><span class="s1">_find_library</span><span class="s2">(</span><span class="s3">'sndfile'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">_libname </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s3">'sndfile library not found using ctypes.util.find_library'</span><span class="s2">)</span>
        <span class="s1">_snd </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">dlopen</span><span class="s2">(</span><span class="s1">_libname</span><span class="s2">)</span>

    <span class="s4">except </span><span class="s1">OSError</span><span class="s2">:</span>
        <span class="s5"># Try explicit file name, if the general does not work (e.g. on nixos)</span>
        <span class="s4">if </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'darwin'</span><span class="s2">:</span>
            <span class="s1">_explicit_libname </span><span class="s2">= </span><span class="s3">'libsndfile.dylib'</span>
        <span class="s4">elif </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'win32'</span><span class="s2">:</span>
            <span class="s1">_explicit_libname </span><span class="s2">= </span><span class="s3">'libsndfile.dll'</span>
        <span class="s4">elif </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'linux'</span><span class="s2">:</span>
            <span class="s1">_explicit_libname </span><span class="s2">= </span><span class="s3">'libsndfile.so'</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise</span>

        <span class="s5"># Homebrew on Apple M1 uses a `/opt/homebrew/lib` instead of</span>
        <span class="s5"># `/usr/local/lib`. We are making sure we pick that up.</span>
        <span class="s4">from </span><span class="s1">platform </span><span class="s4">import </span><span class="s1">machine </span><span class="s4">as </span><span class="s1">_machine</span>
        <span class="s4">if </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'darwin' </span><span class="s4">and </span><span class="s1">_machine</span><span class="s2">() == </span><span class="s3">'arm64'</span><span class="s2">:</span>
            <span class="s1">_hbrew_path </span><span class="s2">= </span><span class="s3">'/opt/homebrew/lib/' </span><span class="s4">if </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">isdir</span><span class="s2">(</span><span class="s3">'/opt/homebrew/lib/'</span><span class="s2">) </span><span class="s1">\</span>
                <span class="s4">else </span><span class="s3">'/usr/local/lib/'</span>
            <span class="s1">_snd </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">dlopen</span><span class="s2">(</span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">_hbrew_path</span><span class="s2">, </span><span class="s1">_explicit_libname</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">_snd </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">dlopen</span><span class="s2">(</span><span class="s1">_explicit_libname</span><span class="s2">)</span>

<span class="s1">__libsndfile_version__ </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_version_string</span><span class="s2">()).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">)</span>
<span class="s4">if </span><span class="s1">__libsndfile_version__</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">'libsndfile-'</span><span class="s2">):</span>
    <span class="s1">__libsndfile_version__ </span><span class="s2">= </span><span class="s1">__libsndfile_version__</span><span class="s2">[</span><span class="s1">len</span><span class="s2">(</span><span class="s3">'libsndfile-'</span><span class="s2">):]</span>


<span class="s4">def </span><span class="s1">read</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">start</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'float64'</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
         <span class="s1">fill_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
         <span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Provide audio data from a sound file as NumPy array. 
 
    By default, the whole file is read from the beginning, but the 
    position to start reading can be specified with *start* and the 
    number of frames to read can be specified with *frames*. 
    Alternatively, a range can be specified with *start* and *stop*. 
 
    If there is less data left in the file than requested, the rest of 
    the frames are filled with *fill_value*. 
    If no *fill_value* is specified, a smaller array is returned. 
 
    Parameters 
    ---------- 
    file : str or int or file-like object 
        The file to read from.  See `SoundFile` for details. 
    frames : int, optional 
        The number of frames to read. If *frames* is negative, the whole 
        rest of the file is read.  Not allowed if *stop* is given. 
    start : int, optional 
        Where to start reading.  A negative value counts from the end. 
    stop : int, optional 
        The index after the last frame to be read.  A negative value 
        counts from the end.  Not allowed if *frames* is given. 
    dtype : {'float64', 'float32', 'int32', 'int16'}, optional 
        Data type of the returned array, by default ``'float64'``. 
        Floating point audio data is typically in the range from 
        ``-1.0`` to ``1.0``.  Integer data is in the range from 
        ``-2**15`` to ``2**15-1`` for ``'int16'`` and from ``-2**31`` to 
        ``2**31-1`` for ``'int32'``. 
 
        .. note:: Reading int values from a float file will *not* 
            scale the data to [-1.0, 1.0). If the file contains 
            ``np.array([42.6], dtype='float32')``, you will read 
            ``np.array([43], dtype='int32')`` for ``dtype='int32'``. 
 
    Returns 
    ------- 
    audiodata : `numpy.ndarray` or type(out) 
        A two-dimensional (frames x channels) NumPy array is returned. 
        If the sound file has only one channel, a one-dimensional array 
        is returned.  Use ``always_2d=True`` to return a two-dimensional 
        array anyway. 
 
        If *out* was specified, it is returned.  If *out* has more 
        frames than available in the file (or if *frames* is smaller 
        than the length of *out*) and no *fill_value* is given, then 
        only a part of *out* is overwritten and a view containing all 
        valid frames is returned. 
    samplerate : int 
        The sample rate of the audio file. 
 
    Other Parameters 
    ---------------- 
    always_2d : bool, optional 
        By default, reading a mono sound file will return a 
        one-dimensional array.  With ``always_2d=True``, audio data is 
        always returned as a two-dimensional array, even if the audio 
        file has only one channel. 
    fill_value : float, optional 
        If more frames are requested than available in the file, the 
        rest of the output is be filled with *fill_value*.  If 
        *fill_value* is not specified, a smaller array is returned. 
    out : `numpy.ndarray` or subclass, optional 
        If *out* is specified, the data is written into the given array 
        instead of creating a new array.  In this case, the arguments 
        *dtype* and *always_2d* are silently ignored!  If *frames* is 
        not given, it is obtained from the length of *out*. 
    samplerate, channels, format, subtype, endian, closefd 
        See `SoundFile`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; data, samplerate = sf.read('stereo_file.wav') 
    &gt;&gt;&gt; data 
    array([[ 0.71329652,  0.06294799], 
           [-0.26450912, -0.38874483], 
           ... 
           [ 0.67398441, -0.11516333]]) 
    &gt;&gt;&gt; samplerate 
    44100 
 
    &quot;&quot;&quot;</span>
    <span class="s4">with </span><span class="s1">SoundFile</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">,</span>
                   <span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">) </span><span class="s4">as </span><span class="s1">f</span><span class="s2">:</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">_prepare_read</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">frames</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">data</span><span class="s2">, </span><span class="s1">f</span><span class="s2">.</span><span class="s1">samplerate</span>


<span class="s4">def </span><span class="s1">write</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
          <span class="s1">closefd</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Write data to a sound file. 
 
    .. note:: If *file* exists, it will be truncated and overwritten! 
 
    Parameters 
    ---------- 
    file : str or int or file-like object 
        The file to write to.  See `SoundFile` for details. 
    data : array_like 
        The data to write.  Usually two-dimensional (frames x channels), 
        but one-dimensional *data* can be used for mono files. 
        Only the data types ``'float64'``, ``'float32'``, ``'int32'`` 
        and ``'int16'`` are supported. 
 
        .. note:: The data type of *data* does **not** select the data 
                  type of the written file. Audio data will be 
                  converted to the given *subtype*. Writing int values 
                  to a float file will *not* scale the values to 
                  [-1.0, 1.0). If you write the value ``np.array([42], 
                  dtype='int32')``, to a ``subtype='FLOAT'`` file, the 
                  file will then contain ``np.array([42.], 
                  dtype='float32')``. 
 
    samplerate : int 
        The sample rate of the audio data. 
    subtype : str, optional 
        See `default_subtype()` for the default value and 
        `available_subtypes()` for all possible values. 
 
    Other Parameters 
    ---------------- 
    format, endian, closefd 
        See `SoundFile`. 
 
    Examples 
    -------- 
    Write 10 frames of random data to a new file: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; sf.write('stereo_file.wav', np.random.randn(10, 2), 44100, 'PCM_24') 
 
    &quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">channels </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">channels </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
    <span class="s4">with </span><span class="s1">SoundFile</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">,</span>
                   <span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">) </span><span class="s4">as </span><span class="s1">f</span><span class="s2">:</span>
        <span class="s1">f</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">blocks</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">blocksize</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">overlap</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">start</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
           <span class="s1">dtype</span><span class="s2">=</span><span class="s3">'float64'</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
           <span class="s1">samplerate</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
           <span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return a generator for block-wise reading. 
 
    By default, iteration starts at the beginning and stops at the end 
    of the file.  Use *start* to start at a later position and *frames* 
    or *stop* to stop earlier. 
 
    If you stop iterating over the generator before it's exhausted, 
    the sound file is not closed. This is normally not a problem 
    because the file is opened in read-only mode. To close the file 
    properly, the generator's ``close()`` method can be called. 
 
    Parameters 
    ---------- 
    file : str or int or file-like object 
        The file to read from.  See `SoundFile` for details. 
    blocksize : int 
        The number of frames to read per block. 
        Either this or *out* must be given. 
    overlap : int, optional 
        The number of frames to rewind between each block. 
 
    Yields 
    ------ 
    `numpy.ndarray` or type(out) 
        Blocks of audio data. 
        If *out* was given, and the requested frames are not an integer 
        multiple of the length of *out*, and no *fill_value* was given, 
        the last block will be a smaller view into *out*. 
 
    Other Parameters 
    ---------------- 
    frames, start, stop 
        See `read()`. 
    dtype : {'float64', 'float32', 'int32', 'int16'}, optional 
        See `read()`. 
    always_2d, fill_value, out 
        See `read()`. 
    samplerate, channels, format, subtype, endian, closefd 
        See `SoundFile`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; for block in sf.blocks('stereo_file.wav', blocksize=1024): 
    &gt;&gt;&gt;     pass  # do something with 'block' 
 
    &quot;&quot;&quot;</span>
    <span class="s4">with </span><span class="s1">SoundFile</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">,</span>
                   <span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">) </span><span class="s4">as </span><span class="s1">f</span><span class="s2">:</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">_prepare_read</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">block </span><span class="s4">in </span><span class="s1">f</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">(</span><span class="s1">blocksize</span><span class="s2">, </span><span class="s1">overlap</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">,</span>
                              <span class="s1">dtype</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">out</span><span class="s2">):</span>
            <span class="s4">yield </span><span class="s1">block</span>


<span class="s4">class </span><span class="s1">_SoundFileInfo</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Information about a SoundFile&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">verbose </span><span class="s2">= </span><span class="s1">verbose</span>
        <span class="s4">with </span><span class="s1">SoundFile</span><span class="s2">(</span><span class="s1">file</span><span class="s2">) </span><span class="s4">as </span><span class="s1">f</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">name</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">samplerate </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">samplerate</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">channels</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">frames</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">duration </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">frames</span><span class="s2">)/</span><span class="s1">f</span><span class="s2">.</span><span class="s1">samplerate</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">format</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">subtype </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">subtype</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">endian </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">endian</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">format_info </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">format_info</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">subtype_info </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">subtype_info</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sections </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">sections</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">extra_info </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">extra_info</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">_duration_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">hours</span><span class="s2">, </span><span class="s1">rest </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">duration</span><span class="s2">, </span><span class="s6">3600</span><span class="s2">)</span>
        <span class="s1">minutes</span><span class="s2">, </span><span class="s1">seconds </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">rest</span><span class="s2">, </span><span class="s6">60</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">hours </span><span class="s2">&gt;= </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">duration </span><span class="s2">= </span><span class="s3">&quot;{0:.0g}:{1:02.0g}:{2:05.3f} h&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">hours</span><span class="s2">, </span><span class="s1">minutes</span><span class="s2">, </span><span class="s1">seconds</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">minutes </span><span class="s2">&gt;= </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">duration </span><span class="s2">= </span><span class="s3">&quot;{0:02.0g}:{1:05.3f} min&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">minutes</span><span class="s2">, </span><span class="s1">seconds</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">seconds </span><span class="s2">&lt;= </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">duration </span><span class="s2">= </span><span class="s3">&quot;{0:d} samples&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">duration </span><span class="s2">= </span><span class="s3">&quot;{0:.3f} s&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">seconds</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">duration</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">info </span><span class="s2">= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
            <span class="s2">[</span><span class="s3">&quot;{0.name}&quot;</span><span class="s2">,</span>
             <span class="s3">&quot;samplerate: {0.samplerate} Hz&quot;</span><span class="s2">,</span>
             <span class="s3">&quot;channels: {0.channels}&quot;</span><span class="s2">,</span>
             <span class="s3">&quot;duration: {0._duration_str}&quot;</span><span class="s2">,</span>
             <span class="s3">&quot;format: {0.format_info} [{0.format}]&quot;</span><span class="s2">,</span>
             <span class="s3">&quot;subtype: {0.subtype_info} [{0.subtype}]&quot;</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verbose</span><span class="s2">:</span>
            <span class="s1">info </span><span class="s2">+= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
                <span class="s2">[</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">endian: {0.endian}&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;sections: {0.sections}&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;frames: {0.frames}&quot;</span><span class="s2">,</span>
                 <span class="s3">'extra_info: &quot;&quot;&quot;'</span><span class="s2">,</span>
                 <span class="s3">'    {1}&quot;&quot;&quot;'</span><span class="s2">])</span>
        <span class="s1">indented_extra_info </span><span class="s2">= (</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">+</span><span class="s3">&quot; &quot;</span><span class="s2">*</span><span class="s6">4</span><span class="s2">).</span><span class="s1">join</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">extra_info</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">info</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indented_extra_info</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">info</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Returns an object with information about a `SoundFile`. 
 
    Parameters 
    ---------- 
    verbose : bool 
        Whether to print additional information. 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_SoundFileInfo</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">available_formats</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot;Return a dictionary of available major formats. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; sf.available_formats() 
    {'FLAC': 'FLAC (FLAC Lossless Audio Codec)', 
     'OGG': 'OGG (OGG Container format)', 
     'WAV': 'WAV (Microsoft)', 
     'AIFF': 'AIFF (Apple/SGI)', 
     ... 
     'WAVEX': 'WAVEX (Microsoft)', 
     'RAW': 'RAW (header-less)', 
     'MAT5': 'MAT5 (GNU Octave 2.1 / Matlab 5.0)'} 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">_available_formats_helper</span><span class="s2">(</span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_FORMAT_MAJOR_COUNT</span><span class="s2">,</span>
                                          <span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_FORMAT_MAJOR</span><span class="s2">))</span>


<span class="s4">def </span><span class="s1">available_subtypes</span><span class="s2">(</span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return a dictionary of available subtypes. 
 
    Parameters 
    ---------- 
    format : str 
        If given, only compatible subtypes are returned. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; sf.available_subtypes('FLAC') 
    {'PCM_24': 'Signed 24 bit PCM', 
     'PCM_16': 'Signed 16 bit PCM', 
     'PCM_S8': 'Signed 8 bit PCM'} 
 
    &quot;&quot;&quot;</span>
    <span class="s1">subtypes </span><span class="s2">= </span><span class="s1">_available_formats_helper</span><span class="s2">(</span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_FORMAT_SUBTYPE_COUNT</span><span class="s2">,</span>
                                         <span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_FORMAT_SUBTYPE</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">dict</span><span class="s2">((</span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) </span><span class="s4">for </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">name </span><span class="s4">in </span><span class="s1">subtypes</span>
                <span class="s4">if </span><span class="s1">format </span><span class="s4">is None or </span><span class="s1">check_format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">))</span>


<span class="s4">def </span><span class="s1">check_format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Check if the combination of format/subtype/endian is valid. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; sf.check_format('WAV', 'PCM_24') 
    True 
    &gt;&gt;&gt; sf.check_format('FLAC', 'VORBIS') 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">_format_int</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">))</span>
    <span class="s4">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s4">return False</span>


<span class="s4">def </span><span class="s1">default_subtype</span><span class="s2">(</span><span class="s1">format</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return the default subtype for a given format. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import soundfile as sf 
    &gt;&gt;&gt; sf.default_subtype('WAV') 
    'PCM_16' 
    &gt;&gt;&gt; sf.default_subtype('MAT5') 
    'DOUBLE' 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">_default_subtypes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">format</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">())</span>


<span class="s4">class </span><span class="s1">SoundFile</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;A sound file. 
 
    For more documentation see the __init__() docstring (which is also 
    used for the online documentation (https://python-soundfile.readthedocs.io/). 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">subtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Open a sound file. 
 
        If a file is opened with `mode` ``'r'`` (the default) or 
        ``'r+'``, no sample rate, channels or file format need to be 
        given because the information is obtained from the file. An 
        exception is the ``'RAW'`` data format, which always requires 
        these data points. 
 
        File formats consist of three case-insensitive strings: 
 
        * a *major format* which is by default obtained from the 
          extension of the file name (if known) and which can be 
          forced with the format argument (e.g. ``format='WAVEX'``). 
        * a *subtype*, e.g. ``'PCM_24'``. Most major formats have a 
          default subtype which is used if no subtype is specified. 
        * an *endian-ness*, which doesn't have to be specified at all in 
          most cases. 
 
        A `SoundFile` object is a *context manager*, which means 
        if used in a &quot;with&quot; statement, `close()` is automatically 
        called when reaching the end of the code block inside the &quot;with&quot; 
        statement. 
 
        Parameters 
        ---------- 
        file : str or int or file-like object 
            The file to open.  This can be a file name, a file 
            descriptor or a Python file object (or a similar object with 
            the methods ``read()``/``readinto()``, ``write()``, 
            ``seek()`` and ``tell()``). 
        mode : {'r', 'r+', 'w', 'w+', 'x', 'x+'}, optional 
            Open mode.  Has to begin with one of these three characters: 
            ``'r'`` for reading, ``'w'`` for writing (truncates *file*) 
            or ``'x'`` for writing (raises an error if *file* already 
            exists).  Additionally, it may contain ``'+'`` to open 
            *file* for both reading and writing. 
            The character ``'b'`` for *binary mode* is implied because 
            all sound files have to be opened in this mode. 
            If *file* is a file descriptor or a file-like object, 
            ``'w'`` doesn't truncate and ``'x'`` doesn't raise an error. 
        samplerate : int 
            The sample rate of the file.  If `mode` contains ``'r'``, 
            this is obtained from the file (except for ``'RAW'`` files). 
        channels : int 
            The number of channels of the file. 
            If `mode` contains ``'r'``, this is obtained from the file 
            (except for ``'RAW'`` files). 
        subtype : str, sometimes optional 
            The subtype of the sound file.  If `mode` contains ``'r'``, 
            this is obtained from the file (except for ``'RAW'`` 
            files), if not, the default value depends on the selected 
            `format` (see `default_subtype()`). 
            See `available_subtypes()` for all possible subtypes for 
            a given `format`. 
        endian : {'FILE', 'LITTLE', 'BIG', 'CPU'}, sometimes optional 
            The endian-ness of the sound file.  If `mode` contains 
            ``'r'``, this is obtained from the file (except for 
            ``'RAW'`` files), if not, the default value is ``'FILE'``, 
            which is correct in most cases. 
        format : str, sometimes optional 
            The major format of the sound file.  If `mode` contains 
            ``'r'``, this is obtained from the file (except for 
            ``'RAW'`` files), if not, the default value is determined 
            from the file extension.  See `available_formats()` for 
            all possible values. 
        closefd : bool, optional 
            Whether to close the file descriptor on `close()`. Only 
            applicable if the *file* argument is a file descriptor. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from soundfile import SoundFile 
 
        Open an existing file for reading: 
 
        &gt;&gt;&gt; myfile = SoundFile('existing_file.wav') 
        &gt;&gt;&gt; # do something with myfile 
        &gt;&gt;&gt; myfile.close() 
 
        Create a new sound file for reading and writing using a with 
        statement: 
 
        &gt;&gt;&gt; with SoundFile('new_file.wav', 'x+', 44100, 2) as myfile: 
        &gt;&gt;&gt;     # do something with myfile 
        &gt;&gt;&gt;     # ... 
        &gt;&gt;&gt;     assert not myfile.closed 
        &gt;&gt;&gt;     # myfile.close() is called automatically at the end 
        &gt;&gt;&gt; assert myfile.closed 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># resolve PathLike objects (see PEP519 for details):</span>
        <span class="s5"># can be replaced with _os.fspath(file) for Python &gt;= 3.6</span>
        <span class="s1">file </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">__fspath__</span><span class="s2">() </span><span class="s4">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'__fspath__'</span><span class="s2">) </span><span class="s4">else </span><span class="s1">file</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s1">file</span>
        <span class="s4">if </span><span class="s1">mode </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">mode </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'mode'</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
        <span class="s1">mode_int </span><span class="s2">= </span><span class="s1">_check_mode</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mode </span><span class="s2">= </span><span class="s1">mode</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_info </span><span class="s2">= </span><span class="s1">_create_info_struct</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">,</span>
                                         <span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_file </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_open</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">set</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">).</span><span class="s1">issuperset</span><span class="s2">(</span><span class="s3">'r+'</span><span class="s2">) </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s5"># Move write position to 0 (like in Python file objects)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_command</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_SET_CLIPPING</span><span class="s2">, </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">NULL</span><span class="s2">,</span>
                        <span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_TRUE</span><span class="s2">)</span>

    <span class="s1">name </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The file name of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">mode </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mode</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The open mode the sound file was opened with.&quot;&quot;&quot;</span>
    <span class="s1">samplerate </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">samplerate</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The sample rate of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">frames </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The number of frames in the sound file.&quot;&quot;&quot;</span>
    <span class="s1">channels </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">channels</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The number of channels in the sound file.&quot;&quot;&quot;</span>
    <span class="s1">format </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span>
        <span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_format_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">&amp; </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FORMAT_TYPEMASK</span><span class="s2">))</span>
    <span class="s3">&quot;&quot;&quot;The major format of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">subtype </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span>
        <span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_format_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">&amp; </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FORMAT_SUBMASK</span><span class="s2">))</span>
    <span class="s3">&quot;&quot;&quot;The subtype of data in the the sound file.&quot;&quot;&quot;</span>
    <span class="s1">endian </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span>
        <span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_format_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">&amp; </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FORMAT_ENDMASK</span><span class="s2">))</span>
    <span class="s3">&quot;&quot;&quot;The endian-ness of the data in the sound file.&quot;&quot;&quot;</span>
    <span class="s1">format_info </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span>
        <span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_format_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">&amp;</span>
                                  <span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FORMAT_TYPEMASK</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">])</span>
    <span class="s3">&quot;&quot;&quot;A description of the major format of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">subtype_info </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span>
        <span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_format_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">&amp;</span>
                                  <span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FORMAT_SUBMASK</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">])</span>
    <span class="s3">&quot;&quot;&quot;A description of the subtype of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">sections </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">sections</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;The number of sections of the sound file.&quot;&quot;&quot;</span>
    <span class="s1">closed </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file </span><span class="s4">is None</span><span class="s2">)</span>
    <span class="s3">&quot;&quot;&quot;Whether the sound file is closed or not.&quot;&quot;&quot;</span>
    <span class="s1">_errorcode </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s4">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">))</span>
    <span class="s3">&quot;&quot;&quot;A pending sndfile error code.&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">extra_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Retrieve the log string generated when opening the file.&quot;&quot;&quot;</span>
        <span class="s1">info </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;char[]&quot;</span><span class="s2">, </span><span class="s6">2</span><span class="s2">**</span><span class="s6">14</span><span class="s2">)</span>
        <span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_command</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_LOG_INFO</span><span class="s2">,</span>
                        <span class="s1">info</span><span class="s2">, </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">info</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">info</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">)</span>

    <span class="s5"># avoid confusion if something goes wrong before assigning self._file:</span>
    <span class="s1">_file </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s2">(</span><span class="s3">&quot;SoundFile({0.name!r}, mode={0.mode!r}, &quot;</span>
                <span class="s3">&quot;samplerate={0.samplerate}, channels={0.channels}, &quot;</span>
                <span class="s3">&quot;format={0.format!r}, subtype={0.subtype!r}, &quot;</span>
                <span class="s3">&quot;endian={0.endian!r})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__del__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">__enter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__exit__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Write text meta-data in the sound file through properties.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">name </span><span class="s4">in </span><span class="s1">_str_types</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_if_closed</span><span class="s2">()</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_set_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">_str_types</span><span class="s2">[</span><span class="s1">name</span><span class="s2">],</span>
                                     <span class="s1">value</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">())</span>
            <span class="s1">_error_check</span><span class="s2">(</span><span class="s1">err</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">object</span><span class="s2">.</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Read text meta-data in the sound file through properties.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">name </span><span class="s4">in </span><span class="s1">_str_types</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_if_closed</span><span class="s2">()</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_get_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">_str_types</span><span class="s2">[</span><span class="s1">name</span><span class="s2">])</span>
            <span class="s4">return </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">data</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">) </span><span class="s4">if </span><span class="s1">data </span><span class="s4">else </span><span class="s3">&quot;&quot;</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">AttributeError</span><span class="s2">(</span>
                <span class="s3">&quot;'SoundFile' object has no attribute {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Note: This is deprecated and will be removed at some point,</span>
        <span class="s5"># see https://github.com/bastibe/python-soundfile/issues/199</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">__bool__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Note: This is temporary until __len__ is removed, afterwards it</span>
        <span class="s5"># can (and should) be removed without change of behavior</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">__nonzero__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Note: This is only for compatibility with Python 2 and it shall be</span>
        <span class="s5"># removed at the same time as __bool__().</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__bool__</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">seekable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return True if the file supports seeking.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">seekable </span><span class="s2">== </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_TRUE</span>

    <span class="s4">def </span><span class="s1">seek</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">whence</span><span class="s2">=</span><span class="s1">SEEK_SET</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Set the read/write position. 
 
        Parameters 
        ---------- 
        frames : int 
            The frame index or offset to seek. 
        whence : {SEEK_SET, SEEK_CUR, SEEK_END}, optional 
            By default (``whence=SEEK_SET``), *frames* are counted from 
            the beginning of the file. 
            ``whence=SEEK_CUR`` seeks from the current position 
            (positive and negative values are allowed for *frames*). 
            ``whence=SEEK_END`` seeks from the end (use negative value 
            for *frames*). 
 
        Returns 
        ------- 
        int 
            The new absolute read/write position in frames. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from soundfile import SoundFile, SEEK_END 
        &gt;&gt;&gt; myfile = SoundFile('stereo_file.wav') 
 
        Seek to the beginning of the file: 
 
        &gt;&gt;&gt; myfile.seek(0) 
        0 
 
        Seek to the end of the file: 
 
        &gt;&gt;&gt; myfile.seek(0, SEEK_END) 
        44100  # this is the file length 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_if_closed</span><span class="s2">()</span>
        <span class="s1">position </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_seek</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">whence</span><span class="s2">)</span>
        <span class="s1">_error_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_errorcode</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">position</span>

    <span class="s4">def </span><span class="s1">tell</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return the current read/write position.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">SEEK_CUR</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'float64'</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
             <span class="s1">fill_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Read from the file and return data as NumPy array. 
 
        Reads the given number of frames in the given data format 
        starting at the current read/write position.  This advances the 
        read/write position by the same number of frames. 
        By default, all frames from the current read/write position to 
        the end of the file are returned. 
        Use `seek()` to move the current read/write position. 
 
        Parameters 
        ---------- 
        frames : int, optional 
            The number of frames to read. If ``frames &lt; 0``, the whole 
            rest of the file is read. 
        dtype : {'float64', 'float32', 'int32', 'int16'}, optional 
            Data type of the returned array, by default ``'float64'``. 
            Floating point audio data is typically in the range from 
            ``-1.0`` to ``1.0``. Integer data is in the range from 
            ``-2**15`` to ``2**15-1`` for ``'int16'`` and from 
            ``-2**31`` to ``2**31-1`` for ``'int32'``. 
 
            .. note:: Reading int values from a float file will *not* 
                scale the data to [-1.0, 1.0). If the file contains 
                ``np.array([42.6], dtype='float32')``, you will read 
                ``np.array([43], dtype='int32')`` for 
                ``dtype='int32'``. 
 
        Returns 
        ------- 
        audiodata : `numpy.ndarray` or type(out) 
            A two-dimensional NumPy (frames x channels) array is 
            returned. If the sound file has only one channel, a 
            one-dimensional array is returned. Use ``always_2d=True`` 
            to return a two-dimensional array anyway. 
 
            If *out* was specified, it is returned. If *out* has more 
            frames than available in the file (or if *frames* is 
            smaller than the length of *out*) and no *fill_value* is 
            given, then only a part of *out* is overwritten and a view 
            containing all valid frames is returned. 
 
        Other Parameters 
        ---------------- 
        always_2d : bool, optional 
            By default, reading a mono sound file will return a 
            one-dimensional array. With ``always_2d=True``, audio data 
            is always returned as a two-dimensional array, even if the 
            audio file has only one channel. 
        fill_value : float, optional 
            If more frames are requested than available in the file, 
            the rest of the output is be filled with *fill_value*. If 
            *fill_value* is not specified, a smaller array is 
            returned. 
        out : `numpy.ndarray` or subclass, optional 
            If *out* is specified, the data is written into the given 
            array instead of creating a new array. In this case, the 
            arguments *dtype* and *always_2d* are silently ignored! If 
            *frames* is not given, it is obtained from the length of 
            *out*. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from soundfile import SoundFile 
        &gt;&gt;&gt; myfile = SoundFile('stereo_file.wav') 
 
        Reading 3 frames from a stereo file: 
 
        &gt;&gt;&gt; myfile.read(3) 
        array([[ 0.71329652,  0.06294799], 
               [-0.26450912, -0.38874483], 
               [ 0.67398441, -0.11516333]]) 
        &gt;&gt;&gt; myfile.close() 
 
        See Also 
        -------- 
        buffer_read, .write 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">out </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_frames</span><span class="s2">(</span><span class="s1">frames</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_empty_array</span><span class="s2">(</span><span class="s1">frames</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">frames </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">frames </span><span class="s2">&gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">out</span><span class="s2">):</span>
                <span class="s1">frames </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_array_io</span><span class="s2">(</span><span class="s3">'read'</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">out</span><span class="s2">) &gt; </span><span class="s1">frames</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">fill_value </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">out </span><span class="s2">= </span><span class="s1">out</span><span class="s2">[:</span><span class="s1">frames</span><span class="s2">]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">out</span><span class="s2">[</span><span class="s1">frames</span><span class="s2">:] = </span><span class="s1">fill_value</span>
        <span class="s4">return </span><span class="s1">out</span>

    <span class="s4">def </span><span class="s1">buffer_read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Read from the file and return data as buffer object. 
 
        Reads the given number of *frames* in the given data format 
        starting at the current read/write position.  This advances the 
        read/write position by the same number of frames. 
        By default, all frames from the current read/write position to 
        the end of the file are returned. 
        Use `seek()` to move the current read/write position. 
 
        Parameters 
        ---------- 
        frames : int, optional 
            The number of frames to read. If ``frames &lt; 0``, the whole 
            rest of the file is read. 
        dtype : {'float64', 'float32', 'int32', 'int16'} 
            Audio data will be converted to the given data type. 
 
        Returns 
        ------- 
        buffer 
            A buffer containing the read data. 
 
        See Also 
        -------- 
        buffer_read_into, .read, buffer_write 
 
        &quot;&quot;&quot;</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_frames</span><span class="s2">(</span><span class="s1">frames</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">)</span>
        <span class="s1">ctype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">cdata </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s1">ctype </span><span class="s2">+ </span><span class="s3">'[]'</span><span class="s2">, </span><span class="s1">frames </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">channels</span><span class="s2">)</span>
        <span class="s1">read_frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cdata_io</span><span class="s2">(</span><span class="s3">'read'</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">read_frames </span><span class="s2">== </span><span class="s1">frames</span>
        <span class="s4">return </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">buffer</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">buffer_read_into</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">buffer</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Read from the file into a given buffer object. 
 
        Fills the given *buffer* with frames in the given data format 
        starting at the current read/write position (which can be 
        changed with `seek()`) until the buffer is full or the end 
        of the file is reached.  This advances the read/write position 
        by the number of frames that were read. 
 
        Parameters 
        ---------- 
        buffer : writable buffer 
            Audio frames from the file are written to this buffer. 
        dtype : {'float64', 'float32', 'int32', 'int16'} 
            The data type of *buffer*. 
 
        Returns 
        ------- 
        int 
            The number of frames that were read from the file. 
            This can be less than the size of *buffer*. 
            The rest of the buffer is not filled with meaningful data. 
 
        See Also 
        -------- 
        buffer_read, .read 
 
        &quot;&quot;&quot;</span>
        <span class="s1">ctype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">cdata</span><span class="s2">, </span><span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_buffer</span><span class="s2">(</span><span class="s1">buffer</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">)</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cdata_io</span><span class="s2">(</span><span class="s3">'read'</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">write</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Write audio data from a NumPy array to the file. 
 
        Writes a number of frames at the read/write position to the 
        file. This also advances the read/write position by the same 
        number of frames and enlarges the file if necessary. 
 
        Note that writing int values to a float file will *not* scale 
        the values to [-1.0, 1.0). If you write the value 
        ``np.array([42], dtype='int32')``, to a ``subtype='FLOAT'`` 
        file, the file will then contain ``np.array([42.], 
        dtype='float32')``. 
 
        Parameters 
        ---------- 
        data : array_like 
            The data to write. Usually two-dimensional (frames x 
            channels), but one-dimensional *data* can be used for mono 
            files. Only the data types ``'float64'``, ``'float32'``, 
            ``'int32'`` and ``'int16'`` are supported. 
 
            .. note:: The data type of *data* does **not** select the 
                  data type of the written file. Audio data will be 
                  converted to the given *subtype*. Writing int values 
                  to a float file will *not* scale the values to 
                  [-1.0, 1.0). If you write the value ``np.array([42], 
                  dtype='int32')``, to a ``subtype='FLOAT'`` file, the 
                  file will then contain ``np.array([42.], 
                  dtype='float32')``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from soundfile import SoundFile 
        &gt;&gt;&gt; myfile = SoundFile('stereo_file.wav') 
 
        Write 10 frames of random data to a new file: 
 
        &gt;&gt;&gt; with SoundFile('stereo_file.wav', 'w', 44100, 2, 'PCM_24') as f: 
        &gt;&gt;&gt;     f.write(np.random.randn(10, 2)) 
 
        See Also 
        -------- 
        buffer_write, .read 
 
        &quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
        <span class="s5"># no copy is made if data has already the correct memory layout:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ascontiguousarray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">written </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_array_io</span><span class="s2">(</span><span class="s3">'write'</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">))</span>
        <span class="s4">assert </span><span class="s1">written </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_frames</span><span class="s2">(</span><span class="s1">written</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">buffer_write</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Write audio data from a buffer/bytes object to the file. 
 
        Writes the contents of *data* to the file at the current 
        read/write position. 
        This also advances the read/write position by the number of 
        frames that were written and enlarges the file if necessary. 
 
        Parameters 
        ---------- 
        data : buffer or bytes 
            A buffer or bytes object containing the audio data to be 
            written. 
        dtype : {'float64', 'float32', 'int32', 'int16'} 
            The data type of the audio data stored in *data*. 
 
        See Also 
        -------- 
        .write, buffer_read 
 
        &quot;&quot;&quot;</span>
        <span class="s1">ctype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">cdata</span><span class="s2">, </span><span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_buffer</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">)</span>
        <span class="s1">written </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cdata_io</span><span class="s2">(</span><span class="s3">'write'</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">written </span><span class="s2">== </span><span class="s1">frames</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_update_frames</span><span class="s2">(</span><span class="s1">written</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">blocks</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocksize</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">overlap</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'float64'</span><span class="s2">,</span>
               <span class="s1">always_2d</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return a generator for block-wise reading. 
 
        By default, the generator yields blocks of the given 
        *blocksize* (using a given *overlap*) until the end of the file 
        is reached; *frames* can be used to stop earlier. 
 
        Parameters 
        ---------- 
        blocksize : int 
            The number of frames to read per block. Either this or *out* 
            must be given. 
        overlap : int, optional 
            The number of frames to rewind between each block. 
        frames : int, optional 
            The number of frames to read. 
            If ``frames &lt; 0``, the file is read until the end. 
        dtype : {'float64', 'float32', 'int32', 'int16'}, optional 
            See `read()`. 
 
        Yields 
        ------ 
        `numpy.ndarray` or type(out) 
            Blocks of audio data. 
            If *out* was given, and the requested frames are not an 
            integer multiple of the length of *out*, and no 
            *fill_value* was given, the last block will be a smaller 
            view into *out*. 
 
 
        Other Parameters 
        ---------------- 
        always_2d, fill_value, out 
            See `read()`. 
        fill_value : float, optional 
            See `read()`. 
        out : `numpy.ndarray` or subclass, optional 
            If *out* is specified, the data is written into the given 
            array instead of creating a new array. In this case, the 
            arguments *dtype* and *always_2d* are silently ignored! 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from soundfile import SoundFile 
        &gt;&gt;&gt; with SoundFile('stereo_file.wav') as f: 
        &gt;&gt;&gt;     for block in f.blocks(blocksize=1024): 
        &gt;&gt;&gt;         pass  # do something with 'block' 
 
        &quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

        <span class="s4">if </span><span class="s3">'r' </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mode </span><span class="s4">and </span><span class="s3">'+' </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mode</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">SoundFileRuntimeError</span><span class="s2">(</span><span class="s3">&quot;blocks() is not allowed in write-only mode&quot;</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">out </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">blocksize </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;One of {blocksize, out} must be specified&quot;</span><span class="s2">)</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_create_empty_array</span><span class="s2">(</span><span class="s1">blocksize</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">copy_out </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">blocksize </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s3">&quot;Only one of {blocksize, out} may be specified&quot;</span><span class="s2">)</span>
            <span class="s1">blocksize </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
            <span class="s1">copy_out </span><span class="s2">= </span><span class="s4">False</span>

        <span class="s1">overlap_memory </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_frames</span><span class="s2">(</span><span class="s1">frames</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">)</span>
        <span class="s4">while </span><span class="s1">frames </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">overlap_memory </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">output_offset </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">output_offset </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">overlap_memory</span><span class="s2">)</span>
                <span class="s1">out</span><span class="s2">[:</span><span class="s1">output_offset</span><span class="s2">] = </span><span class="s1">overlap_memory</span>

            <span class="s1">toread </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">blocksize </span><span class="s2">- </span><span class="s1">output_offset</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">toread</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">out</span><span class="s2">[</span><span class="s1">output_offset</span><span class="s2">:])</span>

            <span class="s4">if </span><span class="s1">overlap</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">overlap_memory </span><span class="s4">is None</span><span class="s2">:</span>
                    <span class="s1">overlap_memory </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">out</span><span class="s2">[-</span><span class="s1">overlap</span><span class="s2">:])</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">overlap_memory</span><span class="s2">[:] = </span><span class="s1">out</span><span class="s2">[-</span><span class="s1">overlap</span><span class="s2">:]</span>

            <span class="s4">if </span><span class="s1">blocksize </span><span class="s2">&gt; </span><span class="s1">frames </span><span class="s2">+ </span><span class="s1">overlap </span><span class="s4">and </span><span class="s1">fill_value </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">block </span><span class="s2">= </span><span class="s1">out</span><span class="s2">[:</span><span class="s1">frames </span><span class="s2">+ </span><span class="s1">overlap</span><span class="s2">]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">block </span><span class="s2">= </span><span class="s1">out</span>
            <span class="s4">yield </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">block</span><span class="s2">) </span><span class="s4">if </span><span class="s1">copy_out </span><span class="s4">else </span><span class="s1">block</span>
            <span class="s1">frames </span><span class="s2">-= </span><span class="s1">toread</span>

    <span class="s4">def </span><span class="s1">truncate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Truncate the file to a given number of frames. 
 
        After this command, the read/write position will be at the new 
        end of the file. 
 
        Parameters 
        ---------- 
        frames : int, optional 
            Only the data before *frames* is kept, the rest is deleted. 
            If not specified, the current read/write position is used. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">frames </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
        <span class="s1">err </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_command</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_FILE_TRUNCATE</span><span class="s2">,</span>
                              <span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;sf_count_t*&quot;</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">),</span>
                              <span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s3">&quot;sf_count_t&quot;</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s5"># get the actual error code</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">LibsndfileError</span><span class="s2">(</span><span class="s1">err</span><span class="s2">, </span><span class="s3">&quot;Error truncating the file&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">= </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">flush</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Write unwritten data to the file system. 
 
        Data written with `write()` is not immediately written to 
        the file system but buffered in memory to be written at a later 
        time.  Calling `flush()` makes sure that all changes are 
        actually written to the file system. 
 
        This has no effect on files opened in read-only mode. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_if_closed</span><span class="s2">()</span>
        <span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_write_sync</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">close</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Close the file.  Can be called multiple times.&quot;&quot;&quot;</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">:</span>
            <span class="s5"># be sure to flush data to disk before closing the file</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">flush</span><span class="s2">()</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_close</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_file </span><span class="s2">= </span><span class="s4">None</span>
            <span class="s1">_error_check</span><span class="s2">(</span><span class="s1">err</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_open</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Call the appropriate sf_open*() function from libsndfile.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">)):</span>
            <span class="s4">if </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">isfile</span><span class="s2">(</span><span class="s1">file</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s3">'x' </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mode</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s3">&quot;File exists: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">))</span>
                <span class="s4">elif </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">mode</span><span class="s2">).</span><span class="s1">issuperset</span><span class="s2">(</span><span class="s3">'w+'</span><span class="s2">):</span>
                    <span class="s5"># truncate the file, because SFM_RDWR doesn't:</span>
                    <span class="s1">_os</span><span class="s2">.</span><span class="s1">close</span><span class="s2">(</span><span class="s1">_os</span><span class="s2">.</span><span class="s1">open</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">O_WRONLY </span><span class="s2">| </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">O_TRUNC</span><span class="s2">))</span>
            <span class="s1">openfunction </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_open</span>
            <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">_unicode</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s3">'win32'</span><span class="s2">:</span>
                    <span class="s1">openfunction </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_wchar_open</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">file </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s1">_sys</span><span class="s2">.</span><span class="s1">getfilesystemencoding</span><span class="s2">())</span>
            <span class="s1">file_ptr </span><span class="s2">= </span><span class="s1">openfunction</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s1">file_ptr </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_open_fd</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">_has_virtual_io_attrs</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">):</span>
            <span class="s1">file_ptr </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_open_virtual</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_init_virtual_io</span><span class="s2">(</span><span class="s1">file</span><span class="s2">),</span>
                                            <span class="s1">mode_int</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">, </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">NULL</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Invalid file: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">file_ptr </span><span class="s2">== </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">NULL</span><span class="s2">:</span>
            <span class="s5"># get the actual error code</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_error</span><span class="s2">(</span><span class="s1">file_ptr</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">LibsndfileError</span><span class="s2">(</span><span class="s1">err</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">=</span><span class="s3">&quot;Error opening {0!r}: &quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">mode_int </span><span class="s2">== </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_WRITE</span><span class="s2">:</span>
            <span class="s5"># Due to a bug in libsndfile version &lt;= 1.0.25, frames != 0</span>
            <span class="s5"># when opening a named pipe in SFM_WRITE mode.</span>
            <span class="s5"># See http://github.com/erikd/libsndfile/issues/77.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s5"># This is not necessary for &quot;normal&quot; files (because</span>
            <span class="s5"># frames == 0 in this case), but it doesn't hurt, either.</span>
        <span class="s4">return </span><span class="s1">file_ptr</span>

    <span class="s4">def </span><span class="s1">_init_virtual_io</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize callback functions for sf_open_virtual().&quot;&quot;&quot;</span>
        <span class="s2">@</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s3">&quot;sf_vio_get_filelen&quot;</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">vio_get_filelen</span><span class="s2">(</span><span class="s1">user_data</span><span class="s2">):</span>
            <span class="s1">curr </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
            <span class="s1">file</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">SEEK_END</span><span class="s2">)</span>
            <span class="s1">size </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
            <span class="s1">file</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s1">curr</span><span class="s2">, </span><span class="s1">SEEK_SET</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">size</span>

        <span class="s2">@</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s3">&quot;sf_vio_seek&quot;</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">vio_seek</span><span class="s2">(</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">whence</span><span class="s2">, </span><span class="s1">user_data</span><span class="s2">):</span>
            <span class="s1">file</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">whence</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">file</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>

        <span class="s2">@</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s3">&quot;sf_vio_read&quot;</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">vio_read</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">user_data</span><span class="s2">):</span>
            <span class="s5"># first try readinto(), if not available fall back to read()</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">buf </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">buffer</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">count</span><span class="s2">)</span>
                <span class="s1">data_read </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">readinto</span><span class="s2">(</span><span class="s1">buf</span><span class="s2">)</span>
            <span class="s4">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">count</span><span class="s2">)</span>
                <span class="s1">data_read </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
                <span class="s1">buf </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">buffer</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">data_read</span><span class="s2">)</span>
                <span class="s1">buf</span><span class="s2">[</span><span class="s6">0</span><span class="s2">:</span><span class="s1">data_read</span><span class="s2">] = </span><span class="s1">data</span>
            <span class="s4">return </span><span class="s1">data_read</span>

        <span class="s2">@</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s3">&quot;sf_vio_write&quot;</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">vio_write</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">user_data</span><span class="s2">):</span>
            <span class="s1">buf </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">buffer</span><span class="s2">(</span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">count</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">buf</span><span class="s2">[:]</span>
            <span class="s1">written </span><span class="s2">= </span><span class="s1">file</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s5"># write() returns None for file objects in Python &lt;= 2.7:</span>
            <span class="s4">if </span><span class="s1">written </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">written </span><span class="s2">= </span><span class="s1">count</span>
            <span class="s4">return </span><span class="s1">written</span>

        <span class="s2">@</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s3">&quot;sf_vio_tell&quot;</span><span class="s2">)</span>
        <span class="s4">def </span><span class="s1">vio_tell</span><span class="s2">(</span><span class="s1">user_data</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">file</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>

        <span class="s5"># Note: the callback functions must be kept alive!</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_virtual_io </span><span class="s2">= {</span><span class="s3">'get_filelen'</span><span class="s2">: </span><span class="s1">vio_get_filelen</span><span class="s2">,</span>
                            <span class="s3">'seek'</span><span class="s2">: </span><span class="s1">vio_seek</span><span class="s2">,</span>
                            <span class="s3">'read'</span><span class="s2">: </span><span class="s1">vio_read</span><span class="s2">,</span>
                            <span class="s3">'write'</span><span class="s2">: </span><span class="s1">vio_write</span><span class="s2">,</span>
                            <span class="s3">'tell'</span><span class="s2">: </span><span class="s1">vio_tell</span><span class="s2">}</span>

        <span class="s4">return </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;SF_VIRTUAL_IO*&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_virtual_io</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_getAttributeNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return all attributes used in __setattr__ and __getattr__. 
 
        This is useful for auto-completion (e.g. IPython). 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">_str_types</span>

    <span class="s4">def </span><span class="s1">_check_if_closed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Check if the file is closed and raise an error if it is. 
 
        This should be used in every method that uses self._file. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">SoundFileRuntimeError</span><span class="s2">(</span><span class="s3">&quot;I/O operation on closed file&quot;</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_check_frames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Reduce frames to no more than are available in the file.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s1">remaining_frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">frames </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s2">(</span><span class="s1">frames </span><span class="s2">&gt; </span><span class="s1">remaining_frames </span><span class="s4">and</span>
                              <span class="s1">fill_value </span><span class="s4">is None</span><span class="s2">):</span>
                <span class="s1">frames </span><span class="s2">= </span><span class="s1">remaining_frames</span>
        <span class="s4">elif </span><span class="s1">frames </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;frames must be specified for non-seekable files&quot;</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">_check_buffer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Convert buffer to cdata and check for valid size.&quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">ctype </span><span class="s4">in </span><span class="s1">_ffi_types</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">):</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">from_buffer</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">frames</span><span class="s2">, </span><span class="s1">remainder </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">),</span>
                                   <span class="s1">self</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">* </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">remainder</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Data size must be a multiple of frame size&quot;</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">data</span><span class="s2">, </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">_create_empty_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">always_2d</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Create an empty array with appropriate shape.&quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
        <span class="s4">if </span><span class="s1">always_2d </span><span class="s4">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">channels</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">frames</span><span class="s2">,</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s3">'C'</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_check_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Check if dtype string is valid and return ctype string.&quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">_ffi_types</span><span class="s2">[</span><span class="s1">dtype</span><span class="s2">]</span>
        <span class="s4">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;dtype must be one of {0!r} and not {1!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                <span class="s1">sorted</span><span class="s2">(</span><span class="s1">_ffi_types</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()), </span><span class="s1">dtype</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">_array_io</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">action</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Check array and call low-level IO function.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">ndim </span><span class="s4">not in </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">) </span><span class="s4">or</span>
                <span class="s1">array</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1 </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">!= </span><span class="s6">1 </span><span class="s4">or</span>
                <span class="s1">array</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2 </span><span class="s4">and </span><span class="s1">array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">channels</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Invalid shape: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s4">if not </span><span class="s1">array</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Data must be C-contiguous&quot;</span><span class="s2">)</span>
        <span class="s1">ctype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_dtype</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">array</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">== </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">)</span>
        <span class="s1">cdata </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ctype </span><span class="s2">+ </span><span class="s3">'*'</span><span class="s2">, </span><span class="s1">array</span><span class="s2">.</span><span class="s1">__array_interface__</span><span class="s2">[</span><span class="s3">'data'</span><span class="s2">][</span><span class="s6">0</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cdata_io</span><span class="s2">(</span><span class="s1">action</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_cdata_io</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">action</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Call one of libsndfile's read/write functions.&quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">ctype </span><span class="s4">in </span><span class="s1">_ffi_types</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_if_closed</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s1">curr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_snd</span><span class="s2">, </span><span class="s3">'sf_' </span><span class="s2">+ </span><span class="s1">action </span><span class="s2">+ </span><span class="s3">'f_' </span><span class="s2">+ </span><span class="s1">ctype</span><span class="s2">)</span>
        <span class="s1">frames </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s1">_error_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_errorcode</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s1">curr </span><span class="s2">+ </span><span class="s1">frames</span><span class="s2">, </span><span class="s1">SEEK_SET</span><span class="s2">)  </span><span class="s5"># Update read &amp; write position</span>
        <span class="s4">return </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">_update_frames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">written</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Update self.frames after writing.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s1">curr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tell</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">SEEK_END</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s1">curr</span><span class="s2">, </span><span class="s1">SEEK_SET</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_info</span><span class="s2">.</span><span class="s1">frames </span><span class="s2">+= </span><span class="s1">written</span>

    <span class="s4">def </span><span class="s1">_prepare_read</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">frames</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Seek to start frame and calculate length.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">start </span><span class="s2">!= </span><span class="s6">0 </span><span class="s4">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;start is only allowed for seekable files&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">frames </span><span class="s2">&gt;= </span><span class="s6">0 </span><span class="s4">and </span><span class="s1">stop </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Only one of {frames, stop} may be used&quot;</span><span class="s2">)</span>

        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">).</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">frames</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">stop </span><span class="s2">&lt; </span><span class="s1">start</span><span class="s2">:</span>
            <span class="s1">stop </span><span class="s2">= </span><span class="s1">start</span>
        <span class="s4">if </span><span class="s1">frames </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">frames </span><span class="s2">= </span><span class="s1">stop </span><span class="s2">- </span><span class="s1">start</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">seekable</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">seek</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">SEEK_SET</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">frames</span>

    <span class="s4">def </span><span class="s1">copy_metadata</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Get all metadata present in this SoundFile 
 
        Returns 
        ------- 
 
        metadata: dict[str, str] 
            A dict with all metadata. Possible keys are: 'title', 'copyright', 
            'software', 'artist', 'comment', 'date', 'album', 'license', 
            'tracknumber' and 'genre'. 
        &quot;&quot;&quot;</span>
        <span class="s1">strs </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">strtype</span><span class="s2">, </span><span class="s1">strid </span><span class="s4">in </span><span class="s1">_str_types</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_get_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_file</span><span class="s2">, </span><span class="s1">strid</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">data</span><span class="s2">:</span>
                <span class="s1">strs</span><span class="s2">[</span><span class="s1">strtype</span><span class="s2">] = </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">data</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">strs</span>



<span class="s4">def </span><span class="s1">_error_check</span><span class="s2">(</span><span class="s1">err</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">=</span><span class="s3">&quot;&quot;</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Raise LibsndfileError if there is an error.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">err </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">LibsndfileError</span><span class="s2">(</span><span class="s1">err</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">=</span><span class="s1">prefix</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_format_int</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return numeric ID for given format|subtype|endian combo.&quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">_check_format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">subtype </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">subtype </span><span class="s2">= </span><span class="s1">default_subtype</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">subtype </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s3">&quot;No default subtype for major format {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">))</span>
    <span class="s4">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">subtype</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Invalid subtype: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">subtype</span><span class="s2">))</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">|= </span><span class="s1">_subtypes</span><span class="s2">[</span><span class="s1">subtype</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">()]</span>
    <span class="s4">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Unknown subtype: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">subtype</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">endian </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">endian </span><span class="s2">= </span><span class="s3">'FILE'</span>
    <span class="s4">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">endian</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Invalid endian-ness: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">endian</span><span class="s2">))</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">|= </span><span class="s1">_endians</span><span class="s2">[</span><span class="s1">endian</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">()]</span>
    <span class="s4">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Unknown endian-ness: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">endian</span><span class="s2">))</span>

    <span class="s1">info </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;SF_INFO*&quot;</span><span class="s2">)</span>
    <span class="s1">info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">result</span>
    <span class="s1">info</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s4">if </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_format_check</span><span class="s2">(</span><span class="s1">info</span><span class="s2">) == </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SF_FALSE</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">&quot;Invalid combination of format, subtype and endian&quot;</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">_check_mode</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Check if mode is valid and return its integer representation.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Invalid mode: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">))</span>
    <span class="s1">mode_set </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">mode_set</span><span class="s2">.</span><span class="s1">difference</span><span class="s2">(</span><span class="s3">'xrwb+'</span><span class="s2">) </span><span class="s4">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">) &gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mode_set</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Invalid mode: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">mode</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mode_set</span><span class="s2">.</span><span class="s1">intersection</span><span class="s2">(</span><span class="s3">'xrw'</span><span class="s2">)) != </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;mode must contain exactly one of 'xrw'&quot;</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s3">'+' </span><span class="s4">in </span><span class="s1">mode_set</span><span class="s2">:</span>
        <span class="s1">mode_int </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_RDWR</span>
    <span class="s4">elif </span><span class="s3">'r' </span><span class="s4">in </span><span class="s1">mode_set</span><span class="s2">:</span>
        <span class="s1">mode_int </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_READ</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">mode_int </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_WRITE</span>
    <span class="s4">return </span><span class="s1">mode_int</span>


<span class="s4">def </span><span class="s1">_create_info_struct</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">,</span>
                        <span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Check arguments and create SF_INFO struct.&quot;&quot;&quot;</span>
    <span class="s1">original_format </span><span class="s2">= </span><span class="s1">format</span>
    <span class="s4">if </span><span class="s1">format </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">format </span><span class="s2">= </span><span class="s1">_get_format_from_filename</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">str</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">_check_format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>

    <span class="s1">info </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;SF_INFO*&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s3">'r' </span><span class="s4">not in </span><span class="s1">mode </span><span class="s4">or </span><span class="s1">format</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">() == </span><span class="s3">'RAW'</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">samplerate </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;samplerate must be specified&quot;</span><span class="s2">)</span>
        <span class="s1">info</span><span class="s2">.</span><span class="s1">samplerate </span><span class="s2">= </span><span class="s1">samplerate</span>
        <span class="s4">if </span><span class="s1">channels </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;channels must be specified&quot;</span><span class="s2">)</span>
        <span class="s1">info</span><span class="s2">.</span><span class="s1">channels </span><span class="s2">= </span><span class="s1">channels</span>
        <span class="s1">info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">_format_int</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">arg </span><span class="s4">is not None for </span><span class="s1">arg </span><span class="s4">in </span><span class="s2">(</span>
                <span class="s1">samplerate</span><span class="s2">, </span><span class="s1">channels</span><span class="s2">, </span><span class="s1">original_format</span><span class="s2">, </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">endian</span><span class="s2">)):</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Not allowed for existing files (except 'RAW'): &quot;</span>
                            <span class="s3">&quot;samplerate, channels, format, subtype, endian&quot;</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">info</span>


<span class="s4">def </span><span class="s1">_get_format_from_filename</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return a format string obtained from file (or file.name). 
 
    If file already exists (= read mode), an empty string is returned on 
    error.  If not, an exception is raised. 
    The return type will always be str or unicode (even if 
    file/file.name is a bytes object). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">format </span><span class="s2">= </span><span class="s3">''</span>
    <span class="s1">file </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">file</span><span class="s2">)</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s5"># This raises an exception if file is not a (Unicode/byte) string:</span>
        <span class="s1">format </span><span class="s2">= </span><span class="s1">_os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">splitext</span><span class="s2">(</span><span class="s1">file</span><span class="s2">)[-</span><span class="s6">1</span><span class="s2">][</span><span class="s6">1</span><span class="s2">:]</span>
        <span class="s5"># Convert bytes to unicode (raises AttributeError on Python 3 str):</span>
        <span class="s1">format </span><span class="s2">= </span><span class="s1">format</span><span class="s2">.</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">)</span>
    <span class="s4">except </span><span class="s1">Exception</span><span class="s2">:</span>
        <span class="s4">pass</span>
    <span class="s4">if </span><span class="s1">format</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">() </span><span class="s4">not in </span><span class="s1">_formats </span><span class="s4">and </span><span class="s3">'r' </span><span class="s4">not in </span><span class="s1">mode</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;No format specified and unable to get format from &quot;</span>
                        <span class="s3">&quot;file extension: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">file</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s1">format</span>


<span class="s4">def </span><span class="s1">_format_str</span><span class="s2">(</span><span class="s1">format_int</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return the string representation of a given numeric format.&quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">dictionary </span><span class="s4">in </span><span class="s1">_formats</span><span class="s2">, </span><span class="s1">_subtypes</span><span class="s2">, </span><span class="s1">_endians</span><span class="s2">:</span>
        <span class="s4">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">dictionary</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">v </span><span class="s2">== </span><span class="s1">format_int</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">k</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s3">'n/a'</span>


<span class="s4">def </span><span class="s1">_format_info</span><span class="s2">(</span><span class="s1">format_int</span><span class="s2">, </span><span class="s1">format_flag</span><span class="s2">=</span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFC_GET_FORMAT_INFO</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return the ID and short description of a given format.&quot;&quot;&quot;</span>
    <span class="s1">format_info </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;SF_FORMAT_INFO*&quot;</span><span class="s2">)</span>
    <span class="s1">format_info</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">format_int</span>
    <span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_command</span><span class="s2">(</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">NULL</span><span class="s2">, </span><span class="s1">format_flag</span><span class="s2">, </span><span class="s1">format_info</span><span class="s2">,</span>
                    <span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s3">&quot;SF_FORMAT_INFO&quot;</span><span class="s2">))</span>
    <span class="s1">name </span><span class="s2">= </span><span class="s1">format_info</span><span class="s2">.</span><span class="s1">name</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">_format_str</span><span class="s2">(</span><span class="s1">format_info</span><span class="s2">.</span><span class="s1">format</span><span class="s2">),</span>
            <span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">name</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">) </span><span class="s4">if </span><span class="s1">name </span><span class="s4">else </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_available_formats_helper</span><span class="s2">(</span><span class="s1">count_flag</span><span class="s2">, </span><span class="s1">format_flag</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Helper for available_formats() and available_subtypes().&quot;&quot;&quot;</span>
    <span class="s1">count </span><span class="s2">= </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">new</span><span class="s2">(</span><span class="s3">&quot;int*&quot;</span><span class="s2">)</span>
    <span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_command</span><span class="s2">(</span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">NULL</span><span class="s2">, </span><span class="s1">count_flag</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s3">&quot;int&quot;</span><span class="s2">))</span>
    <span class="s4">for </span><span class="s1">format_int </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">count</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]):</span>
        <span class="s4">yield </span><span class="s1">_format_info</span><span class="s2">(</span><span class="s1">format_int</span><span class="s2">, </span><span class="s1">format_flag</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_check_format</span><span class="s2">(</span><span class="s1">format_str</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Check if `format_str` is valid and return format ID.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">format_str</span><span class="s2">, (</span><span class="s1">_unicode</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Invalid format: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">format_str</span><span class="s2">))</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">format_int </span><span class="s2">= </span><span class="s1">_formats</span><span class="s2">[</span><span class="s1">format_str</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">()]</span>
    <span class="s4">except </span><span class="s1">KeyError</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Unknown format: {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">format_str</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s1">format_int</span>


<span class="s4">def </span><span class="s1">_has_virtual_io_attrs</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">mode_int</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Check if file has all the necessary attributes for virtual IO.&quot;&quot;&quot;</span>
    <span class="s1">readonly </span><span class="s2">= </span><span class="s1">mode_int </span><span class="s2">== </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_READ</span>
    <span class="s1">writeonly </span><span class="s2">= </span><span class="s1">mode_int </span><span class="s2">== </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">SFM_WRITE</span>
    <span class="s4">return </span><span class="s1">all</span><span class="s2">([</span>
        <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'seek'</span><span class="s2">),</span>
        <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'tell'</span><span class="s2">),</span>
        <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'write'</span><span class="s2">) </span><span class="s4">or </span><span class="s1">readonly</span><span class="s2">,</span>
        <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'read'</span><span class="s2">) </span><span class="s4">or </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s3">'readinto'</span><span class="s2">) </span><span class="s4">or </span><span class="s1">writeonly</span><span class="s2">,</span>
    <span class="s2">])</span>


<span class="s4">class </span><span class="s1">SoundFileError</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Base class for all soundfile-specific errors.&quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">class </span><span class="s1">SoundFileRuntimeError</span><span class="s2">(</span><span class="s1">SoundFileError</span><span class="s2">, </span><span class="s1">RuntimeError</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;soundfile module runtime error. 
 
    Errors that used to be `RuntimeError`.&quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">class </span><span class="s1">LibsndfileError</span><span class="s2">(</span><span class="s1">SoundFileRuntimeError</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;libsndfile errors. 
 
 
    Attributes 
    ---------- 
    code 
        libsndfile internal error number. 
    &quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">=</span><span class="s3">&quot;&quot;</span><span class="s2">):</span>
        <span class="s1">SoundFileRuntimeError</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">code </span><span class="s2">= </span><span class="s1">code</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">prefix </span><span class="s2">= </span><span class="s1">prefix</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">error_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Raw libsndfile error message.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">code</span><span class="s2">:</span>
            <span class="s1">err_str </span><span class="s2">= </span><span class="s1">_snd</span><span class="s2">.</span><span class="s1">sf_error_number</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">code</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">_ffi</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">err_str</span><span class="s2">).</span><span class="s1">decode</span><span class="s2">(</span><span class="s3">'utf-8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Due to race conditions, if used concurrently, sf_error() may</span>
            <span class="s5"># return 0 (= no error) even if an error has happened.</span>
            <span class="s5"># See https://github.com/erikd/libsndfile/issues/610 for details.</span>
            <span class="s4">return </span><span class="s3">&quot;(Garbled error message from libsndfile)&quot;</span>

    <span class="s4">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">prefix </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">error_string</span>
</pre>
</body>
</html>