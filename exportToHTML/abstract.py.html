<html>
<head>
<title>abstract.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
abstract.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s2">, </span><span class="s1">abstractmethod</span><span class="s2">, </span><span class="s1">abstractproperty</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict </span><span class="s0">as </span><span class="s1">ptDict</span><span class="s2">, </span><span class="s1">Type </span><span class="s0">as </span><span class="s1">ptType</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">cached_property</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">get_hashable_key</span>

<span class="s3"># Types are added to a global registry (_typecache) in order to assign</span>
<span class="s3"># them unique integer codes for fast matching in _dispatcher.c.</span>
<span class="s3"># However, we also want types to be disposable, therefore we ensure</span>
<span class="s3"># each type is interned as a weak reference, so that it lives only as</span>
<span class="s3"># long as necessary to keep a stable type code.</span>
<span class="s3"># NOTE: some types can still be made immortal elsewhere (for example</span>
<span class="s3"># in _dispatcher.c's internal caches).</span>
<span class="s1">_typecodes </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">count</span><span class="s2">()</span>

<span class="s0">def </span><span class="s1">_autoincr</span><span class="s2">():</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">_typecodes</span><span class="s2">)</span>
    <span class="s3"># 4 billion types should be enough, right?</span>
    <span class="s0">assert </span><span class="s1">n </span><span class="s2">&lt; </span><span class="s4">2 </span><span class="s2">** </span><span class="s4">32</span><span class="s2">, </span><span class="s5">&quot;Limited to 4 billion types&quot;</span>
    <span class="s0">return </span><span class="s1">n</span>

<span class="s1">_typecache</span><span class="s2">: </span><span class="s1">ptDict</span><span class="s2">[</span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">, </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">] = {}</span>

<span class="s0">def </span><span class="s1">_on_type_disposal</span><span class="s2">(</span><span class="s1">wr</span><span class="s2">, </span><span class="s1">_pop</span><span class="s2">=</span><span class="s1">_typecache</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">):</span>
    <span class="s1">_pop</span><span class="s2">(</span><span class="s1">wr</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">_TypeMetaclass</span><span class="s2">(</span><span class="s1">ABCMeta</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    A metaclass that will intern instances after they are created. 
    This is done by first creating a new instance (including calling 
    __init__, which sets up the required attributes for equality 
    and hashing), then looking it up in the _typecache registry. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">orig_vars</span><span class="s2">):</span>
        <span class="s3"># __init__ is hooked to mark whether a Type class being defined is a</span>
        <span class="s3"># Numba internal type (one which is defined somewhere under the `numba`</span>
        <span class="s3"># module) or an external type (one which is defined elsewhere, for</span>
        <span class="s3"># example a user defined type).</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">_TypeMetaclass</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">orig_vars</span><span class="s2">)</span>
        <span class="s1">root </span><span class="s2">= (</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">'.'</span><span class="s2">))[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">cls</span><span class="s2">.</span><span class="s1">_is_internal </span><span class="s2">= </span><span class="s1">root </span><span class="s2">== </span><span class="s5">&quot;numba&quot;</span>

    <span class="s0">def </span><span class="s1">_intern</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">inst</span><span class="s2">):</span>
        <span class="s3"># Try to intern the created instance</span>
        <span class="s1">wr </span><span class="s2">= </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">, </span><span class="s1">_on_type_disposal</span><span class="s2">)</span>
        <span class="s1">orig </span><span class="s2">= </span><span class="s1">_typecache</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">wr</span><span class="s2">)</span>
        <span class="s1">orig </span><span class="s2">= </span><span class="s1">orig </span><span class="s0">and </span><span class="s1">orig</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">orig </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">orig</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">inst</span><span class="s2">.</span><span class="s1">_code </span><span class="s2">= </span><span class="s1">_autoincr</span><span class="s2">()</span>
            <span class="s1">_typecache</span><span class="s2">[</span><span class="s1">wr</span><span class="s2">] = </span><span class="s1">wr</span>
            <span class="s0">return </span><span class="s1">inst</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Instantiate *cls* (a Type subclass, presumably) and intern it. 
        If an interned instance already exists, it is returned, otherwise 
        the new instance is returned. 
        &quot;&quot;&quot;</span>
        <span class="s1">inst </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_intern</span><span class="s2">(</span><span class="s1">inst</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_type_reconstructor</span><span class="s2">(</span><span class="s1">reconstructor</span><span class="s2">, </span><span class="s1">reconstructor_args</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Rebuild function for unpickling types. 
    &quot;&quot;&quot;</span>
    <span class="s1">obj </span><span class="s2">= </span><span class="s1">reconstructor</span><span class="s2">(*</span><span class="s1">reconstructor_args</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">state</span><span class="s2">:</span>
        <span class="s1">obj</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">_intern</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Type</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_TypeMetaclass</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    The base class for all Numba types. 
    It is essential that proper equality comparison is implemented.  The 
    default implementation uses the &quot;key&quot; property (overridable in subclasses) 
    for both comparison and hashing, to ensure sane behaviour. 
    &quot;&quot;&quot;</span>

    <span class="s1">mutable </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s3"># Rather the type is reflected at the python&lt;-&gt;nopython boundary</span>
    <span class="s1">reflected </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">name</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        A property used for __eq__, __ne__ and __hash__.  Can be overridden 
        in subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">mangling_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns `(basename, args)` where `basename` is the name of the type 
        and `args` is a sequence of parameters of the type. 
 
        Subclass should override to specialize the behavior. 
        By default, this returns `(self.name, ())`. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, ()</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">is </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">key </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">key</span>

    <span class="s0">def </span><span class="s1">__ne__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return not </span><span class="s2">(</span><span class="s1">self </span><span class="s2">== </span><span class="s1">other</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">reconstructor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">state </span><span class="s2">= </span><span class="s1">super</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__reduce__</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">_type_reconstructor</span><span class="s2">, (</span><span class="s1">reconstructor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">state</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Try to unify this type with the *other*.  A third type must 
        be returned, or None if unification is not possible. 
        Only override this if the coercion logic cannot be expressed 
        as simple casting rules. 
        &quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">can_convert_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Check whether this type can be converted to the *other*. 
        If successful, must return a string describing the conversion, e.g. 
        &quot;exact&quot;, &quot;promote&quot;, &quot;unsafe&quot;, &quot;safe&quot;; otherwise None is returned. 
        &quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">can_convert_from</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Similar to *can_convert_to*, but in reverse.  Only needed if 
        the type provides conversion from other types. 
        &quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">is_precise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Whether this type is precise, i.e. can be part of a successful 
        type inference.  Default implementation returns True. 
        &quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">augment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Augment this type with the *other*.  Return the augmented type, 
        or None if not supported. 
        &quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s3"># User-facing helpers.  These are not part of the core Type API but</span>
    <span class="s3"># are provided so that users can write e.g. `numba.boolean(1.5)`</span>
    <span class="s3"># (returns True) or `types.int32(types.int32[:])` (returns something</span>
    <span class="s3"># usable as a function signature).</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">import </span><span class="s1">signature</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s4">1 </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">Type</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cast_python_value</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s3"># return_type</span>
                         <span class="s2">*</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Return an array of this type. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">types </span><span class="s0">import </span><span class="s1">Array</span>
        <span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_determine_array_spec</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">=</span><span class="s1">layout</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_determine_array_spec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s3"># XXX non-contiguous by default, even for 1d arrays,</span>
        <span class="s3"># doesn't sound very intuitive</span>
        <span class="s0">def </span><span class="s1">validate_slice</span><span class="s2">(</span><span class="s1">s</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">s</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">) </span><span class="s0">and </span><span class="s1">s</span><span class="s2">.</span><span class="s1">start </span><span class="s0">is None and </span><span class="s1">s</span><span class="s2">.</span><span class="s1">stop </span><span class="s0">is None</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, (</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">all</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">validate_slice</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)):</span>
            <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">step </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'F'</span>
            <span class="s0">elif </span><span class="s1">args</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">].</span><span class="s1">step </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'C'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'A'</span>
        <span class="s0">elif </span><span class="s1">validate_slice</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s1">ndim </span><span class="s2">= </span><span class="s4">1</span>
            <span class="s0">if </span><span class="s1">args</span><span class="s2">.</span><span class="s1">step </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'C'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">layout </span><span class="s2">= </span><span class="s5">'A'</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># Raise a KeyError to not be handled by collection constructors (e.g. list).</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s5">f&quot;Can only index numba types with slices with no start or stop, got </span><span class="s0">{</span><span class="s1">args</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">layout</span>

    <span class="s0">def </span><span class="s1">cast_python_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_internal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; Returns True if this class is an internally defined Numba type by 
        virtue of the module in which it is instantiated, False else.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_is_internal</span>

    <span class="s0">def </span><span class="s1">dump</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tab</span><span class="s2">=</span><span class="s5">''</span><span class="s2">):</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">f'</span><span class="s0">{</span><span class="s1">tab</span><span class="s0">}</span><span class="s5">DUMP </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">[code=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_code</span><span class="s0">}</span><span class="s5">, name=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">]'</span><span class="s2">)</span>

<span class="s3"># XXX we should distinguish between Dummy (no meaningful</span>
<span class="s3"># representation, e.g. None or a builtin function) and Opaque (has a</span>
<span class="s3"># meaningful representation, e.g. ExternalFunctionPointer)</span>

<span class="s0">class </span><span class="s1">Dummy</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for types that do not really have a representation and are 
    compatible with a void*. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Hashable</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for hashable types. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Number</span><span class="s2">(</span><span class="s1">Hashable</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for number types. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Unify the two number types using Numpy's rules. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">numpy_support</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">):</span>
            <span class="s3"># XXX: this can produce unsafe conversions,</span>
            <span class="s3"># e.g. would unify {int64, uint64} to float64</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">as_dtype</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s1">sel </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">promote_types</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">numpy_support</span><span class="s2">.</span><span class="s1">from_dtype</span><span class="s2">(</span><span class="s1">sel</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Callable</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for callables. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Using the typing *context*, resolve the callable's signature for 
        the given arguments.  A signature object is returned, or None. 
        &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_call_signatures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns a tuple of (list of signatures, parameterized) 
        &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_impl_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Returns the impl key for the given signature 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DTypeSpec</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for types usable as &quot;dtype&quot; arguments to various Numpy APIs 
    (e.g. np.empty()). 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">abstractproperty</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        The actual dtype denoted by this dtype spec (a Type instance). 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">IterableType</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for iterable types. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">abstractproperty</span>
    <span class="s0">def </span><span class="s1">iterator_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        The iterator type obtained when calling iter() (explicitly or implicitly). 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Sized</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for objects that support len() 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">ConstSized</span><span class="s2">(</span><span class="s1">Sized</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    For types that have a constant size 
    &quot;&quot;&quot;</span>
    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">IteratorType</span><span class="s2">(</span><span class="s1">IterableType</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for all iterator types. 
    Derived classes should implement the *yield_type* attribute. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">IteratorType</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">abstractproperty</span>
    <span class="s0">def </span><span class="s1">yield_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        The type of values yielded by the iterator. 
        &quot;&quot;&quot;</span>

    <span class="s3"># This is a property to avoid recursivity (for pickling)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">iterator_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">Container</span><span class="s2">(</span><span class="s1">Sized</span><span class="s2">, </span><span class="s1">IterableType</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for container types. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Sequence</span><span class="s2">(</span><span class="s1">Container</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for 1d sequence types.  Instances should have the *dtype* 
    attribute. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">MutableSequence</span><span class="s2">(</span><span class="s1">Sequence</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Base class for 1d mutable sequence types.  Instances should have the 
    *dtype* attribute. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">ArrayCompatible</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Type class for Numpy array-compatible objects (typically, objects 
    exposing an __array__ method). 
    Derived classes should implement the *as_array* attribute. 
    &quot;&quot;&quot;</span>
    <span class="s3"># If overridden by a subclass, it should also implement typing</span>
    <span class="s3"># for '__array_wrap__' with arguments (input, formal result).</span>
    <span class="s1">array_priority </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s2">@</span><span class="s1">abstractproperty</span>
    <span class="s0">def </span><span class="s1">as_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        The equivalent array type, for operations supporting array-compatible 
        objects (such as ufuncs). 
        &quot;&quot;&quot;</span>

    <span class="s3"># For compatibility with types.Array</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">as_array</span><span class="s2">.</span><span class="s1">ndim</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">layout</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">as_array</span><span class="s2">.</span><span class="s1">layout</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">as_array</span><span class="s2">.</span><span class="s1">dtype</span>


<span class="s0">class </span><span class="s1">Literal</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Base class for Literal types. 
    Literal types contain the original Python value in the type. 
 
    A literal type should always be constructed from the `literal(val)` 
    function. 
    &quot;&quot;&quot;</span>

    <span class="s3"># *ctor_map* is a dictionary mapping Python types to Literal subclasses</span>
    <span class="s3"># for constructing a numba type for a given Python type.</span>
    <span class="s3"># It is used in `literal(val)` function.</span>
    <span class="s3"># To add new Literal subclass, register a new mapping to this dict.</span>
    <span class="s1">ctor_map</span><span class="s2">: </span><span class="s1">ptDict</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, </span><span class="s1">ptType</span><span class="s2">[</span><span class="s5">'Literal'</span><span class="s2">]] = {}</span>

    <span class="s3"># *_literal_type_cache* is used to cache the numba type of the given value.</span>
    <span class="s1">_literal_type_cache </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Literal</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;Cannot be constructed directly. &quot;</span>
                <span class="s5">&quot;Use `numba.types.literal(value)` instead&quot;</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_init</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">fmt </span><span class="s2">= </span><span class="s5">&quot;Literal[{}]({})&quot;</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">value</span><span class="s2">).</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">value</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_literal_init</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_value </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s3"># We want to support constants of non-hashable values, therefore</span>
        <span class="s3"># fall back on the value's id() if necessary.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_key </span><span class="s2">= </span><span class="s1">get_hashable_key</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">literal_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_value</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">literal_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_type_cache </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typing</span>
            <span class="s1">ctx </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Context</span><span class="s2">()</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">resolve_value_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">literal_value</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>

                <span class="s0">if </span><span class="s5">&quot;Int value is too large&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">):</span>
                    <span class="s3"># If a string literal cannot create an IntegerLiteral</span>
                    <span class="s3"># because of overflow we generate this message.</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s5">f&quot;Cannot create literal type. </span><span class="s0">{</span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                <span class="s3"># Not all literal types have a literal_value that can be</span>
                <span class="s3"># resolved to a type, for example, LiteralStrKeyDict has a</span>
                <span class="s3"># literal_value that is a python dict for which there's no</span>
                <span class="s3"># `typeof` support.</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;{} has no attribute 'literal_type'&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_type_cache </span><span class="s2">= </span><span class="s1">res</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_literal_type_cache</span>



<span class="s0">class </span><span class="s1">TypeRef</span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Reference to a type. 
 
    Used when a type is passed as a value. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">instance_type</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">instance_type </span><span class="s2">= </span><span class="s1">instance_type</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">TypeRef</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s5">'typeref[{}]'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">instance_type</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">instance_type</span>


<span class="s0">class </span><span class="s1">InitialValue</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Used as a mixin for a type will potentially have an initial value that will 
    be carried in the .initial_value attribute. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">initial_value</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_value </span><span class="s2">= </span><span class="s1">initial_value</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">initial_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_value</span>


<span class="s0">class </span><span class="s1">Poison</span><span class="s2">(</span><span class="s1">Type</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    This is the &quot;bottom&quot; type in the type system. It won't unify and it's 
    unliteral version is Poison of itself. It's advisable for debugging purposes 
    to call the constructor with the type that's being poisoned (for whatever 
    reason) but this isn't strictly required. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ty </span><span class="s2">= </span><span class="s1">ty</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">Poison</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;Poison&lt;%s&gt;&quot; </span><span class="s2">% </span><span class="s1">ty</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__unliteral__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Poison</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">unify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typingctx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return None</span>
</pre>
</body>
</html>