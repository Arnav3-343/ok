<html>
<head>
<title>imputils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
imputils.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Utilities to simplify the boilerplate for native lowering. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">typing</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">utils</span><span class="s3">, </span><span class="s1">cgutils</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">typing</span><span class="s3">.</span><span class="s1">templates </span><span class="s2">import </span><span class="s1">BaseRegistryLoader</span>


<span class="s2">class </span><span class="s1">Registry</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A registry of function and attribute implementations. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s4">'unspecified'</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">functions </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">getattrs </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">setattrs </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">casts </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constants </span><span class="s3">= []</span>

    <span class="s2">def </span><span class="s1">lower</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, *</span><span class="s1">argtys</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate an implementation of *func* for the given argument types. 
        *func* may be an actual global function object, or any 
        pseudo-function supported by Numba, such as &quot;getitem&quot;. 
 
        The decorated implementation has the signature 
        (context, builder, sig, args). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">decorate</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">functions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">argtys</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">impl</span>
        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">_decorate_attr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">impl_list</span><span class="s3">, </span><span class="s1">decorator</span><span class="s3">):</span>
        <span class="s1">real_impl </span><span class="s3">= </span><span class="s1">decorator</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s1">impl_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">real_impl</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">real_impl</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">impl</span>

    <span class="s2">def </span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate an implementation of __getattr__ for type *ty* and 
        the attribute *attr*. 
 
        The decorated implementation will have the signature 
        (context, builder, typ, val). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">decorate</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_decorate_attr</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getattrs</span><span class="s3">,</span>
                                       <span class="s1">_decorate_getattr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">lower_getattr_generic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate the fallback implementation of __getattr__ for type *ty*. 
 
        The decorated implementation will have the signature 
        (context, builder, typ, val, attr).  The implementation is 
        called for attributes which haven't been explicitly registered 
        with lower_getattr(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower_getattr</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lower_setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate an implementation of __setattr__ for type *ty* and 
        the attribute *attr*. 
 
        The decorated implementation will have the signature 
        (context, builder, sig, args). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">decorate</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_decorate_attr</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">setattrs</span><span class="s3">,</span>
                                       <span class="s1">_decorate_setattr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">lower_setattr_generic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate the fallback implementation of __setattr__ for type *ty*. 
 
        The decorated implementation will have the signature 
        (context, builder, sig, args, attr).  The implementation is 
        called for attributes which haven't been explicitly registered 
        with lower_setattr(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower_setattr</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lower_cast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate the implementation of implicit conversion between 
        *fromty* and *toty*. 
 
        The decorated implementation will have the signature 
        (context, builder, fromty, toty, val). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">decorate</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">casts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">fromty</span><span class="s3">, </span><span class="s1">toty</span><span class="s3">)))</span>
            <span class="s2">return </span><span class="s1">impl</span>
        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">lower_constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Decorate the implementation for creating a constant of type *ty*. 
 
        The decorated implementation will have the signature 
        (context, builder, ty, pyval). 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">decorate</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">constants</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">impl</span><span class="s3">, (</span><span class="s1">ty</span><span class="s3">,)))</span>
            <span class="s2">return </span><span class="s1">impl</span>
        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">f&quot;Lowering Registry&lt;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">RegistryLoader</span><span class="s3">(</span><span class="s1">BaseRegistryLoader</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    An incremental loader for a target registry. 
    &quot;&quot;&quot;</span>
    <span class="s1">registry_items </span><span class="s3">= (</span><span class="s4">'functions'</span><span class="s3">, </span><span class="s4">'getattrs'</span><span class="s3">, </span><span class="s4">'setattrs'</span><span class="s3">, </span><span class="s4">'casts'</span><span class="s3">, </span><span class="s4">'constants'</span><span class="s3">)</span>


<span class="s5"># Global registry for implementations of builtin operations</span>
<span class="s5"># (functions, attributes, type casts)</span>
<span class="s1">builtin_registry </span><span class="s3">= </span><span class="s1">Registry</span><span class="s3">(</span><span class="s4">'builtin_registry'</span><span class="s3">)</span>

<span class="s1">lower_builtin </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower</span>
<span class="s1">lower_getattr </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_getattr</span>
<span class="s1">lower_getattr_generic </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_getattr_generic</span>
<span class="s1">lower_setattr </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_setattr</span>
<span class="s1">lower_setattr_generic </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_setattr_generic</span>
<span class="s1">lower_cast </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_cast</span>
<span class="s1">lower_constant </span><span class="s3">= </span><span class="s1">builtin_registry</span><span class="s3">.</span><span class="s1">lower_constant</span>


<span class="s2">def </span><span class="s1">_decorate_getattr</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s1">real_impl </span><span class="s3">= </span><span class="s1">impl</span>

    <span class="s2">if </span><span class="s1">attr </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">res</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">res</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s1">res</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= (</span><span class="s1">ty</span><span class="s3">,)</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">attr</span>
    <span class="s2">return </span><span class="s1">res</span>

<span class="s2">def </span><span class="s1">_decorate_setattr</span><span class="s3">(</span><span class="s1">impl</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s1">real_impl </span><span class="s3">= </span><span class="s1">impl</span>

    <span class="s2">if </span><span class="s1">attr </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">res</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">res</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">real_impl</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>

    <span class="s1">res</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= (</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">)</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">attr </span><span class="s3">= </span><span class="s1">attr</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">fix_returning_optional</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">):</span>
    <span class="s5"># Reconstruct optional return type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
        <span class="s1">value_type </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">.</span><span class="s1">type</span>
        <span class="s1">optional_none </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_optional_none</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">)</span>
        <span class="s1">retvalptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">optional_none</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">is_none</span><span class="s3">)):</span>
            <span class="s1">optional_value </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_optional_value</span><span class="s3">(</span>
                <span class="s1">builder</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">optional_value</span><span class="s3">, </span><span class="s1">retvalptr</span><span class="s3">)</span>
        <span class="s1">retval </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">retvalptr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">retval</span>

<span class="s2">def </span><span class="s1">user_function</span><span class="s3">(</span><span class="s1">fndesc</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A wrapper inserting code calling Numba-compiled *fndesc*. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">imp</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">declare_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">)</span>
        <span class="s5"># env=None assumes this is a nopython function</span>
        <span class="s1">status</span><span class="s3">, </span><span class="s1">retval </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">call_function</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">restype</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">.</span><span class="s1">is_error</span><span class="s3">):</span>
            <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_status_propagate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type </span><span class="s3">== </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">restype</span>
        <span class="s5"># Reconstruct optional return type</span>
        <span class="s1">retval </span><span class="s3">= </span><span class="s1">fix_returning_optional</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>
        <span class="s5"># If the data representations don't match up</span>
        <span class="s2">if </span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">(</span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;function returned {0} but expect {1}&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">restype</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>

    <span class="s1">imp</span><span class="s3">.</span><span class="s1">signature </span><span class="s3">= </span><span class="s1">fndesc</span><span class="s3">.</span><span class="s1">argtypes</span>
    <span class="s1">imp</span><span class="s3">.</span><span class="s1">libs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">libs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">imp</span>


<span class="s2">def </span><span class="s1">user_generator</span><span class="s3">(</span><span class="s1">gendesc</span><span class="s3">, </span><span class="s1">libs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A wrapper inserting code calling Numba-compiled *gendesc*. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">imp</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">declare_function</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">gendesc</span><span class="s3">)</span>
        <span class="s5"># env=None assumes this is a nopython function</span>
        <span class="s1">status</span><span class="s3">, </span><span class="s1">retval </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">call_function</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">gendesc</span><span class="s3">.</span><span class="s1">restype</span><span class="s3">, </span><span class="s1">gendesc</span><span class="s3">.</span><span class="s1">argtypes</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s5"># Return raw status for caller to process StopIteration</span>
        <span class="s2">return </span><span class="s1">status</span><span class="s3">, </span><span class="s1">retval</span>

    <span class="s1">imp</span><span class="s3">.</span><span class="s1">libs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">libs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">imp</span>


<span class="s2">def </span><span class="s1">iterator_impl</span><span class="s3">(</span><span class="s1">iterable_type</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator a given class as implementing *iterator_type* 
    (by providing an `iternext()` method). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
        <span class="s5"># These are unbound methods</span>
        <span class="s1">iternext </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">iternext</span>

        <span class="s3">@</span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">iternext_wrapper</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">):</span>
            <span class="s3">(</span><span class="s1">value</span><span class="s3">,) = </span><span class="s1">args</span>
            <span class="s1">iterobj </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">iternext</span><span class="s3">(</span><span class="s1">iterobj</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>

        <span class="s1">lower_builtin</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">)(</span><span class="s1">iternext_wrapper</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">class </span><span class="s1">_IternextResult</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A result wrapper for iteration, passed by iternext_impl() into the 
    wrapped function. 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">'_context'</span><span class="s3">, </span><span class="s4">'_builder'</span><span class="s3">, </span><span class="s4">'_pairobj'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pairobj</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj </span><span class="s3">= </span><span class="s1">pairobj</span>

    <span class="s2">def </span><span class="s1">set_exhausted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Mark the iterator as exhausted. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj</span><span class="s3">.</span><span class="s1">second </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">set_valid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">is_valid</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Mark the iterator as valid according to *is_valid* (which must 
        be either a Python boolean or a LLVM inst). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">is_valid </span><span class="s2">in </span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">):</span>
            <span class="s1">is_valid </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">get_constant</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">is_valid</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj</span><span class="s3">.</span><span class="s1">second </span><span class="s3">= </span><span class="s1">is_valid</span>

    <span class="s2">def </span><span class="s1">yield_</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Mark the iterator as yielding the given *value* (a LLVM inst). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj</span><span class="s3">.</span><span class="s1">first </span><span class="s3">= </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">is_valid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the iterator is marked valid. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">get_argument_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">,</span>
                                                <span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">,</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj</span><span class="s3">.</span><span class="s1">second</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">yielded_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the iterator's yielded value, if any. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_pairobj</span><span class="s3">.</span><span class="s1">first</span>

<span class="s2">class </span><span class="s1">RefType</span><span class="s3">(</span><span class="s1">Enum</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Enumerate the reference type 
    &quot;&quot;&quot;</span>
    <span class="s4">&quot;&quot;&quot; 
    A new reference 
    &quot;&quot;&quot;</span>
    <span class="s1">NEW </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s4">&quot;&quot;&quot; 
    A borrowed reference 
    &quot;&quot;&quot;</span>
    <span class="s1">BORROWED </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s4">&quot;&quot;&quot; 
    An untracked reference 
    &quot;&quot;&quot;</span>
    <span class="s1">UNTRACKED </span><span class="s3">= </span><span class="s6">3</span>

<span class="s2">def </span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">ref_type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Wrap the given iternext() implementation so that it gets passed 
    an _IternextResult() object easing the returning of the iternext() 
    result pair. 
 
    ref_type: a numba.targets.imputils.RefType value, the reference type used is 
    that specified through the RefType enum. 
 
    The wrapped function will be called with the following signature: 
        (context, builder, sig, args, iternext_result) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">ref_type </span><span class="s2">not in </span><span class="s3">[</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">RefType</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;ref_type must be an enum member of imputils.RefType&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">outer</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">pair_type </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">return_type</span>
            <span class="s1">pairobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pair_type</span><span class="s3">)</span>
            <span class="s1">func</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                <span class="s1">_IternextResult</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pairobj</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">ref_type </span><span class="s3">== </span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">NEW</span><span class="s3">:</span>
                <span class="s1">impl_ret </span><span class="s3">= </span><span class="s1">impl_ret_new_ref</span>
            <span class="s2">elif </span><span class="s1">ref_type </span><span class="s3">== </span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">BORROWED</span><span class="s3">:</span>
                <span class="s1">impl_ret </span><span class="s3">= </span><span class="s1">impl_ret_borrowed</span>
            <span class="s2">elif </span><span class="s1">ref_type </span><span class="s3">== </span><span class="s1">RefType</span><span class="s3">.</span><span class="s1">UNTRACKED</span><span class="s3">:</span>
                <span class="s1">impl_ret </span><span class="s3">= </span><span class="s1">impl_ret_untracked</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown ref_type encountered&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">impl_ret</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">,</span>
                                    <span class="s1">pair_type</span><span class="s3">, </span><span class="s1">pairobj</span><span class="s3">.</span><span class="s1">_getvalue</span><span class="s3">())</span>
        <span class="s2">return </span><span class="s1">wrapper</span>
    <span class="s2">return </span><span class="s1">outer</span>


<span class="s2">def </span><span class="s1">call_getiter</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterable_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call the `getiter()` implementation for the given *iterable_type* 
    of value *val*, and return the corresponding LLVM inst. 
    &quot;&quot;&quot;</span>
    <span class="s1">getiter_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">iterable_type</span><span class="s3">.</span><span class="s1">iterator_type</span><span class="s3">, </span><span class="s1">iterable_type</span><span class="s3">)</span>
    <span class="s1">getiter_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s4">'getiter'</span><span class="s3">, </span><span class="s1">getiter_sig</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">getiter_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">val</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">call_iternext</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call the `iternext()` implementation for the given *iterator_type* 
    of value *val*, and return a convenience _IternextResult() object 
    reflecting the results. 
    &quot;&quot;&quot;</span>
    <span class="s1">itemty </span><span class="s3">= </span><span class="s1">iterator_type</span><span class="s3">.</span><span class="s1">yield_type</span>
    <span class="s1">pair_type </span><span class="s3">= </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Pair</span><span class="s3">(</span><span class="s1">itemty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">boolean</span><span class="s3">)</span>
    <span class="s1">iternext_sig </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">pair_type</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">)</span>
    <span class="s1">iternext_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s4">'iternext'</span><span class="s3">, </span><span class="s1">iternext_sig</span><span class="s3">)</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">iternext_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">val</span><span class="s3">,))</span>
    <span class="s1">pairobj </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pair_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_IternextResult</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pairobj</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">call_len</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Call len() on the given value.  Return None if len() isn't defined on 
    this type. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">len_impl </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_function</span><span class="s3">(</span><span class="s1">len</span><span class="s3">, </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">,))</span>
    <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
        <span class="s2">return None</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">len_impl</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, (</span><span class="s1">val</span><span class="s3">,))</span>


<span class="s1">_ForIterLoop </span><span class="s3">= </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'_ForIterLoop'</span><span class="s3">,</span>
                                      <span class="s3">(</span><span class="s4">'value'</span><span class="s3">, </span><span class="s4">'do_break'</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">for_iter</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterable_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Simulate a for loop on the given iterable.  Yields a namedtuple with 
    the given members: 
    - `value` is the value being yielded 
    - `do_break` is a callable to early out of the loop 
    &quot;&quot;&quot;</span>
    <span class="s1">iterator_type </span><span class="s3">= </span><span class="s1">iterable_type</span><span class="s3">.</span><span class="s1">iterator_type</span>
    <span class="s1">iterval </span><span class="s3">= </span><span class="s1">call_getiter</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterable_type</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s1">bb_body </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'for_iter.body'</span><span class="s3">)</span>
    <span class="s1">bb_end </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">'for_iter.end'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">do_break</span><span class="s3">():</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bb_end</span><span class="s3">)</span>

    <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bb_body</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_block</span><span class="s3">(</span><span class="s1">bb_body</span><span class="s3">):</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">call_iternext</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">, </span><span class="s1">iterval</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">is_valid</span><span class="s3">()), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bb_end</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">_ForIterLoop</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">yielded_value</span><span class="s3">(), </span><span class="s1">do_break</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bb_body</span><span class="s3">)</span>

    <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bb_end</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">decref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">iterator_type</span><span class="s3">, </span><span class="s1">iterval</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">impl_ret_new_ref</span><span class="s3">(</span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The implementation returns a new reference. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">impl_ret_borrowed</span><span class="s3">(</span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The implementation returns a borrowed reference. 
    This function automatically incref so that the implementation is 
    returning a new reference. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">ctx</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
        <span class="s1">ctx</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">incref</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">impl_ret_untracked</span><span class="s3">(</span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The return type is not a NRT object. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">force_error_model</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">model_name</span><span class="s3">=</span><span class="s4">'numpy'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Temporarily change the context's error model. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">callconv</span>

    <span class="s1">old_error_model </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">error_model</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">error_model </span><span class="s3">= </span><span class="s1">callconv</span><span class="s3">.</span><span class="s1">create_error_model</span><span class="s3">(</span><span class="s1">model_name</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">error_model </span><span class="s3">= </span><span class="s1">old_error_model</span>


<span class="s2">def </span><span class="s1">numba_typeref_ctor</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A stub for use internally by Numba when a call is emitted 
    on a TypeRef. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;This function should not be executed.&quot;</span><span class="s3">)</span>
</pre>
</body>
</html>