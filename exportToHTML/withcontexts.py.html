<html>
<head>
<title>withcontexts.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
withcontexts.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">, </span><span class="s1">sigutils</span><span class="s2">, </span><span class="s1">ir_utils</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">typeof </span><span class="s0">import </span><span class="s1">typeof_impl</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">transforms </span><span class="s0">import </span><span class="s1">find_region_inout_vars</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ir_utils </span><span class="s0">import </span><span class="s1">build_definitions</span>
<span class="s0">import </span><span class="s1">numba</span>


<span class="s0">class </span><span class="s1">WithContext</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A dummy object for use as contextmanager. 
    This can be used as a contextmanager. 
    &quot;&quot;&quot;</span>
    <span class="s1">is_callable </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__enter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__exit__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">mutate_with_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                         <span class="s1">body_blocks</span><span class="s2">, </span><span class="s1">dispatcher_factory</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Mutate the *blocks* to implement this contextmanager. 
 
        Parameters 
        ---------- 
        func_ir : FunctionIR 
        blocks : dict[ir.Block] 
        blk_start, blk_end : int 
            labels of the starting and ending block of the context-manager. 
        body_block: sequence[int] 
            A sequence of int's representing labels of the with-body 
        dispatcher_factory : callable 
            A callable that takes a `FunctionIR` and returns a `Dispatcher`. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">@</span><span class="s1">typeof_impl</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">WithContext</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">typeof_contextmanager</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">c</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ContextManager</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_var_parent</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Get parent of the variable given its name 
    &quot;&quot;&quot;</span>
    <span class="s4"># If not a temporary variable</span>
    <span class="s0">if not </span><span class="s1">name</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'$'</span><span class="s2">):</span>
        <span class="s4"># Return the base component of the name</span>
        <span class="s0">return </span><span class="s1">name</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">'.'</span><span class="s2">, )[</span><span class="s6">0</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_clear_blocks</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">to_clear</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Remove keys in *to_clear* from *blocks*. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">to_clear</span><span class="s2">:</span>
        <span class="s0">del </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">b</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">_ByPassContextType</span><span class="s2">(</span><span class="s1">WithContext</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A simple context-manager that tells the compiler to bypass the body 
    of the with-block. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">mutate_with_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                         <span class="s1">body_blocks</span><span class="s2">, </span><span class="s1">dispatcher_factory</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">extra </span><span class="s0">is None</span>
        <span class="s4"># Determine variables that need forwarding</span>
        <span class="s1">vlt </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">variable_lifetime</span>
        <span class="s1">inmap </span><span class="s2">= {</span><span class="s1">_get_var_parent</span><span class="s2">(</span><span class="s1">k</span><span class="s2">): </span><span class="s1">k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">vlt</span><span class="s2">.</span><span class="s1">livemap</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">]}</span>
        <span class="s1">outmap </span><span class="s2">= {</span><span class="s1">_get_var_parent</span><span class="s2">(</span><span class="s1">k</span><span class="s2">): </span><span class="s1">k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">vlt</span><span class="s2">.</span><span class="s1">livemap</span><span class="s2">[</span><span class="s1">blk_end</span><span class="s2">]}</span>
        <span class="s1">forwardvars </span><span class="s2">= {</span><span class="s1">inmap</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]: </span><span class="s1">outmap</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">filter</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">, </span><span class="s1">outmap</span><span class="s2">)}</span>
        <span class="s4"># Transform the block</span>
        <span class="s1">_bypass_with_context</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">forwardvars</span><span class="s2">)</span>
        <span class="s1">_clear_blocks</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">body_blocks</span><span class="s2">)</span>


<span class="s1">bypass_context </span><span class="s2">= </span><span class="s1">_ByPassContextType</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">_CallContextType</span><span class="s2">(</span><span class="s1">WithContext</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A simple context-manager that tells the compiler to lift the body of the 
    with-block as another function. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">mutate_with_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                         <span class="s1">body_blocks</span><span class="s2">, </span><span class="s1">dispatcher_factory</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">extra </span><span class="s0">is None</span>
        <span class="s1">vlt </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">variable_lifetime</span>

        <span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs </span><span class="s2">= </span><span class="s1">find_region_inout_vars</span><span class="s2">(</span>
            <span class="s1">blocks</span><span class="s2">=</span><span class="s1">blocks</span><span class="s2">,</span>
            <span class="s1">livemap</span><span class="s2">=</span><span class="s1">vlt</span><span class="s2">.</span><span class="s1">livemap</span><span class="s2">,</span>
            <span class="s1">callfrom</span><span class="s2">=</span><span class="s1">blk_start</span><span class="s2">,</span>
            <span class="s1">returnto</span><span class="s2">=</span><span class="s1">blk_end</span><span class="s2">,</span>
            <span class="s1">body_block_ids</span><span class="s2">=</span><span class="s1">set</span><span class="s2">(</span><span class="s1">body_blocks</span><span class="s2">),</span>
            <span class="s2">)</span>

        <span class="s1">lifted_blks </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">body_blocks</span><span class="s2">}</span>
        <span class="s1">_mutate_with_block_callee</span><span class="s2">(</span><span class="s1">lifted_blks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                                  <span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">)</span>

        <span class="s4"># XXX: transform body-blocks to return the output variables</span>
        <span class="s1">lifted_ir </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">derive</span><span class="s2">(</span>
            <span class="s1">blocks</span><span class="s2">=</span><span class="s1">lifted_blks</span><span class="s2">,</span>
            <span class="s1">arg_names</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">),</span>
            <span class="s1">arg_count</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">),</span>
            <span class="s1">force_non_generator</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s1">dispatcher </span><span class="s2">= </span><span class="s1">dispatcher_factory</span><span class="s2">(</span><span class="s1">lifted_ir</span><span class="s2">)</span>

        <span class="s1">newblk </span><span class="s2">= </span><span class="s1">_mutate_with_block_caller</span><span class="s2">(</span>
            <span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">] = </span><span class="s1">newblk</span>
        <span class="s1">_clear_blocks</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">body_blocks</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">dispatcher</span>


<span class="s1">call_context </span><span class="s2">= </span><span class="s1">_CallContextType</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">_ObjModeContextType</span><span class="s2">(</span><span class="s1">WithContext</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Creates a contextmanager to be used inside jitted functions to enter 
    *object-mode* for using interpreter features.  The body of the with-context 
    is lifted into a function that is compiled in *object-mode*.  This 
    transformation process is limited and cannot process all possible 
    Python code.  However, users can wrap complicated logic in another 
    Python function, which will then be executed by the interpreter. 
 
    Use this as a function that takes keyword arguments only. 
    The argument names must correspond to the output variables from the 
    with-block.  Their respective values can be: 
 
    1. strings representing the expected types; i.e. ``&quot;float32&quot;``. 
    2. compile-time bound global or nonlocal variables referring to the 
       expected type. The variables are read at compile time. 
 
    When exiting the with-context, the output variables are converted 
    to the expected nopython types according to the annotation.  This process 
    is the same as passing Python objects into arguments of a nopython 
    function. 
 
    Example:: 
 
        import numpy as np 
        from numba import njit, objmode, types 
 
        def bar(x): 
            # This code is executed by the interpreter. 
            return np.asarray(list(reversed(x.tolist()))) 
 
        # Output type as global variable 
        out_ty = types.intp[:] 
 
        @njit 
        def foo(): 
            x = np.arange(5) 
            y = np.zeros_like(x) 
            with objmode(y='intp[:]', z=out_ty):  # annotate return type 
                # this region is executed by object-mode. 
                y += bar(x) 
                z = y 
            return y, z 
 
    .. note:: Known limitations: 
 
        - with-block cannot use incoming list objects. 
        - with-block cannot use incoming function objects. 
        - with-block cannot ``yield``, ``break``, ``return`` or ``raise`` \ 
          such that the execution will leave the with-block immediately. 
        - with-block cannot contain `with` statements. 
        - random number generator states do not synchronize; i.e. \ 
          nopython-mode and object-mode uses different RNG states. 
 
    .. note:: When used outside of no-python mode, the context-manager has no 
        effect. 
 
    .. warning:: This feature is experimental.  The supported features may 
        change with or without notice. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">is_callable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_legalize_args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">func_globals</span><span class="s2">,</span>
                       <span class="s1">func_closures</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Legalize arguments to the context-manager 
 
        Parameters 
        ---------- 
        func_ir: FunctionIR 
        args: tuple 
            Positional arguments to the with-context call as IR nodes. 
        kwargs: dict 
            Keyword arguments to the with-context call as IR nodes. 
        loc: numba.core.ir.Loc 
            Source location of the with-context call. 
        func_globals: dict 
            The globals dictionary of the calling function. 
        func_closures: dict 
            The resolved closure variables of the calling function. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">CompilerError</span><span class="s2">(</span>
                <span class="s5">&quot;objectmode context doesn't take any positional arguments&quot;</span><span class="s2">,</span>
                <span class="s2">)</span>
        <span class="s1">typeanns </span><span class="s2">= {}</span>

        <span class="s0">def </span><span class="s1">report_error</span><span class="s2">(</span><span class="s1">varname</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">CompilerError</span><span class="s2">(</span>
                    <span class="s5">f&quot;Error handling objmode argument </span><span class="s0">{</span><span class="s1">varname</span><span class="s0">!r}</span><span class="s5">. </span><span class="s0">{</span><span class="s1">msg</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">,</span>
                    <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">,</span>
                <span class="s2">)</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Const</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s1">typeanns</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">sigutils</span><span class="s2">.</span><span class="s1">_parse_signature_string</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FreeVar</span><span class="s2">):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">v </span><span class="s2">= </span><span class="s1">func_closures</span><span class="s2">[</span><span class="s1">v</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                    <span class="s1">report_error</span><span class="s2">(</span>
                        <span class="s1">varname</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">f&quot;Freevar </span><span class="s0">{</span><span class="s1">v</span><span class="s2">.</span><span class="s1">name</span><span class="s0">!r} </span><span class="s5">is not defined.&quot;</span><span class="s2">,</span>
                        <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s1">typeanns</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">v</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">v </span><span class="s2">= </span><span class="s1">func_globals</span><span class="s2">[</span><span class="s1">v</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                    <span class="s1">report_error</span><span class="s2">(</span>
                        <span class="s1">varname</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">f&quot;Global </span><span class="s0">{</span><span class="s1">v</span><span class="s2">.</span><span class="s1">name</span><span class="s0">!r} </span><span class="s5">is not defined.&quot;</span><span class="s2">,</span>
                        <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s1">typeanns</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">v</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">) </span><span class="s0">and </span><span class="s1">v</span><span class="s2">.</span><span class="s1">op </span><span class="s2">== </span><span class="s5">&quot;getattr&quot;</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">base_obj </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">infer_constant</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s1">typ </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">base_obj</span><span class="s2">, </span><span class="s1">v</span><span class="s2">.</span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s2">(</span><span class="s1">errors</span><span class="s2">.</span><span class="s1">ConstantInferenceError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">):</span>
                    <span class="s1">report_error</span><span class="s2">(</span>
                        <span class="s1">varname</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                        <span class="s1">msg</span><span class="s2">=</span><span class="s5">&quot;Getattr cannot be resolved at compile-time.&quot;</span><span class="s2">,</span>
                        <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">typeanns</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">typ</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">report_error</span><span class="s2">(</span>
                    <span class="s1">varname</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                    <span class="s1">msg</span><span class="s2">=(</span><span class="s5">&quot;The value must be a compile-time constant either as &quot;</span>
                         <span class="s5">&quot;a non-local variable or a getattr expression that &quot;</span>
                         <span class="s5">&quot;refers to a Numba type.&quot;</span><span class="s2">),</span>
                    <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span>
                <span class="s2">)</span>

        <span class="s4"># Legalize the types for objmode</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">typeanns</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_legalize_arg_type</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">typeanns</span>

    <span class="s0">def </span><span class="s1">_legalize_arg_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Legalize the argument type 
 
        Parameters 
        ---------- 
        name: str 
            argument name. 
        typ: numba.core.types.Type 
            argument type. 
        loc: numba.core.ir.Loc 
            source location for error reporting. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s5">&quot;reflected&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s1">msgbuf </span><span class="s2">= [</span>
                <span class="s5">&quot;Objmode context failed.&quot;</span><span class="s2">,</span>
                <span class="s5">f&quot;Argument </span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r} </span><span class="s5">is declared as &quot;</span>
                <span class="s5">f&quot;an unsupported type: </span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">,</span>
                <span class="s5">f&quot;Reflected types are not supported.&quot;</span><span class="s2">,</span>
            <span class="s2">]</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">CompilerError</span><span class="s2">(</span><span class="s5">&quot; &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">msgbuf</span><span class="s2">), </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">mutate_with_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                         <span class="s1">body_blocks</span><span class="s2">, </span><span class="s1">dispatcher_factory</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">):</span>
        <span class="s1">cellnames </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_freevars</span>
        <span class="s1">closures </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__closure__</span>
        <span class="s1">func_globals </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">func_id</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__globals__</span>
        <span class="s0">if </span><span class="s1">closures </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s4"># Resolve free variables</span>
            <span class="s1">func_closures </span><span class="s2">= {}</span>
            <span class="s0">for </span><span class="s1">cellname</span><span class="s2">, </span><span class="s1">closure </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">cellnames</span><span class="s2">, </span><span class="s1">closures</span><span class="s2">):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">cellval </span><span class="s2">= </span><span class="s1">closure</span><span class="s2">.</span><span class="s1">cell_contents</span>
                <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s4"># empty cell will raise</span>
                    <span class="s0">if </span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) != </span><span class="s5">&quot;Cell is empty&quot;</span><span class="s2">:</span>
                        <span class="s0">raise</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">func_closures</span><span class="s2">[</span><span class="s1">cellname</span><span class="s2">] = </span><span class="s1">cellval</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Missing closure object</span>
            <span class="s1">func_closures </span><span class="s2">= {}</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">extra</span><span class="s2">[</span><span class="s5">'args'</span><span class="s2">] </span><span class="s0">if </span><span class="s1">extra </span><span class="s0">else </span><span class="s2">()</span>
        <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">extra</span><span class="s2">[</span><span class="s5">'kwargs'</span><span class="s2">] </span><span class="s0">if </span><span class="s1">extra </span><span class="s0">else </span><span class="s2">{}</span>

        <span class="s1">typeanns </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_legalize_args</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">=</span><span class="s1">func_ir</span><span class="s2">,</span>
                                       <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
                                       <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
                                       <span class="s1">loc</span><span class="s2">=</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">loc</span><span class="s2">,</span>
                                       <span class="s1">func_globals</span><span class="s2">=</span><span class="s1">func_globals</span><span class="s2">,</span>
                                       <span class="s1">func_closures</span><span class="s2">=</span><span class="s1">func_closures</span><span class="s2">,</span>
                                       <span class="s2">)</span>
        <span class="s1">vlt </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">variable_lifetime</span>

        <span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs </span><span class="s2">= </span><span class="s1">find_region_inout_vars</span><span class="s2">(</span>
            <span class="s1">blocks</span><span class="s2">=</span><span class="s1">blocks</span><span class="s2">,</span>
            <span class="s1">livemap</span><span class="s2">=</span><span class="s1">vlt</span><span class="s2">.</span><span class="s1">livemap</span><span class="s2">,</span>
            <span class="s1">callfrom</span><span class="s2">=</span><span class="s1">blk_start</span><span class="s2">,</span>
            <span class="s1">returnto</span><span class="s2">=</span><span class="s1">blk_end</span><span class="s2">,</span>
            <span class="s1">body_block_ids</span><span class="s2">=</span><span class="s1">set</span><span class="s2">(</span><span class="s1">body_blocks</span><span class="s2">),</span>
            <span class="s2">)</span>

        <span class="s4"># Determine types in the output tuple</span>
        <span class="s0">def </span><span class="s1">strip_var_ver</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">'.'</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s1">stripped_outs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">strip_var_ver</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">))</span>

        <span class="s4"># Verify that only outputs are annotated</span>
        <span class="s1">extra_annotated </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">typeanns</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">stripped_outs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">extra_annotated</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span>
                <span class="s5">'Invalid type annotation on non-outgoing variables: {}.'</span>
                <span class="s5">'Suggestion: remove annotation of the listed variables'</span>
            <span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">extra_annotated</span><span class="s2">))</span>

        <span class="s4"># Verify that all outputs are annotated</span>

        <span class="s4"># Note on &quot;$cp&quot; variable:</span>
        <span class="s4"># ``transforms.consolidate_multi_exit_withs()`` introduces the variable</span>
        <span class="s4"># for the control-point to determine the correct exit block. This</span>
        <span class="s4"># variable crosses the with-region boundary. Thus, it will be consider</span>
        <span class="s4"># an output variable leaving the lifted with-region.</span>
        <span class="s1">typeanns</span><span class="s2">[</span><span class="s5">&quot;$cp&quot;</span><span class="s2">] = </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span>
        <span class="s1">not_annotated </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">stripped_outs</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">typeanns</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">not_annotated</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span>
                <span class="s5">'Missing type annotation on outgoing variable(s): {0}</span><span class="s0">\n\n</span><span class="s5">'</span>
                <span class="s5">'Example code: with objmode({1}=</span><span class="s0">\'</span><span class="s5">&lt;'</span>
                <span class="s5">'add_type_as_string_here&gt;</span><span class="s0">\'</span><span class="s5">)</span><span class="s0">\n</span><span class="s5">'</span>
            <span class="s2">)</span>
            <span class="s1">stable_ann </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">not_annotated</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">stable_ann</span><span class="s2">, </span><span class="s1">stable_ann</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]))</span>

        <span class="s4"># Get output types</span>
        <span class="s1">outtup </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">([</span><span class="s1">typeanns</span><span class="s2">[</span><span class="s1">v</span><span class="s2">] </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">stripped_outs</span><span class="s2">])</span>

        <span class="s1">lifted_blks </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">body_blocks</span><span class="s2">}</span>
        <span class="s1">_mutate_with_block_callee</span><span class="s2">(</span><span class="s1">lifted_blks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                                  <span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">)</span>

        <span class="s1">lifted_ir </span><span class="s2">= </span><span class="s1">func_ir</span><span class="s2">.</span><span class="s1">derive</span><span class="s2">(</span>
            <span class="s1">blocks</span><span class="s2">=</span><span class="s1">lifted_blks</span><span class="s2">,</span>
            <span class="s1">arg_names</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">),</span>
            <span class="s1">arg_count</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">inputs</span><span class="s2">),</span>
            <span class="s1">force_non_generator</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s1">dispatcher </span><span class="s2">= </span><span class="s1">dispatcher_factory</span><span class="s2">(</span><span class="s1">lifted_ir</span><span class="s2">, </span><span class="s1">objectmode</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                        <span class="s1">output_types</span><span class="s2">=</span><span class="s1">outtup</span><span class="s2">)</span>

        <span class="s1">newblk </span><span class="s2">= </span><span class="s1">_mutate_with_block_caller</span><span class="s2">(</span>
            <span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">] = </span><span class="s1">newblk</span>
        <span class="s1">_clear_blocks</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">body_blocks</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">dispatcher</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4"># No effect when used in pure-python</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s1">objmode_context </span><span class="s2">= </span><span class="s1">_ObjModeContextType</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_bypass_with_context</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">forwardvars</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Given the starting and ending block of the with-context, 
    replaces the head block with a new block that jumps to the end. 
 
    *blocks* is modified inplace. 
    &quot;&quot;&quot;</span>
    <span class="s1">sblk </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">]</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">sblk</span><span class="s2">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s2">= </span><span class="s1">sblk</span><span class="s2">.</span><span class="s1">loc</span>
    <span class="s1">newblk </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">forwardvars</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">newblk</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">value</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">.</span><span class="s1">get_exact</span><span class="s2">(</span><span class="s1">k</span><span class="s2">),</span>
                                <span class="s1">target</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">.</span><span class="s1">get_exact</span><span class="s2">(</span><span class="s1">v</span><span class="s2">),</span>
                                <span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">))</span>
    <span class="s1">newblk</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Jump</span><span class="s2">(</span><span class="s1">target</span><span class="s2">=</span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">))</span>
    <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">] = </span><span class="s1">newblk</span>


<span class="s0">def </span><span class="s1">_mutate_with_block_caller</span><span class="s2">(</span><span class="s1">dispatcher</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                              <span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Make a new block that calls into the lifeted with-context. 
 
    Parameters 
    ---------- 
    dispatcher : Dispatcher 
    blocks : dict[ir.Block] 
    blk_start, blk_end : int 
        labels of the starting and ending block of the context-manager. 
    inputs: sequence[str] 
        Input variable names 
    outputs: sequence[str] 
        Output variable names 
    &quot;&quot;&quot;</span>
    <span class="s1">sblk </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">]</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">sblk</span><span class="s2">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s2">= </span><span class="s1">sblk</span><span class="s2">.</span><span class="s1">loc</span>
    <span class="s1">newblock </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">)</span>

    <span class="s1">ir_utils</span><span class="s2">.</span><span class="s1">fill_block_with_call</span><span class="s2">(</span>
        <span class="s1">newblock</span><span class="s2">=</span><span class="s1">newblock</span><span class="s2">,</span>
        <span class="s1">callee</span><span class="s2">=</span><span class="s1">dispatcher</span><span class="s2">,</span>
        <span class="s1">label_next</span><span class="s2">=</span><span class="s1">blk_end</span><span class="s2">,</span>
        <span class="s1">inputs</span><span class="s2">=</span><span class="s1">inputs</span><span class="s2">,</span>
        <span class="s1">outputs</span><span class="s2">=</span><span class="s1">outputs</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">newblock</span>


<span class="s0">def </span><span class="s1">_mutate_with_block_callee</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">, </span><span class="s1">inputs</span><span class="s2">, </span><span class="s1">outputs</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Mutate *blocks* for the callee of a with-context. 
 
    Parameters 
    ---------- 
    blocks : dict[ir.Block] 
    blk_start, blk_end : int 
        labels of the starting and ending block of the context-manager. 
    inputs: sequence[str] 
        Input variable names 
    outputs: sequence[str] 
        Output variable names 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">blocks</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaValueError</span><span class="s2">(</span><span class="s5">&quot;No blocks in with-context block&quot;</span><span class="s2">)</span>
    <span class="s1">head_blk </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">)</span>
    <span class="s1">temp_blk </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">head_blk</span><span class="s2">]</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">temp_blk</span><span class="s2">.</span><span class="s1">scope</span>
    <span class="s1">loc </span><span class="s2">= </span><span class="s1">temp_blk</span><span class="s2">.</span><span class="s1">loc</span>

    <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">] = </span><span class="s1">ir_utils</span><span class="s2">.</span><span class="s1">fill_callee_prologue</span><span class="s2">(</span>
        <span class="s1">block</span><span class="s2">=</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">),</span>
        <span class="s1">inputs</span><span class="s2">=</span><span class="s1">inputs</span><span class="s2">,</span>
        <span class="s1">label_next</span><span class="s2">=</span><span class="s1">head_blk</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_end</span><span class="s2">] = </span><span class="s1">ir_utils</span><span class="s2">.</span><span class="s1">fill_callee_epilogue</span><span class="s2">(</span>
        <span class="s1">block</span><span class="s2">=</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">=</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">),</span>
        <span class="s1">outputs</span><span class="s2">=</span><span class="s1">outputs</span><span class="s2">,</span>
    <span class="s2">)</span>

<span class="s0">class </span><span class="s1">_ParallelChunksize</span><span class="s2">(</span><span class="s1">WithContext</span><span class="s2">):</span>
    <span class="s1">is_callable </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s5">&quot;&quot;&quot;A context-manager that on entry stores the current chunksize 
    for the executing parfors and then changes the current chunksize 
    to the programmer specified value. On exit the original 
    chunksize is restored. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">mutate_with_body</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func_ir</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">blk_start</span><span class="s2">, </span><span class="s1">blk_end</span><span class="s2">,</span>
                         <span class="s1">body_blocks</span><span class="s2">, </span><span class="s1">dispatcher_factory</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">):</span>
        <span class="s1">ir_utils</span><span class="s2">.</span><span class="s1">dprint_func_ir</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s5">&quot;Before with changes&quot;</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">=</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">extra </span><span class="s0">is not None</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">extra</span><span class="s2">[</span><span class="s5">&quot;args&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s6">1</span>
        <span class="s1">arg </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">scope </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">scope</span>
        <span class="s1">loc </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">loc</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Arg</span><span class="s2">):</span>
            <span class="s1">arg </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Var</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">set_state </span><span class="s2">= []</span>
        <span class="s1">restore_state </span><span class="s2">= []</span>

        <span class="s4"># global for Numba itself</span>
        <span class="s1">gvar </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">&quot;$ngvar&quot;</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">set_state</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Global</span><span class="s2">(</span><span class="s5">'numba'</span><span class="s2">, </span><span class="s1">numba</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">), </span><span class="s1">gvar</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>
        <span class="s4"># getattr for set chunksize function in Numba</span>
        <span class="s1">spcattr </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">gvar</span><span class="s2">, </span><span class="s5">'set_parallel_chunksize'</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">spcvar </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">&quot;$spc&quot;</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">set_state</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">spcattr</span><span class="s2">, </span><span class="s1">spcvar</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>
        <span class="s4"># call set_parallel_chunksize</span>
        <span class="s1">orig_pc_var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">&quot;$save_pc&quot;</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">cs_var </span><span class="s2">= </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">redefine</span><span class="s2">(</span><span class="s5">&quot;$cs_var&quot;</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">set_state</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">cs_var</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>
        <span class="s1">spc_call </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">spcvar</span><span class="s2">, [</span><span class="s1">cs_var</span><span class="s2">], (), </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">set_state</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">spc_call</span><span class="s2">, </span><span class="s1">orig_pc_var</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>

        <span class="s1">restore_spc_call </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Expr</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">spcvar</span><span class="s2">, [</span><span class="s1">orig_pc_var</span><span class="s2">], (), </span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">restore_state</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">Assign</span><span class="s2">(</span><span class="s1">restore_spc_call</span><span class="s2">, </span><span class="s1">orig_pc_var</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>

        <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">body </span><span class="s2">= (</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">body</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] + </span>
                                  <span class="s1">set_state </span><span class="s2">+ </span>
                                  <span class="s2">[</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_start</span><span class="s2">].</span><span class="s1">body</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]])</span>
        <span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_end</span><span class="s2">].</span><span class="s1">body </span><span class="s2">= </span><span class="s1">restore_state </span><span class="s2">+ </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blk_end</span><span class="s2">].</span><span class="s1">body</span>
        <span class="s1">func_ir</span><span class="s2">.</span><span class="s1">_definitions </span><span class="s2">= </span><span class="s1">build_definitions</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">ir_utils</span><span class="s2">.</span><span class="s1">dprint_func_ir</span><span class="s2">(</span><span class="s1">func_ir</span><span class="s2">, </span><span class="s5">&quot;After with changes&quot;</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">=</span><span class="s1">blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Act like a function and enforce the contract that 
        setting the chunksize takes only one integer input. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) != </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">kwargs </span><span class="s0">or not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;parallel_chunksize takes only a &quot;</span>
                             <span class="s5">&quot;single integer argument.&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">chunksize </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__enter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">orig_chunksize </span><span class="s2">= </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">get_parallel_chunksize</span><span class="s2">()</span>
        <span class="s1">numba</span><span class="s2">.</span><span class="s1">set_parallel_chunksize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">chunksize</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__exit__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">):</span>
        <span class="s1">numba</span><span class="s2">.</span><span class="s1">set_parallel_chunksize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">orig_chunksize</span><span class="s2">)</span>

<span class="s1">parallel_chunksize </span><span class="s2">= </span><span class="s1">_ParallelChunksize</span><span class="s2">()</span>
</pre>
</body>
</html>