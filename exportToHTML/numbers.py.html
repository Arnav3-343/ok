<html>
<head>
<title>numbers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
numbers.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">numbers</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir</span>
<span class="s0">from </span><span class="s1">llvmlite</span><span class="s2">.</span><span class="s1">ir </span><span class="s0">import </span><span class="s1">Constant</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">imputils </span><span class="s0">import </span><span class="s1">impl_ret_untracked</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">typing</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">cgutils</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython</span><span class="s2">.</span><span class="s1">unsafe</span><span class="s2">.</span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">viewer</span>

<span class="s0">def </span><span class="s1">_int_arith_flags</span><span class="s2">(</span><span class="s1">rettype</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return the modifier flags for integer arithmetic. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">rettype</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s4"># Ignore the effects of signed overflow.  This is important for</span>
        <span class="s4"># optimization of some indexing operations.  For example</span>
        <span class="s4"># array[i+1] could see `i+1` trigger a signed overflow and</span>
        <span class="s4"># give a negative number.  With Python's indexing, a negative</span>
        <span class="s4"># index is treated differently: its resolution has a runtime cost.</span>
        <span class="s4"># Telling LLVM to ignore signed overflows allows it to optimize</span>
        <span class="s4"># away the check for a negative `i+1` if it knows `i` is positive.</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s5">'nsw'</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">[]</span>


<span class="s0">def </span><span class="s1">int_add_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">va</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">ta</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ta</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">=</span><span class="s1">_int_arith_flags</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_sub_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">va</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">ta</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ta</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">=</span><span class="s1">_int_arith_flags</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_mul_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">va</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">ta</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ta</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">=</span><span class="s1">_int_arith_flags</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_divmod_signed</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Reference Objects/intobject.c 
    xdivy = x / y; 
    xmody = (long)(x - (unsigned long)xdivy * y); 
    /* If the signs of x and y differ, and the remainder is non-0, 
     * C89 doesn't define whether xdivy is now the floor or the 
     * ceiling of the infinitely precise quotient.  We want the floor, 
     * and we have it iff the remainder's sign matches y's. 
     */ 
    if (xmody &amp;&amp; ((y ^ xmody) &lt; 0) /* i.e. and signs differ */) { 
        xmody += y; 
        --xdivy; 
        assert(xmody &amp;&amp; ((y ^ xmody) &gt;= 0)); 
    } 
    *p_xdivy = xdivy; 
    *p_xmody = xmody; 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span>

    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">ONE </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s4"># NOTE: On x86 at least, dividing the lowest representable integer</span>
    <span class="s4"># (e.g. 0x80000000 for int32) by -1 causes a SIFGPE (division overflow),</span>
    <span class="s4"># causing the process to crash.</span>
    <span class="s4"># We return 0, 0 instead (more or less like Numpy).</span>

    <span class="s1">resdiv </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once_value</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">resmod </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once_value</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>

    <span class="s1">is_overflow </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">(</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">.</span><span class="s1">minval</span><span class="s2">)),</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">)))</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_then</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">not_</span><span class="s2">(</span><span class="s1">is_overflow</span><span class="s2">), </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s4"># Note LLVM will optimize this to a single divmod instruction,</span>
        <span class="s4"># if available on the target CPU (e.g. x86).</span>
        <span class="s1">xdivy </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sdiv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">xmody </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">srem</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s1">y_xor_xmody_ltz </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">xor</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">xmody</span><span class="s2">), </span><span class="s1">ZERO</span><span class="s2">)</span>
        <span class="s1">xmody_istrue </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">xmody</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
        <span class="s1">cond </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">(</span><span class="s1">xmody_istrue</span><span class="s2">, </span><span class="s1">y_xor_xmody_ltz</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">cond</span><span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_different_signs</span><span class="s2">, </span><span class="s1">if_same_signs</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">if_same_signs</span><span class="s2">:</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">xdivy</span><span class="s2">, </span><span class="s1">resdiv</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">xmody</span><span class="s2">, </span><span class="s1">resmod</span><span class="s2">)</span>

            <span class="s0">with </span><span class="s1">if_different_signs</span><span class="s2">:</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s1">xdivy</span><span class="s2">, </span><span class="s1">ONE</span><span class="s2">), </span><span class="s1">resdiv</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">xmody</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">resmod</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">resdiv</span><span class="s2">), </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">resmod</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Integer divmod(x, y).  The caller must ensure that y != 0. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">int_divmod_signed</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">udiv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">urem</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_int_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">zerodiv_message</span><span class="s2">):</span>
    <span class="s1">va</span><span class="s2">, </span><span class="s1">vb </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">ta</span><span class="s2">, </span><span class="s1">tb </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>

    <span class="s1">ty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">UniTuple</span><span class="s2">):</span>
        <span class="s1">ty </span><span class="s2">= </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">dtype</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ta</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">quot </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;quot&quot;</span><span class="s2">)</span>
    <span class="s1">rem </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;rem&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_scalar_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">False</span>
                         <span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_zero</span><span class="s2">, </span><span class="s1">if_non_zero</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">if_zero</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span>
                <span class="s1">builder</span><span class="s2">, (</span><span class="s1">zerodiv_message</span><span class="s2">,)):</span>
                <span class="s4"># No exception raised =&gt; return 0</span>
                <span class="s4"># XXX We should also set the FPU exception status, but</span>
                <span class="s4"># there's no easy way to do that from LLVM.</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">quot</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">rem</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">if_non_zero</span><span class="s2">:</span>
            <span class="s1">q</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">int_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">quot</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">rem</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">quot</span><span class="s2">, </span><span class="s1">rem</span>


<span class="s4"># @lower_builtin(divmod, types.Integer, types.Integer)</span>
<span class="s0">def </span><span class="s1">int_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">quot</span><span class="s2">, </span><span class="s1">rem </span><span class="s2">= </span><span class="s1">_int_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">,</span>
                                 <span class="s5">&quot;integer divmod by zero&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">pack_array</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">,</span>
                              <span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">quot</span><span class="s2">), </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">rem</span><span class="s2">)))</span>


<span class="s4"># @lower_builtin(operator.floordiv, types.Integer, types.Integer)</span>
<span class="s4"># @lower_builtin(operator.ifloordiv, types.Integer, types.Integer)</span>
<span class="s0">def </span><span class="s1">int_floordiv_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">quot</span><span class="s2">, </span><span class="s1">rem </span><span class="s2">= </span><span class="s1">_int_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">,</span>
                                 <span class="s5">&quot;integer division by zero&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">quot</span><span class="s2">)</span>


<span class="s4"># @lower_builtin(operator.truediv, types.Integer, types.Integer)</span>
<span class="s4"># @lower_builtin(operator.itruediv, types.Integer, types.Integer)</span>
<span class="s0">def </span><span class="s1">int_truediv_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">va</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">ta</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ta</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vb</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">if_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
        <span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, (</span><span class="s5">&quot;division by zero&quot;</span><span class="s2">,))</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s4"># @lower_builtin(operator.mod, types.Integer, types.Integer)</span>
<span class="s4"># @lower_builtin(operator.imod, types.Integer, types.Integer)</span>
<span class="s0">def </span><span class="s1">int_rem_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">quot</span><span class="s2">, </span><span class="s1">rem </span><span class="s2">= </span><span class="s1">_int_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">,</span>
                                 <span class="s5">&quot;integer modulo by zero&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">rem</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_power_zerodiv_return</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)</span>
        <span class="s0">and not </span><span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">raise_on_fp_zero_division</span><span class="s2">):</span>
        <span class="s4"># If not raising, return 0x8000... when computing 0 ** &lt;negative number&gt;</span>
        <span class="s0">return </span><span class="s2">-</span><span class="s6">1 </span><span class="s2">&lt;&lt; (</span><span class="s1">return_type</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">- </span><span class="s6">1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">int_power_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    a ^ b, where a is an integer or real, and b an integer 
    &quot;&quot;&quot;</span>
    <span class="s1">is_integer </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)</span>
    <span class="s1">tp </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span>
    <span class="s1">zerodiv_return </span><span class="s2">= </span><span class="s1">_get_power_zerodiv_return</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">int_power</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
        <span class="s4"># Ensure computations are done with a large enough width</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">tp</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">tp</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">b </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">invert </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">exp </span><span class="s2">= -</span><span class="s1">b</span>
            <span class="s0">if </span><span class="s1">exp </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">OverflowError</span>
            <span class="s0">if </span><span class="s1">is_integer</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">a </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">zerodiv_return</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">zerodiv_return</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">ZeroDivisionError</span><span class="s2">(</span><span class="s5">&quot;0 cannot be raised to a negative power&quot;</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">a </span><span class="s2">!= </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">a </span><span class="s2">!= -</span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s6">0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">invert </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">exp </span><span class="s2">= </span><span class="s1">b</span>
        <span class="s0">if </span><span class="s1">exp </span><span class="s2">&gt; </span><span class="s6">0x10000</span><span class="s2">:</span>
            <span class="s4"># Optimization cutoff: fallback on the generic algorithm</span>
            <span class="s0">return </span><span class="s1">math</span><span class="s2">.</span><span class="s1">pow</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">float</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>
        <span class="s0">while </span><span class="s1">exp </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">exp </span><span class="s2">&amp; </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">r </span><span class="s2">*= </span><span class="s1">a</span>
            <span class="s1">exp </span><span class="s2">&gt;&gt;= </span><span class="s6">1</span>
            <span class="s1">a </span><span class="s2">*= </span><span class="s1">a</span>

        <span class="s0">return </span><span class="s6">1.0 </span><span class="s2">/ </span><span class="s1">r </span><span class="s0">if </span><span class="s1">invert </span><span class="s0">else </span><span class="s1">r</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">int_power</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s4"># @lower_builtin(operator.pow, types.Integer, types.IntegerLiteral)</span>
<span class="s4"># @lower_builtin(operator.ipow, types.Integer, types.IntegerLiteral)</span>
<span class="s4"># @lower_builtin(operator.pow, types.Float, types.IntegerLiteral)</span>
<span class="s4"># @lower_builtin(operator.ipow, types.Float, types.IntegerLiteral)</span>
<span class="s0">def </span><span class="s1">static_power_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    a ^ b, where a is an integer or real, and b a constant integer 
    &quot;&quot;&quot;</span>
    <span class="s1">exp </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">].</span><span class="s1">value</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">, </span><span class="s1">numbers</span><span class="s2">.</span><span class="s1">Integral</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>
    <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">) &gt; </span><span class="s6">0x10000</span><span class="s2">:</span>
        <span class="s4"># Optimization cutoff: fallback on the generic algorithm above</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>
    <span class="s1">invert </span><span class="s2">= </span><span class="s1">exp </span><span class="s2">&lt; </span><span class="s6">0</span>
    <span class="s1">exp </span><span class="s2">= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">exp</span><span class="s2">)</span>

    <span class="s1">tp </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span>
    <span class="s1">is_integer </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">)</span>
    <span class="s1">zerodiv_return </span><span class="s2">= </span><span class="s1">_get_power_zerodiv_return</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">)</span>

    <span class="s1">val </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">tp</span><span class="s2">)</span>
    <span class="s1">lty </span><span class="s2">= </span><span class="s1">val</span><span class="s2">.</span><span class="s1">type</span>

    <span class="s0">def </span><span class="s1">mul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">is_integer</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">mul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s4"># Unroll the exponentiation loop</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">lty</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">val</span>
    <span class="s0">while </span><span class="s1">exp </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">exp </span><span class="s2">&amp; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">mul</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s1">exp </span><span class="s2">&gt;&gt;= </span><span class="s6">1</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">mul</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">invert</span><span class="s2">:</span>
        <span class="s4"># If the exponent was negative, fix the result by inverting it</span>
        <span class="s0">if </span><span class="s1">is_integer</span><span class="s2">:</span>
            <span class="s4"># Integer inversion</span>
            <span class="s0">def </span><span class="s1">invert_impl</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">a </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">zerodiv_return</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">zerodiv_return</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">ZeroDivisionError</span><span class="s2">(</span><span class="s5">&quot;0 cannot be raised to a negative power&quot;</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">a </span><span class="s2">!= </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">a </span><span class="s2">!= -</span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s6">0</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">a</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Real inversion</span>
            <span class="s0">def </span><span class="s1">invert_impl</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s6">1.0 </span><span class="s2">/ </span><span class="s1">a</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">invert_impl</span><span class="s2">,</span>
                                       <span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">), (</span><span class="s1">res</span><span class="s2">,))</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">int_slt_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_sle_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_sgt_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_sge_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&gt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_ult_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_ule_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'&lt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_ugt_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_uge_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'&gt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_eq_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_ne_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_signed_unsigned_cmp</span><span class="s2">(</span><span class="s1">op</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">) = </span><span class="s1">args</span>
        <span class="s4"># This code is translated from the NumPy source.</span>
        <span class="s4"># What we're going to do is divide the range of a signed value at zero.</span>
        <span class="s4"># If the signed value is less than zero, then we can treat zero as the</span>
        <span class="s4"># unsigned value since the unsigned value is necessarily zero or larger</span>
        <span class="s4"># and any signed comparison between a negative value and zero/infinity</span>
        <span class="s4"># will yield the same result. If the signed value is greater than or</span>
        <span class="s4"># equal to zero, then we can safely cast it to an unsigned value and do</span>
        <span class="s4"># the expected unsigned-unsigned comparison operation.</span>
        <span class="s4"># Original: https://github.com/numpy/numpy/pull/23713</span>
        <span class="s1">cmp_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">))</span>
        <span class="s1">lt_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">))</span>
        <span class="s1">ge_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">select</span><span class="s2">(</span><span class="s1">cmp_zero</span><span class="s2">, </span><span class="s1">lt_zero</span><span class="s2">, </span><span class="s1">ge_zero</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl</span>


<span class="s0">def </span><span class="s1">int_unsigned_signed_cmp</span><span class="s2">(</span><span class="s1">op</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">) = </span><span class="s1">args</span>
        <span class="s4"># See the function `int_signed_unsigned_cmp` for implementation notes.</span>
        <span class="s1">cmp_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">))</span>
        <span class="s1">lt_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">), </span><span class="s1">right</span><span class="s2">)</span>
        <span class="s1">ge_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">select</span><span class="s2">(</span><span class="s1">cmp_zero</span><span class="s2">, </span><span class="s1">lt_zero</span><span class="s2">, </span><span class="s1">ge_zero</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl</span>


<span class="s0">def </span><span class="s1">int_abs_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">ltz </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">negated </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">neg</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">select</span><span class="s2">(</span><span class="s1">ltz</span><span class="s2">, </span><span class="s1">negated</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">uint_abs_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_shl_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">valty</span><span class="s2">, </span><span class="s1">amtty</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">val </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">valty</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">amt </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">, </span><span class="s1">amtty</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">shl</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_shr_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">valty</span><span class="s2">, </span><span class="s1">amtty</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">val </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">valty</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">amt </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">, </span><span class="s1">amtty</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">ashr</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">lshr</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">amt</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_and_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">at</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">av</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">cav </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">av</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">cbc </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">(</span><span class="s1">cav</span><span class="s2">, </span><span class="s1">cbc</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_or_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">at</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">av</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">cav </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">av</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">cbc </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">(</span><span class="s1">cav</span><span class="s2">, </span><span class="s1">cbc</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_xor_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">at</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">av</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">cav </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">av</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">cbc </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">xor</span><span class="s2">(</span><span class="s1">cav</span><span class="s2">, </span><span class="s1">cbc</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_negate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s4"># Negate before upcasting, for unsigned numbers</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">neg</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_positive_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_invert_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s4"># Invert before upcasting, for unsigned numbers</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">xor</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">int</span><span class="s2">(</span><span class="s5">'1' </span><span class="s2">* </span><span class="s1">val</span><span class="s2">.</span><span class="s1">type</span><span class="s2">.</span><span class="s1">width</span><span class="s2">, </span><span class="s6">2</span><span class="s2">)))</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">int_sign_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    np.sign(int) 
    &quot;&quot;&quot;</span>
    <span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">POS </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">NEG </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">cmp_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">cmp_pos </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_signed</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>

    <span class="s1">presult </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>

    <span class="s1">bb_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">&quot;.zero&quot;</span><span class="s2">)</span>
    <span class="s1">bb_postest </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">&quot;.postest&quot;</span><span class="s2">)</span>
    <span class="s1">bb_pos </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">&quot;.pos&quot;</span><span class="s2">)</span>
    <span class="s1">bb_neg </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">&quot;.neg&quot;</span><span class="s2">)</span>
    <span class="s1">bb_exit </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">&quot;.exit&quot;</span><span class="s2">)</span>

    <span class="s1">builder</span><span class="s2">.</span><span class="s1">cbranch</span><span class="s2">(</span><span class="s1">cmp_zero</span><span class="s2">, </span><span class="s1">bb_zero</span><span class="s2">, </span><span class="s1">bb_postest</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb_zero</span><span class="s2">):</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">ZERO</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">branch</span><span class="s2">(</span><span class="s1">bb_exit</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb_postest</span><span class="s2">):</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">cbranch</span><span class="s2">(</span><span class="s1">cmp_pos</span><span class="s2">, </span><span class="s1">bb_pos</span><span class="s2">, </span><span class="s1">bb_neg</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb_pos</span><span class="s2">):</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">POS</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">branch</span><span class="s2">(</span><span class="s1">bb_exit</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">goto_block</span><span class="s2">(</span><span class="s1">bb_neg</span><span class="s2">):</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">NEG</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">branch</span><span class="s2">(</span><span class="s1">bb_exit</span><span class="s2">)</span>

    <span class="s1">builder</span><span class="s2">.</span><span class="s1">position_at_end</span><span class="s2">(</span><span class="s1">bb_exit</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">presult</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">bool_negate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">neg</span><span class="s2">(</span><span class="s1">res</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">bool_unary_positive_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s4"># lower_builtin(operator.eq, types.boolean, types.boolean)(int_eq_impl)</span>
<span class="s4"># lower_builtin(operator.ne, types.boolean, types.boolean)(int_ne_impl)</span>
<span class="s4"># lower_builtin(operator.lt, types.boolean, types.boolean)(int_ult_impl)</span>
<span class="s4"># lower_builtin(operator.le, types.boolean, types.boolean)(int_ule_impl)</span>
<span class="s4"># lower_builtin(operator.gt, types.boolean, types.boolean)(int_ugt_impl)</span>
<span class="s4"># lower_builtin(operator.ge, types.boolean, types.boolean)(int_uge_impl)</span>
<span class="s4"># lower_builtin(operator.neg, types.boolean)(bool_negate_impl)</span>
<span class="s4"># lower_builtin(operator.pos, types.boolean)(bool_unary_positive_impl)</span>


<span class="s4"># def _implement_integer_operators():</span>
<span class="s4">#     ty = types.Integer</span>

<span class="s4">#     lower_builtin(operator.add, ty, ty)(int_add_impl)</span>
<span class="s4">#     lower_builtin(operator.iadd, ty, ty)(int_add_impl)</span>
<span class="s4">#     lower_builtin(operator.sub, ty, ty)(int_sub_impl)</span>
<span class="s4">#     lower_builtin(operator.isub, ty, ty)(int_sub_impl)</span>
<span class="s4">#     lower_builtin(operator.mul, ty, ty)(int_mul_impl)</span>
<span class="s4">#     lower_builtin(operator.imul, ty, ty)(int_mul_impl)</span>
<span class="s4">#     lower_builtin(operator.eq, ty, ty)(int_eq_impl)</span>
<span class="s4">#     lower_builtin(operator.ne, ty, ty)(int_ne_impl)</span>

<span class="s4">#     lower_builtin(operator.lshift, ty, ty)(int_shl_impl)</span>
<span class="s4">#     lower_builtin(operator.ilshift, ty, ty)(int_shl_impl)</span>
<span class="s4">#     lower_builtin(operator.rshift, ty, ty)(int_shr_impl)</span>
<span class="s4">#     lower_builtin(operator.irshift, ty, ty)(int_shr_impl)</span>

<span class="s4">#     lower_builtin(operator.neg, ty)(int_negate_impl)</span>
<span class="s4">#     lower_builtin(operator.pos, ty)(int_positive_impl)</span>

<span class="s4">#     lower_builtin(operator.pow, ty, ty)(int_power_impl)</span>
<span class="s4">#     lower_builtin(operator.ipow, ty, ty)(int_power_impl)</span>
<span class="s4">#     lower_builtin(pow, ty, ty)(int_power_impl)</span>

<span class="s4">#     for ty in types.unsigned_domain:</span>
<span class="s4">#         lower_builtin(operator.lt, ty, ty)(int_ult_impl)</span>
<span class="s4">#         lower_builtin(operator.le, ty, ty)(int_ule_impl)</span>
<span class="s4">#         lower_builtin(operator.gt, ty, ty)(int_ugt_impl)</span>
<span class="s4">#         lower_builtin(operator.ge, ty, ty)(int_uge_impl)</span>
<span class="s4">#         lower_builtin(operator.pow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(operator.ipow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(pow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(abs, ty)(uint_abs_impl)</span>

<span class="s4">#     lower_builtin(operator.lt, types.IntegerLiteral, types.IntegerLiteral)(int_slt_impl)</span>
<span class="s4">#     lower_builtin(operator.gt, types.IntegerLiteral, types.IntegerLiteral)(int_slt_impl)</span>
<span class="s4">#     lower_builtin(operator.le, types.IntegerLiteral, types.IntegerLiteral)(int_slt_impl)</span>
<span class="s4">#     lower_builtin(operator.ge, types.IntegerLiteral, types.IntegerLiteral)(int_slt_impl)</span>
<span class="s4">#     for ty in types.signed_domain:</span>
<span class="s4">#         lower_builtin(operator.lt, ty, ty)(int_slt_impl)</span>
<span class="s4">#         lower_builtin(operator.le, ty, ty)(int_sle_impl)</span>
<span class="s4">#         lower_builtin(operator.gt, ty, ty)(int_sgt_impl)</span>
<span class="s4">#         lower_builtin(operator.ge, ty, ty)(int_sge_impl)</span>
<span class="s4">#         lower_builtin(operator.pow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(operator.ipow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(pow, types.Float, ty)(int_power_impl)</span>
<span class="s4">#         lower_builtin(abs, ty)(int_abs_impl)</span>

<span class="s4"># def _implement_bitwise_operators():</span>
<span class="s4">#     for ty in (types.Boolean, types.Integer):</span>
<span class="s4">#         lower_builtin(operator.and_, ty, ty)(int_and_impl)</span>
<span class="s4">#         lower_builtin(operator.iand, ty, ty)(int_and_impl)</span>
<span class="s4">#         lower_builtin(operator.or_, ty, ty)(int_or_impl)</span>
<span class="s4">#         lower_builtin(operator.ior, ty, ty)(int_or_impl)</span>
<span class="s4">#         lower_builtin(operator.xor, ty, ty)(int_xor_impl)</span>
<span class="s4">#         lower_builtin(operator.ixor, ty, ty)(int_xor_impl)</span>

<span class="s4">#         lower_builtin(operator.invert, ty)(int_invert_impl)</span>

<span class="s4"># _implement_integer_operators()</span>

<span class="s4"># _implement_bitwise_operators()</span>


<span class="s0">def </span><span class="s1">real_add_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_sub_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_mul_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_div_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">if_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
        <span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, (</span><span class="s5">&quot;division by zero&quot;</span><span class="s2">,))</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span>
    <span class="s1">floatty </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span>

    <span class="s1">module </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
    <span class="s1">fname </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">mangler</span><span class="s2">(</span><span class="s5">&quot;.numba.python.rem&quot;</span><span class="s2">, [</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">])</span>
    <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">floatty</span><span class="s2">, (</span><span class="s1">floatty</span><span class="s2">, </span><span class="s1">floatty</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">PointerType</span><span class="s2">(</span><span class="s1">floatty</span><span class="s2">)))</span>
    <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">is_declaration</span><span class="s2">:</span>
        <span class="s1">fn</span><span class="s2">.</span><span class="s1">linkage </span><span class="s2">= </span><span class="s5">'linkonce_odr'</span>
        <span class="s1">fnbuilder </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IRBuilder</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">append_basic_block</span><span class="s2">(</span><span class="s5">'entry'</span><span class="s2">))</span>
        <span class="s1">fx</span><span class="s2">, </span><span class="s1">fy</span><span class="s2">, </span><span class="s1">pmod </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">div</span><span class="s2">, </span><span class="s1">mod </span><span class="s2">= </span><span class="s1">real_divmod_func_body</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">fnbuilder</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">fy</span><span class="s2">)</span>
        <span class="s1">fnbuilder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">pmod</span><span class="s2">)</span>
        <span class="s1">fnbuilder</span><span class="s2">.</span><span class="s1">ret</span><span class="s2">(</span><span class="s1">div</span><span class="s2">)</span>

    <span class="s1">pmod </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">floatty</span><span class="s2">)</span>
    <span class="s1">quotient </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">pmod</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">quotient</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">pmod</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_divmod_func_body</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vx</span><span class="s2">, </span><span class="s1">wx</span><span class="s2">):</span>
    <span class="s4"># Reference Objects/floatobject.c</span>
    <span class="s4">#</span>
    <span class="s4"># float_divmod(PyObject *v, PyObject *w)</span>
    <span class="s4"># {</span>
    <span class="s4">#     double vx, wx;</span>
    <span class="s4">#     double div, mod, floordiv;</span>
    <span class="s4">#     CONVERT_TO_DOUBLE(v, vx);</span>
    <span class="s4">#     CONVERT_TO_DOUBLE(w, wx);</span>
    <span class="s4">#     mod = fmod(vx, wx);</span>
    <span class="s4">#     /* fmod is typically exact, so vx-mod is *mathematically* an</span>
    <span class="s4">#        exact multiple of wx.  But this is fp arithmetic, and fp</span>
    <span class="s4">#        vx - mod is an approximation; the result is that div may</span>
    <span class="s4">#        not be an exact integral value after the division, although</span>
    <span class="s4">#        it will always be very close to one.</span>
    <span class="s4">#     */</span>
    <span class="s4">#     div = (vx - mod) / wx;</span>
    <span class="s4">#     if (mod) {</span>
    <span class="s4">#         /* ensure the remainder has the same sign as the denominator */</span>
    <span class="s4">#         if ((wx &lt; 0) != (mod &lt; 0)) {</span>
    <span class="s4">#             mod += wx;</span>
    <span class="s4">#             div -= 1.0;</span>
    <span class="s4">#         }</span>
    <span class="s4">#     }</span>
    <span class="s4">#     else {</span>
    <span class="s4">#         /* the remainder is zero, and in the presence of signed zeroes</span>
    <span class="s4">#            fmod returns different results across platforms; ensure</span>
    <span class="s4">#            it has the same sign as the denominator; we'd like to do</span>
    <span class="s4">#            &quot;mod = wx * 0.0&quot;, but that may get optimized away */</span>
    <span class="s4">#         mod *= mod;  /* hide &quot;mod = +0&quot; from optimizer */</span>
    <span class="s4">#         if (wx &lt; 0.0)</span>
    <span class="s4">#             mod = -mod;</span>
    <span class="s4">#     }</span>
    <span class="s4">#     /* snap quotient to nearest integral value */</span>
    <span class="s4">#     if (div) {</span>
    <span class="s4">#         floordiv = floor(div);</span>
    <span class="s4">#         if (div - floordiv &gt; 0.5)</span>
    <span class="s4">#             floordiv += 1.0;</span>
    <span class="s4">#     }</span>
    <span class="s4">#     else {</span>
    <span class="s4">#         /* div is zero - get the same sign as the true quotient */</span>
    <span class="s4">#         div *= div;             /* hide &quot;div = +0&quot; from optimizers */</span>
    <span class="s4">#         floordiv = div * vx / wx; /* zero w/ sign of vx/wx */</span>
    <span class="s4">#     }</span>
    <span class="s4">#     return Py_BuildValue(&quot;(dd)&quot;, floordiv, mod);</span>
    <span class="s4"># }</span>
    <span class="s1">pmod </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
    <span class="s1">pdiv </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
    <span class="s1">pfloordiv </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>

    <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">frem</span><span class="s2">(</span><span class="s1">vx</span><span class="s2">, </span><span class="s1">wx</span><span class="s2">)</span>
    <span class="s1">div </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">vx</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">), </span><span class="s1">wx</span><span class="s2">)</span>

    <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">pmod</span><span class="s2">)</span>
    <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">pdiv</span><span class="s2">)</span>

    <span class="s4"># Note the use of negative zero for proper negating with `ZERO - x`</span>
    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s6">0.0</span><span class="s2">)</span>
    <span class="s1">NZERO </span><span class="s2">= </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(-</span><span class="s6">0.0</span><span class="s2">)</span>
    <span class="s1">ONE </span><span class="s2">= </span><span class="s1">vx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s6">1.0</span><span class="s2">)</span>
    <span class="s1">mod_istrue </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">wx_ltz </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">wx</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">mod_ltz </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">mod_istrue</span><span class="s2">, </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_nonzero_mod</span><span class="s2">, </span><span class="s1">if_zero_mod</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">if_nonzero_mod</span><span class="s2">:</span>
            <span class="s4"># `mod` is non-zero or NaN</span>
            <span class="s4"># Ensure the remainder has the same sign as the denominator</span>
            <span class="s1">wx_ltz_ne_mod_ltz </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">wx_ltz</span><span class="s2">, </span><span class="s1">mod_ltz</span><span class="s2">)</span>

            <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_then</span><span class="s2">(</span><span class="s1">wx_ltz_ne_mod_ltz</span><span class="s2">):</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">ONE</span><span class="s2">), </span><span class="s1">pdiv</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">wx</span><span class="s2">), </span><span class="s1">pmod</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">if_zero_mod</span><span class="s2">:</span>
            <span class="s4"># `mod` is zero, select the proper sign depending on</span>
            <span class="s4"># the denominator's sign</span>
            <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">select</span><span class="s2">(</span><span class="s1">wx_ltz</span><span class="s2">, </span><span class="s1">NZERO</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">pmod</span><span class="s2">)</span>

    <span class="s0">del </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">div</span>

    <span class="s1">div </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">pdiv</span><span class="s2">)</span>
    <span class="s1">div_istrue </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">div</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_then</span><span class="s2">(</span><span class="s1">div_istrue</span><span class="s2">):</span>
        <span class="s1">realtypemap </span><span class="s2">= {</span><span class="s5">'float'</span><span class="s2">: </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">,</span>
                       <span class="s5">'double'</span><span class="s2">: </span><span class="s1">types</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">}</span>
        <span class="s1">realtype </span><span class="s2">= </span><span class="s1">realtypemap</span><span class="s2">[</span><span class="s1">str</span><span class="s2">(</span><span class="s1">wx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)]</span>
        <span class="s1">floorfn </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">math</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">,</span>
                                       <span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">))</span>
        <span class="s1">floordiv </span><span class="s2">= </span><span class="s1">floorfn</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, [</span><span class="s1">div</span><span class="s2">])</span>
        <span class="s1">floordivdiff </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">floordiv</span><span class="s2">)</span>
        <span class="s1">floordivincr </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(</span><span class="s1">floordiv</span><span class="s2">, </span><span class="s1">ONE</span><span class="s2">)</span>
        <span class="s1">HALF </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">wx</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0.5</span><span class="s2">)</span>
        <span class="s1">pred </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, </span><span class="s1">floordivdiff</span><span class="s2">, </span><span class="s1">HALF</span><span class="s2">)</span>
        <span class="s1">floordiv </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">select</span><span class="s2">(</span><span class="s1">pred</span><span class="s2">, </span><span class="s1">floordivincr</span><span class="s2">, </span><span class="s1">floordiv</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">floordiv</span><span class="s2">, </span><span class="s1">pfloordiv</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">ifnot</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">div_istrue</span><span class="s2">):</span>
        <span class="s1">div </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">div</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">pdiv</span><span class="s2">)</span>
        <span class="s1">floordiv </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">vx</span><span class="s2">), </span><span class="s1">wx</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">floordiv</span><span class="s2">, </span><span class="s1">pfloordiv</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">pfloordiv</span><span class="s2">), </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">pmod</span><span class="s2">)</span>


<span class="s4"># @lower_builtin(divmod, types.Float, types.Float)</span>
<span class="s0">def </span><span class="s1">real_divmod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">quot </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;quot&quot;</span><span class="s2">)</span>
    <span class="s1">rem </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;rem&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_scalar_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">False</span>
                         <span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_zero</span><span class="s2">, </span><span class="s1">if_non_zero</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">if_zero</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span>
                <span class="s1">builder</span><span class="s2">, (</span><span class="s5">&quot;modulo by zero&quot;</span><span class="s2">,), </span><span class="s1">loc</span><span class="s2">):</span>
                <span class="s4"># No exception raised =&gt; compute the nan result,</span>
                <span class="s4"># and set the FP exception word for Numpy warnings.</span>
                <span class="s1">q </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">frem</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">quot</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">rem</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">if_non_zero</span><span class="s2">:</span>
            <span class="s1">q</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">real_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">quot</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">rem</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">pack_array</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">,</span>
                              <span class="s2">(</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">quot</span><span class="s2">), </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">rem</span><span class="s2">)))</span>


<span class="s0">def </span><span class="s1">real_mod_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_scalar_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">False</span>
                         <span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_zero</span><span class="s2">, </span><span class="s1">if_non_zero</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">if_zero</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span>
                <span class="s1">builder</span><span class="s2">, (</span><span class="s5">&quot;modulo by zero&quot;</span><span class="s2">,), </span><span class="s1">loc</span><span class="s2">):</span>
                <span class="s4"># No exception raised =&gt; compute the nan result,</span>
                <span class="s4"># and set the FP exception word for Numpy warnings.</span>
                <span class="s1">rem </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">frem</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">rem</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">if_non_zero</span><span class="s2">:</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">rem </span><span class="s2">= </span><span class="s1">real_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">rem</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                              <span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">res</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">real_floordiv_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">is_scalar_zero</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">likely</span><span class="s2">=</span><span class="s0">False</span>
                         <span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">if_zero</span><span class="s2">, </span><span class="s1">if_non_zero</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">if_zero</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">context</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">.</span><span class="s1">fp_zero_division</span><span class="s2">(</span>
                <span class="s1">builder</span><span class="s2">, (</span><span class="s5">&quot;division by zero&quot;</span><span class="s2">,), </span><span class="s1">loc</span><span class="s2">):</span>
                <span class="s4"># No exception raised =&gt; compute the +/-inf or nan result,</span>
                <span class="s4"># and set the FP exception word for Numpy warnings.</span>
                <span class="s1">quot </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fdiv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">quot</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">if_non_zero</span><span class="s2">:</span>
            <span class="s1">quot</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">real_divmod</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">quot</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                              <span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">res</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">real_power_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">module </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
    <span class="s0">if </span><span class="s1">context</span><span class="s2">.</span><span class="s1">implement_powi_as_math_call</span><span class="s2">:</span>
        <span class="s1">imp </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">math</span><span class="s2">.</span><span class="s1">pow</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">imp</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">module</span><span class="s2">.</span><span class="s1">declare_intrinsic</span><span class="s2">(</span><span class="s5">'llvm.pow'</span><span class="s2">, [</span><span class="s1">y</span><span class="s2">.</span><span class="s1">type</span><span class="s2">])</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_lt_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_le_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&lt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_gt_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_ge_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&gt;='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_eq_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_ne_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_abs_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">ty</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s1">sig </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">impl </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">math</span><span class="s2">.</span><span class="s1">fabs</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_negate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython </span><span class="s0">import </span><span class="s1">mathimpl</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">mathimpl</span><span class="s2">.</span><span class="s1">negate_real</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_positive_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">real_sign_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    np.sign(float) 
    &quot;&quot;&quot;</span>
    <span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">POS </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">NEG </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">presult </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">alloca_once</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>

    <span class="s1">is_pos </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&gt;'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">is_neg </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'&lt;'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">is_pos</span><span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">gt_zero</span><span class="s2">, </span><span class="s1">not_gt_zero</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">gt_zero</span><span class="s2">:</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">POS</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">not_gt_zero</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">is_neg</span><span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">lt_zero</span><span class="s2">, </span><span class="s1">not_lt_zero</span><span class="s2">):</span>
                <span class="s0">with </span><span class="s1">lt_zero</span><span class="s2">:</span>
                    <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">NEG</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>
                <span class="s0">with </span><span class="s1">not_lt_zero</span><span class="s2">:</span>
                    <span class="s4"># For both NaN and 0, the result of sign() is simply</span>
                    <span class="s4"># the input value.</span>
                    <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">presult</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">presult</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s4"># ty = types.Float</span>

<span class="s4"># lower_builtin(operator.add, ty, ty)(real_add_impl)</span>
<span class="s4"># lower_builtin(operator.iadd, ty, ty)(real_add_impl)</span>
<span class="s4"># lower_builtin(operator.sub, ty, ty)(real_sub_impl)</span>
<span class="s4"># lower_builtin(operator.isub, ty, ty)(real_sub_impl)</span>
<span class="s4"># lower_builtin(operator.mul, ty, ty)(real_mul_impl)</span>
<span class="s4"># lower_builtin(operator.imul, ty, ty)(real_mul_impl)</span>
<span class="s4"># lower_builtin(operator.floordiv, ty, ty)(real_floordiv_impl)</span>
<span class="s4"># lower_builtin(operator.ifloordiv, ty, ty)(real_floordiv_impl)</span>
<span class="s4"># lower_builtin(operator.truediv, ty, ty)(real_div_impl)</span>
<span class="s4"># lower_builtin(operator.itruediv, ty, ty)(real_div_impl)</span>
<span class="s4"># lower_builtin(operator.mod, ty, ty)(real_mod_impl)</span>
<span class="s4"># lower_builtin(operator.imod, ty, ty)(real_mod_impl)</span>
<span class="s4"># lower_builtin(operator.pow, ty, ty)(real_power_impl)</span>
<span class="s4"># lower_builtin(operator.ipow, ty, ty)(real_power_impl)</span>
<span class="s4"># lower_builtin(pow, ty, ty)(real_power_impl)</span>

<span class="s4"># lower_builtin(operator.eq, ty, ty)(real_eq_impl)</span>
<span class="s4"># lower_builtin(operator.ne, ty, ty)(real_ne_impl)</span>
<span class="s4"># lower_builtin(operator.lt, ty, ty)(real_lt_impl)</span>
<span class="s4"># lower_builtin(operator.le, ty, ty)(real_le_impl)</span>
<span class="s4"># lower_builtin(operator.gt, ty, ty)(real_gt_impl)</span>
<span class="s4"># lower_builtin(operator.ge, ty, ty)(real_ge_impl)</span>

<span class="s4"># lower_builtin(abs, ty)(real_abs_impl)</span>

<span class="s4"># lower_builtin(operator.neg, ty)(real_negate_impl)</span>
<span class="s4"># lower_builtin(operator.pos, ty)(real_positive_impl)</span>

<span class="s4"># del ty</span>


<span class="s4"># @lower_getattr(types.Complex, &quot;real&quot;)</span>
<span class="s0">def </span><span class="s1">complex_real_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
    <span class="s1">cplx </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">cplx</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s4"># @lower_getattr(types.Complex, &quot;imag&quot;)</span>
<span class="s0">def </span><span class="s1">complex_imag_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
    <span class="s1">cplx </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">cplx</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s4"># @lower_builtin(&quot;complex.conjugate&quot;, types.Complex)</span>
<span class="s0">def </span><span class="s1">complex_conjugate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython </span><span class="s0">import </span><span class="s1">mathimpl</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">mathimpl</span><span class="s2">.</span><span class="s1">negate_real</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">z</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">real_real_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">real_imag_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_null_value</span><span class="s2">(</span><span class="s1">value</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">real_conjugate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>

<span class="s4"># for cls in (types.Float, types.Integer):</span>
<span class="s4">#     lower_getattr(cls, &quot;real&quot;)(real_real_impl)</span>
<span class="s4">#     lower_getattr(cls, &quot;imag&quot;)(real_imag_impl)</span>
<span class="s4">#     lower_builtin(&quot;complex.conjugate&quot;, cls)(real_conjugate_impl)</span>


<span class="s4"># @lower_builtin(operator.pow, types.Complex, types.Complex)</span>
<span class="s4"># @lower_builtin(operator.ipow, types.Complex, types.Complex)</span>
<span class="s4"># @lower_builtin(pow, types.Complex, types.Complex)</span>
<span class="s0">def </span><span class="s1">complex_power_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">ca</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">ty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">fty </span><span class="s2">= </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">underlying_float</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">ca</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cb</span><span class="s2">)</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">module </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
    <span class="s1">pa </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">_getpointer</span><span class="s2">()</span>
    <span class="s1">pb </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">_getpointer</span><span class="s2">()</span>
    <span class="s1">pc </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">_getpointer</span><span class="s2">()</span>

    <span class="s4"># Optimize for square because cpow loses a lot of precision</span>
    <span class="s1">TWO </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">fty</span><span class="s2">, </span><span class="s6">2</span><span class="s2">)</span>
    <span class="s1">ZERO </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">fty</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">b_real_is_two </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">TWO</span><span class="s2">)</span>
    <span class="s1">b_imag_is_zero </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">, </span><span class="s1">ZERO</span><span class="s2">)</span>
    <span class="s1">b_is_two </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">(</span><span class="s1">b_real_is_two</span><span class="s2">, </span><span class="s1">b_imag_is_zero</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">if_else</span><span class="s2">(</span><span class="s1">b_is_two</span><span class="s2">) </span><span class="s0">as </span><span class="s2">(</span><span class="s1">then</span><span class="s2">, </span><span class="s1">otherwise</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">then</span><span class="s2">:</span>
            <span class="s4"># Lower as multiplication</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">complex_mul_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, (</span><span class="s1">ca</span><span class="s2">, </span><span class="s1">ca</span><span class="s2">))</span>
            <span class="s1">cres </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>
            <span class="s1">c</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">real</span>
            <span class="s1">c</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">imag</span>

        <span class="s0">with </span><span class="s1">otherwise</span><span class="s2">:</span>
            <span class="s4"># Lower with call to external function</span>
            <span class="s1">func_name </span><span class="s2">= {</span>
                <span class="s1">types</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">: </span><span class="s5">&quot;numba_cpowf&quot;</span><span class="s2">,</span>
                <span class="s1">types</span><span class="s2">.</span><span class="s1">complex128</span><span class="s2">: </span><span class="s5">&quot;numba_cpow&quot;</span><span class="s2">,</span>
                <span class="s2">}[</span><span class="s1">ty</span><span class="s2">]</span>
            <span class="s1">fnty </span><span class="s2">= </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">ir</span><span class="s2">.</span><span class="s1">VoidType</span><span class="s2">(), [</span><span class="s1">pa</span><span class="s2">.</span><span class="s1">type</span><span class="s2">] * </span><span class="s6">3</span><span class="s2">)</span>
            <span class="s1">cpow </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">)</span>
            <span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">cpow</span><span class="s2">, (</span><span class="s1">pa</span><span class="s2">, </span><span class="s1">pb</span><span class="s2">, </span><span class="s1">pc</span><span class="s2">))</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">pc</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">complex_add_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">ty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cx</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cy</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">)</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_sub_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">ty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cx</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cy</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">)</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_mul_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    (a+bi)(c+di)=(ac-bd)+i(ad+bc) 
    &quot;&quot;&quot;</span>
    <span class="s2">[</span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">ty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cx</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cy</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">ac </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">)</span>
    <span class="s1">bd </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
    <span class="s1">ad </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
    <span class="s1">bc </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fmul</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">)</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fsub</span><span class="s2">(</span><span class="s1">ac</span><span class="s2">, </span><span class="s1">bd</span><span class="s2">)</span>
    <span class="s1">z</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fadd</span><span class="s2">(</span><span class="s1">ad</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s1">NAN </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s5">'nan'</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">complex_div_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">complex_div</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
        <span class="s4"># This is CPython's algorithm (in _Py_c_quot()).</span>
        <span class="s1">areal </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real</span>
        <span class="s1">aimag </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag</span>
        <span class="s1">breal </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">real</span>
        <span class="s1">bimag </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">imag</span>
        <span class="s0">if not </span><span class="s1">breal </span><span class="s0">and not </span><span class="s1">bimag</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ZeroDivisionError</span><span class="s2">(</span><span class="s5">&quot;complex division by zero&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">breal</span><span class="s2">) &gt;= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">bimag</span><span class="s2">):</span>
            <span class="s4"># Divide tops and bottom by b.real</span>
            <span class="s0">if not </span><span class="s1">breal</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">complex</span><span class="s2">(</span><span class="s1">NAN</span><span class="s2">, </span><span class="s1">NAN</span><span class="s2">)</span>
            <span class="s1">ratio </span><span class="s2">= </span><span class="s1">bimag </span><span class="s2">/ </span><span class="s1">breal</span>
            <span class="s1">denom </span><span class="s2">= </span><span class="s1">breal </span><span class="s2">+ </span><span class="s1">bimag </span><span class="s2">* </span><span class="s1">ratio</span>
            <span class="s0">return </span><span class="s1">complex</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">areal </span><span class="s2">+ </span><span class="s1">aimag </span><span class="s2">* </span><span class="s1">ratio</span><span class="s2">) / </span><span class="s1">denom</span><span class="s2">,</span>
                <span class="s2">(</span><span class="s1">aimag </span><span class="s2">- </span><span class="s1">areal </span><span class="s2">* </span><span class="s1">ratio</span><span class="s2">) / </span><span class="s1">denom</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Divide tops and bottom by b.imag</span>
            <span class="s0">if not </span><span class="s1">bimag</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">complex</span><span class="s2">(</span><span class="s1">NAN</span><span class="s2">, </span><span class="s1">NAN</span><span class="s2">)</span>
            <span class="s1">ratio </span><span class="s2">= </span><span class="s1">breal </span><span class="s2">/ </span><span class="s1">bimag</span>
            <span class="s1">denom </span><span class="s2">= </span><span class="s1">breal </span><span class="s2">* </span><span class="s1">ratio </span><span class="s2">+ </span><span class="s1">bimag</span>
            <span class="s0">return </span><span class="s1">complex</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">real </span><span class="s2">* </span><span class="s1">ratio </span><span class="s2">+ </span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">) / </span><span class="s1">denom</span><span class="s2">,</span>
                <span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">* </span><span class="s1">ratio </span><span class="s2">- </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real</span><span class="s2">) / </span><span class="s1">denom</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">complex_div</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_negate_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython </span><span class="s0">import </span><span class="s1">mathimpl</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">cmplx </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">)</span>
    <span class="s1">res</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">mathimpl</span><span class="s2">.</span><span class="s1">negate_real</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">cmplx</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s1">res</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">mathimpl</span><span class="s2">.</span><span class="s1">negate_real</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">cmplx</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_positive_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_eq_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">typ </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cx</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cy</span><span class="s2">)</span>

    <span class="s1">reals_are_eq </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s1">imags_are_eq </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_ordered</span><span class="s2">(</span><span class="s5">'=='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">and_</span><span class="s2">(</span><span class="s1">reals_are_eq</span><span class="s2">, </span><span class="s1">imags_are_eq</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_ne_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">typ </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cx</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">cy</span><span class="s2">)</span>

    <span class="s1">reals_are_ne </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s1">imags_are_ne </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">(</span><span class="s1">reals_are_ne</span><span class="s2">, </span><span class="s1">imags_are_ne</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">complex_abs_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    abs(z) := hypot(z.real, z.imag) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">complex_abs</span><span class="s2">(</span><span class="s1">z</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">math</span><span class="s2">.</span><span class="s1">hypot</span><span class="s2">(</span><span class="s1">z</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">z</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">complex_abs</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s4"># ty = types.Complex</span>

<span class="s4"># lower_builtin(operator.add, ty, ty)(complex_add_impl)</span>
<span class="s4"># lower_builtin(operator.iadd, ty, ty)(complex_add_impl)</span>
<span class="s4"># lower_builtin(operator.sub, ty, ty)(complex_sub_impl)</span>
<span class="s4"># lower_builtin(operator.isub, ty, ty)(complex_sub_impl)</span>
<span class="s4"># lower_builtin(operator.mul, ty, ty)(complex_mul_impl)</span>
<span class="s4"># lower_builtin(operator.imul, ty, ty)(complex_mul_impl)</span>
<span class="s4"># lower_builtin(operator.truediv, ty, ty)(complex_div_impl)</span>
<span class="s4"># lower_builtin(operator.itruediv, ty, ty)(complex_div_impl)</span>
<span class="s4"># lower_builtin(operator.neg, ty)(complex_negate_impl)</span>
<span class="s4"># lower_builtin(operator.pos, ty)(complex_positive_impl)</span>
<span class="s4"># # Complex modulo is deprecated in python3</span>

<span class="s4"># lower_builtin(operator.eq, ty, ty)(complex_eq_impl)</span>
<span class="s4"># lower_builtin(operator.ne, ty, ty)(complex_ne_impl)</span>

<span class="s4"># lower_builtin(abs, ty)(complex_abs_impl)</span>

<span class="s4"># del ty</span>


<span class="s4"># @lower_builtin(&quot;number.item&quot;, types.Boolean)</span>
<span class="s4"># @lower_builtin(&quot;number.item&quot;, types.Number)</span>
<span class="s0">def </span><span class="s1">number_item_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    The no-op .item() method on booleans and numbers. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>


<span class="s4">#------------------------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">number_not_impl</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">istrue </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">not_</span><span class="s2">(</span><span class="s1">istrue</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">impl_ret_untracked</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>

<span class="s4"># @lower_builtin(bool, types.Boolean)</span>
<span class="s0">def </span><span class="s1">bool_as_bool</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s0">return </span><span class="s1">val</span>

<span class="s4"># @lower_builtin(bool, types.Integer)</span>
<span class="s0">def </span><span class="s1">int_as_bool</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">icmp_unsigned</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0</span><span class="s2">))</span>

<span class="s4"># @lower_builtin(bool, types.Float)</span>
<span class="s0">def </span><span class="s1">float_as_bool</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0.0</span><span class="s2">))</span>

<span class="s4"># @lower_builtin(bool, types.Complex)</span>
<span class="s0">def </span><span class="s1">complex_as_bool</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s2">[</span><span class="s1">typ</span><span class="s2">] = </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span>
    <span class="s2">[</span><span class="s1">val</span><span class="s2">] = </span><span class="s1">args</span>
    <span class="s1">cmplx </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
    <span class="s1">real</span><span class="s2">, </span><span class="s1">imag </span><span class="s2">= </span><span class="s1">cmplx</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">cmplx</span><span class="s2">.</span><span class="s1">imag</span>
    <span class="s1">zero </span><span class="s2">= </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">real</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s6">0.0</span><span class="s2">)</span>
    <span class="s1">real_istrue </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">)</span>
    <span class="s1">imag_istrue </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fcmp_unordered</span><span class="s2">(</span><span class="s5">'!='</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">(</span><span class="s1">real_istrue</span><span class="s2">, </span><span class="s1">imag_istrue</span><span class="s2">)</span>


<span class="s4"># for ty in (types.Integer, types.Float, types.Complex):</span>
<span class="s4">#     lower_builtin(operator.not_, ty)(number_not_impl)</span>

<span class="s4"># lower_builtin(operator.not_, types.boolean)(number_not_impl)</span>


<span class="s4">#------------------------------------------------------------------------------</span>
<span class="s4"># Hashing numbers, see hashing.py</span>

<span class="s4">#-------------------------------------------------------------------------------</span>
<span class="s4"># Implicit casts between numerics</span>

<span class="s4"># @lower_cast(types.IntegerLiteral, types.Integer)</span>
<span class="s4"># @lower_cast(types.IntegerLiteral, types.Float)</span>
<span class="s4"># @lower_cast(types.IntegerLiteral, types.Complex)</span>
<span class="s0">def </span><span class="s1">literal_int_to_number</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">lit </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span>
        <span class="s1">builder</span><span class="s2">,</span>
        <span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_type</span><span class="s2">,</span>
        <span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_value</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">lit</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_type</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">)</span>


<span class="s4"># @lower_cast(types.Integer, types.Integer)</span>
<span class="s0">def </span><span class="s1">integer_to_integer</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">== </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">bitwidth</span><span class="s2">:</span>
        <span class="s4"># Just a change of signedness</span>
        <span class="s0">return </span><span class="s1">val</span>
    <span class="s0">elif </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">&lt; </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">bitwidth</span><span class="s2">:</span>
        <span class="s4"># Downcast</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">trunc</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">))</span>
    <span class="s0">elif </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s4"># Signed upcast</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sext</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s4"># Unsigned upcast</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">zext</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">))</span>

<span class="s4"># @lower_cast(types.Integer, types.voidptr)</span>
<span class="s0">def </span><span class="s1">integer_to_voidptr</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">inttoptr</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">))</span>

<span class="s4"># @lower_cast(types.Float, types.Float)</span>
<span class="s0">def </span><span class="s1">float_to_float</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">lty </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">&lt; </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">bitwidth</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fpext</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fptrunc</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>

<span class="s4"># @lower_cast(types.Integer, types.Float)</span>
<span class="s0">def </span><span class="s1">integer_to_float</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">lty </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">sitofp</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">uitofp</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>

<span class="s4"># @lower_cast(types.Float, types.Integer)</span>
<span class="s0">def </span><span class="s1">float_to_integer</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">lty </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">signed</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fptosi</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">fptoui</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">lty</span><span class="s2">)</span>

<span class="s4"># @lower_cast(types.Float, types.Complex)</span>
<span class="s4"># @lower_cast(types.Integer, types.Complex)</span>
<span class="s0">def </span><span class="s1">non_complex_to_complex</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">real </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">underlying_float</span><span class="s2">)</span>
    <span class="s1">imag </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">.</span><span class="s1">underlying_float</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">cmplx </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">)</span>
    <span class="s1">cmplx</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">real</span>
    <span class="s1">cmplx</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">imag</span>
    <span class="s0">return </span><span class="s1">cmplx</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>

<span class="s4"># @lower_cast(types.Complex, types.Complex)</span>
<span class="s0">def </span><span class="s1">complex_to_complex</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">srcty </span><span class="s2">= </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">underlying_float</span>
    <span class="s1">dstty </span><span class="s2">= </span><span class="s1">toty</span><span class="s2">.</span><span class="s1">underlying_float</span>

    <span class="s1">src </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s1">dst </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">)</span>
    <span class="s1">dst</span><span class="s2">.</span><span class="s1">real </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">src</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, </span><span class="s1">srcty</span><span class="s2">, </span><span class="s1">dstty</span><span class="s2">)</span>
    <span class="s1">dst</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">src</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">, </span><span class="s1">srcty</span><span class="s2">, </span><span class="s1">dstty</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">dst</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>

<span class="s4"># @lower_cast(types.Any, types.Boolean)</span>
<span class="s0">def </span><span class="s1">any_to_boolean</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s2">.</span><span class="s1">is_true</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

<span class="s4"># @lower_cast(types.Boolean, types.Number)</span>
<span class="s0">def </span><span class="s1">boolean_to_any</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s4"># Casting from boolean to anything first casts to int32</span>
    <span class="s1">asint </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">zext</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">ir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s6">32</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">asint</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">)</span>

<span class="s4"># @lower_cast(types.IntegerLiteral, types.Boolean)</span>
<span class="s4"># @lower_cast(types.BooleanLiteral, types.Boolean)</span>
<span class="s0">def </span><span class="s1">literal_int_to_boolean</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
    <span class="s1">lit </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span>
        <span class="s1">builder</span><span class="s2">,</span>
        <span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_type</span><span class="s2">,</span>
        <span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_value</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s2">.</span><span class="s1">is_true</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">.</span><span class="s1">literal_type</span><span class="s2">, </span><span class="s1">lit</span><span class="s2">)</span>

<span class="s4">#-------------------------------------------------------------------------------</span>
<span class="s4"># Constants</span>

<span class="s4"># @lower_constant(types.Complex)</span>
<span class="s0">def </span><span class="s1">constant_complex</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">pyval</span><span class="s2">):</span>
    <span class="s1">fty </span><span class="s2">= </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">underlying_float</span>
    <span class="s1">real </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fty</span><span class="s2">, </span><span class="s1">pyval</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s1">imag </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fty</span><span class="s2">, </span><span class="s1">pyval</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">Constant</span><span class="s2">.</span><span class="s1">literal_struct</span><span class="s2">((</span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">))</span>

<span class="s4"># @lower_constant(types.Integer)</span>
<span class="s4"># @lower_constant(types.Float)</span>
<span class="s4"># @lower_constant(types.Boolean)</span>
<span class="s0">def </span><span class="s1">constant_integer</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">pyval</span><span class="s2">):</span>
    <span class="s4"># See https://github.com/numba/numba/issues/6979</span>
    <span class="s4"># llvmlite ir.IntType specialises the formatting of the constant for a</span>
    <span class="s4"># cpython bool. A NumPy np.bool_ is not a cpython bool so force it to be one</span>
    <span class="s4"># so that the constant renders correctly!</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">pyval</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">):</span>
        <span class="s1">pyval </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">pyval</span><span class="s2">)</span>
    <span class="s1">lty </span><span class="s2">= </span><span class="s1">context</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">lty</span><span class="s2">(</span><span class="s1">pyval</span><span class="s2">)</span>


<span class="s4">#-------------------------------------------------------------------------------</span>
<span class="s4"># View</span>

<span class="s0">def </span><span class="s1">scalar_view</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">viewty</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; Typing for the np scalar 'view' method. &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, (</span><span class="s1">types</span><span class="s2">.</span><span class="s1">Float</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Integer</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">viewty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">abstract</span><span class="s2">.</span><span class="s1">DTypeSpec</span><span class="s2">)):</span>
        <span class="s0">if </span><span class="s1">scalar</span><span class="s2">.</span><span class="s1">bitwidth </span><span class="s2">!= </span><span class="s1">viewty</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">bitwidth</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">TypingError</span><span class="s2">(</span>
                <span class="s5">&quot;Changing the dtype of a 0d array is only supported if the &quot;</span>
                <span class="s5">&quot;itemsize is unchanged&quot;</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">viewty</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">viewer</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">viewty</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">impl</span>


<span class="s4"># overload_method(types.Float, 'view')(scalar_view)</span>
<span class="s4"># overload_method(types.Integer, 'view')(scalar_view)</span>
</pre>
</body>
</html>