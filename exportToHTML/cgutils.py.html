<html>
<head>
<title>cgutils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cgutils.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Generic helpers for LLVM code generation. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span><span class="s3">, </span><span class="s1">ExitStack</span>
<span class="s2">import </span><span class="s1">functools</span>

<span class="s2">from </span><span class="s1">llvmlite </span><span class="s2">import </span><span class="s1">ir</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">utils</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">debuginfo</span>
<span class="s2">import </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">datamodel</span>


<span class="s1">bool_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
<span class="s1">int8_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>
<span class="s1">int32_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">32</span><span class="s3">)</span>
<span class="s1">intp_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">MACHINE_BITS</span><span class="s3">)</span>
<span class="s1">voidptr_t </span><span class="s3">= </span><span class="s1">int8_t</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>

<span class="s1">true_bit </span><span class="s3">= </span><span class="s1">bool_t</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
<span class="s1">false_bit </span><span class="s3">= </span><span class="s1">bool_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
<span class="s1">true_byte </span><span class="s3">= </span><span class="s1">int8_t</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
<span class="s1">false_byte </span><span class="s3">= </span><span class="s1">int8_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">as_bool_bit</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s5">'!='</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">make_anonymous_struct</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">struct_type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an anonymous struct containing the given LLVM *values*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">struct_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">struct_type </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">LiteralStructType</span><span class="s3">([</span><span class="s1">v</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values</span><span class="s3">])</span>
    <span class="s1">struct_val </span><span class="s3">= </span><span class="s1">struct_type</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Undefined</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">values</span><span class="s3">):</span>
        <span class="s1">struct_val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">struct_val</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">struct_val</span>


<span class="s2">def </span><span class="s1">make_bytearray</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make a byte array constant from *buf*. 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">8</span><span class="s3">), </span><span class="s1">n</span><span class="s3">), </span><span class="s1">b</span><span class="s3">)</span>


<span class="s1">_struct_proxy_cache </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">create_struct_proxy</span><span class="s3">(</span><span class="s1">fe_type</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s5">'value'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a specialized StructProxy subclass for the given fe_type. 
    &quot;&quot;&quot;</span>
    <span class="s1">cache_key </span><span class="s3">= (</span><span class="s1">fe_type</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">_struct_proxy_cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cache_key</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">res </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">base </span><span class="s3">= {</span><span class="s5">'value'</span><span class="s3">: </span><span class="s1">ValueStructProxy</span><span class="s3">,</span>
                <span class="s5">'data'</span><span class="s3">: </span><span class="s1">DataStructProxy</span><span class="s3">,</span>
                <span class="s3">}[</span><span class="s1">kind</span><span class="s3">]</span>
        <span class="s1">clsname </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">+ </span><span class="s5">'_' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">fe_type</span><span class="s3">)</span>
        <span class="s1">bases </span><span class="s3">= (</span><span class="s1">base</span><span class="s3">,)</span>
        <span class="s1">clsmembers </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">_fe_type</span><span class="s3">=</span><span class="s1">fe_type</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">clsname</span><span class="s3">, </span><span class="s1">bases</span><span class="s3">, </span><span class="s1">clsmembers</span><span class="s3">)</span>

        <span class="s1">_struct_proxy_cache</span><span class="s3">[</span><span class="s1">cache_key</span><span class="s3">] = </span><span class="s1">res</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">copy_struct</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">repl</span><span class="s3">={}):</span>
    <span class="s0">&quot;&quot;&quot; 
    Copy structure from *src* to *dst* with replacement from *repl*. 
    &quot;&quot;&quot;</span>
    <span class="s1">repl </span><span class="s3">= </span><span class="s1">repl</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s6"># copy data from src or use those in repl</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">src</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">repl</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">k</span><span class="s3">))</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
    <span class="s6"># use remaining key-values in repl</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">repl</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">dst</span>


<span class="s2">class </span><span class="s1">_StructProxy</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a `Structure` like interface that is constructed with information 
    from DataModel instance.  FE type must have a data model that is a 
    subclass of StructModel. 
    &quot;&quot;&quot;</span>
    <span class="s6"># The following class members must be overridden by subclass</span>
    <span class="s1">_fe_type </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fe_type</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">, </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">datamodel</span><span class="s3">.</span><span class="s1">StructModel</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s5">&quot;Not a structure model: {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder </span><span class="s3">= </span><span class="s1">builder</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_be_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">)</span>
        <span class="s2">assert not </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">)</span>

        <span class="s1">outer_ref</span><span class="s3">, </span><span class="s1">ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_refs</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s5">&quot;bad ref type: expected %s, got %s&quot;</span>
                                 <span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">(), </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">outer_ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s5">&quot;bad value type: expected %s, got %s&quot;</span>
                                     <span class="s3">% (</span><span class="s1">outer_ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">, </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">outer_ref</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">= </span><span class="s1">ref</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_outer_ref </span><span class="s3">= </span><span class="s1">outer_ref</span>

    <span class="s2">def </span><span class="s1">_make_refs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an (outer ref, value ref) pair.  By default, these are 
        the same pointers, but a derived class may override this. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">ref </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ref</span><span class="s3">, </span><span class="s1">ref</span>

    <span class="s2">def </span><span class="s1">_get_be_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">datamodel</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_cast_member_to_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_cast_member_from_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">):</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_field_position</span><span class="s3">(</span><span class="s1">attrname</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load the LLVM value of the named *field*. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_field_position</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Store the LLVM *value* into the named *field*. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">super</span><span class="s3">(</span><span class="s1">_StructProxy</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_field_position</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)] = </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load the LLVM value of the field at *index*. 
        &quot;&quot;&quot;</span>
        <span class="s1">member_val </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cast_member_to_value</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">member_val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Store the LLVM *value* into the field at *index*. 
        &quot;&quot;&quot;</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cast_member_from_value</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) </span><span class="s2">and </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee </span><span class="s3">== </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">):</span>
                <span class="s6"># Differ by address-space only</span>
                <span class="s6"># Auto coerce it</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">addrspacecast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">,</span>
                                                    <span class="s1">value</span><span class="s3">,</span>
                                                    <span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">.</span><span class="s1">addrspace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;Invalid store of {value.type} to &quot;</span>
                                <span class="s5">&quot;{ptr.type.pointee} in &quot;</span>
                                <span class="s5">&quot;{self._datamodel} &quot;</span>
                                <span class="s5">&quot;(trying to write member #{index})&quot;</span>
                                <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">=</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">self</span><span class="s3">=</span><span class="s1">self</span><span class="s3">,</span>
                                        <span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of fields. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">field_count</span>

    <span class="s2">def </span><span class="s1">_getpointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the LLVM pointer to the underlying structure. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_outer_ref</span>

    <span class="s2">def </span><span class="s1">_getvalue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load and return the value of the underlying LLVM structure. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_outer_ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_setvalue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Store the value in this structure. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert not </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">, (</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_be_type</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">ValueStructProxy</span><span class="s3">(</span><span class="s1">_StructProxy</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a StructProxy suitable for accessing regular values 
    (e.g. LLVM values or alloca slots). 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_get_be_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">datamodel</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">datamodel</span><span class="s3">.</span><span class="s1">get_value_type</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_cast_member_to_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">_cast_member_from_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">val</span>


<span class="s2">class </span><span class="s1">DataStructProxy</span><span class="s3">(</span><span class="s1">_StructProxy</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a StructProxy suitable for accessing data persisted in memory. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_get_be_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">datamodel</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">datamodel</span><span class="s3">.</span><span class="s1">get_data_type</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_cast_member_to_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">model </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_model</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">model</span><span class="s3">.</span><span class="s1">from_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cast_member_from_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
        <span class="s1">model </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_datamodel</span><span class="s3">.</span><span class="s1">get_model</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">model</span><span class="s3">.</span><span class="s1">as_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Structure</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A high-level object wrapping a alloca'ed LLVM structure, including 
    named fields and attribute access. 
    &quot;&quot;&quot;</span>

    <span class="s6"># XXX Should this warrant several separate constructors?</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">cast_ref</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_type </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_struct_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder </span><span class="s3">= </span><span class="s1">builder</span>
        <span class="s2">if </span><span class="s1">ref </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">= </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">assert not </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
                <span class="s2">assert </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">, (</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">)</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">value </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type </span><span class="s3">!= </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">cast_ref</span><span class="s3">:</span>
                    <span class="s1">ref </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">())</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                        <span class="s5">&quot;mismatching pointer type: got %s, expected %s&quot;</span>
                        <span class="s3">% (</span><span class="s1">ref</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_value </span><span class="s3">= </span><span class="s1">ref</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fdmap </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_typemap </span><span class="s3">= []</span>
        <span class="s1">base </span><span class="s3">= </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fields</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">i</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_fdmap</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">base</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_typemap</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fdmap</span><span class="s3">[</span><span class="s1">index</span><span class="s3">], </span><span class="s1">inbounds</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ptr</span>

    <span class="s2">def </span><span class="s1">_get_ptr_by_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap</span><span class="s3">[</span><span class="s1">attrname</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load the LLVM value of the named *field*. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">field</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap</span><span class="s3">[</span><span class="s1">field</span><span class="s3">]]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">field</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Store the LLVM *value* into the named *field*. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">super</span><span class="s3">(</span><span class="s1">Structure</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap</span><span class="s3">[</span><span class="s1">field</span><span class="s3">]] = </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load the LLVM value of the field at *index*. 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Store the LLVM *value* into the field at *index*. 
        &quot;&quot;&quot;</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_ptr_by_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee </span><span class="s3">!= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
            <span class="s1">fmt </span><span class="s3">= </span><span class="s5">&quot;Type mismatch: __setitem__(%d, ...) expected %r but got %r&quot;</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">fmt </span><span class="s3">% (</span><span class="s1">index</span><span class="s3">,</span>
                                        <span class="s1">str</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">),</span>
                                        <span class="s1">str</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of fields. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namemap</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_getpointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the LLVM pointer to the underlying structure. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span>

    <span class="s2">def </span><span class="s1">_getvalue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Load and return the value of the underlying LLVM structure. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_setvalue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Store the value in this structure&quot;&quot;&quot;</span>
        <span class="s2">assert not </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">, (</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_value</span><span class="s3">)</span>

    <span class="s6"># __iter__ is derived by Python from __len__ and __getitem__</span>


<span class="s2">def </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">''</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Allocate stack memory at the entry block of the current function 
    pointed by ``builder`` with llvm type ``ty``.  The optional ``size`` arg 
    set the number of element to allocate.  The default is 1.  The optional 
    ``name`` arg set the symbol name inside the llvm IR for debugging. 
    If ``zfill`` is set, fill the memory with zeros at the current 
    use-site location.  Note that the memory is always zero-filled after the 
    ``alloca`` at init-site (the entry block). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
    <span class="s6"># suspend debug metadata emission else it links up python source lines with</span>
    <span class="s6"># alloca in the entry block as well as their actual location and it makes</span>
    <span class="s6"># the debug info &quot;jump about&quot;.</span>
    <span class="s2">with </span><span class="s1">debuginfo</span><span class="s3">.</span><span class="s1">suspend_emission</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_entry_block</span><span class="s3">():</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">alloca</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s6"># Always zero-fill at init-site.  This is safe.</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">(</span><span class="s2">None</span><span class="s3">), </span><span class="s1">ptr</span><span class="s3">)</span>
        <span class="s6"># Also zero-fill at the use-site</span>
        <span class="s2">if </span><span class="s1">zfill</span><span class="s3">:</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">(</span><span class="s2">None</span><span class="s3">), </span><span class="s1">ptr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ptr</span>


<span class="s2">def </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Compute sizeof using GEP 
    &quot;&quot;&quot;</span>
    <span class="s1">null </span><span class="s3">= </span><span class="s1">ptr_type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s1">null</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">([</span><span class="s1">int32_t</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)])</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">ptrtoint</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">alloca_once_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">''</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like alloca_once(), but passing a *value* instead of a type.  The 
    type is inferred and the allocated slot is also initialized with the 
    given value. 
    &quot;&quot;&quot;</span>
    <span class="s1">storage </span><span class="s3">= </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s1">zfill</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">storage</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">storage</span>


<span class="s2">def </span><span class="s1">insert_pure_function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Insert a pure function (in the functional programming sense) in the 
    given module. 
    &quot;&quot;&quot;</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">fn</span><span class="s3">.</span><span class="s1">attributes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">&quot;readonly&quot;</span><span class="s3">)</span>
    <span class="s1">fn</span><span class="s3">.</span><span class="s1">attributes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">&quot;nounwind&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">fn</span>


<span class="s2">def </span><span class="s1">get_or_insert_function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the function named *name* with type *fnty* from *module*, or insert it 
    if it doesn't exist. 
    &quot;&quot;&quot;</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">fn</span>


<span class="s2">def </span><span class="s1">get_or_insert_named_metadata</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">get_named_metadata</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">add_named_metadata</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">add_global_variable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">addrspace</span><span class="s3">=</span><span class="s4">0</span><span class="s3">):</span>
    <span class="s1">unique_name </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">get_unique_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">GlobalVariable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">unique_name</span><span class="s3">, </span><span class="s1">addrspace</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">terminate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">bbend</span><span class="s3">):</span>
    <span class="s1">bb </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">basic_block</span>
    <span class="s2">if </span><span class="s1">bb</span><span class="s3">.</span><span class="s1">terminator </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">ltype</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">ltype</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">null </span><span class="s3">= </span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s5">'=='</span><span class="s3">, </span><span class="s1">null</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_not_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s1">null </span><span class="s3">= </span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s5">'!='</span><span class="s3">, </span><span class="s1">null</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">if_likely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ifnot</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Increment an index *val*. 
    &quot;&quot;&quot;</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s6"># We pass the &quot;nsw&quot; flag in the hope that LLVM understands the index</span>
    <span class="s6"># never changes sign.  Unfortunately this doesn't always work</span>
    <span class="s6"># (e.g. ndindex()).</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">one</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=[</span><span class="s5">'nsw'</span><span class="s3">])</span>


<span class="s1">Loop </span><span class="s3">= </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s5">'Loop'</span><span class="s3">, (</span><span class="s5">'index'</span><span class="s3">, </span><span class="s5">'do_break'</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate LLVM IR for a for-loop in [start, count). 
    *start* is equal to 0 by default. 
 
    Yields a Loop namedtuple with the following members: 
    - `index` is the loop index's value 
    - `do_break` is a no-argument callable to break out of the loop 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">intp </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">intp </span><span class="s3">= </span><span class="s1">count</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">intp</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">stop </span><span class="s3">= </span><span class="s1">count</span>

    <span class="s1">bbcond </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.cond&quot;</span><span class="s3">)</span>
    <span class="s1">bbbody </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.body&quot;</span><span class="s3">)</span>
    <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.end&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">do_break</span><span class="s3">():</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s1">bbstart </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">basic_block</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbcond</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_block</span><span class="s3">(</span><span class="s1">bbcond</span><span class="s3">):</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">phi</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;loop.index&quot;</span><span class="s3">)</span>
        <span class="s1">pred </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">cbranch</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">bbbody</span><span class="s3">, </span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_block</span><span class="s3">(</span><span class="s1">bbbody</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">Loop</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">do_break</span><span class="s3">)</span>
        <span class="s6"># Update bbbody as a new basic block may have been activated</span>
        <span class="s1">bbbody </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">basic_block</span>
        <span class="s1">incr </span><span class="s3">= </span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">terminate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">bbcond</span><span class="s3">)</span>

    <span class="s1">index</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">bbstart</span><span class="s3">)</span>
    <span class="s1">index</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">incr</span><span class="s3">, </span><span class="s1">bbbody</span><span class="s3">)</span>

    <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">for_range_slice</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">inc</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate LLVM IR for a for-loop based on a slice.  Yields a 
    (index, count) tuple where `index` is the slice index's value 
    inside the loop, and `count` the iteration count. 
 
    Parameters 
    ------------- 
    builder : object 
        IRBuilder object 
    start : int 
        The beginning value of the slice 
    stop : int 
        The end value of the slice 
    step : int 
        The step value of the slice 
    intp : 
        The data type 
    inc : boolean, optional 
        Signals whether the step is positive (True) or negative (False). 
 
    Returns 
    ----------- 
        None 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">intp </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">intp </span><span class="s3">= </span><span class="s1">start</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s1">bbcond </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.cond&quot;</span><span class="s3">)</span>
    <span class="s1">bbbody </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.body&quot;</span><span class="s3">)</span>
    <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">&quot;for.end&quot;</span><span class="s3">)</span>
    <span class="s1">bbstart </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">basic_block</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbcond</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_block</span><span class="s3">(</span><span class="s1">bbcond</span><span class="s3">):</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">phi</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;loop.index&quot;</span><span class="s3">)</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">phi</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;loop.count&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">inc</span><span class="s3">):</span>
            <span class="s1">pred </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">pred </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&gt;'</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">cbranch</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">bbbody</span><span class="s3">, </span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">goto_block</span><span class="s3">(</span><span class="s1">bbbody</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">index</span><span class="s3">, </span><span class="s1">count</span>
        <span class="s1">bbbody </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">basic_block</span>
        <span class="s1">incr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">step</span><span class="s3">)</span>
        <span class="s1">next_count </span><span class="s3">= </span><span class="s1">increment_index</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>
        <span class="s1">terminate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">bbcond</span><span class="s3">)</span>

    <span class="s1">index</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">bbstart</span><span class="s3">)</span>
    <span class="s1">index</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">incr</span><span class="s3">, </span><span class="s1">bbbody</span><span class="s3">)</span>
    <span class="s1">count</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">), </span><span class="s1">bbstart</span><span class="s3">)</span>
    <span class="s1">count</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">next_count</span><span class="s3">, </span><span class="s1">bbbody</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">for_range_slice_generic</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper wrapper for for_range_slice().  This is a context manager which 
    yields two for_range_slice()-alike context managers, the first for 
    the positive step case, the second for the negative step case. 
 
    Use: 
        with for_range_slice_generic(...) as (pos_range, neg_range): 
            with pos_range as (idx, count): 
                ... 
            with neg_range as (idx, count): 
                ... 
    &quot;&quot;&quot;</span>
    <span class="s1">intp </span><span class="s3">= </span><span class="s1">start</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s1">is_pos_step </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&gt;='</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">intp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">))</span>

    <span class="s1">pos_for_range </span><span class="s3">= </span><span class="s1">for_range_slice</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">, </span><span class="s1">inc</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">neg_for_range </span><span class="s3">= </span><span class="s1">for_range_slice</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">, </span><span class="s1">inc</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">cm_cond</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">inner_cm</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">cond</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">inner_cm </span><span class="s2">as </span><span class="s1">value</span><span class="s3">:</span>
                <span class="s2">yield </span><span class="s1">value</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_pos_step</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">then</span><span class="s3">, </span><span class="s1">otherwise</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">cm_cond</span><span class="s3">(</span><span class="s1">then</span><span class="s3">, </span><span class="s1">pos_for_range</span><span class="s3">), </span><span class="s1">cm_cond</span><span class="s3">(</span><span class="s1">otherwise</span><span class="s3">, </span><span class="s1">neg_for_range</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">'C'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a loop nest walking a N-dimensional array. 
    Yields a tuple of N indices for use in the inner loop body, 
    iterating over the *shape* space. 
 
    If *order* is 'C' (the default), indices are incremented inside-out 
    (i.e. (0,0), (0,1), (0,2), (1,0) etc.). 
    If *order* is 'F', they are incremented outside-in 
    (i.e. (0,0), (1,0), (2,0), (0,1) etc.). 
    This has performance implications when walking an array as it impacts 
    the spatial locality of memory accesses. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">order </span><span class="s2">in </span><span class="s5">'CF'</span>
    <span class="s2">if not </span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s6"># 0-d array</span>
        <span class="s2">yield </span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">order </span><span class="s3">== </span><span class="s5">'F'</span><span class="s3">:</span>
            <span class="s1">_swap </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">[::-</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">_swap </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span>
        <span class="s2">with </span><span class="s1">_loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">_swap</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">intp</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">_swap</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">_loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">):</span>
    <span class="s2">with </span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">intp</span><span class="s3">=</span><span class="s1">intp</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) &gt; </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">_loop_nest</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:], </span><span class="s1">intp</span><span class="s3">) </span><span class="s2">as </span><span class="s1">indices</span><span class="s3">:</span>
                <span class="s2">yield </span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,) + </span><span class="s1">indices</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s3">(</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">,)</span>


<span class="s2">def </span><span class="s1">pack_array</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pack a sequence of values in a LLVM array.  *ty* should be given 
    if the array may be empty, in which case the type can't be inferred 
    from the values. 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">values</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ty </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">ty </span><span class="s3">= </span><span class="s1">values</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">type</span>
    <span class="s1">ary </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Undefined</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">values</span><span class="s3">):</span>
        <span class="s1">ary </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">ary</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ary</span>


<span class="s2">def </span><span class="s1">pack_struct</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">values</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pack a sequence of values into a LLVM struct. 
    &quot;&quot;&quot;</span>
    <span class="s1">structty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">LiteralStructType</span><span class="s3">([</span><span class="s1">v</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values</span><span class="s3">])</span>
    <span class="s1">st </span><span class="s3">= </span><span class="s1">structty</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Undefined</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">values</span><span class="s3">):</span>
        <span class="s1">st </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">insert_value</span><span class="s3">(</span><span class="s1">st</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">st</span>


<span class="s2">def </span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">tup</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Unpack an array or structure of values, return a Python tuple. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">count </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># Assuming *tup* is an aggregate</span>
        <span class="s1">count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">elements</span><span class="s3">)</span>
    <span class="s1">vals </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)]</span>
    <span class="s2">return </span><span class="s1">vals</span>


<span class="s2">def </span><span class="s1">get_item_pointer</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">aryty</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">inds</span><span class="s3">, </span><span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                     <span class="s1">boundscheck</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6"># Set boundscheck=True for any pointer access that should be</span>
    <span class="s6"># boundschecked. do_boundscheck() will handle enabling or disabling the</span>
    <span class="s6"># actual boundschecking based on the user config.</span>
    <span class="s1">shapes </span><span class="s3">= </span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">strides </span><span class="s3">= </span><span class="s1">unpack_tuple</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">=</span><span class="s1">ary</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shapes</span><span class="s3">,</span>
                             <span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">=</span><span class="s1">aryty</span><span class="s3">.</span><span class="s1">layout</span><span class="s3">, </span><span class="s1">inds</span><span class="s3">=</span><span class="s1">inds</span><span class="s3">,</span>
                             <span class="s1">wraparound</span><span class="s3">=</span><span class="s1">wraparound</span><span class="s3">, </span><span class="s1">boundscheck</span><span class="s3">=</span><span class="s1">boundscheck</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">do_boundscheck</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">_dbg</span><span class="s3">():</span>
        <span class="s6"># Remove this when we figure out how to include this information</span>
        <span class="s6"># in the error message.</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
                <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot;debug: IndexError: index %d is out of bounds &quot;</span>
                       <span class="s5">&quot;for axis {} with size %d</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot;debug: IndexError: index %d is out of bounds &quot;</span>
                       <span class="s5">&quot;for axis %d with size %d</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                       <span class="s1">dimlen</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                   <span class="s5">&quot;debug: IndexError: index %d is out of bounds for size %d</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">,</span>
                   <span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">)</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;index is out of bounds&quot;</span>
    <span class="s1">out_of_bounds_upper </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&gt;='</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_of_bounds_upper</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">FULL_TRACEBACKS</span><span class="s3">:</span>
            <span class="s1">_dbg</span><span class="s3">()</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>
    <span class="s1">out_of_bounds_lower </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">out_of_bounds_lower</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">FULL_TRACEBACKS</span><span class="s3">:</span>
            <span class="s1">_dbg</span><span class="s3">()</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, (</span><span class="s1">msg</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">get_item_pointer2</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">, </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">inds</span><span class="s3">,</span>
                      <span class="s1">wraparound</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">boundscheck</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6"># Set boundscheck=True for any pointer access that should be</span>
    <span class="s6"># boundschecked. do_boundscheck() will handle enabling or disabling the</span>
    <span class="s6"># actual boundschecking based on the user config.</span>
    <span class="s2">if </span><span class="s1">wraparound</span><span class="s3">:</span>
        <span class="s6"># Wraparound</span>
        <span class="s1">indices </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">inds</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
            <span class="s1">negative </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>
            <span class="s1">wrapped </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">dimlen</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">)</span>
            <span class="s1">selected </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">negative</span><span class="s3">, </span><span class="s1">wrapped</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">)</span>
            <span class="s1">indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">selected</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">indices </span><span class="s3">= </span><span class="s1">inds</span>
    <span class="s2">if </span><span class="s1">boundscheck</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s3">, (</span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)):</span>
            <span class="s1">do_boundscheck</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">dimlen</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">indices</span><span class="s3">:</span>
        <span class="s6"># Indexing with empty tuple</span>
        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">int32_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)])</span>
    <span class="s1">intp </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">type</span>
    <span class="s6"># Indexing code</span>
    <span class="s2">if </span><span class="s1">layout </span><span class="s2">in </span><span class="s5">'CF'</span><span class="s3">:</span>
        <span class="s1">steps </span><span class="s3">= []</span>
        <span class="s6"># Compute steps for each dimension</span>
        <span class="s2">if </span><span class="s1">layout </span><span class="s3">== </span><span class="s5">'C'</span><span class="s3">:</span>
            <span class="s6"># C contiguous</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)):</span>
                <span class="s1">last </span><span class="s3">= </span><span class="s1">intp</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">:]:</span>
                    <span class="s1">last </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">last</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>
                <span class="s1">steps</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">last</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">layout </span><span class="s3">== </span><span class="s5">'F'</span><span class="s3">:</span>
            <span class="s6"># F contiguous</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)):</span>
                <span class="s1">last </span><span class="s3">= </span><span class="s1">intp</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">]:</span>
                    <span class="s1">last </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">last</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>
                <span class="s1">steps</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">last</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s5">&quot;unreachable&quot;</span><span class="s3">)</span>

        <span class="s6"># Compute index</span>
        <span class="s1">loc </span><span class="s3">= </span><span class="s1">intp</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">steps</span><span class="s3">):</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
            <span class="s1">loc </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">)</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, [</span><span class="s1">loc</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">ptr</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Any layout</span>
        <span class="s1">dimoffs </span><span class="s3">= [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">strides</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">)]</span>
        <span class="s1">offset </span><span class="s3">= </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">, </span><span class="s1">dimoffs</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">pointer_add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_scalar_pred_against_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">fpred</span><span class="s3">, </span><span class="s1">icond</span><span class="s3">):</span>
    <span class="s1">nullval </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, (</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FloatType</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">DoubleType</span><span class="s3">)):</span>
        <span class="s1">isnull </span><span class="s3">= </span><span class="s1">fpred</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">nullval</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">):</span>
        <span class="s1">isnull </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s1">icond</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">nullval</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;unexpected value type %s&quot; </span><span class="s3">% (</span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,))</span>
    <span class="s2">return </span><span class="s1">isnull</span>


<span class="s2">def </span><span class="s1">is_scalar_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a predicate representing whether *value* is equal to zero. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_scalar_pred_against_zero</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">fcmp_ordered</span><span class="s3">, </span><span class="s5">'=='</span><span class="s3">), </span><span class="s5">'=='</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_not_scalar_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a predicate representing whether a *value* is not equal to zero. 
    (not exactly &quot;not is_scalar_zero&quot; because of nans) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_scalar_pred_against_zero</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">fcmp_unordered</span><span class="s3">, </span><span class="s5">'!='</span><span class="s3">), </span><span class="s5">'!='</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_scalar_zero_or_nan</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a predicate representing whether *value* is equal to either zero 
    or NaN. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_scalar_pred_against_zero</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">fcmp_unordered</span><span class="s3">, </span><span class="s5">'=='</span><span class="s3">), </span><span class="s5">'=='</span><span class="s3">)</span>


<span class="s1">is_true </span><span class="s3">= </span><span class="s1">is_not_scalar_zero</span>
<span class="s1">is_false </span><span class="s3">= </span><span class="s1">is_scalar_zero</span>


<span class="s2">def </span><span class="s1">is_scalar_neg</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Is *value* negative?  Assumes *value* is signed. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_scalar_pred_against_zero</span><span class="s3">(</span>
        <span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">fcmp_ordered</span><span class="s3">, </span><span class="s5">'&lt;'</span><span class="s3">), </span><span class="s5">'&lt;'</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">early_exit_if</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">: </span><span class="s1">ExitStack</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The Python code:: 
 
        with contextlib.ExitStack() as stack: 
            with early_exit_if(builder, stack, cond): 
                cleanup() 
            body() 
 
    emits the code:: 
 
        if (cond) { 
            &lt;cleanup&gt; 
        } 
        else { 
            &lt;body&gt; 
        } 
 
    This can be useful for generating code with lots of early exits, without 
    having to increase the indentation each time. 
    &quot;&quot;&quot;</span>
    <span class="s1">then</span><span class="s3">, </span><span class="s1">otherwise </span><span class="s3">= </span><span class="s1">stack</span><span class="s3">.</span><span class="s1">enter_context</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">then</span><span class="s3">:</span>
        <span class="s2">yield</span>
    <span class="s1">stack</span><span class="s3">.</span><span class="s1">enter_context</span><span class="s3">(</span><span class="s1">otherwise</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">early_exit_if_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A convenience wrapper for :func:`early_exit_if`, for the common case where 
    the CPython API indicates an error by returning ``NULL``. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">early_exit_if</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">, </span><span class="s1">is_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">guard_null</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">exc_tuple</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Guard against *value* being null or zero. 
    *exc_tuple* should be a (exception type, arguments...) tuple. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_scalar_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">exc_tuple</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">exc_args </span><span class="s3">= </span><span class="s1">exc_tuple</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:] </span><span class="s2">or None</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">guard_memory_error</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pointer</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Guard against *pointer* being NULL (and raise a MemoryError). 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pointer</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">), </span><span class="s1">pointer</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s1">exc_args </span><span class="s3">= (</span><span class="s1">msg</span><span class="s3">,) </span><span class="s2">if </span><span class="s1">msg </span><span class="s2">else </span><span class="s3">()</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pointer</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">MemoryError</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">contextmanager</span>
<span class="s2">def </span><span class="s1">if_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">likely</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Execute the given block if the scalar value is zero. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">is_scalar_zero</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">), </span><span class="s1">likely</span><span class="s3">=</span><span class="s1">likely</span><span class="s3">):</span>
        <span class="s2">yield</span>


<span class="s1">guard_zero </span><span class="s3">= </span><span class="s1">guard_null</span>


<span class="s2">def </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">ltyp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Whether the LLVM type *typ* is a struct type. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ltyp</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_record_member</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">record</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">):</span>
    <span class="s1">pval </span><span class="s3">= </span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">record</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
    <span class="s2">assert not </span><span class="s1">is_pointer</span><span class="s3">(</span><span class="s1">pval</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">pval</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">())</span>


<span class="s2">def </span><span class="s1">is_neg_int</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">gep_inbounds</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, *</span><span class="s1">inds</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Same as *gep*, but add the `inbounds` keyword. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">gep</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, *</span><span class="s1">inds</span><span class="s3">, </span><span class="s1">inbounds</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">gep</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, *</span><span class="s1">inds</span><span class="s3">, **</span><span class="s1">kws</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Emit a getelementptr instruction for the given pointer and indices. 
    The indices can be LLVM values or Python int constants. 
    &quot;&quot;&quot;</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">kws</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'name'</span><span class="s3">, </span><span class="s5">''</span><span class="s3">)</span>
    <span class="s1">inbounds </span><span class="s3">= </span><span class="s1">kws</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">'inbounds'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">assert not </span><span class="s1">kws</span>
    <span class="s1">idx </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">inds</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s6"># NOTE: llvm only accepts int32 inside structs, not int64</span>
            <span class="s1">ind </span><span class="s3">= </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ind </span><span class="s3">= </span><span class="s1">i</span>
        <span class="s1">idx</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">inbounds</span><span class="s3">=</span><span class="s1">inbounds</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pointer_add</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">return_type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add an integral *offset* to pointer *ptr*, and return a pointer 
    of *return_type* (or, if omitted, the same type as *ptr*). 
 
    Note the computation is done in bytes, and ignores the width of 
    the pointed item type. 
    &quot;&quot;&quot;</span>
    <span class="s1">intptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">ptrtoint</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">offset </span><span class="s3">= </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">)</span>
    <span class="s1">intptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">intptr</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">inttoptr</span><span class="s3">(</span><span class="s1">intptr</span><span class="s3">, </span><span class="s1">return_type </span><span class="s2">or </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fill *size* bytes starting from *ptr* with *value*. 
    &quot;&quot;&quot;</span>
    <span class="s1">fn </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">declare_intrinsic</span><span class="s3">(</span><span class="s5">'llvm.memset'</span><span class="s3">, (</span><span class="s1">voidptr_t</span><span class="s3">, </span><span class="s1">size</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
    <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">voidptr_t</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">int8_t</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">bool_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)])</span>


<span class="s2">def </span><span class="s1">memset_padding</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fill padding bytes of the pointee with zeros. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Load existing value</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">)</span>
    <span class="s6"># Fill pointee with zeros</span>
    <span class="s1">memset</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">), </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s6"># Store value back</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">global_constant</span><span class="s3">(</span><span class="s1">builder_or_module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">linkage</span><span class="s3">=</span><span class="s5">'internal'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get or create a (LLVM module-)global constant with *name* or *value*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">builder_or_module</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Module</span><span class="s3">):</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">builder_or_module</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">builder_or_module</span><span class="s3">.</span><span class="s1">module</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">add_global_variable</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">value</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s1">data</span><span class="s3">.</span><span class="s1">linkage </span><span class="s3">= </span><span class="s1">linkage</span>
    <span class="s1">data</span><span class="s3">.</span><span class="s1">global_constant </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s1">data</span><span class="s3">.</span><span class="s1">initializer </span><span class="s3">= </span><span class="s1">value</span>
    <span class="s2">return </span><span class="s1">data</span>


<span class="s2">def </span><span class="s1">divmod_by_constant</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the (quotient, remainder) of *val* divided by the constant 
    positive *divisor*.  The semantics reflects those of Python integer 
    floor division, rather than C's / LLVM's signed division and modulo. 
    The difference lies with a negative *val*. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">divisor </span><span class="s3">&gt; </span><span class="s4">0</span>
    <span class="s1">divisor </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">divisor</span><span class="s3">)</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">quot </span><span class="s3">= </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">is_neg_int</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">if_neg</span><span class="s3">, </span><span class="s1">if_pos</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">if_pos</span><span class="s3">:</span>
            <span class="s6"># quot = val / divisor</span>
            <span class="s1">quot_val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sdiv</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">quot_val</span><span class="s3">, </span><span class="s1">quot</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">if_neg</span><span class="s3">:</span>
            <span class="s6"># quot = -1 + (val + 1) / divisor</span>
            <span class="s1">val_plus_one </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">one</span><span class="s3">)</span>
            <span class="s1">quot_val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sdiv</span><span class="s3">(</span><span class="s1">val_plus_one</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">quot_val</span><span class="s3">, </span><span class="s1">one</span><span class="s3">), </span><span class="s1">quot</span><span class="s3">)</span>

    <span class="s6"># rem = val - quot * divisor</span>
    <span class="s6"># (should be slightly faster than a separate modulo operation)</span>
    <span class="s1">quot_val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">quot</span><span class="s3">)</span>
    <span class="s1">rem_val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">quot_val</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">quot_val</span><span class="s3">, </span><span class="s1">rem_val</span>


<span class="s2">def </span><span class="s1">cbranch_or_continue</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">, </span><span class="s1">bbtrue</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Branch conditionally or continue. 
 
    Note: a new block is created and builder is moved to the end of the new 
          block. 
    &quot;&quot;&quot;</span>
    <span class="s1">bbcont </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s5">'.continue'</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">cbranch</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">bbtrue</span><span class="s3">, </span><span class="s1">bbcont</span><span class="s3">)</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbcont</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">bbcont</span>


<span class="s2">def </span><span class="s1">memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Emit a memcpy to the builder. 
 
    Copies each element of dst to src. Unlike the C equivalent, each element 
    can be any LLVM type. 
 
    Assumes 
    ------- 
    * dst.type == src.type 
    * count is positive 
    &quot;&quot;&quot;</span>
    <span class="s6"># Note this does seem to be optimized as a raw memcpy() by LLVM</span>
    <span class="s6"># whenever possible...</span>
    <span class="s2">assert </span><span class="s1">dst</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">src</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">with </span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">intp</span><span class="s3">=</span><span class="s1">count</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) </span><span class="s2">as </span><span class="s1">loop</span><span class="s3">:</span>
        <span class="s1">out_ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">, [</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">])</span>
        <span class="s1">in_ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, [</span><span class="s1">loop</span><span class="s3">.</span><span class="s1">index</span><span class="s3">])</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_ptr</span><span class="s3">), </span><span class="s1">out_ptr</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_raw_memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">):</span>
    <span class="s1">size_t </span><span class="s3">= </span><span class="s1">count</span><span class="s3">.</span><span class="s1">type</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">size_t</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">)</span>

    <span class="s1">memcpy </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">declare_intrinsic</span><span class="s3">(</span><span class="s1">func_name</span><span class="s3">,</span>
                                              <span class="s3">[</span><span class="s1">voidptr_t</span><span class="s3">, </span><span class="s1">voidptr_t</span><span class="s3">, </span><span class="s1">size_t</span><span class="s3">])</span>
    <span class="s1">is_volatile </span><span class="s3">= </span><span class="s1">false_bit</span>
    <span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">memcpy</span><span class="s3">, [</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">dst</span><span class="s3">, </span><span class="s1">voidptr_t</span><span class="s3">),</span>
                          <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">src</span><span class="s3">, </span><span class="s1">voidptr_t</span><span class="s3">),</span>
                          <span class="s1">builder</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">count</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">),</span>
                          <span class="s1">is_volatile</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">raw_memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">=</span><span class="s4">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Emit a raw memcpy() call for `count` items of size `itemsize` 
    from `src` to `dest`. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_raw_memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">'llvm.memcpy'</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">raw_memmove</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">=</span><span class="s4">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Emit a raw memmove() call for `count` items of size `itemsize` 
    from `src` to `dest`. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_raw_memcpy</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">'llvm.memmove'</span><span class="s3">, </span><span class="s1">dst</span><span class="s3">, </span><span class="s1">src</span><span class="s3">, </span><span class="s1">count</span><span class="s3">,</span>
                       <span class="s1">itemsize</span><span class="s3">, </span><span class="s1">align</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">muladd_with_overflow</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute (a * b + c) and return a (result, overflow bit) pair. 
    The operands must be signed integers. 
    &quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">smul_with_overflow</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">prod </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">prod_ovf </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sadd_with_overflow</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">, </span><span class="s1">c</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">ovf </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">prod_ovf</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s3">, </span><span class="s1">ovf</span>


<span class="s2">def </span><span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">format</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calls printf(). 
    Argument `format` is expected to be a Python string. 
    Values to be printed are listed in `args`. 
 
    Note: There is no checking to ensure there is correct number of values 
    in `args` and there type matches the declaration in the format string. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">format</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>
    <span class="s1">mod </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span>
    <span class="s6"># Make global constant for format string</span>
    <span class="s1">cstring </span><span class="s3">= </span><span class="s1">voidptr_t</span>
    <span class="s1">fmt_bytes </span><span class="s3">= </span><span class="s1">make_bytearray</span><span class="s3">((</span><span class="s1">format </span><span class="s3">+ </span><span class="s5">'</span><span class="s2">\00</span><span class="s5">'</span><span class="s3">).</span><span class="s1">encode</span><span class="s3">(</span><span class="s5">'ascii'</span><span class="s3">))</span>
    <span class="s1">global_fmt </span><span class="s3">= </span><span class="s1">global_constant</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s5">&quot;printf_format&quot;</span><span class="s3">, </span><span class="s1">fmt_bytes</span><span class="s3">)</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">int32_t</span><span class="s3">, [</span><span class="s1">cstring</span><span class="s3">], </span><span class="s1">var_arg</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s6"># Insert printf()</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">get_global</span><span class="s3">(</span><span class="s5">'printf'</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;printf&quot;</span><span class="s3">)</span>
    <span class="s6"># Call</span>
    <span class="s1">ptr_fmt </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">global_fmt</span><span class="s3">, </span><span class="s1">cstring</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [</span><span class="s1">ptr_fmt</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">snprintf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">bufsz</span><span class="s3">, </span><span class="s1">format</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Calls libc snprintf(buffer, bufsz, format, ...args) 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">format</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)</span>
    <span class="s1">mod </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span>
    <span class="s6"># Make global constant for format string</span>
    <span class="s1">cstring </span><span class="s3">= </span><span class="s1">voidptr_t</span>
    <span class="s1">fmt_bytes </span><span class="s3">= </span><span class="s1">make_bytearray</span><span class="s3">((</span><span class="s1">format </span><span class="s3">+ </span><span class="s5">'</span><span class="s2">\00</span><span class="s5">'</span><span class="s3">).</span><span class="s1">encode</span><span class="s3">(</span><span class="s5">'ascii'</span><span class="s3">))</span>
    <span class="s1">global_fmt </span><span class="s3">= </span><span class="s1">global_constant</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s5">&quot;snprintf_format&quot;</span><span class="s3">, </span><span class="s1">fmt_bytes</span><span class="s3">)</span>
    <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span>
        <span class="s1">int32_t</span><span class="s3">, [</span><span class="s1">cstring</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">cstring</span><span class="s3">], </span><span class="s1">var_arg</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s6"># Actual symbol name of snprintf is different on win32.</span>
    <span class="s1">symbol </span><span class="s3">= </span><span class="s5">'snprintf'</span>
    <span class="s2">if </span><span class="s1">config</span><span class="s3">.</span><span class="s1">IS_WIN32</span><span class="s3">:</span>
        <span class="s1">symbol </span><span class="s3">= </span><span class="s5">'_' </span><span class="s3">+ </span><span class="s1">symbol</span>
    <span class="s6"># Insert snprintf()</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">get_global</span><span class="s3">(</span><span class="s1">symbol</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">symbol</span><span class="s3">)</span>
    <span class="s6"># Call</span>
    <span class="s1">ptr_fmt </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">global_fmt</span><span class="s3">, </span><span class="s1">cstring</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">bufsz</span><span class="s3">, </span><span class="s1">ptr_fmt</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">snprintf_stackbuffer</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">bufsz</span><span class="s3">, </span><span class="s1">format</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Similar to `snprintf()` but the buffer is stack allocated to size 
    *bufsz*. 
 
    Returns the buffer pointer as i8*. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bufsz</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">spacety </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">8</span><span class="s3">), </span><span class="s1">bufsz</span><span class="s3">)</span>
    <span class="s1">space </span><span class="s3">= </span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">spacety</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">buffer </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">space</span><span class="s3">, </span><span class="s1">voidptr_t</span><span class="s3">)</span>
    <span class="s1">snprintf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">bufsz</span><span class="s3">), </span><span class="s1">format</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">buffer</span>


<span class="s2">def </span><span class="s1">normalize_ir_text</span><span class="s3">(</span><span class="s1">text</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Normalize the given string to latin1 compatible encoding that is 
    suitable for use in LLVM IR. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Just re-encoding to latin1 is enough</span>
    <span class="s2">return </span><span class="s1">text</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s5">'utf8'</span><span class="s3">).</span><span class="s1">decode</span><span class="s3">(</span><span class="s5">'latin1'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">hexdump</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Debug print the memory region in *ptr* to *ptr + nbytes* 
    as hex. 
    &quot;&quot;&quot;</span>
    <span class="s1">bytes_per_line </span><span class="s3">= </span><span class="s4">16</span>
    <span class="s1">nbytes </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">zext</span><span class="s3">(</span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">)</span>
    <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot;hexdump p=%p n=%zu&quot;</span><span class="s3">,</span>
           <span class="s1">ptr</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">)</span>
    <span class="s1">byte_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s4">8</span><span class="s3">)</span>
    <span class="s1">ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, </span><span class="s1">byte_t</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">())</span>
    <span class="s6"># Loop to print the bytes in *ptr* as hex</span>
    <span class="s2">with </span><span class="s1">for_range</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">) </span><span class="s2">as </span><span class="s1">idx</span><span class="s3">:</span>
        <span class="s1">div_by </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">urem</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s1">bytes_per_line</span><span class="s3">))</span>
        <span class="s1">do_new_line </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s5">&quot;==&quot;</span><span class="s3">, </span><span class="s1">div_by</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">do_new_line</span><span class="s3">):</span>
            <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">)</span>

        <span class="s1">offset </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">ptr</span><span class="s3">, [</span><span class="s1">idx</span><span class="s3">.</span><span class="s1">index</span><span class="s3">])</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">)</span>
        <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot; %02x&quot;</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>
    <span class="s1">printf</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">is_nonelike</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; returns if 'ty' is none &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">ty </span><span class="s2">is None or</span>
        <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">NoneType</span><span class="s3">) </span><span class="s2">or</span>
        <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Omitted</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">create_constant_array</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">val</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an LLVM-constant of a fixed-length array from Python values. 
 
    The type provided is the type of the elements. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)), </span><span class="s1">val</span><span class="s3">)</span>
</pre>
</body>
</html>