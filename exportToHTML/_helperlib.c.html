<html>
<head>
<title>_helperlib.c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #0da19e;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_helperlib.c</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Helper functions used by Numba at runtime. 
 * This C file is meant to be included after defining the 
 * NUMBA_EXPORT_FUNC() and NUMBA_EXPORT_DATA() macros. 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;_pymodule.h&quot;</span>
<span class="s2">#include </span><span class="s1">&lt;stddef.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdio.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;math.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;complex.h&gt;</span>
<span class="s2">#ifdef </span><span class="s1">_MSC_VER</span>
    <span class="s2">#define </span><span class="s1">int64_t </span><span class="s2">signed </span><span class="s1">__int64</span>
    <span class="s2">#define </span><span class="s1">uint64_t </span><span class="s2">unsigned </span><span class="s1">__int64</span>
    <span class="s2">#define </span><span class="s1">uint32_t </span><span class="s2">unsigned </span><span class="s1">__int32</span>
    <span class="s2">#define </span><span class="s1">_complex_float_t _Fcomplex</span>
    <span class="s2">#define </span><span class="s1">_complex_float_ctor(r, i) _FCbuild(r, i)</span>
    <span class="s2">#define </span><span class="s1">_complex_double_t _Dcomplex</span>
<span class="s2">#else</span>
    <span class="s2">#include </span><span class="s1">&lt;stdint.h&gt;</span>
    <span class="s2">#define </span><span class="s1">_complex_float_t complex </span><span class="s2">float</span>
    <span class="s2">#define </span><span class="s1">_complex_float_ctor(r, i) (r + I * i)</span>
    <span class="s2">#define </span><span class="s1">_complex_double_t complex </span><span class="s2">double</span>
<span class="s2">#endif</span>
<span class="s2">#define </span><span class="s1">NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION</span>
<span class="s2">#include </span><span class="s1">&lt;numpy/ndarrayobject.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;numpy/arrayscalars.h&gt;</span>

<span class="s2">#include </span><span class="s3">&quot;_arraystruct.h&quot;</span>


<span class="s2">#if </span><span class="s1">(PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION == </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s0">/* 
     * For struct _frame 
     */</span>
    <span class="s2">#include </span><span class="s3">&quot;internal/pycore_frame.h&quot;</span>
<span class="s2">#endif</span>

<span class="s0">/* 
 * Other helpers. 
 */</span>


<span class="s0">/* Fix fmod() and fmodf() for windows x64 VC 9.0 (VS 2008) 
https://support.microsoft.com/en-us/kb/982107 
*/</span>
<span class="s2">static  void </span><span class="s1">(*fnclex)(</span><span class="s2">void</span><span class="s1">) = NULL;</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_fixed_fmod(</span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">y){</span>
    <span class="s1">fnclex();  </span><span class="s0">/* no inline asm in x64 =( */</span>
    <span class="s2">return </span><span class="s1">fmod(x, y);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_fixed_fmodf(</span><span class="s2">float </span><span class="s1">x, </span><span class="s2">float </span><span class="s1">y) {</span>
    <span class="s1">fnclex();  </span><span class="s0">/* no inline asm in x64 =( */</span>
    <span class="s2">return </span><span class="s1">fmodf(x, y);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_set_fnclex(</span><span class="s2">void </span><span class="s1">*fn){</span>
    <span class="s1">fnclex = fn;</span>
<span class="s1">}</span>

<span class="s0">/* provide 64-bit division function to 32-bit platforms */</span>
<span class="s1">NUMBA_EXPORT_FUNC(int64_t)</span>
<span class="s1">numba_sdiv(int64_t a, int64_t b) {</span>
    <span class="s2">return </span><span class="s1">a / b;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(uint64_t)</span>
<span class="s1">numba_udiv(uint64_t a, uint64_t b) {</span>
    <span class="s2">return </span><span class="s1">a / b;</span>
<span class="s1">}</span>

<span class="s0">/* provide 64-bit remainder function to 32-bit platforms */</span>
<span class="s1">NUMBA_EXPORT_FUNC(int64_t)</span>
<span class="s1">numba_srem(int64_t a, int64_t b) {</span>
    <span class="s2">return </span><span class="s1">a % b;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(uint64_t)</span>
<span class="s1">numba_urem(uint64_t a, uint64_t b) {</span>
    <span class="s2">return </span><span class="s1">a % b;</span>
<span class="s1">}</span>

<span class="s0">/* provide frexp and ldexp; these wrappers deal with special cases 
 * (zero, nan, infinity) directly, to sidestep platform differences. 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_frexp(</span><span class="s2">double </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">*exp)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!Py_IS_FINITE(x) || !x)</span>
        <span class="s1">*exp = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">else</span>
        <span class="s1">x = frexp(x, exp);</span>
    <span class="s2">return </span><span class="s1">x;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_frexpf(</span><span class="s2">float </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">*exp)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(Py_IS_NAN(x) || Py_IS_INFINITY(x) || !x)</span>
        <span class="s1">*exp = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">else</span>
        <span class="s1">x = frexpf(x, exp);</span>
    <span class="s2">return </span><span class="s1">x;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_ldexp(</span><span class="s2">double </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">exp)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(Py_IS_FINITE(x) &amp;&amp; x &amp;&amp; exp)</span>
        <span class="s1">x = ldexp(x, exp);</span>
    <span class="s2">return </span><span class="s1">x;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_ldexpf(</span><span class="s2">float </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">exp)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(Py_IS_FINITE(x) &amp;&amp; x &amp;&amp; exp)</span>
        <span class="s1">x = ldexpf(x, exp);</span>
    <span class="s2">return </span><span class="s1">x;</span>
<span class="s1">}</span>

<span class="s0">/* provide complex power */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_cpow(Py_complex *a, Py_complex *b, Py_complex *out) {</span>
    <span class="s1">errno = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">*out = _Py_c_pow(*a, *b);</span>
    <span class="s2">if </span><span class="s1">(errno == EDOM) {</span>
        <span class="s0">/* _Py_c_pow() doesn't bother returning the right value 
           in this case, as Python raises ZeroDivisionError */</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">real = out</span><span class="s5">-&gt;</span><span class="s1">imag = Py_NAN;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_cpowf(_complex_float_t *a, _complex_float_t *b, _complex_float_t *out) {</span>
    <span class="s1">Py_complex _a, _b, _out;</span>
    <span class="s1">_a.real = crealf(*a);</span>
    <span class="s1">_a.imag = cimagf(*a);</span>
    <span class="s1">_b.real = crealf(*b);</span>
    <span class="s1">_b.imag = cimagf(*b);</span>
    <span class="s1">numba_cpow(&amp;_a, &amp;_b, &amp;_out);</span>
    <span class="s1">*out = _complex_float_ctor((</span><span class="s2">float</span><span class="s1">) _out.real, (</span><span class="s2">float</span><span class="s1">) _out.imag);</span>
<span class="s1">}</span>

<span class="s0">/* C99 math functions: redirect to system implementations */</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_gamma(</span><span class="s2">double </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">tgamma(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_gammaf(</span><span class="s2">float </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">tgammaf(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_lgamma(</span><span class="s2">double </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">lgamma(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_lgammaf(</span><span class="s2">float </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">lgammaf(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_erf(</span><span class="s2">double </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">erf(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_erff(</span><span class="s2">float </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">erff(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_erfc(</span><span class="s2">double </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">erfc(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_erfcf(</span><span class="s2">float </span><span class="s1">x)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">erfcf(x);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">float</span><span class="s1">)</span>
<span class="s1">numba_nextafterf(</span><span class="s2">float </span><span class="s1">a, </span><span class="s2">float </span><span class="s1">b)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">nextafterf(a, b);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">double</span><span class="s1">)</span>
<span class="s1">numba_nextafter(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">nextafter(a, b);</span>
<span class="s1">}</span>

<span class="s0">/* Unpack any Python complex-like object into a Py_complex structure */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_complex_adaptor(PyObject* obj, Py_complex *out) {</span>
    <span class="s1">PyObject* fobj;</span>
    <span class="s1">PyArray_Descr *dtype;</span>
    <span class="s2">double </span><span class="s1">val[</span><span class="s4">2</span><span class="s1">];</span>

    <span class="s0">// Convert from python complex or numpy complex128</span>
    <span class="s2">if </span><span class="s1">(PyComplex_Check(obj)) {</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">real = PyComplex_RealAsDouble(obj);</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">imag = PyComplex_ImagAsDouble(obj);</span>
    <span class="s1">}</span>
    <span class="s0">// Convert from numpy complex64</span>
    <span class="s2">else if </span><span class="s1">(PyArray_IsScalar(obj, ComplexFloating)) {</span>
        <span class="s1">dtype = PyArray_DescrFromScalar(obj);</span>
        <span class="s2">if </span><span class="s1">(dtype == NULL) {</span>
            <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(PyArray_CastScalarDirect(obj, dtype, &amp;val[</span><span class="s4">0</span><span class="s1">], NPY_CDOUBLE) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">Py_DECREF(dtype);</span>
            <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">real = val[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">imag = val[</span><span class="s4">1</span><span class="s1">];</span>
        <span class="s1">Py_DECREF(dtype);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">fobj = PyNumber_Float(obj);</span>
        <span class="s2">if </span><span class="s1">(!fobj) </span><span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">real = PyFloat_AsDouble(fobj);</span>
        <span class="s1">out</span><span class="s5">-&gt;</span><span class="s1">imag = </span><span class="s4">0</span><span class="s1">.;</span>
        <span class="s1">Py_DECREF(fobj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* Minimum PyBufferObject structure to hack inside it */</span>
<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD</span>
    <span class="s1">PyObject *b_base;</span>
    <span class="s2">void </span><span class="s1">*b_ptr;</span>
    <span class="s1">Py_ssize_t b_size;</span>
    <span class="s1">Py_ssize_t b_offset;</span>
<span class="s1">}  PyBufferObject_Hack;</span>

<span class="s0">/* 
Get data address of record data buffer 
*/</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void </span><span class="s1">*)</span>
<span class="s1">numba_extract_record_data(PyObject *recordobj, Py_buffer *pbuf) {</span>
    <span class="s1">PyObject *attrdata;</span>
    <span class="s2">void </span><span class="s1">*ptr;</span>

    <span class="s1">attrdata = PyObject_GetAttrString(recordobj, </span><span class="s3">&quot;data&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(!attrdata) </span><span class="s2">return </span><span class="s1">NULL;</span>

    <span class="s2">if </span><span class="s1">(-</span><span class="s4">1 </span><span class="s1">== PyObject_GetBuffer(attrdata, pbuf, </span><span class="s4">0</span><span class="s1">)){</span>
        <span class="s1">Py_DECREF(attrdata);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ptr = pbuf</span><span class="s5">-&gt;</span><span class="s1">buf;</span>
    <span class="s1">}</span>
    <span class="s1">Py_DECREF(attrdata);</span>
    <span class="s2">return </span><span class="s1">ptr;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Return a record instance with dtype as the record type, and backed 
 * by a copy of the memory area pointed to by (pdata, size). 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_recreate_record(</span><span class="s2">void </span><span class="s1">*pdata, </span><span class="s2">int </span><span class="s1">size, PyObject *dtype) {</span>
    <span class="s1">PyObject *numpy = NULL;</span>
    <span class="s1">PyObject *numpy_record = NULL;</span>
    <span class="s1">PyObject *aryobj = NULL;</span>
    <span class="s1">PyObject *dtypearg = NULL;</span>
    <span class="s1">PyObject *record = NULL;</span>
    <span class="s1">PyArray_Descr *descr = NULL;</span>

    <span class="s2">if </span><span class="s1">(dtype == NULL) {</span>
        <span class="s1">PyErr_Format(PyExc_RuntimeError,</span>
            <span class="s3">&quot;In 'numba_recreate_record', 'dtype' is NULL&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">numpy = PyImport_ImportModuleNoBlock(</span><span class="s3">&quot;numpy&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(!numpy) </span><span class="s2">goto </span><span class="s1">CLEANUP;</span>

    <span class="s1">numpy_record = PyObject_GetAttrString(numpy, </span><span class="s3">&quot;record&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(!numpy_record) </span><span class="s2">goto </span><span class="s1">CLEANUP;</span>

    <span class="s1">dtypearg = PyTuple_Pack(</span><span class="s4">2</span><span class="s1">, numpy_record, dtype);</span>
    <span class="s2">if </span><span class="s1">(!dtypearg || !PyArray_DescrConverter(dtypearg, &amp;descr))</span>
        <span class="s2">goto </span><span class="s1">CLEANUP;</span>

    <span class="s0">/* This steals a reference to descr, so we don't have to DECREF it */</span>
    <span class="s1">aryobj = PyArray_FromString(pdata, size, descr, </span><span class="s4">1</span><span class="s1">, NULL);</span>
    <span class="s2">if </span><span class="s1">(!aryobj) </span><span class="s2">goto </span><span class="s1">CLEANUP;</span>

    <span class="s1">record = PySequence_GetItem(aryobj, </span><span class="s4">0</span><span class="s1">);</span>

<span class="s1">CLEANUP:</span>
    <span class="s1">Py_XDECREF(numpy);</span>
    <span class="s1">Py_XDECREF(numpy_record);</span>
    <span class="s1">Py_XDECREF(aryobj);</span>
    <span class="s1">Py_XDECREF(dtypearg);</span>

    <span class="s2">return </span><span class="s1">record;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_adapt_ndarray(PyObject *obj, arystruct_t* arystruct) {</span>
    <span class="s1">PyArrayObject *ndary;</span>
    <span class="s2">int </span><span class="s1">i, ndim;</span>
    <span class="s1">npy_intp *p;</span>

    <span class="s2">if </span><span class="s1">(!PyArray_Check(obj)) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ndary = (PyArrayObject*)obj;</span>
    <span class="s1">ndim = PyArray_NDIM(ndary);</span>

    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">data = PyArray_DATA(ndary);</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">nitems = PyArray_SIZE(ndary);</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">itemsize = PyArray_ITEMSIZE(ndary);</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">parent = obj;</span>
    <span class="s1">p = arystruct</span><span class="s5">-&gt;</span><span class="s1">shape_and_strides;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; ndim; i++, p++) {</span>
        <span class="s1">*p = PyArray_DIM(ndary, i);</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; ndim; i++, p++) {</span>
        <span class="s1">*p = PyArray_STRIDE(ndary, i);</span>
    <span class="s1">}</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">meminfo = NULL;</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_get_buffer(PyObject *obj, Py_buffer *buf)</span>
<span class="s1">{</span>
    <span class="s0">/* Ask for shape and strides, but no suboffsets */</span>
    <span class="s2">return </span><span class="s1">PyObject_GetBuffer(obj, buf, PyBUF_RECORDS_RO);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_adapt_buffer(Py_buffer *buf, arystruct_t *arystruct)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">i;</span>
    <span class="s1">npy_intp *p;</span>

    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">data = buf</span><span class="s5">-&gt;</span><span class="s1">buf;</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">itemsize = buf</span><span class="s5">-&gt;</span><span class="s1">itemsize;</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">parent = buf</span><span class="s5">-&gt;</span><span class="s1">obj;</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">nitems = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">p = arystruct</span><span class="s5">-&gt;</span><span class="s1">shape_and_strides;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; buf</span><span class="s5">-&gt;</span><span class="s1">ndim; i++, p++) {</span>
        <span class="s1">*p = buf</span><span class="s5">-&gt;</span><span class="s1">shape[i];</span>
        <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">nitems *= buf</span><span class="s5">-&gt;</span><span class="s1">shape[i];</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; buf</span><span class="s5">-&gt;</span><span class="s1">ndim; i++, p++) {</span>
        <span class="s1">*p = buf</span><span class="s5">-&gt;</span><span class="s1">strides[i];</span>
    <span class="s1">}</span>
    <span class="s1">arystruct</span><span class="s5">-&gt;</span><span class="s1">meminfo = NULL;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_release_buffer(Py_buffer *buf)</span>
<span class="s1">{</span>
    <span class="s1">PyBuffer_Release(buf);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_ndarray_new(</span><span class="s2">int </span><span class="s1">nd,</span>
                  <span class="s1">npy_intp *dims,   </span><span class="s0">/* shape */</span>
                  <span class="s1">npy_intp *strides,</span>
                  <span class="s2">void</span><span class="s1">* data,</span>
                  <span class="s2">int </span><span class="s1">type_num,</span>
                  <span class="s2">int </span><span class="s1">itemsize)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *ndary;</span>
    <span class="s2">int </span><span class="s1">flags = NPY_ARRAY_BEHAVED;</span>
    <span class="s1">ndary = PyArray_New((PyTypeObject*)&amp;PyArray_Type, nd, dims, type_num,</span>
                       <span class="s1">strides, data, </span><span class="s4">0</span><span class="s1">, flags, NULL);</span>
    <span class="s2">return </span><span class="s1">ndary;</span>
<span class="s1">}</span>


<span class="s0">/* 
 * Handle reshaping of zero-sized array. 
 * See numba_attempt_nocopy_reshape() below. 
 */</span>
<span class="s2">static int</span>
<span class="s1">nocopy_empty_reshape(npy_intp nd, </span><span class="s2">const </span><span class="s1">npy_intp *dims, </span><span class="s2">const </span><span class="s1">npy_intp *strides,</span>
                     <span class="s1">npy_intp newnd, </span><span class="s2">const </span><span class="s1">npy_intp *newdims,</span>
                     <span class="s1">npy_intp *newstrides, npy_intp itemsize,</span>
                     <span class="s2">int </span><span class="s1">is_f_order)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">i;</span>
    <span class="s0">/* Just make the strides vaguely reasonable 
     * (they can have any value in theory). 
     */</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; newnd; i++)</span>
        <span class="s1">newstrides[i] = itemsize;</span>
    <span class="s2">return </span><span class="s4">1</span><span class="s1">;  </span><span class="s0">/* reshape successful */</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Straight from Numpy's _attempt_nocopy_reshape() 
 * (np/core/src/multiarray/shape.c). 
 * Attempt to reshape an array without copying data 
 * 
 * This function should correctly handle all reshapes, including 
 * axes of length 1. Zero strides should work but are untested. 
 * 
 * If a copy is needed, returns 0 
 * If no copy is needed, returns 1 and fills `npy_intp *newstrides` 
 *     with appropriate strides 
 */</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_attempt_nocopy_reshape(npy_intp nd, </span><span class="s2">const </span><span class="s1">npy_intp *dims, </span><span class="s2">const </span><span class="s1">npy_intp *strides,</span>
                             <span class="s1">npy_intp newnd, </span><span class="s2">const </span><span class="s1">npy_intp *newdims,</span>
                             <span class="s1">npy_intp *newstrides, npy_intp itemsize,</span>
                             <span class="s2">int </span><span class="s1">is_f_order)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">oldnd;</span>
    <span class="s1">npy_intp olddims[NPY_MAXDIMS];</span>
    <span class="s1">npy_intp oldstrides[NPY_MAXDIMS];</span>
    <span class="s1">npy_intp np, op, last_stride;</span>
    <span class="s2">int </span><span class="s1">oi, oj, ok, ni, nj, nk;</span>

    <span class="s1">oldnd = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">/* 
     * Remove axes with dimension 1 from the old array. They have no effect 
     * but would need special cases since their strides do not matter. 
     */</span>
    <span class="s2">for </span><span class="s1">(oi = </span><span class="s4">0</span><span class="s1">; oi &lt; nd; oi++) {</span>
        <span class="s2">if </span><span class="s1">(dims[oi]!= </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">olddims[oldnd] = dims[oi];</span>
            <span class="s1">oldstrides[oldnd] = strides[oi];</span>
            <span class="s1">oldnd++;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">np = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(ni = </span><span class="s4">0</span><span class="s1">; ni &lt; newnd; ni++) {</span>
        <span class="s1">np *= newdims[ni];</span>
    <span class="s1">}</span>
    <span class="s1">op = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(oi = </span><span class="s4">0</span><span class="s1">; oi &lt; oldnd; oi++) {</span>
        <span class="s1">op *= olddims[oi];</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(np != op) {</span>
        <span class="s0">/* different total sizes; no hope */</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(np == </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">/* the Numpy code does not handle 0-sized arrays */</span>
        <span class="s2">return </span><span class="s1">nocopy_empty_reshape(nd, dims, strides,</span>
                                    <span class="s1">newnd, newdims, newstrides,</span>
                                    <span class="s1">itemsize, is_f_order);</span>
    <span class="s1">}</span>

    <span class="s0">/* oi to oj and ni to nj give the axis ranges currently worked with */</span>
    <span class="s1">oi = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">oj = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">ni = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">nj = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(ni &lt; newnd &amp;&amp; oi &lt; oldnd) {</span>
        <span class="s1">np = newdims[ni];</span>
        <span class="s1">op = olddims[oi];</span>

        <span class="s2">while </span><span class="s1">(np != op) {</span>
            <span class="s2">if </span><span class="s1">(np &lt; op) {</span>
                <span class="s0">/* Misses trailing 1s, these are handled later */</span>
                <span class="s1">np *= newdims[nj++];</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">op *= olddims[oj++];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/* Check whether the original axes can be combined */</span>
        <span class="s2">for </span><span class="s1">(ok = oi; ok &lt; oj - </span><span class="s4">1</span><span class="s1">; ok++) {</span>
            <span class="s2">if </span><span class="s1">(is_f_order) {</span>
                <span class="s2">if </span><span class="s1">(oldstrides[ok+</span><span class="s4">1</span><span class="s1">] != olddims[ok]*oldstrides[ok]) {</span>
                     <span class="s0">/* not contiguous enough */</span>
                    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s0">/* C order */</span>
                <span class="s2">if </span><span class="s1">(oldstrides[ok] != olddims[ok+</span><span class="s4">1</span><span class="s1">]*oldstrides[ok+</span><span class="s4">1</span><span class="s1">]) {</span>
                    <span class="s0">/* not contiguous enough */</span>
                    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/* Calculate new strides for all axes currently worked with */</span>
        <span class="s2">if </span><span class="s1">(is_f_order) {</span>
            <span class="s1">newstrides[ni] = oldstrides[oi];</span>
            <span class="s2">for </span><span class="s1">(nk = ni + </span><span class="s4">1</span><span class="s1">; nk &lt; nj; nk++) {</span>
                <span class="s1">newstrides[nk] = newstrides[nk - </span><span class="s4">1</span><span class="s1">]*newdims[nk - </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">/* C order */</span>
            <span class="s1">newstrides[nj - </span><span class="s4">1</span><span class="s1">] = oldstrides[oj - </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s2">for </span><span class="s1">(nk = nj - </span><span class="s4">1</span><span class="s1">; nk &gt; ni; nk--) {</span>
                <span class="s1">newstrides[nk - </span><span class="s4">1</span><span class="s1">] = newstrides[nk]*newdims[nk];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">ni = nj++;</span>
        <span class="s1">oi = oj++;</span>
    <span class="s1">}</span>

    <span class="s0">/* 
     * Set strides corresponding to trailing 1s of the new shape. 
     */</span>
    <span class="s2">if </span><span class="s1">(ni &gt;= </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">last_stride = newstrides[ni - </span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">last_stride = itemsize;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(is_f_order) {</span>
        <span class="s1">last_stride *= newdims[ni - </span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(nk = ni; nk &lt; newnd; nk++) {</span>
        <span class="s1">newstrides[nk] = last_stride;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Cython utilities. 
 */</span>

<span class="s0">/* Fetch the address of the given function, as exposed by 
   a cython module */</span>
<span class="s2">static void </span><span class="s1">*</span>
<span class="s1">import_cython_function(</span><span class="s2">const char </span><span class="s1">*module_name, </span><span class="s2">const char </span><span class="s1">*function_name)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *module, *capi, *cobj;</span>
    <span class="s2">void </span><span class="s1">*res = NULL;</span>
    <span class="s2">const char </span><span class="s1">*capsule_name;</span>

    <span class="s1">module = PyImport_ImportModule(module_name);</span>
    <span class="s2">if </span><span class="s1">(module == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">capi = PyObject_GetAttrString(module, </span><span class="s3">&quot;__pyx_capi__&quot;</span><span class="s1">);</span>
    <span class="s1">Py_DECREF(module);</span>
    <span class="s2">if </span><span class="s1">(capi == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">cobj = PyMapping_GetItemString(capi, (</span><span class="s2">char </span><span class="s1">*)function_name);</span>
    <span class="s1">Py_DECREF(capi);</span>
    <span class="s2">if </span><span class="s1">(cobj == NULL) {</span>
        <span class="s1">PyErr_Clear();</span>
        <span class="s1">PyErr_Format(PyExc_ValueError,</span>
                     <span class="s3">&quot;No function '%s' found in __pyx_capi__ of '%s'&quot;</span><span class="s1">,</span>
                     <span class="s1">function_name, module_name);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s0">/* 2.7+ =&gt; Cython exports a PyCapsule */</span>
    <span class="s1">capsule_name = PyCapsule_GetName(cobj);</span>
    <span class="s2">if </span><span class="s1">(capsule_name != NULL) {</span>
        <span class="s1">res = PyCapsule_GetPointer(cobj, capsule_name);</span>
    <span class="s1">}</span>
    <span class="s1">Py_DECREF(cobj);</span>
    <span class="s2">return </span><span class="s1">res;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">_numba_import_cython_function(PyObject *self, PyObject *args)</span>
<span class="s1">{</span>
    <span class="s2">const char </span><span class="s1">*module_name;</span>
    <span class="s2">const char </span><span class="s1">*function_name;</span>
    <span class="s2">void </span><span class="s1">*p = NULL;</span>
    <span class="s1">PyObject *res;</span>

    <span class="s2">if </span><span class="s1">(!PyArg_ParseTuple(args, </span><span class="s3">&quot;ss&quot;</span><span class="s1">, &amp;module_name, &amp;function_name)) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s1">p = import_cython_function(module_name, function_name);</span>
    <span class="s2">if </span><span class="s1">(p == NULL) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s1">res = PyLong_FromVoidPtr(p);</span>
    <span class="s2">if </span><span class="s1">(res == NULL) {</span>
      <span class="s1">PyErr_SetString(PyExc_RuntimeError,</span>
                      <span class="s3">&quot;Could not convert function address to int&quot;</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res;</span>
<span class="s1">}</span>

<span class="s0">/* We use separate functions for datetime64 and timedelta64, to ensure 
 * proper type checking. 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(npy_int64)</span>
<span class="s1">numba_extract_np_datetime(PyObject *td)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyArray_IsScalar(td, Datetime)) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError,</span>
                        <span class="s3">&quot;expected a numpy.datetime64 object&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">PyArrayScalar_VAL(td, Timedelta);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(npy_int64)</span>
<span class="s1">numba_extract_np_timedelta(PyObject *td)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyArray_IsScalar(td, Timedelta)) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError,</span>
                        <span class="s3">&quot;expected a numpy.timedelta64 object&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">PyArrayScalar_VAL(td, Timedelta);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_create_np_datetime(npy_int64 value, </span><span class="s2">int </span><span class="s1">unit_code)</span>
<span class="s1">{</span>
    <span class="s1">PyDatetimeScalarObject *obj = (PyDatetimeScalarObject *)</span>
        <span class="s1">PyArrayScalar_New(Datetime);</span>
    <span class="s2">if </span><span class="s1">(obj != NULL) {</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obval = value;</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obmeta.base = unit_code;</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obmeta.num = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(PyObject *) obj;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_create_np_timedelta(npy_int64 value, </span><span class="s2">int </span><span class="s1">unit_code)</span>
<span class="s1">{</span>
    <span class="s1">PyTimedeltaScalarObject *obj = (PyTimedeltaScalarObject *)</span>
        <span class="s1">PyArrayScalar_New(Timedelta);</span>
    <span class="s2">if </span><span class="s1">(obj != NULL) {</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obval = value;</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obmeta.base = unit_code;</span>
        <span class="s1">obj</span><span class="s5">-&gt;</span><span class="s1">obmeta.num = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(PyObject *) obj;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(uint64_t)</span>
<span class="s1">numba_fptoui(</span><span class="s2">double </span><span class="s1">x) {</span>
    <span class="s0">/* First cast to signed int of the full width to make sure sign extension 
       happens (this can make a difference on some platforms...). */</span>
    <span class="s2">return </span><span class="s1">(uint64_t) (int64_t) x;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(uint64_t)</span>
<span class="s1">numba_fptouif(</span><span class="s2">float </span><span class="s1">x) {</span>
    <span class="s2">return </span><span class="s1">(uint64_t) (int64_t) x;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_gil_ensure(PyGILState_STATE *state) {</span>
    <span class="s1">*state = PyGILState_Ensure();</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_gil_release(PyGILState_STATE *state) {</span>
    <span class="s1">PyGILState_Release(*state);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_py_type(PyObject *obj) {</span>
    <span class="s2">return </span><span class="s1">(PyObject *) Py_TYPE(obj);</span>
<span class="s1">}</span>


<span class="s0">/* 
 * Functions for tagging an arbitrary Python object with an arbitrary pointer. 
 * These functions make strong lifetime assumptions, see below. 
 */</span>

<span class="s2">static </span><span class="s1">PyObject *private_data_dict = NULL;</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_get_private_data_dict(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(private_data_dict == NULL)</span>
        <span class="s1">private_data_dict = PyDict_New();</span>
    <span class="s2">return </span><span class="s1">private_data_dict;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_set_pyobject_private_data(PyObject *obj, </span><span class="s2">void </span><span class="s1">*ptr)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *dct = _get_private_data_dict();</span>
    <span class="s0">/* This assumes the reference to setobj is kept alive until the 
       call to numba_reset_set_private_data()! */</span>
    <span class="s1">PyObject *key = PyLong_FromVoidPtr((</span><span class="s2">void </span><span class="s1">*) obj);</span>
    <span class="s1">PyObject *value = PyLong_FromVoidPtr(ptr);</span>

    <span class="s2">if </span><span class="s1">(!dct || !value || !key)</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s2">if </span><span class="s1">(PyDict_SetItem(dct, key, value))</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s1">Py_DECREF(key);</span>
    <span class="s1">Py_DECREF(value);</span>
    <span class="s2">return</span><span class="s1">;</span>

<span class="s1">error:</span>
    <span class="s1">Py_FatalError(</span><span class="s3">&quot;unable to set private data&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void </span><span class="s1">*)</span>
<span class="s1">numba_get_pyobject_private_data(PyObject *obj)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *dct = _get_private_data_dict();</span>
    <span class="s1">PyObject *value, *key = PyLong_FromVoidPtr((</span><span class="s2">void </span><span class="s1">*) obj);</span>
    <span class="s2">void </span><span class="s1">*ptr;</span>
    <span class="s2">if </span><span class="s1">(!dct || !key)</span>
        <span class="s2">goto </span><span class="s1">error;</span>

    <span class="s1">value = PyDict_GetItem(dct, key);</span>
    <span class="s1">Py_DECREF(key);</span>
    <span class="s2">if </span><span class="s1">(!value)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ptr = PyLong_AsVoidPtr(value);</span>
        <span class="s2">if </span><span class="s1">(ptr == NULL &amp;&amp; PyErr_Occurred())</span>
            <span class="s2">goto </span><span class="s1">error;</span>
        <span class="s2">return </span><span class="s1">ptr;</span>
    <span class="s1">}</span>

<span class="s1">error:</span>
    <span class="s1">Py_FatalError(</span><span class="s3">&quot;unable to get private data&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_reset_pyobject_private_data(PyObject *obj)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *dct = _get_private_data_dict();</span>
    <span class="s1">PyObject *key = PyLong_FromVoidPtr((</span><span class="s2">void </span><span class="s1">*) obj);</span>

    <span class="s2">if </span><span class="s1">(!key)</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s2">if </span><span class="s1">(PyDict_DelItem(dct, key))</span>
        <span class="s1">PyErr_Clear();</span>
    <span class="s1">Py_DECREF(key);</span>
    <span class="s2">return</span><span class="s1">;</span>

<span class="s1">error:</span>
    <span class="s1">Py_FatalError(</span><span class="s3">&quot;unable to reset private data&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_unpack_slice(PyObject *obj,</span>
                   <span class="s1">Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)</span>
<span class="s1">{</span>
    <span class="s1">PySliceObject *slice = (PySliceObject *) obj;</span>
    <span class="s2">if </span><span class="s1">(!PySlice_Check(obj)) {</span>
        <span class="s1">PyErr_Format(PyExc_TypeError,</span>
                     <span class="s3">&quot;Expected a slice object, got '%s'&quot;</span><span class="s1">,</span>
                     <span class="s1">Py_TYPE(slice)</span><span class="s5">-&gt;</span><span class="s1">tp_name);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s2">#define </span><span class="s1">FETCH_MEMBER(NAME, DEFAULT)                             \</span>
    <span class="s2">if </span><span class="s1">(slice</span><span class="s5">-&gt;</span><span class="s1">NAME != Py_None) {                               \</span>
        <span class="s1">Py_ssize_t v = PyNumber_AsSsize_t(slice</span><span class="s5">-&gt;</span><span class="s1">NAME,          \</span>
                                          <span class="s1">PyExc_OverflowError); \</span>
        <span class="s2">if </span><span class="s1">(v == -</span><span class="s4">1 </span><span class="s1">&amp;&amp; PyErr_Occurred())                        \</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;                                          \</span>
        <span class="s1">*NAME = v;                                              \</span>
    <span class="s1">}                                                           \</span>
    <span class="s2">else </span><span class="s1">{                                                      \</span>
        <span class="s1">*NAME = DEFAULT;                                        \</span>
    <span class="s1">}</span>
    <span class="s1">FETCH_MEMBER(step, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">FETCH_MEMBER(stop, (*step &gt; </span><span class="s4">0</span><span class="s1">) ? PY_SSIZE_T_MAX : PY_SSIZE_T_MIN)</span>
    <span class="s1">FETCH_MEMBER(start, (*step &gt; </span><span class="s4">0</span><span class="s1">) ? </span><span class="s4">0 </span><span class="s1">: PY_SSIZE_T_MAX)</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>

<span class="s2">#undef </span><span class="s1">FETCH_MEMBER</span>
<span class="s1">}</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_fatal_error(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s1">PyGILState_Ensure();</span>
    <span class="s1">Py_FatalError(</span><span class="s3">&quot;in Numba-compiled function&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s1">; </span><span class="s0">/* unreachable */</span>
<span class="s1">}</span>

<span class="s0">/* Insert a frame into the traceback for (funcname, filename, lineno). */</span>
<span class="s0">/* This function is CPython's _PyTraceback_Add, renamed, see: 
 * https://github.com/python/cpython/blob/d545869d084e70d4838310e79b52a25a72a1ca56/Python/traceback.c#L246 
 * and modified for Python 2.x based on 
 * https://github.com/python/cpython/blob/2e1a34025cde19bddf12a2eac8fedb6afcca8339/Modules/_ctypes/callbacks.c#L151-L174 
 */</span>
<span class="s2">static void </span><span class="s1">traceback_add(</span><span class="s2">const char </span><span class="s1">*funcname, </span><span class="s2">const char </span><span class="s1">*filename, </span><span class="s2">int </span><span class="s1">lineno)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *globals = NULL;</span>
    <span class="s1">PyCodeObject *code = NULL;</span>
    <span class="s1">PyFrameObject *frame = NULL;</span>
    <span class="s1">PyObject *exc, *val, *tb;</span>

    <span class="s0">/* Save and clear the current exception. Python functions must not be 
       called with an exception set. Calling Python functions happens when 
       the codec of the filesystem encoding is implemented in pure Python. */</span>
    <span class="s1">PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);</span>

    <span class="s1">globals = PyDict_New();</span>
    <span class="s2">if </span><span class="s1">(!globals)</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s1">code = PyCode_NewEmpty(filename, funcname, lineno);</span>
    <span class="s2">if </span><span class="s1">(!code) {</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s1">}</span>
    <span class="s1">frame = PyFrame_New(PyThreadState_Get(), code, globals, NULL);</span>
    <span class="s1">Py_DECREF(globals);</span>
    <span class="s1">Py_DECREF(code);</span>
    <span class="s2">if </span><span class="s1">(!frame)</span>
        <span class="s2">goto </span><span class="s1">error;</span>

<span class="s2">#if </span><span class="s1">(PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION == </span><span class="s4">12</span><span class="s1">) </span><span class="s0">/* 3.12 */</span>
<span class="s1">#elif (PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION == </span><span class="s4">11</span><span class="s1">) </span><span class="s0">/* 3.11 */</span>

    <span class="s0">/* unsafe cast to our copy of _frame to access the f_lineno field */</span>
    <span class="s2">typedef struct </span><span class="s1">_frame py_frame;</span>
    <span class="s1">py_frame* hacked_frame = (py_frame*)frame;</span>
    <span class="s1">hacked_frame</span><span class="s5">-&gt;</span><span class="s1">f_lineno = lineno;</span>

<span class="s1">#elif (PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION &lt; </span><span class="s4">11</span><span class="s1">) </span><span class="s0">/* &lt;3.11 */</span>
    <span class="s1">frame</span><span class="s5">-&gt;</span><span class="s1">f_lineno = lineno;</span>
<span class="s2">#else</span>
    <span class="s2">#error </span><span class="s3">&quot;Check if struct _frame has been changed in the new version&quot;</span>
<span class="s2">#endif</span>
    <span class="s1">PyErr_Restore(exc, val, tb);</span>
    <span class="s1">PyTraceBack_Here(frame);</span>
    <span class="s1">Py_DECREF(frame);</span>
    <span class="s2">return</span><span class="s1">;</span>

<span class="s2">#if </span><span class="s1">(PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION == </span><span class="s4">12</span><span class="s1">) </span><span class="s0">/* 3.12 */</span>
<span class="s1">error:</span>
    <span class="s1">_PyErr_ChainExceptions1(exc);</span>
<span class="s1">#elif (PY_MAJOR_VERSION == </span><span class="s4">3</span><span class="s1">) &amp;&amp; ((PY_MINOR_VERSION == </span><span class="s4">9</span><span class="s1">) || (PY_MINOR_VERSION == </span><span class="s4">10</span><span class="s1">) || (PY_MINOR_VERSION == </span><span class="s4">11</span><span class="s1">)) </span><span class="s0">/* 3.11 and below */</span>
<span class="s1">error:</span>
    <span class="s1">_PyErr_ChainExceptions(exc, val, tb);</span>
<span class="s2">#else</span>
<span class="s2">#error </span><span class="s3">&quot;Python major version is not supported.&quot;</span>
<span class="s2">#endif</span>
<span class="s1">}</span>


<span class="s0">/* 
 * Add traceback information to *loc* to the active exception. 
 * loc can be NULL, which causes this function to become a no-op. 
 */</span>
<span class="s2">static</span>
<span class="s2">void </span><span class="s1">traceback_add_loc(PyObject *loc) {</span>
    <span class="s2">const char </span><span class="s1">*function_name_str = NULL, *filename_str = NULL;</span>
    <span class="s1">PyObject *function_name = NULL, *filename = NULL, *lineno = NULL;</span>
    <span class="s1">Py_ssize_t pos;</span>

    <span class="s0">/* instance is instantiated/internal exception is raised, if loc is present 
     * add a frame for it into the traceback */</span>
    <span class="s2">if</span><span class="s1">(loc &amp;&amp; loc != Py_None &amp;&amp; PyTuple_Check(loc))</span>
    <span class="s1">{</span>
        <span class="s1">pos = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">function_name = PyTuple_GET_ITEM(loc, pos);</span>
        <span class="s1">function_name_str = PyString_AsString(function_name);</span>
        <span class="s1">pos = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">filename = PyTuple_GET_ITEM(loc, pos);</span>
        <span class="s1">filename_str = PyString_AsString(filename);</span>
        <span class="s1">pos = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s1">lineno = PyTuple_GET_ITEM(loc, pos);</span>
        <span class="s1">traceback_add(function_name_str, filename_str, \</span>
                      <span class="s1">(</span><span class="s2">int</span><span class="s1">)PyLong_AsLong(lineno));</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Re-raise the current active exception. 
 * Called internal by process_raise() when *exc* is None. 
 */</span>
<span class="s2">static</span>
<span class="s2">int </span><span class="s1">reraise_exc_is_none(</span><span class="s2">void</span><span class="s1">) {</span>
    <span class="s0">/* Reraise */</span>
    <span class="s1">PyObject *tb, *type, *value;</span>

<span class="s2">#if </span><span class="s1">(PY_MAJOR_VERSION &gt;= </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION &gt;= </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">PyErr_GetExcInfo(&amp;type, &amp;value, &amp;tb);</span>
<span class="s1">#elif (PY_MAJOR_VERSION &gt;= </span><span class="s4">3</span><span class="s1">) &amp;&amp; (PY_MINOR_VERSION &gt;= </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">PyThreadState *tstate = PyThreadState_GET();</span>
    <span class="s1">_PyErr_StackItem *tstate_exc = tstate</span><span class="s5">-&gt;</span><span class="s1">exc_info;</span>
    <span class="s1">type = tstate_exc</span><span class="s5">-&gt;</span><span class="s1">exc_type;</span>
    <span class="s1">value = tstate_exc</span><span class="s5">-&gt;</span><span class="s1">exc_value;</span>
    <span class="s1">tb = tstate_exc</span><span class="s5">-&gt;</span><span class="s1">exc_traceback;</span>
<span class="s2">#endif</span>
    <span class="s2">if </span><span class="s1">(type == Py_None) {</span>
        <span class="s1">PyErr_SetString(PyExc_RuntimeError,</span>
                        <span class="s3">&quot;No active exception to reraise&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/* incref needed because PyErr_Restore DOES NOT */</span>
    <span class="s1">Py_XINCREF(type);</span>
    <span class="s1">Py_XINCREF(value);</span>
    <span class="s1">Py_XINCREF(tb);</span>
    <span class="s1">PyErr_Restore(type, value, tb);</span>
    <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Set exception given the Exception type and the constructor argument. 
 * Equivalent to ``raise exc(value)``. 
 * PyExceptionClass_Check(exc) must be True. 
 * value can be NULL. 
 */</span>
<span class="s2">static</span>
<span class="s2">int </span><span class="s1">process_exception_class(PyObject *exc, PyObject *value) {</span>
    <span class="s1">PyObject *type;</span>
    <span class="s0">/* It is a class, type used here just as a tmp var */</span>
    <span class="s1">type = PyObject_CallObject(exc, value);</span>
    <span class="s2">if </span><span class="s1">(type == NULL){</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!PyExceptionInstance_Check(type)) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError,</span>
                        <span class="s3">&quot;exceptions must derive from BaseException&quot;</span><span class="s1">);</span>
        <span class="s1">Py_DECREF(type);</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/* all ok, set type to the exc */</span>
    <span class="s1">Py_DECREF(type);</span>
    <span class="s1">type = exc;</span>
    <span class="s1">PyErr_SetObject(type, value);</span>
    <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Internal routine to process exceptions. 
 * exc cannot be NULL. It can be a None, Exception type, or Exception instance. 
 * value can be NULL for absent, or any PyObject valid for the exception. 
 */</span>
<span class="s2">static</span>
<span class="s2">int </span><span class="s1">process_raise(PyObject *exc, PyObject *value) {</span>
    <span class="s0">/* exc is None */</span>
    <span class="s2">if </span><span class="s1">(exc == Py_None) {</span>
        <span class="s2">return </span><span class="s1">reraise_exc_is_none();</span>
    <span class="s1">}</span>
    <span class="s0">/* exc should be an exception class */</span>
    <span class="s2">else if </span><span class="s1">(PyExceptionClass_Check(exc)) {</span>
        <span class="s2">return </span><span class="s1">process_exception_class(exc, value);</span>
    <span class="s1">}</span>
    <span class="s0">/* exc is an instance of an Exception */</span>
    <span class="s2">else if </span><span class="s1">(PyExceptionInstance_Check(exc)) {</span>
        <span class="s1">PyObject *type = PyExceptionInstance_Class(exc);</span>
        <span class="s1">PyErr_SetObject(type, exc);</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* Not something you can raise.  You get an exception 
        anyway, just not what you specified :-) */</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError,</span>
                        <span class="s3">&quot;exceptions must derive from BaseException&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/* Logic for raising an arbitrary object.  Adapted from CPython's ceval.c. 
   This *consumes* a reference count to its argument. */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">int</span><span class="s1">)</span>
<span class="s1">numba_do_raise(PyObject *exc_packed)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">status;</span>
    <span class="s1">PyObject *exc = NULL, *value = NULL, *loc = NULL;</span>

    <span class="s0">/* We support the following forms of raise: 
       raise 
       raise &lt;instance&gt; 
       raise &lt;type&gt; */</span>

    <span class="s0">/* could be a tuple from npm (some exc like thing, args, location) */</span>
    <span class="s2">if </span><span class="s1">(PyTuple_CheckExact(exc_packed)) {</span>
        <span class="s0">/* Unpack a (class/inst/tuple, arguments, location) tuple. */</span>
        <span class="s2">if </span><span class="s1">(!PyArg_ParseTuple(exc_packed, </span><span class="s3">&quot;OOO&quot;</span><span class="s1">, &amp;exc, &amp;value, &amp;loc)) {</span>
            <span class="s1">traceback_add_loc(loc);</span>
            <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* could be a reraise or an exception from objmode */</span>
        <span class="s1">exc = exc_packed;</span>
        <span class="s0">/* branch exit with value = NULL and loc = NULL */</span>
    <span class="s1">}</span>
    <span class="s0">/* value is either NULL or borrowed */</span>
    <span class="s1">status = process_raise(exc, value);</span>
    <span class="s1">traceback_add_loc(loc);</span>
    <span class="s1">Py_DECREF(exc_packed);</span>
    <span class="s2">return </span><span class="s1">status;</span>
<span class="s1">}</span>

<span class="s2">#ifdef </span><span class="s1">PYCC_COMPILING</span>
<span class="s0">/* AOT avoid the use of `numba.core.serialize` */</span>
<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_unpickle(</span><span class="s2">const char </span><span class="s1">*data, </span><span class="s2">int </span><span class="s1">n, </span><span class="s2">const char </span><span class="s1">*hashed)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *buf, *obj;</span>
    <span class="s2">static </span><span class="s1">PyObject *loads;</span>

    <span class="s0">/* Caching the pickle.loads function shaves a couple µs here. */</span>
    <span class="s2">if </span><span class="s1">(loads == NULL) {</span>
        <span class="s1">PyObject *picklemod;</span>
        <span class="s1">picklemod = PyImport_ImportModule(</span><span class="s3">&quot;pickle&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(picklemod == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">loads = PyObject_GetAttrString(picklemod, </span><span class="s3">&quot;loads&quot;</span><span class="s1">);</span>
        <span class="s1">Py_DECREF(picklemod);</span>
        <span class="s2">if </span><span class="s1">(loads == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">buf = PyBytes_FromStringAndSize(data, n);</span>
    <span class="s2">if </span><span class="s1">(buf == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">obj = PyObject_CallFunctionObjArgs(loads, buf, NULL);</span>
    <span class="s1">Py_DECREF(buf);</span>
    <span class="s2">return </span><span class="s1">obj;</span>
<span class="s1">}</span>

<span class="s2">#else</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_unpickle(</span><span class="s2">const char </span><span class="s1">*data, </span><span class="s2">int </span><span class="s1">n, </span><span class="s2">const char </span><span class="s1">*hashed)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *buf=NULL, *obj=NULL, *addr=NULL, *hashedbuf=NULL;</span>
    <span class="s2">static </span><span class="s1">PyObject *loads=NULL;</span>

    <span class="s0">/* Caching the _numba_unpickle function shaves a couple µs here. */</span>
    <span class="s2">if </span><span class="s1">(loads == NULL) {</span>
        <span class="s1">PyObject *picklemod;</span>
        <span class="s1">picklemod = PyImport_ImportModule(</span><span class="s3">&quot;numba.core.serialize&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(picklemod == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">loads = PyObject_GetAttrString(picklemod, </span><span class="s3">&quot;_numba_unpickle&quot;</span><span class="s1">);</span>
        <span class="s1">Py_DECREF(picklemod);</span>
        <span class="s2">if </span><span class="s1">(loads == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">buf = PyBytes_FromStringAndSize(data, n);</span>
    <span class="s2">if </span><span class="s1">(buf == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s0">/* SHA1 produces 160 bit or 20 bytes */</span>
    <span class="s1">hashedbuf = PyBytes_FromStringAndSize(hashed, </span><span class="s4">20</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(hashedbuf == NULL)</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s1">addr = PyLong_FromVoidPtr((</span><span class="s2">void</span><span class="s1">*)data);</span>
    <span class="s2">if </span><span class="s1">(addr == NULL)</span>
        <span class="s2">goto </span><span class="s1">error;</span>
    <span class="s1">obj = PyObject_CallFunctionObjArgs(loads, addr, buf, hashedbuf, NULL);</span>
<span class="s1">error:</span>
    <span class="s1">Py_XDECREF(addr);</span>
    <span class="s1">Py_XDECREF(hashedbuf);</span>
    <span class="s1">Py_DECREF(buf);</span>
    <span class="s2">return </span><span class="s1">obj;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s1">NUMBA_EXPORT_FUNC(PyObject *)</span>
<span class="s1">numba_runtime_build_excinfo_struct(PyObject* struct_gv, PyObject* exc_args)</span>
<span class="s1">{</span>
    <span class="s1">PyObject *obj = NULL;</span>
    <span class="s2">static </span><span class="s1">PyObject *func = NULL;</span>

    <span class="s0">/* Caching the function shaves a couple µs here. */</span>
    <span class="s2">if </span><span class="s1">(func == NULL)</span>
    <span class="s1">{</span>
        <span class="s1">PyObject *picklemod;</span>
        <span class="s1">picklemod = PyImport_ImportModule(</span><span class="s3">&quot;numba.core.serialize&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(picklemod == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">func = PyObject_GetAttrString(picklemod,</span>
                                      <span class="s3">&quot;runtime_build_excinfo_struct&quot;</span><span class="s1">);</span>
        <span class="s1">Py_DECREF(picklemod);</span>
        <span class="s2">if </span><span class="s1">(func == NULL)</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">obj = PyObject_CallFunctionObjArgs(func, struct_gv, exc_args, NULL);</span>
    <span class="s0">// func returns None on failure (i.e. can't serialize one of the args).</span>
    <span class="s0">// Is there a better way to handle this? raise an exception here?</span>
    <span class="s2">return </span><span class="s1">obj;</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Unicode helpers 
 */</span>

<span class="s0">/* Developer note: 
 * 
 * The hash value of unicode objects is obtained via: 
 * ((PyASCIIObject *)(obj))-&gt;hash; 
 * The use comes from this definition: 
 * https://github.com/python/cpython/blob/6d43f6f081023b680d9db4542d19b9e382149f0a/Objects/unicodeobject.c#L119-L120 
 * and it's used extensively throughout the `cpython/Object/unicodeobject.c` 
 * source, not least in `unicode_hash` itself: 
 * https://github.com/python/cpython/blob/6d43f6f081023b680d9db4542d19b9e382149f0a/Objects/unicodeobject.c#L11662-L11679 
 * 
 * The Unicode string struct layouts are described here: 
 * https://github.com/python/cpython/blob/6d43f6f081023b680d9db4542d19b9e382149f0a/Include/cpython/unicodeobject.h#L82-L161 
 * essentially, all the unicode string layouts start with a `PyASCIIObject` at 
 * offset 0 (as of commit 6d43f6f081023b680d9db4542d19b9e382149f0a, somewhere 
 * in the 3.8 development cycle). 
 * 
 * For safety against future CPython internal changes, the code checks that the 
 * _base members of the unicode structs are what is expected in 3.7, and that 
 * their offset is 0. It then walks the struct to the hash location to make sure 
 * the offset is indeed the same as PyASCIIObject-&gt;hash. 
 * Note: The large condition in the if should evaluate to a compile time 
 * constant. 
 */</span>

<span class="s2">#define </span><span class="s1">MEMBER_SIZE(structure, member) </span><span class="s2">sizeof</span><span class="s1">(((structure *)</span><span class="s4">0</span><span class="s1">)</span><span class="s5">-&gt;</span><span class="s1">member)</span>

<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void </span><span class="s1">*)</span>
<span class="s1">numba_extract_unicode(PyObject *obj, Py_ssize_t *length, </span><span class="s2">int </span><span class="s1">*kind,</span>
                      <span class="s2">unsigned int </span><span class="s1">*ascii, Py_ssize_t *hash) {</span>
    <span class="s2">if </span><span class="s1">(!PyUnicode_READY(obj)) {</span>
        <span class="s1">*length = PyUnicode_GET_LENGTH(obj);</span>
        <span class="s1">*kind = PyUnicode_KIND(obj);</span>
        <span class="s0">/* could also use PyUnicode_IS_ASCII but it is not publicly advertised in https://docs.python.org/3/c-api/unicode.html */</span>
        <span class="s1">*ascii = (</span><span class="s2">unsigned int</span><span class="s1">)(PyUnicode_MAX_CHAR_VALUE(obj) == (</span><span class="s4">0x7f</span><span class="s1">));</span>
        <span class="s0">/* this is here as a crude check for safe casting of all unicode string 
         * structs to a PyASCIIObject */</span>
        <span class="s2">if </span><span class="s1">(MEMBER_SIZE(PyCompactUnicodeObject, _base) == </span><span class="s2">sizeof</span><span class="s1">(PyASCIIObject)             &amp;&amp;</span>
            <span class="s1">MEMBER_SIZE(PyUnicodeObject, _base) == </span><span class="s2">sizeof</span><span class="s1">(PyCompactUnicodeObject)           &amp;&amp;</span>
            <span class="s1">offsetof(PyCompactUnicodeObject, _base) == </span><span class="s4">0                                    </span><span class="s1">&amp;&amp;</span>
            <span class="s1">offsetof(PyUnicodeObject, _base) == </span><span class="s4">0                                           </span><span class="s1">&amp;&amp;</span>
            <span class="s1">offsetof(PyCompactUnicodeObject, _base.hash) == offsetof(PyASCIIObject, hash)   &amp;&amp;</span>
            <span class="s1">offsetof(PyUnicodeObject, _base._base.hash) == offsetof(PyASCIIObject, hash)</span>
           <span class="s1">) {</span>
            <span class="s0">/* Grab the hash from the type object cache, do not compute it. */</span>
            <span class="s1">*hash = ((PyASCIIObject *)(obj))</span><span class="s5">-&gt;</span><span class="s1">hash;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">/* cast is not safe, fail */</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">PyUnicode_DATA(obj);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/* this is late included as it #defines e.g. SHIFT that should not impact 
 * the above */</span>
<span class="s2">#include </span><span class="s3">&quot;_unicodetype_db.h&quot;</span>

<span class="s0">/* This function is a modified copy of the private function gettyperecord from 
 * CPython's Objects/unicodectype.c 
 * 
 * See:https://github.com/python/cpython/blob/1d4b6ba19466aba0eb91c4ba01ba509acf18c723/Objects/unicodectype.c#L45-L59 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_gettyperecord(Py_UCS4 code, </span><span class="s2">int </span><span class="s1">*upper, </span><span class="s2">int </span><span class="s1">*lower, </span><span class="s2">int </span><span class="s1">*title,</span>
                    <span class="s2">unsigned char </span><span class="s1">*decimal, </span><span class="s2">unsigned char </span><span class="s1">*digit,</span>
                    <span class="s2">unsigned short </span><span class="s1">*flags)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">index;</span>
    <span class="s2">const </span><span class="s1">numba_PyUnicode_TypeRecord *rec;</span>

    <span class="s2">if </span><span class="s1">(code &gt;= </span><span class="s4">0x110000</span><span class="s1">)</span>
        <span class="s1">index = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">else</span>
    <span class="s1">{</span>
        <span class="s1">index = index1[(code&gt;&gt;SHIFT)];</span>
        <span class="s1">index = index2[(index&lt;&lt;SHIFT)+(code&amp;((</span><span class="s4">1</span><span class="s1">&lt;&lt;SHIFT)-</span><span class="s4">1</span><span class="s1">))];</span>
    <span class="s1">}</span>

    <span class="s1">rec = &amp;numba_PyUnicode_TypeRecords[index];</span>
    <span class="s1">*upper = rec</span><span class="s5">-&gt;</span><span class="s1">upper;</span>
    <span class="s1">*lower = rec</span><span class="s5">-&gt;</span><span class="s1">lower;</span>
    <span class="s1">*title = rec</span><span class="s5">-&gt;</span><span class="s1">title;</span>
    <span class="s1">*decimal = rec</span><span class="s5">-&gt;</span><span class="s1">decimal;</span>
    <span class="s1">*digit = rec</span><span class="s5">-&gt;</span><span class="s1">digit;</span>
    <span class="s1">*flags = rec</span><span class="s5">-&gt;</span><span class="s1">flags;</span>
<span class="s1">}</span>

<span class="s0">/* This function provides a consistent access point for the 
 * _PyUnicode_ExtendedCase array defined in CPython's Objects/unicodectype.c 
 * and now also as numba_PyUnicode_ExtendedCase in Numba's _unicodetype_db.h 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(Py_UCS4)</span>
<span class="s1">numba_get_PyUnicode_ExtendedCase(</span><span class="s2">int </span><span class="s1">code)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">numba_PyUnicode_ExtendedCase[code];</span>
<span class="s1">}</span>

<span class="s0">/* from _unicodetype_db.h */</span>
<span class="s2">#undef </span><span class="s1">SHIFT</span>

<span class="s0">/* 
 * defined break point for gdb 
 */</span>
<span class="s1">NUMBA_EXPORT_FUNC(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">numba_gdb_breakpoint(</span><span class="s2">void</span><span class="s1">) {</span>
  <span class="s0">/* does nothing */</span>
<span class="s1">}</span>

<span class="s0">/* 
 * Define bridge for all math functions 
 */</span>

<span class="s2">#define </span><span class="s1">MATH_UNARY(F, R, A) \</span>
    <span class="s1">NUMBA_EXPORT_FUNC(R) numba_##F(A a) { </span><span class="s2">return </span><span class="s1">F(a); }</span>
<span class="s2">#define </span><span class="s1">MATH_BINARY(F, R, A, B) \</span>
    <span class="s1">NUMBA_EXPORT_FUNC(R) numba_##F(A a, B b) { </span><span class="s2">return </span><span class="s1">F(a, b); }</span>

<span class="s2">#include </span><span class="s3">&quot;mathnames.h&quot;</span>

<span class="s2">#undef </span><span class="s1">MATH_UNARY</span>
<span class="s2">#undef </span><span class="s1">MATH_BINARY</span>

<span class="s0">/* 
 * BLAS and LAPACK wrappers 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;_lapack.c&quot;</span>

<span class="s0">/* 
 * PRNG support 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;_random.c&quot;</span>
</pre>
</body>
</html>