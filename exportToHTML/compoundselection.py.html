<html>
<head>
<title>compoundselection.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compoundselection.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Compound Selection Behavior 
=========================== 
 
The :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior` 
`mixin &lt;https://en.wikipedia.org/wiki/Mixin&gt;`_ class implements the logic 
behind keyboard and touch selection of selectable widgets managed by the 
derived widget. For example, it can be combined with a 
:class:`~kivy.uix.gridlayout.GridLayout` to add selection to the layout. 
 
Compound selection concepts 
--------------------------- 
 
At its core, it keeps a dynamic list of widgets that can be selected. 
Then, as the touches and keyboard input are passed in, it selects one or 
more of the widgets based on these inputs. For example, it uses the mouse 
scroll and keyboard up/down buttons to scroll through the list of widgets. 
Multiselection can also be achieved using the keyboard shift and ctrl keys. 
 
Finally, in addition to the up/down type keyboard inputs, compound selection 
can also accept letters from the keyboard to be used to select nodes with 
associated strings that start with those letters, similar to how files 
are selected by a file browser. 
 
Selection mechanics 
------------------- 
 
When the controller needs to select a node, it calls :meth:`select_node` and 
:meth:`deselect_node`. Therefore, they must be overwritten in order alter 
node selection. By default, the class doesn't listen for keyboard or 
touch events, so the derived widget must call 
:meth:`select_with_touch`, :meth:`select_with_key_down`, and 
:meth:`select_with_key_up` on events that it wants to pass on for selection 
purposes. 
 
Example 
------- 
 
To add selection to a grid layout which will contain 
:class:`~kivy.uix.Button` widgets. For each button added to the layout, you 
need to bind the :attr:`~kivy.uix.widget.Widget.on_touch_down` of the button 
to :meth:`select_with_touch` to pass on the touch events:: 
 
    from kivy.uix.behaviors.compoundselection import CompoundSelectionBehavior 
    from kivy.uix.button import Button 
    from kivy.uix.gridlayout import GridLayout 
    from kivy.uix.behaviors import FocusBehavior 
    from kivy.core.window import Window 
    from kivy.app import App 
 
 
    class SelectableGrid(FocusBehavior, CompoundSelectionBehavior, GridLayout): 
 
        def keyboard_on_key_down(self, window, keycode, text, modifiers): 
            &quot;&quot;&quot;Based on FocusBehavior that provides automatic keyboard 
            access, key presses will be used to select children. 
            &quot;&quot;&quot; 
            if super(SelectableGrid, self).keyboard_on_key_down( 
                window, keycode, text, modifiers): 
                return True 
            if self.select_with_key_down(window, keycode, text, modifiers): 
                return True 
            return False 
 
        def keyboard_on_key_up(self, window, keycode): 
            &quot;&quot;&quot;Based on FocusBehavior that provides automatic keyboard 
            access, key release will be used to select children. 
            &quot;&quot;&quot; 
            if super(SelectableGrid, self).keyboard_on_key_up(window, keycode): 
                return True 
            if self.select_with_key_up(window, keycode): 
                return True 
            return False 
 
        def add_widget(self, widget, *args, **kwargs): 
            &quot;&quot;&quot; Override the adding of widgets so we can bind and catch their 
            *on_touch_down* events. &quot;&quot;&quot; 
            widget.bind(on_touch_down=self.button_touch_down, 
                        on_touch_up=self.button_touch_up) 
            return super(SelectableGrid, self)\ 
                .add_widget(widget, *args, **kwargs) 
 
        def button_touch_down(self, button, touch): 
            &quot;&quot;&quot; Use collision detection to select buttons when the touch occurs 
            within their area. &quot;&quot;&quot; 
            if button.collide_point(*touch.pos): 
                self.select_with_touch(button, touch) 
 
        def button_touch_up(self, button, touch): 
            &quot;&quot;&quot; Use collision detection to de-select buttons when the touch 
            occurs outside their area and *touch_multiselect* is not True. &quot;&quot;&quot; 
            if not (button.collide_point(*touch.pos) or 
                    self.touch_multiselect): 
                self.deselect_node(button) 
 
        def select_node(self, node): 
            node.background_color = (1, 0, 0, 1) 
            return super(SelectableGrid, self).select_node(node) 
 
        def deselect_node(self, node): 
            node.background_color = (1, 1, 1, 1) 
            super(SelectableGrid, self).deselect_node(node) 
 
        def on_selected_nodes(self, grid, nodes): 
            print(&quot;Selected nodes = {0}&quot;.format(nodes)) 
 
 
    class TestApp(App): 
        def build(self): 
            grid = SelectableGrid(cols=3, rows=2, touch_multiselect=True, 
                                  multiselect=True) 
            for i in range(0, 6): 
                grid.add_widget(Button(text=&quot;Button {0}&quot;.format(i))) 
            return grid 
 
 
    TestApp().run() 
 
 
.. warning:: 
 
    This code is still experimental, and its API is subject to change in a 
    future version. 
 
'''</span>

<span class="s1">__all__ </span><span class="s2">= (</span><span class="s3">'CompoundSelectionBehavior'</span><span class="s2">, )</span>

<span class="s4">from </span><span class="s1">time </span><span class="s4">import </span><span class="s1">time</span>
<span class="s4">from </span><span class="s1">os </span><span class="s4">import </span><span class="s1">environ</span>

<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">properties </span><span class="s4">import </span><span class="s1">NumericProperty</span><span class="s2">, </span><span class="s1">BooleanProperty</span><span class="s2">, </span><span class="s1">ListProperty</span>


<span class="s4">if </span><span class="s3">'KIVY_DOC' </span><span class="s4">not in </span><span class="s1">environ</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">config </span><span class="s4">import </span><span class="s1">Config</span>
    <span class="s1">_is_desktop </span><span class="s2">= </span><span class="s1">Config</span><span class="s2">.</span><span class="s1">getboolean</span><span class="s2">(</span><span class="s3">'kivy'</span><span class="s2">, </span><span class="s3">'desktop'</span><span class="s2">)</span>
<span class="s4">else</span><span class="s2">:</span>
    <span class="s1">_is_desktop </span><span class="s2">= </span><span class="s4">False</span>


<span class="s4">class </span><span class="s1">CompoundSelectionBehavior</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">'''The Selection behavior `mixin &lt;https://en.wikipedia.org/wiki/Mixin&gt;`_ 
    implements the logic behind keyboard and touch 
    selection of selectable widgets managed by the derived widget. Please see 
    the :mod:`compound selection behaviors module 
    &lt;kivy.uix.behaviors.compoundselection&gt;` documentation 
    for more information. 
 
    .. versionadded:: 1.9.0 
    '''</span>

    <span class="s1">selected_nodes </span><span class="s2">= </span><span class="s1">ListProperty</span><span class="s2">([])</span>
    <span class="s3">'''The list of selected nodes. 
 
    .. note:: 
 
        Multiple nodes can be selected right after one another e.g. using the 
        keyboard. When listening to :attr:`selected_nodes`, one should be 
        aware of this. 
 
    :attr:`selected_nodes` is a :class:`~kivy.properties.ListProperty` and 
    defaults to the empty list, []. It is read-only and should not be modified. 
    '''</span>

    <span class="s1">touch_multiselect </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s3">'''A special touch mode which determines whether touch events, as 
    processed by :meth:`select_with_touch`, will add the currently touched 
    node to the selection, or if it will clear the selection before adding the 
    node. This allows the selection of multiple nodes by simply touching them. 
 
    This is different from :attr:`multiselect` because when it is True, 
    simply touching an unselected node will select it, even if ctrl is not 
    pressed. If it is False, however, ctrl must be pressed in order to 
    add to the selection when :attr:`multiselect` is True. 
 
    .. note:: 
 
        :attr:`multiselect`, when False, will disable 
        :attr:`touch_multiselect`. 
 
    :attr:`touch_multiselect` is a :class:`~kivy.properties.BooleanProperty` 
    and defaults to False. 
    '''</span>

    <span class="s1">multiselect </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s3">'''Determines whether multiple nodes can be selected. If enabled, keyboard 
    shift and ctrl selection, optionally combined with touch, for example, will 
    be able to select multiple widgets in the normally expected manner. 
    This dominates :attr:`touch_multiselect` when False. 
 
    :attr:`multiselect` is a :class:`~kivy.properties.BooleanProperty` and 
    defaults to False. 
    '''</span>

    <span class="s1">touch_deselect_last </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">not </span><span class="s1">_is_desktop</span><span class="s2">)</span>
    <span class="s3">'''Determines whether the last selected node can be deselected when 
    :attr:`multiselect` or :attr:`touch_multiselect` is False. 
 
    .. versionadded:: 1.10.0 
 
    :attr:`touch_deselect_last` is a :class:`~kivy.properties.BooleanProperty` 
    and defaults to True on mobile, False on desktop platforms. 
    '''</span>

    <span class="s1">keyboard_select </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s3">'''Determines whether the keyboard can be used for selection. If False, 
    keyboard inputs will be ignored. 
 
    :attr:`keyboard_select` is a :class:`~kivy.properties.BooleanProperty` 
    and defaults to True. 
    '''</span>

    <span class="s1">page_count </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
    <span class="s3">'''Determines by how much the selected node is moved up or down, relative 
    to the position of the last selected node, when pageup (or pagedown) is 
    pressed. 
 
    :attr:`page_count` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 10. 
    '''</span>

    <span class="s1">up_count </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s3">'''Determines by how much the selected node is moved up or down, relative 
    to the position of the last selected node, when the up (or down) arrow on 
    the keyboard is pressed. 
 
    :attr:`up_count` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 1. 
    '''</span>

    <span class="s1">right_count </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s3">'''Determines by how much the selected node is moved up or down, relative 
    to the position of the last selected node, when the right (or left) arrow 
    on the keyboard is pressed. 
 
    :attr:`right_count` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 1. 
    '''</span>

    <span class="s1">scroll_count </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s3">'''Determines by how much the selected node is moved up or down, relative 
    to the position of the last selected node, when the mouse scroll wheel is 
    scrolled. 
 
    :attr:`right_count` is a :class:`~kivy.properties.NumericProperty` and 
    defaults to 0. 
    '''</span>

    <span class="s1">nodes_order_reversed </span><span class="s2">= </span><span class="s1">BooleanProperty</span><span class="s2">(</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s3">''' (Internal) Indicates whether the order of the nodes as displayed top- 
    down is reversed compared to their order in :meth:`get_selectable_nodes` 
    (e.g. how the children property is reversed compared to how 
    it's displayed). 
    '''</span>

    <span class="s1">text_entry_timeout </span><span class="s2">= </span><span class="s1">NumericProperty</span><span class="s2">(</span><span class="s5">1.</span><span class="s2">)</span>
    <span class="s3">'''When typing characters in rapid succession (i.e. the time difference 
    since the last character is less than :attr:`text_entry_timeout`), the 
    keys get concatenated and the combined text is passed as the key argument 
    of :meth:`goto_node`. 
 
    .. versionadded:: 1.10.0 
    '''</span>

    <span class="s1">_anchor </span><span class="s2">= </span><span class="s4">None  </span><span class="s6"># the last anchor node selected (e.g. shift relative node)</span>
    <span class="s6"># the idx may be out of sync</span>
    <span class="s1">_anchor_idx </span><span class="s2">= </span><span class="s5">0  </span><span class="s6"># cache indexes in case list hasn't changed</span>
    <span class="s1">_last_selected_node </span><span class="s2">= </span><span class="s4">None  </span><span class="s6"># the absolute last node selected</span>
    <span class="s1">_last_node_idx </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">_ctrl_down </span><span class="s2">= </span><span class="s4">False  </span><span class="s6"># if it's pressed - for e.g. shift selection</span>
    <span class="s1">_shift_down </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s6"># holds str used to find node, e.g. if word is typed. passed to goto_node</span>
    <span class="s1">_word_filter </span><span class="s2">= </span><span class="s3">''</span>
    <span class="s1">_last_key_time </span><span class="s2">= </span><span class="s5">0  </span><span class="s6"># time since last press, for finding whole strs in node</span>
    <span class="s1">_key_list </span><span class="s2">= []  </span><span class="s6"># keys that are already pressed, to not press continuously</span>
    <span class="s1">_offset_counts </span><span class="s2">= {}  </span><span class="s6"># cache of counts for faster access</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">(</span><span class="s1">CompoundSelectionBehavior</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">__init__</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_key_list </span><span class="s2">= []</span>

        <span class="s4">def </span><span class="s1">ensure_single_select</span><span class="s2">(*</span><span class="s1">l</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">multiselect</span><span class="s2">) </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
        <span class="s1">update_counts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_counts</span>
        <span class="s1">update_counts</span><span class="s2">()</span>
        <span class="s1">fbind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fbind</span>
        <span class="s1">fbind</span><span class="s2">(</span><span class="s3">'multiselect'</span><span class="s2">, </span><span class="s1">ensure_single_select</span><span class="s2">)</span>
        <span class="s1">fbind</span><span class="s2">(</span><span class="s3">'page_count'</span><span class="s2">, </span><span class="s1">update_counts</span><span class="s2">)</span>
        <span class="s1">fbind</span><span class="s2">(</span><span class="s3">'up_count'</span><span class="s2">, </span><span class="s1">update_counts</span><span class="s2">)</span>
        <span class="s1">fbind</span><span class="s2">(</span><span class="s3">'right_count'</span><span class="s2">, </span><span class="s1">update_counts</span><span class="s2">)</span>
        <span class="s1">fbind</span><span class="s2">(</span><span class="s3">'scroll_count'</span><span class="s2">, </span><span class="s1">update_counts</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">select_with_touch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">touch</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">'''(internal) Processes a touch on the node. This should be called by 
        the derived widget when a node is touched and is to be used for 
        selection. Depending on the keyboard keys pressed and the 
        configuration, it could select or deslect this and other nodes in the 
        selectable nodes list, :meth:`get_selectable_nodes`. 
 
        :Parameters: 
            `node` 
                The node that received the touch. Can be None for a scroll 
                type touch. 
            `touch` 
                Optionally, the touch. Defaults to None. 
 
        :Returns: 
            bool, True if the touch was used, False otherwise. 
        '''</span>
        <span class="s1">multi </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">multiselect</span>
        <span class="s1">multiselect </span><span class="s2">= </span><span class="s1">multi </span><span class="s4">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ctrl_down </span><span class="s4">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">touch_multiselect</span><span class="s2">)</span>
        <span class="s1">range_select </span><span class="s2">= </span><span class="s1">multi </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shift_down</span>

        <span class="s4">if </span><span class="s1">touch </span><span class="s4">and </span><span class="s3">'button' </span><span class="s4">in </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">profile </span><span class="s4">and </span><span class="s1">touch</span><span class="s2">.</span><span class="s1">button </span><span class="s4">in</span><span class="s1">\</span>
            <span class="s2">(</span><span class="s3">'scrollup'</span><span class="s2">, </span><span class="s3">'scrolldown'</span><span class="s2">, </span><span class="s3">'scrollleft'</span><span class="s2">, </span><span class="s3">'scrollright'</span><span class="s2">):</span>
            <span class="s1">node_src</span><span class="s2">, </span><span class="s1">idx_src </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_last_node</span><span class="s2">()</span>
            <span class="s1">node</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">goto_node</span><span class="s2">(</span><span class="s1">touch</span><span class="s2">.</span><span class="s1">button</span><span class="s2">, </span><span class="s1">node_src</span><span class="s2">, </span><span class="s1">idx_src</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">node </span><span class="s2">== </span><span class="s1">node_src</span><span class="s2">:</span>
                <span class="s4">return False</span>
            <span class="s4">if </span><span class="s1">range_select</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_select_range</span><span class="s2">(</span><span class="s1">multiselect</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if not </span><span class="s1">multiselect</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s4">return True</span>
        <span class="s4">if </span><span class="s1">node </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return False</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">node </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes </span><span class="s4">and </span><span class="s2">(</span><span class="s4">not </span><span class="s1">range_select</span><span class="s2">)):  </span><span class="s6"># selected</span>
            <span class="s4">if </span><span class="s1">multiselect</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">deselect_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">selected_node_count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
                <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">touch_deselect_last </span><span class="s4">or </span><span class="s1">selected_node_count </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">range_select</span><span class="s2">:</span>
            <span class="s6"># keep anchor only if not multiselect (ctrl-type selection)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_select_range</span><span class="s2">(</span><span class="s1">multiselect</span><span class="s2">, </span><span class="s4">not </span><span class="s1">multiselect</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:   </span><span class="s6"># it's not selected at this point</span>
            <span class="s4">if not </span><span class="s1">multiselect</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">select_with_key_down</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">keyboard</span><span class="s2">, </span><span class="s1">scancode</span><span class="s2">, </span><span class="s1">codepoint</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">,</span>
                             <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">'''Processes a key press. This is called when a key press is to be used 
        for selection. Depending on the keyboard keys pressed and the 
        configuration, it could select or deselect nodes or node ranges 
        from the selectable nodes list, :meth:`get_selectable_nodes`. 
 
        The parameters are such that it could be bound directly to the 
        on_key_down event of a keyboard. Therefore, it is safe to be called 
        repeatedly when the key is held down as is done by the keyboard. 
 
        :Returns: 
            bool, True if the keypress was used, False otherwise. 
        '''</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">keyboard_select</span><span class="s2">:</span>
            <span class="s4">return False</span>
        <span class="s1">keys </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_key_list</span>
        <span class="s1">multi </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">multiselect</span>
        <span class="s1">node_src</span><span class="s2">, </span><span class="s1">idx_src </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolve_last_node</span><span class="s2">()</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s1">scancode</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">text </span><span class="s2">== </span><span class="s3">'shift'</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shift_down </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">elif </span><span class="s1">text </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'ctrl'</span><span class="s2">, </span><span class="s3">'lctrl'</span><span class="s2">, </span><span class="s3">'rctrl'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_ctrl_down </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">elif </span><span class="s2">(</span><span class="s1">multi </span><span class="s4">and </span><span class="s3">'ctrl' </span><span class="s4">in </span><span class="s1">modifiers </span><span class="s4">and </span><span class="s1">text </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">) </span><span class="s4">and</span>
              <span class="s1">text </span><span class="s4">not in </span><span class="s1">keys</span><span class="s2">):</span>
            <span class="s1">sister_nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_selectable_nodes</span><span class="s2">()</span>
            <span class="s1">select </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span>
            <span class="s4">for </span><span class="s1">node </span><span class="s4">in </span><span class="s1">sister_nodes</span><span class="s2">:</span>
                <span class="s1">select</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s1">keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">text</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s1">text</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">text</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">d </span><span class="s2">= {</span><span class="s3">'divide'</span><span class="s2">: </span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">'mul'</span><span class="s2">: </span><span class="s3">'*'</span><span class="s2">, </span><span class="s3">'substract'</span><span class="s2">: </span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'add'</span><span class="s2">: </span><span class="s3">'+'</span><span class="s2">,</span>
                     <span class="s3">'decimal'</span><span class="s2">: </span><span class="s3">'.'</span><span class="s2">}</span>
                <span class="s4">if </span><span class="s1">text</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">'numpad'</span><span class="s2">):</span>
                    <span class="s1">s </span><span class="s2">= </span><span class="s1">text</span><span class="s2">[</span><span class="s5">6</span><span class="s2">:]</span>
                    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">s</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
                        <span class="s4">if </span><span class="s1">s </span><span class="s4">in </span><span class="s1">d</span><span class="s2">:</span>
                            <span class="s1">s </span><span class="s2">= </span><span class="s1">d</span><span class="s2">[</span><span class="s1">s</span><span class="s2">]</span>
                        <span class="s4">else</span><span class="s2">:</span>
                            <span class="s1">s </span><span class="s2">= </span><span class="s4">None</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">s </span><span class="s2">= </span><span class="s4">None</span>

            <span class="s4">if </span><span class="s1">s </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">s </span><span class="s4">not in </span><span class="s1">keys</span><span class="s2">:  </span><span class="s6"># don't keep adding while holding down</span>
                    <span class="s4">if </span><span class="s1">time</span><span class="s2">() - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_key_time </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">text_entry_timeout</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_word_filter </span><span class="s2">+= </span><span class="s1">s</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_word_filter </span><span class="s2">= </span><span class="s1">s</span>
                    <span class="s1">keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_key_time </span><span class="s2">= </span><span class="s1">time</span><span class="s2">()</span>
                <span class="s1">node</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">goto_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_word_filter</span><span class="s2">, </span><span class="s1">node_src</span><span class="s2">,</span>
                                           <span class="s1">idx_src</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_word_filter </span><span class="s2">= </span><span class="s3">''</span>
                <span class="s1">node</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">goto_node</span><span class="s2">(</span><span class="s1">text</span><span class="s2">, </span><span class="s1">node_src</span><span class="s2">, </span><span class="s1">idx_src</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">node </span><span class="s2">== </span><span class="s1">node_src</span><span class="s2">:</span>
                <span class="s4">return False</span>

            <span class="s1">multiselect </span><span class="s2">= </span><span class="s1">multi </span><span class="s4">and </span><span class="s3">'ctrl' </span><span class="s4">in </span><span class="s1">modifiers</span>
            <span class="s4">if </span><span class="s1">multi </span><span class="s4">and </span><span class="s3">'shift' </span><span class="s4">in </span><span class="s1">modifiers</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_select_range</span><span class="s2">(</span><span class="s1">multiselect</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if not </span><span class="s1">multiselect</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s4">return True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_word_filter </span><span class="s2">= </span><span class="s3">''</span>
        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">select_with_key_up</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">keyboard</span><span class="s2">, </span><span class="s1">scancode</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">'''(internal) Processes a key release. This must be called by the 
        derived widget when a key that :meth:`select_with_key_down` returned 
        True is released. 
 
        The parameters are such that it could be bound directly to the 
        on_key_up event of a keyboard. 
 
        :Returns: 
            bool, True if the key release was used, False otherwise. 
        '''</span>
        <span class="s4">if </span><span class="s1">scancode</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s3">'shift'</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shift_down </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">elif </span><span class="s1">scancode</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'ctrl'</span><span class="s2">, </span><span class="s3">'lctrl'</span><span class="s2">, </span><span class="s3">'rctrl'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_ctrl_down </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_key_list</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">scancode</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
                <span class="s4">return True</span>
            <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s4">return False</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">_update_counts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">largs</span><span class="s2">):</span>
        <span class="s6"># doesn't invert indices here</span>
        <span class="s1">pc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">page_count</span>
        <span class="s1">uc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">up_count</span>
        <span class="s1">rc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">right_count</span>
        <span class="s1">sc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">scroll_count</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_offset_counts </span><span class="s2">= {</span><span class="s3">'pageup'</span><span class="s2">: -</span><span class="s1">pc</span><span class="s2">, </span><span class="s3">'pagedown'</span><span class="s2">: </span><span class="s1">pc</span><span class="s2">, </span><span class="s3">'up'</span><span class="s2">: -</span><span class="s1">uc</span><span class="s2">,</span>
        <span class="s3">'down'</span><span class="s2">: </span><span class="s1">uc</span><span class="s2">, </span><span class="s3">'right'</span><span class="s2">: </span><span class="s1">rc</span><span class="s2">, </span><span class="s3">'left'</span><span class="s2">: -</span><span class="s1">rc</span><span class="s2">, </span><span class="s3">'scrollup'</span><span class="s2">: </span><span class="s1">sc</span><span class="s2">,</span>
        <span class="s3">'scrolldown'</span><span class="s2">: -</span><span class="s1">sc</span><span class="s2">, </span><span class="s3">'scrollright'</span><span class="s2">: -</span><span class="s1">sc</span><span class="s2">, </span><span class="s3">'scrollleft'</span><span class="s2">: </span><span class="s1">sc</span><span class="s2">}</span>

    <span class="s4">def </span><span class="s1">_resolve_last_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># for offset selection, we have a anchor, and we select everything</span>
        <span class="s6"># between anchor and added offset relative to last node</span>
        <span class="s1">sister_nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_selectable_nodes</span><span class="s2">()</span>
        <span class="s4">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sister_nodes</span><span class="s2">):</span>
            <span class="s4">return None</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s1">last_node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_selected_node</span>
        <span class="s1">last_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_last_node_idx</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sister_nodes</span><span class="s2">) - </span><span class="s5">1</span>

        <span class="s4">if </span><span class="s1">last_node </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">last_node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor</span>
            <span class="s1">last_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor_idx</span>
        <span class="s4">if </span><span class="s1">last_node </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">end</span><span class="s2">], </span><span class="s1">end</span>
        <span class="s4">if </span><span class="s1">last_idx </span><span class="s2">&gt; </span><span class="s1">end </span><span class="s4">or </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">last_idx</span><span class="s2">] != </span><span class="s1">last_node</span><span class="s2">:</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_index_of_node</span><span class="s2">(</span><span class="s1">last_node</span><span class="s2">,</span>
                                                         <span class="s1">sister_nodes</span><span class="s2">)</span>
            <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">end</span><span class="s2">], </span><span class="s1">end</span>
        <span class="s4">return </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">last_idx</span>

    <span class="s4">def </span><span class="s1">_select_range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">multiselect</span><span class="s2">, </span><span class="s1">keep_anchor</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">):</span>
        <span class="s0">'''Selects a range between self._anchor and node or idx. 
        If multiselect is True, it will be added to the selection, otherwise 
        it will unselect everything before selecting the range. This is only 
        called if self.multiselect is True. 
        If keep anchor is False, the anchor is moved to node. This should 
        always be True for keyboard selection. 
        '''</span>
        <span class="s1">select </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">select_node</span>
        <span class="s1">sister_nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_selectable_nodes</span><span class="s2">()</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sister_nodes</span><span class="s2">) - </span><span class="s5">1</span>
        <span class="s1">last_node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor</span>
        <span class="s1">last_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor_idx</span>

        <span class="s4">if </span><span class="s1">last_node </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">last_idx </span><span class="s2">= </span><span class="s1">end</span>
            <span class="s1">last_node </span><span class="s2">= </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">end</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">last_idx </span><span class="s2">&gt; </span><span class="s1">end </span><span class="s4">or </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">last_idx</span><span class="s2">] != </span><span class="s1">last_node</span><span class="s2">:</span>
                <span class="s4">try</span><span class="s2">:</span>
                    <span class="s1">last_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_index_of_node</span><span class="s2">(</span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">sister_nodes</span><span class="s2">)</span>
                <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                    <span class="s6"># list changed - cannot do select across them</span>
                    <span class="s4">return</span>
        <span class="s4">if </span><span class="s1">idx </span><span class="s2">&gt; </span><span class="s1">end </span><span class="s4">or </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] != </span><span class="s1">node</span><span class="s2">:</span>
            <span class="s4">try</span><span class="s2">:    </span><span class="s6"># just in case</span>
                <span class="s1">idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_index_of_node</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s1">sister_nodes</span><span class="s2">)</span>
            <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s4">return</span>

        <span class="s4">if </span><span class="s1">last_idx </span><span class="s2">&gt; </span><span class="s1">idx</span><span class="s2">:</span>
            <span class="s1">last_idx</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">= </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">last_idx</span>
        <span class="s4">if not </span><span class="s1">multiselect</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
        <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">last_idx</span><span class="s2">:</span><span class="s1">idx </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s1">select</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">keep_anchor</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor </span><span class="s2">= </span><span class="s1">last_node</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor_idx </span><span class="s2">= </span><span class="s1">last_idx</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor </span><span class="s2">= </span><span class="s1">node  </span><span class="s6"># in case idx was reversed, reset</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor_idx </span><span class="s2">= </span><span class="s1">idx</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_selected_node </span><span class="s2">= </span><span class="s1">node</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_node_idx </span><span class="s2">= </span><span class="s1">idx</span>

    <span class="s4">def </span><span class="s1">clear_selection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">''' Deselects all the currently selected nodes. 
        '''</span>
        <span class="s6"># keep the anchor and last selected node</span>
        <span class="s1">deselect </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">deselect_node</span>
        <span class="s1">nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes</span>
        <span class="s6"># empty beforehand so lookup in deselect will be fast</span>
        <span class="s4">for </span><span class="s1">node </span><span class="s4">in </span><span class="s1">nodes</span><span class="s2">[:]:</span>
            <span class="s1">deselect</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">get_selectable_nodes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">'''(internal) Returns a list of the nodes that can be selected. It can 
        be overwritten by the derived widget to return the correct list. 
 
        This list is used to determine which nodes to select with group 
        selection. E.g. the last element in the list will be selected when 
        home is pressed, pagedown will move (or add to, if shift is held) the 
        selection from the current position by negative :attr:`page_count` 
        nodes starting from the position of the currently selected node in 
        this list and so on. Still, nodes can be selected even if they are not 
        in this list. 
 
        .. note:: 
 
            It is safe to dynamically change this list including removing, 
            adding, or re-arranging its elements. Nodes can be selected even 
            if they are not on this list. And selected nodes removed from the 
            list will remain selected until :meth:`deselect_node` is called. 
 
        .. warning:: 
 
            Layouts display their children in the reverse order. That is, the 
            contents of :attr:`~kivy.uix.widget.Widget.children` is displayed 
            form right to left, bottom to top. Therefore, internally, the 
            indices of the elements returned by this function are reversed to 
            make it work by default for most layouts so that the final result 
            is consistent e.g. home, although it will select the last element 
            in this list visually, will select the first element when 
            counting from top to bottom and left to right. If this behavior is 
            not desired, a reversed list should be returned instead. 
 
        Defaults to returning :attr:`~kivy.uix.widget.Widget.children`. 
        '''</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">children</span>

    <span class="s4">def </span><span class="s1">get_index_of_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">selectable_nodes</span><span class="s2">):</span>
        <span class="s0">'''(internal) Returns the index of the `node` within the 
        `selectable_nodes` returned by :meth:`get_selectable_nodes`. 
        '''</span>
        <span class="s4">return </span><span class="s1">selectable_nodes</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">goto_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">last_node_idx</span><span class="s2">):</span>
        <span class="s0">'''(internal) Used by the controller to get the node at the position 
        indicated by key. The key can be keyboard inputs, e.g. pageup, 
        or scroll inputs from the mouse scroll wheel, e.g. scrollup. 
        'last_node' is the last node selected and is used to find the resulting 
        node. For example, if the key is up, the returned node is one node 
        up from the last node. 
 
        It can be overwritten by the derived widget. 
 
        :Parameters: 
            `key` 
                str, the string used to find the desired node. It can be any 
                of the keyboard keys, as well as the mouse scrollup, 
                scrolldown, scrollright, and scrollleft strings. If letters 
                are typed in quick succession, the letters will be combined 
                before it's passed in as key and can be used to find nodes that 
                have an associated string that starts with those letters. 
            `last_node` 
                The last node that was selected. 
            `last_node_idx` 
                The cached index of the last node selected in the 
                :meth:`get_selectable_nodes` list. If the list hasn't changed 
                it saves having to look up the index of `last_node` in that 
                list. 
 
        :Returns: 
            tuple, the node targeted by key and its index in the 
            :meth:`get_selectable_nodes` list. Returning 
            `(last_node, last_node_idx)` indicates a node wasn't found. 
        '''</span>
        <span class="s1">sister_nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_selectable_nodes</span><span class="s2">()</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sister_nodes</span><span class="s2">) - </span><span class="s5">1</span>
        <span class="s1">counts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_offset_counts</span>
        <span class="s4">if </span><span class="s1">end </span><span class="s2">== -</span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">last_node_idx</span>
        <span class="s4">if </span><span class="s1">last_node_idx </span><span class="s2">&gt; </span><span class="s1">end </span><span class="s4">or </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">last_node_idx</span><span class="s2">] != </span><span class="s1">last_node</span><span class="s2">:</span>
            <span class="s4">try</span><span class="s2">:    </span><span class="s6"># just in case</span>
                <span class="s1">last_node_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_index_of_node</span><span class="s2">(</span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">sister_nodes</span><span class="s2">)</span>
            <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">last_node_idx</span>

        <span class="s1">is_reversed </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nodes_order_reversed</span>
        <span class="s4">if </span><span class="s1">key </span><span class="s4">in </span><span class="s1">counts</span><span class="s2">:</span>
            <span class="s1">count </span><span class="s2">= -</span><span class="s1">counts</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] </span><span class="s4">if </span><span class="s1">is_reversed </span><span class="s4">else </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
            <span class="s1">idx </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">min</span><span class="s2">(</span><span class="s1">count </span><span class="s2">+ </span><span class="s1">last_node_idx</span><span class="s2">, </span><span class="s1">end</span><span class="s2">), </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">], </span><span class="s1">idx</span>
        <span class="s4">elif </span><span class="s1">key </span><span class="s2">== </span><span class="s3">'home'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">is_reversed</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">end</span><span class="s2">], </span><span class="s1">end</span>
            <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">0</span>
        <span class="s4">elif </span><span class="s1">key </span><span class="s2">== </span><span class="s3">'end'</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">is_reversed</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">0</span>
            <span class="s4">return </span><span class="s1">sister_nodes</span><span class="s2">[</span><span class="s1">end</span><span class="s2">], </span><span class="s1">end</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">last_node</span><span class="s2">, </span><span class="s1">last_node_idx</span>

    <span class="s4">def </span><span class="s1">select_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">):</span>
        <span class="s0">''' Selects a node. 
 
        It is called by the controller when it selects a node and can be 
        called from the outside to select a node directly. The derived widget 
        should overwrite this method and change the node state to selected 
        when called. 
 
        :Parameters: 
            `node` 
                The node to be selected. 
 
        :Returns: 
            bool, True if the node was selected, False otherwise. 
 
        .. warning:: 
 
            This method must be called by the derived widget using super if it 
            is overwritten. 
        '''</span>
        <span class="s1">nodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes</span>
        <span class="s4">if </span><span class="s1">node </span><span class="s4">in </span><span class="s1">nodes</span><span class="s2">:</span>
            <span class="s4">return False</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">multiselect</span><span class="s2">) </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nodes</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">clear_selection</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">node </span><span class="s4">not in </span><span class="s1">nodes</span><span class="s2">:</span>
            <span class="s1">nodes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_anchor </span><span class="s2">= </span><span class="s1">node</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_last_selected_node </span><span class="s2">= </span><span class="s1">node</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">deselect_node</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">):</span>
        <span class="s0">''' Deselects a possibly selected node. 
 
        It is called by the controller when it deselects a node and can also 
        be called from the outside to deselect a node directly. The derived 
        widget should overwrite this method and change the node to its 
        unselected state when this is called 
 
        :Parameters: 
            `node` 
                The node to be deselected. 
 
        .. warning:: 
 
            This method must be called by the derived widget using super if it 
            is overwritten. 
        '''</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">selected_nodes</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s4">return True</span>
        <span class="s4">except </span><span class="s1">ValueError</span><span class="s2">:</span>
            <span class="s4">return False</span>
</pre>
</body>
</html>