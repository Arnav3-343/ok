<html>
<head>
<title>gesture.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gesture.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Gesture recognition 
=================== 
 
This class allows you to easily create new 
gestures and compare them:: 
 
    from kivy.gesture import Gesture, GestureDatabase 
 
    # Create a gesture 
    g = Gesture() 
    g.add_stroke(point_list=[(1,1), (3,4), (2,1)]) 
    g.normalize() 
 
    # Add it to the database 
    gdb = GestureDatabase() 
    gdb.add_gesture(g) 
 
    # And for the next gesture, try to find it! 
    g2 = Gesture() 
    # ... 
    gdb.find(g2) 
 
.. warning:: 
 
   You don't really want to do this: it's more of an example of how 
   to construct gestures dynamically. Typically, you would 
   need a lot more points, so it's better to record gestures in a file and 
   reload them to compare later. Look in the examples/gestures directory for 
   an example of how to do that. 
 
'''</span>

<span class="s1">__all__ </span><span class="s2">= (</span><span class="s3">'Gesture'</span><span class="s2">, </span><span class="s3">'GestureDatabase'</span><span class="s2">, </span><span class="s3">'GesturePoint'</span><span class="s2">, </span><span class="s3">'GestureStroke'</span><span class="s2">)</span>

<span class="s4">import </span><span class="s1">pickle</span>
<span class="s4">import </span><span class="s1">base64</span>
<span class="s4">import </span><span class="s1">zlib</span>
<span class="s4">import </span><span class="s1">math</span>

<span class="s4">from </span><span class="s1">kivy</span><span class="s2">.</span><span class="s1">vector </span><span class="s4">import </span><span class="s1">Vector</span>

<span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>


<span class="s4">class </span><span class="s1">GestureDatabase</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">'''Class to handle a gesture database.'''</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">db </span><span class="s2">= []</span>

    <span class="s4">def </span><span class="s1">add_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">gesture</span><span class="s2">):</span>
        <span class="s0">'''Add a new gesture to the database.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">db</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gesture</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">find</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">gesture</span><span class="s2">, </span><span class="s1">minscore</span><span class="s2">=</span><span class="s5">0.9</span><span class="s2">, </span><span class="s1">rotation_invariant</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">'''Find a matching gesture in the database.'''</span>
        <span class="s4">if not </span><span class="s1">gesture</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s1">best </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">bestscore </span><span class="s2">= </span><span class="s1">minscore</span>
        <span class="s4">for </span><span class="s1">g </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">db</span><span class="s2">:</span>
            <span class="s1">score </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">get_score</span><span class="s2">(</span><span class="s1">gesture</span><span class="s2">, </span><span class="s1">rotation_invariant</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">score </span><span class="s2">&lt; </span><span class="s1">bestscore</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s1">bestscore </span><span class="s2">= </span><span class="s1">score</span>
            <span class="s1">best </span><span class="s2">= </span><span class="s1">g</span>
        <span class="s4">if not </span><span class="s1">best</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s4">return </span><span class="s2">(</span><span class="s1">bestscore</span><span class="s2">, </span><span class="s1">best</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">gesture_to_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">gesture</span><span class="s2">):</span>
        <span class="s0">'''Convert a gesture into a unique string.'''</span>
        <span class="s1">io </span><span class="s2">= </span><span class="s1">BytesIO</span><span class="s2">()</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">Pickler</span><span class="s2">(</span><span class="s1">io</span><span class="s2">)</span>
        <span class="s1">p</span><span class="s2">.</span><span class="s1">dump</span><span class="s2">(</span><span class="s1">gesture</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">base64</span><span class="s2">.</span><span class="s1">b64encode</span><span class="s2">(</span><span class="s1">zlib</span><span class="s2">.</span><span class="s1">compress</span><span class="s2">(</span><span class="s1">io</span><span class="s2">.</span><span class="s1">getvalue</span><span class="s2">(), </span><span class="s5">9</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">str_to_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s0">'''Convert a unique string to a gesture.'''</span>
        <span class="s1">io </span><span class="s2">= </span><span class="s1">BytesIO</span><span class="s2">(</span><span class="s1">zlib</span><span class="s2">.</span><span class="s1">decompress</span><span class="s2">(</span><span class="s1">base64</span><span class="s2">.</span><span class="s1">b64decode</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)))</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">Unpickler</span><span class="s2">(</span><span class="s1">io</span><span class="s2">)</span>
        <span class="s1">gesture </span><span class="s2">= </span><span class="s1">p</span><span class="s2">.</span><span class="s1">load</span><span class="s2">()</span>
        <span class="s4">return </span><span class="s1">gesture</span>


<span class="s4">class </span><span class="s1">GesturePoint</span><span class="s2">:</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s0">'''Stores the x,y coordinates of a point in the gesture.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">scale</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">):</span>
        <span class="s0">''' Scales the point by the given factor.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">*= </span><span class="s1">factor</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y </span><span class="s2">*= </span><span class="s1">factor</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s3">'Mouse_point: %f,%f' </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">GestureStroke</span><span class="s2">:</span>
    <span class="s0">''' Gestures can be made up of multiple strokes.'''</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">''' A stroke in the gesture.'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">points </span><span class="s2">= </span><span class="s1">list</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">screenpoints </span><span class="s2">= </span><span class="s1">list</span><span class="s2">()</span>

    <span class="s6"># These return the min and max coordinates of the stroke</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">max_x</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s4">return </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s4">lambda </span><span class="s1">pt</span><span class="s2">: </span><span class="s1">pt</span><span class="s2">.</span><span class="s1">x</span><span class="s2">).</span><span class="s1">x</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">min_x</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s4">return </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s4">lambda </span><span class="s1">pt</span><span class="s2">: </span><span class="s1">pt</span><span class="s2">.</span><span class="s1">x</span><span class="s2">).</span><span class="s1">x</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">max_y</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s4">return </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s4">lambda </span><span class="s1">pt</span><span class="s2">: </span><span class="s1">pt</span><span class="s2">.</span><span class="s1">y</span><span class="s2">).</span><span class="s1">y</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">min_y</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s4">return </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s4">lambda </span><span class="s1">pt</span><span class="s2">: </span><span class="s1">pt</span><span class="s2">.</span><span class="s1">y</span><span class="s2">).</span><span class="s1">y</span>

    <span class="s4">def </span><span class="s1">add_point</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s0">''' 
        add_point(x=x_pos, y=y_pos) 
        Adds a point to the stroke. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">GesturePoint</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">screenpoints</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">scale_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">scale_factor</span><span class="s2">):</span>
        <span class="s0">''' 
        scale_stroke(scale_factor=float) 
        Scales the stroke down by scale_factor. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">points </span><span class="s2">= [</span><span class="s1">pt</span><span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s1">scale_factor</span><span class="s2">) </span><span class="s4">for </span><span class="s1">pt </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">points_distance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">point1</span><span class="s2">, </span><span class="s1">point2</span><span class="s2">):</span>
        <span class="s0">''' 
        points_distance(point1=GesturePoint, point2=GesturePoint) 
        Returns the distance between two GesturePoints. 
        '''</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">point1</span><span class="s2">.</span><span class="s1">x </span><span class="s2">- </span><span class="s1">point2</span><span class="s2">.</span><span class="s1">x</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">point1</span><span class="s2">.</span><span class="s1">y </span><span class="s2">- </span><span class="s1">point2</span><span class="s2">.</span><span class="s1">y</span>
        <span class="s4">return </span><span class="s1">math</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">x </span><span class="s2">* </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y </span><span class="s2">* </span><span class="s1">y</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">stroke_length</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">point_list</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">'''Finds the length of the stroke. If a point list is given, 
           finds the length of that list. 
        '''</span>
        <span class="s4">if </span><span class="s1">point_list </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">point_list </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span>
        <span class="s1">gesture_length </span><span class="s2">= </span><span class="s5">0.0</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">point_list</span><span class="s2">) &lt;= </span><span class="s5">1</span><span class="s2">:  </span><span class="s6"># If there is only one point -&gt; no length</span>
            <span class="s4">return </span><span class="s1">gesture_length</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">point_list</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">):</span>
            <span class="s1">gesture_length </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points_distance</span><span class="s2">(</span>
                <span class="s1">point_list</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">point_list</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">gesture_length</span>

    <span class="s4">def </span><span class="s1">normalize_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sample_points</span><span class="s2">=</span><span class="s5">32</span><span class="s2">):</span>
        <span class="s0">'''Normalizes strokes so that every stroke has a standard number of 
           points. Returns True if stroke is normalized, False if it can't be 
           normalized. sample_points controls the resolution of the stroke. 
        '''</span>
        <span class="s6"># If there is only one point or the length is 0, don't normalize</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) &lt;= </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">stroke_length</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) == </span><span class="s5">0.0</span><span class="s2">:</span>
            <span class="s4">return False</span>

        <span class="s6"># Calculate how long each point should be in the stroke</span>
        <span class="s1">target_stroke_size </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">stroke_length</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) / </span><span class="s1">float</span><span class="s2">(</span><span class="s1">sample_points</span><span class="s2">)</span>
        <span class="s1">new_points </span><span class="s2">= </span><span class="s1">list</span><span class="s2">()</span>
        <span class="s1">new_points</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s6"># We loop on the points</span>
        <span class="s1">prev </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">src_distance </span><span class="s2">= </span><span class="s5">0.0</span>
        <span class="s1">dst_distance </span><span class="s2">= </span><span class="s1">target_stroke_size</span>
        <span class="s4">for </span><span class="s1">curr </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points_distance</span><span class="s2">(</span><span class="s1">prev</span><span class="s2">, </span><span class="s1">curr</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">d </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">prev </span><span class="s2">= </span><span class="s1">curr</span>
                <span class="s1">src_distance </span><span class="s2">= </span><span class="s1">src_distance </span><span class="s2">+ </span><span class="s1">d</span>

                <span class="s6"># The new point need to be inserted into the</span>
                <span class="s6"># segment [prev, curr]</span>
                <span class="s4">while </span><span class="s1">dst_distance </span><span class="s2">&lt; </span><span class="s1">src_distance</span><span class="s2">:</span>
                    <span class="s1">x_dir </span><span class="s2">= </span><span class="s1">curr</span><span class="s2">.</span><span class="s1">x </span><span class="s2">- </span><span class="s1">prev</span><span class="s2">.</span><span class="s1">x</span>
                    <span class="s1">y_dir </span><span class="s2">= </span><span class="s1">curr</span><span class="s2">.</span><span class="s1">y </span><span class="s2">- </span><span class="s1">prev</span><span class="s2">.</span><span class="s1">y</span>
                    <span class="s1">ratio </span><span class="s2">= (</span><span class="s1">src_distance </span><span class="s2">- </span><span class="s1">dst_distance</span><span class="s2">) / </span><span class="s1">d</span>
                    <span class="s1">to_x </span><span class="s2">= </span><span class="s1">x_dir </span><span class="s2">* </span><span class="s1">ratio </span><span class="s2">+ </span><span class="s1">prev</span><span class="s2">.</span><span class="s1">x</span>
                    <span class="s1">to_y </span><span class="s2">= </span><span class="s1">y_dir </span><span class="s2">* </span><span class="s1">ratio </span><span class="s2">+ </span><span class="s1">prev</span><span class="s2">.</span><span class="s1">y</span>
                    <span class="s1">new_points</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">GesturePoint</span><span class="s2">(</span><span class="s1">to_x</span><span class="s2">, </span><span class="s1">to_y</span><span class="s2">))</span>
                    <span class="s1">dst_distance </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">stroke_length</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">) / </span><span class="s1">\</span>
                        <span class="s1">float</span><span class="s2">(</span><span class="s1">sample_points</span><span class="s2">) * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_points</span><span class="s2">)</span>

        <span class="s6"># If this happens, we are into troubles...</span>
        <span class="s4">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_points</span><span class="s2">) == </span><span class="s1">sample_points</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Invalid number of strokes points; got '</span>
                             <span class="s3">'%d while it should be %d' </span><span class="s2">%</span>
                             <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_points</span><span class="s2">), </span><span class="s1">sample_points</span><span class="s2">))</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">points </span><span class="s2">= </span><span class="s1">new_points</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">center_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">offset_x</span><span class="s2">, </span><span class="s1">offset_y</span><span class="s2">):</span>
        <span class="s0">'''Centers the stroke by offsetting the points.'''</span>
        <span class="s4">for </span><span class="s1">point </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">points</span><span class="s2">:</span>
            <span class="s1">point</span><span class="s2">.</span><span class="s1">x </span><span class="s2">-= </span><span class="s1">offset_x</span>
            <span class="s1">point</span><span class="s2">.</span><span class="s1">y </span><span class="s2">-= </span><span class="s1">offset_y</span>


<span class="s4">class </span><span class="s1">Gesture</span><span class="s2">:</span>
    <span class="s0">'''A python implementation of a gesture recognition algorithm by 
    Oleg Dopertchouk: http://www.gamedev.net/reference/articles/article2039.asp 
 
    Implemented by Jeiel Aranal (chemikhazi@gmail.com), 
    released into the public domain. 
    '''</span>

    <span class="s6"># Tolerance for evaluation using the '==' operator</span>
    <span class="s1">DEFAULT_TOLERANCE </span><span class="s2">= </span><span class="s5">0.1</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">''' 
        Gesture([tolerance=float]) 
        Creates a new gesture with an optional matching tolerance value. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">width </span><span class="s2">= </span><span class="s5">0.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">height </span><span class="s2">= </span><span class="s5">0.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gesture_product </span><span class="s2">= </span><span class="s5">0.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">strokes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">tolerance </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">tolerance </span><span class="s2">= </span><span class="s1">Gesture</span><span class="s2">.</span><span class="s1">DEFAULT_TOLERANCE</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">tolerance </span><span class="s2">= </span><span class="s1">tolerance</span>

    <span class="s4">def </span><span class="s1">_scale_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">''' Scales down the gesture to a unit of 1.'''</span>
        <span class="s6"># map() creates a list of min/max coordinates of the strokes</span>
        <span class="s6"># in the gesture and min()/max() pulls the lowest/highest value</span>
        <span class="s1">min_x </span><span class="s2">= </span><span class="s1">min</span><span class="s2">([</span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">min_x </span><span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">])</span>
        <span class="s1">max_x </span><span class="s2">= </span><span class="s1">max</span><span class="s2">([</span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">max_x </span><span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">])</span>
        <span class="s1">min_y </span><span class="s2">= </span><span class="s1">min</span><span class="s2">([</span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">min_y </span><span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">])</span>
        <span class="s1">max_y </span><span class="s2">= </span><span class="s1">max</span><span class="s2">([</span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">max_y </span><span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">])</span>
        <span class="s1">x_len </span><span class="s2">= </span><span class="s1">max_x </span><span class="s2">- </span><span class="s1">min_x</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">width </span><span class="s2">= </span><span class="s1">x_len</span>
        <span class="s1">y_len </span><span class="s2">= </span><span class="s1">max_y </span><span class="s2">- </span><span class="s1">min_y</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">height </span><span class="s2">= </span><span class="s1">y_len</span>
        <span class="s1">scale_factor </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">x_len</span><span class="s2">, </span><span class="s1">y_len</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">scale_factor </span><span class="s2">&lt;= </span><span class="s5">0.0</span><span class="s2">:</span>
            <span class="s4">return False</span>
        <span class="s1">scale_factor </span><span class="s2">= </span><span class="s5">1.0 </span><span class="s2">/ </span><span class="s1">scale_factor</span>
        <span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">:</span>
            <span class="s1">stroke</span><span class="s2">.</span><span class="s1">scale_stroke</span><span class="s2">(</span><span class="s1">scale_factor</span><span class="s2">)</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">_center_gesture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">''' Centers the Gesture.points of the gesture.'''</span>
        <span class="s1">total_x </span><span class="s2">= </span><span class="s5">0.0</span>
        <span class="s1">total_y </span><span class="s2">= </span><span class="s5">0.0</span>
        <span class="s1">total_points </span><span class="s2">= </span><span class="s5">0</span>

        <span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">:</span>
            <span class="s6"># adds up all the points inside the stroke</span>
            <span class="s1">stroke_y </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">([</span><span class="s1">pt</span><span class="s2">.</span><span class="s1">y </span><span class="s4">for </span><span class="s1">pt </span><span class="s4">in </span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">])</span>
            <span class="s1">stroke_x </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">([</span><span class="s1">pt</span><span class="s2">.</span><span class="s1">x </span><span class="s4">for </span><span class="s1">pt </span><span class="s4">in </span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">])</span>
            <span class="s1">total_y </span><span class="s2">+= </span><span class="s1">stroke_y</span>
            <span class="s1">total_x </span><span class="s2">+= </span><span class="s1">stroke_x</span>
            <span class="s1">total_points </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">total_points </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return False</span>
        <span class="s6"># Average to get the offset</span>
        <span class="s1">total_x </span><span class="s2">/= </span><span class="s1">total_points</span>
        <span class="s1">total_y </span><span class="s2">/= </span><span class="s1">total_points</span>
        <span class="s6"># Apply the offset to the strokes</span>
        <span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">:</span>
            <span class="s1">stroke</span><span class="s2">.</span><span class="s1">center_stroke</span><span class="s2">(</span><span class="s1">total_x</span><span class="s2">, </span><span class="s1">total_y</span><span class="s2">)</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">add_stroke</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">point_list</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">'''Adds a stroke to the gesture and returns the Stroke instance. 
           Optional point_list argument is a list of the mouse points for 
           the stroke. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">GestureStroke</span><span class="s2">())</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point_list</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point_list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s4">for </span><span class="s1">point </span><span class="s4">in </span><span class="s1">point_list</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point</span><span class="s2">, </span><span class="s1">GesturePoint</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">points</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">point</span><span class="s2">)</span>
                <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">point</span><span class="s2">) != </span><span class="s5">2</span><span class="s2">:</span>
                        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Stroke entry must have 2 values max&quot;</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">add_point</span><span class="s2">(</span><span class="s1">point</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">point</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;The point list should either be &quot;</span>
                                    <span class="s3">&quot;tuples of x and y or a list of &quot;</span>
                                    <span class="s3">&quot;GesturePoint objects&quot;</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">point_list </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;point_list should be a tuple/list&quot;</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">normalize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">stroke_samples</span><span class="s2">=</span><span class="s5">32</span><span class="s2">):</span>
        <span class="s0">'''Runs the gesture normalization algorithm and calculates the dot 
        product with self. 
        '''</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scale_gesture</span><span class="s2">() </span><span class="s4">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_center_gesture</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gesture_product </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s4">return False</span>
        <span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">:</span>
            <span class="s1">stroke</span><span class="s2">.</span><span class="s1">normalize_stroke</span><span class="s2">(</span><span class="s1">stroke_samples</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gesture_product </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dot_product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">get_rigid_rotation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dstpts</span><span class="s2">):</span>
        <span class="s0">''' 
        Extract the rotation to apply to a group of points to minimize the 
        distance to a second group of points. The two groups of points are 
        assumed to be centered. This is a simple version that just picks 
        an angle based on the first point of the gesture. 
        '''</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">) &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">points</span><span class="s2">) &lt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dstpts</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">) &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dstpts</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">points</span><span class="s2">) &lt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s5">0</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">dstpts</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">points</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">target </span><span class="s2">= </span><span class="s1">Vector</span><span class="s2">([</span><span class="s1">p</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">.</span><span class="s1">y</span><span class="s2">])</span>
        <span class="s1">source </span><span class="s2">= </span><span class="s1">Vector</span><span class="s2">([</span><span class="s1">p</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">.</span><span class="s1">y</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">source</span><span class="s2">.</span><span class="s1">angle</span><span class="s2">(</span><span class="s1">target</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">dot_product</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s0">''' Calculates the dot product of the gesture with another gesture.'''</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span>
        <span class="s4">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">, </span><span class="s3">'gesture_product'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">) </span><span class="s4">is False or </span><span class="s1">\</span>
           <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s3">'gesture_product'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">) </span><span class="s4">is False</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s2">-</span><span class="s5">1</span>
        <span class="s1">dot_product </span><span class="s2">= </span><span class="s5">0.0</span>
        <span class="s4">for </span><span class="s1">stroke_index</span><span class="s2">, (</span><span class="s1">my_stroke</span><span class="s2">, </span><span class="s1">cmp_stroke</span><span class="s2">) </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span>
                <span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">))):</span>
            <span class="s4">for </span><span class="s1">pt_index</span><span class="s2">, (</span><span class="s1">my_point</span><span class="s2">, </span><span class="s1">cmp_point</span><span class="s2">) </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span>
                    <span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">my_stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">, </span><span class="s1">cmp_stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">))):</span>
                <span class="s1">dot_product </span><span class="s2">+= (</span><span class="s1">my_point</span><span class="s2">.</span><span class="s1">x </span><span class="s2">* </span><span class="s1">cmp_point</span><span class="s2">.</span><span class="s1">x </span><span class="s2">+</span>
                                <span class="s1">my_point</span><span class="s2">.</span><span class="s1">y </span><span class="s2">* </span><span class="s1">cmp_point</span><span class="s2">.</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">dot_product</span>

    <span class="s4">def </span><span class="s1">rotate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">):</span>
        <span class="s1">g </span><span class="s2">= </span><span class="s1">Gesture</span><span class="s2">()</span>
        <span class="s4">for </span><span class="s1">stroke </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strokes</span><span class="s2">:</span>
            <span class="s1">tmp </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">stroke</span><span class="s2">.</span><span class="s1">points</span><span class="s2">:</span>
                <span class="s1">v </span><span class="s2">= </span><span class="s1">Vector</span><span class="s2">([</span><span class="s1">j</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">j</span><span class="s2">.</span><span class="s1">y</span><span class="s2">]).</span><span class="s1">rotate</span><span class="s2">(</span><span class="s1">angle</span><span class="s2">)</span>
                <span class="s1">tmp</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s1">g</span><span class="s2">.</span><span class="s1">add_stroke</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">)</span>
        <span class="s1">g</span><span class="s2">.</span><span class="s1">gesture_product </span><span class="s2">= </span><span class="s1">g</span><span class="s2">.</span><span class="s1">dot_product</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">g</span>

    <span class="s4">def </span><span class="s1">get_score</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">, </span><span class="s1">rotation_invariant</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">''' Returns the matching score of the gesture against another gesture. 
        '''</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">, </span><span class="s1">Gesture</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">rotation_invariant</span><span class="s2">:</span>
                <span class="s6"># get orientation</span>
                <span class="s1">angle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_rigid_rotation</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">)</span>

                <span class="s6"># rotate the gesture to be in the same frame.</span>
                <span class="s1">comparison_gesture </span><span class="s2">= </span><span class="s1">comparison_gesture</span><span class="s2">.</span><span class="s1">rotate</span><span class="s2">(</span><span class="s1">angle</span><span class="s2">)</span>

            <span class="s6"># this is the normal &quot;orientation&quot; code.</span>
            <span class="s1">score </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dot_product</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">score </span><span class="s2">&lt;= </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">score</span>
            <span class="s1">score </span><span class="s2">/= </span><span class="s1">math</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">gesture_product </span><span class="s2">* </span><span class="s1">comparison_gesture</span><span class="s2">.</span><span class="s1">gesture_product</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">score</span>

    <span class="s4">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s0">''' Allows easy comparisons between gesture instances.'''</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">, </span><span class="s1">Gesture</span><span class="s2">):</span>
            <span class="s6"># If the gestures don't have the same number of strokes, its</span>
            <span class="s6"># definitely not the same gesture</span>
            <span class="s1">score </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_score</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">score </span><span class="s2">&gt; (</span><span class="s5">1.0 </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tolerance</span><span class="s2">) </span><span class="s4">and</span>
                    <span class="s1">score </span><span class="s2">&lt; (</span><span class="s5">1.0 </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tolerance</span><span class="s2">)):</span>
                <span class="s4">return True</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__ne__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">comparison_gesture</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">result </span><span class="s4">is </span><span class="s1">NotImplemented</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">result</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return not </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">__lt__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Gesture cannot be evaluated with &lt;&quot;</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__gt__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Gesture cannot be evaluated with &gt;&quot;</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__le__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Gesture cannot be evaluated with &lt;=&quot;</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__ge__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_gesture</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;Gesture cannot be evaluated with &gt;=&quot;</span><span class="s2">)</span>
</pre>
</body>
</html>