<html>
<head>
<title>callconv.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
callconv.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Calling conventions for Numba-compiled functions. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">hashlib</span>

<span class="s2">from </span><span class="s1">llvmlite </span><span class="s2">import </span><span class="s1">ir</span>

<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">types</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">, </span><span class="s1">errors</span>
<span class="s2">from </span><span class="s1">numba</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">PYOBJECT</span><span class="s3">, </span><span class="s1">GENERIC_POINTER</span>


<span class="s1">TryStatus </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'TryStatus'</span><span class="s3">, [</span><span class="s4">'in_try'</span><span class="s3">, </span><span class="s4">'excinfo'</span><span class="s3">])</span>


<span class="s1">Status </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">&quot;Status&quot;</span><span class="s3">,</span>
                    <span class="s3">(</span><span class="s4">&quot;code&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the function returned ok (a value or None)</span>
                     <span class="s4">&quot;is_ok&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the function returned None</span>
                     <span class="s4">&quot;is_none&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the function errored out (== not is_ok)</span>
                     <span class="s4">&quot;is_error&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the generator exited with StopIteration</span>
                     <span class="s4">&quot;is_stop_iteration&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the function errored with an already set exception</span>
                     <span class="s4">&quot;is_python_exc&quot;</span><span class="s3">,</span>
                     <span class="s5"># If the function errored with a user exception</span>
                     <span class="s4">&quot;is_user_exc&quot;</span><span class="s3">,</span>
                     <span class="s5"># The pointer to the exception info structure (for user</span>
                     <span class="s5"># exceptions)</span>
                     <span class="s4">&quot;excinfoptr&quot;</span><span class="s3">,</span>
                     <span class="s3">))</span>

<span class="s1">int32_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s6">32</span><span class="s3">)</span>
<span class="s1">int64_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s6">64</span><span class="s3">)</span>
<span class="s1">errcode_t </span><span class="s3">= </span><span class="s1">int32_t</span>


<span class="s2">def </span><span class="s1">_const_int</span><span class="s3">(</span><span class="s1">code</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">errcode_t</span><span class="s3">, </span><span class="s1">code</span><span class="s3">)</span>


<span class="s1">RETCODE_OK </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
<span class="s1">RETCODE_EXC </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">RETCODE_NONE </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(-</span><span class="s6">2</span><span class="s3">)</span>
<span class="s5"># StopIteration</span>
<span class="s1">RETCODE_STOPIT </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(-</span><span class="s6">3</span><span class="s3">)</span>

<span class="s1">FIRST_USEREXC </span><span class="s3">= </span><span class="s6">1</span>

<span class="s1">RETCODE_USEREXC </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(</span><span class="s1">FIRST_USEREXC</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">BaseCallConv</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context </span><span class="s3">= </span><span class="s1">context</span>

    <span class="s2">def </span><span class="s1">return_optional_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">valty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">valty </span><span class="s3">== </span><span class="s1">types</span><span class="s3">.</span><span class="s1">none</span><span class="s3">:</span>
            <span class="s5"># Value is none</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">return_native_none</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">retty </span><span class="s3">== </span><span class="s1">valty</span><span class="s3">:</span>
            <span class="s5"># Value is an optional, need a runtime switch</span>
            <span class="s1">optval </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">make_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">)</span>

            <span class="s1">validbit </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">as_bool_bit</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">optval</span><span class="s3">.</span><span class="s1">valid</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">validbit</span><span class="s3">):</span>
                <span class="s1">retval </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_return_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,</span>
                                                       <span class="s1">optval</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">return_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">return_native_none</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>

        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">valty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Optional</span><span class="s3">):</span>
            <span class="s5"># Value is not an optional, need a cast</span>
            <span class="s2">if </span><span class="s1">valty </span><span class="s3">!= </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">fromty</span><span class="s3">=</span><span class="s1">valty</span><span class="s3">,</span>
                                          <span class="s1">toty</span><span class="s3">=</span><span class="s1">retty</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s1">retval </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_return_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">return_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;returning {0} for {1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">valty</span><span class="s3">,</span>
                                                                     <span class="s1">retty</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">return_native_none</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_NONE</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_EXC</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_stop_iteration</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_STOPIT</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_return_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the actual type of the return argument for Numba type *ty*. 
        &quot;&quot;&quot;</span>
        <span class="s1">restype </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span><span class="s3">[</span><span class="s1">ty</span><span class="s3">].</span><span class="s1">get_return_type</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">restype</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">init_call_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize and return a call helper object for the given builder. 
        &quot;&quot;&quot;</span>
        <span class="s1">ch </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_call_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">__call_helper </span><span class="s3">= </span><span class="s1">ch</span>
        <span class="s2">return </span><span class="s1">ch</span>

    <span class="s2">def </span><span class="s1">_get_call_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">__call_helper</span>

    <span class="s2">def </span><span class="s1">unpack_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">unserialize</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">excinfoptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">raise_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a non-ok *status*, raise the corresponding Python exception. 
        &quot;&quot;&quot;</span>
        <span class="s1">bbend </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">()</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">is_user_exc</span><span class="s3">):</span>
            <span class="s5"># Unserialize user exception.</span>
            <span class="s5"># Make sure another error may not interfere.</span>
            <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">err_clear</span><span class="s3">()</span>
            <span class="s1">exc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">unpack_exception</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_likely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                   <span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_not_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">)):</span>
                <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">raise_object</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">)  </span><span class="s5"># steals ref</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">is_stop_iteration</span><span class="s3">):</span>
            <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">err_set_none</span><span class="s3">(</span><span class="s4">&quot;PyExc_StopIteration&quot;</span><span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">is_python_exc</span><span class="s3">):</span>
            <span class="s5"># Error already raised =&gt; nothing to do</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

        <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">err_set_string</span><span class="s3">(</span><span class="s4">&quot;PyExc_SystemError&quot;</span><span class="s3">,</span>
                             <span class="s4">&quot;unknown error when calling native function&quot;</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

        <span class="s1">builder</span><span class="s3">.</span><span class="s1">position_at_end</span><span class="s3">(</span><span class="s1">bbend</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">decode_arguments</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the decoded (unpacked) Python arguments with *argtypes* 
        from LLVM function *func*.  A tuple of LLVM values is returned. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw_args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">argtypes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">arginfo</span><span class="s3">.</span><span class="s1">from_arguments</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">raw_args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get an argument packer for the given argument types. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_arg_packer</span><span class="s3">(</span><span class="s1">argtypes</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">MinimalCallConv</span><span class="s3">(</span><span class="s1">BaseCallConv</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A minimal calling convention, suitable for e.g. GPU targets. 
    The implemented function signature is: 
 
        retcode_t (&lt;Python return type&gt;*, ... &lt;Python arguments&gt;) 
 
    The return code will be one of the RETCODE_* constants or a 
    function-specific user exception id (&gt;= RETCODE_USEREXC). 
 
    Caller is responsible for allocating a slot for the return value 
    (passed as a pointer in the first argument). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_make_call_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_MinimalCallHelper</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">return_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">):</span>
        <span class="s1">retptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">retptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">, </span><span class="s1">\</span>
            <span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type</span><span class="s3">), </span><span class="s1">str</span><span class="s3">(</span><span class="s1">retptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">, </span><span class="s1">retptr</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_OK</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">func_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">exc </span><span class="s2">is not None and not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc should be None or exception class, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc</span><span class="s3">,))</span>
        <span class="s2">if </span><span class="s1">exc_args </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc_args should be None or tuple, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc_args</span><span class="s3">,))</span>

        <span class="s5"># Build excinfo struct</span>
        <span class="s2">if </span><span class="s1">loc </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">fname </span><span class="s3">= </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">_raw_function_name</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">fname </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s5"># could be exec(&lt;string&gt;) or REPL, try func_name</span>
                <span class="s1">fname </span><span class="s3">= </span><span class="s1">func_name</span>

            <span class="s1">locinfo </span><span class="s3">= (</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line</span><span class="s3">)</span>
            <span class="s2">if None in </span><span class="s1">locinfo</span><span class="s3">:</span>
                <span class="s1">locinfo </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">locinfo </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">call_helper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_call_helper</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">exc_id </span><span class="s3">= </span><span class="s1">call_helper</span><span class="s3">.</span><span class="s1">_add_exception</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">locinfo</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">_const_int</span><span class="s3">(</span><span class="s1">exc_id</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">return_status_propagate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">.</span><span class="s1">code</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s1">code </span><span class="s3">= </span><span class="s1">_const_int</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_return_status</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a return *code*, get a Status instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">norm </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_OK</span><span class="s3">)</span>
        <span class="s1">none </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_NONE</span><span class="s3">)</span>
        <span class="s1">ok </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">none</span><span class="s3">)</span>
        <span class="s1">err </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">ok</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_EXC</span><span class="s3">)</span>
        <span class="s1">is_stop_iteration </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_STOPIT</span><span class="s3">)</span>
        <span class="s1">is_user_exc </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_USEREXC</span><span class="s3">)</span>

        <span class="s1">status </span><span class="s3">= </span><span class="s1">Status</span><span class="s3">(</span><span class="s1">code</span><span class="s3">=</span><span class="s1">code</span><span class="s3">,</span>
                        <span class="s1">is_ok</span><span class="s3">=</span><span class="s1">ok</span><span class="s3">,</span>
                        <span class="s1">is_error</span><span class="s3">=</span><span class="s1">err</span><span class="s3">,</span>
                        <span class="s1">is_python_exc</span><span class="s3">=</span><span class="s1">exc</span><span class="s3">,</span>
                        <span class="s1">is_none</span><span class="s3">=</span><span class="s1">none</span><span class="s3">,</span>
                        <span class="s1">is_user_exc</span><span class="s3">=</span><span class="s1">is_user_exc</span><span class="s3">,</span>
                        <span class="s1">is_stop_iteration</span><span class="s3">=</span><span class="s1">is_stop_iteration</span><span class="s3">,</span>
                        <span class="s1">excinfoptr</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">status</span>

    <span class="s2">def </span><span class="s1">get_function_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">restype</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the implemented Function type for *restype* and *argtypes*. 
        &quot;&quot;&quot;</span>
        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">argtypes</span><span class="s3">)</span>
        <span class="s1">argtypes </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arginfo</span><span class="s3">.</span><span class="s1">argument_types</span><span class="s3">)</span>
        <span class="s1">resptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_return_type</span><span class="s3">(</span><span class="s1">restype</span><span class="s3">)</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">errcode_t</span><span class="s3">, [</span><span class="s1">resptr</span><span class="s3">] + </span><span class="s1">argtypes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">fnty</span>

    <span class="s2">def </span><span class="s1">decorate_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fe_argtypes</span><span class="s3">, </span><span class="s1">noalias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set names and attributes of function arguments. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert not </span><span class="s1">noalias</span>
        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">fe_argtypes</span><span class="s3">)</span>
        <span class="s1">arginfo</span><span class="s3">.</span><span class="s1">assign_names</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">),</span>
                             <span class="s3">[</span><span class="s4">'arg.' </span><span class="s3">+ </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>
        <span class="s1">fn</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">name </span><span class="s3">= </span><span class="s4">&quot;.ret&quot;</span>

    <span class="s2">def </span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the Python-level arguments of LLVM *func*. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>

    <span class="s2">def </span><span class="s1">call_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">argtys</span><span class="s3">, </span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call the Numba-compiled *callee*. 
        &quot;&quot;&quot;</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span>
        <span class="s1">retvaltmp </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s5"># initialize return value</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">), </span><span class="s1">retvaltmp</span><span class="s3">)</span>

        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">argtys</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">arginfo</span><span class="s3">.</span><span class="s1">as_arguments</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">realargs </span><span class="s3">= [</span><span class="s1">retvaltmp</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">realargs</span><span class="s3">)</span>
        <span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_status</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">)</span>
        <span class="s1">retval </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">retvaltmp</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_returned_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">status</span><span class="s3">, </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">_MinimalCallHelper</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A call helper object for the &quot;minimal&quot; calling convention. 
    User exceptions are represented as integer codes and stored in 
    a mapping for retrieval from the caller. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">exceptions </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">_add_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">locinfo</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a new user exception to this helper. Returns an integer that can be 
        used to refer to the added exception in future. 
 
        Parameters 
        ---------- 
        exc : 
            exception type 
        exc_args : None or tuple 
            exception args 
        locinfo : tuple 
            location information 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_id </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">exceptions</span><span class="s3">) + </span><span class="s1">FIRST_USEREXC</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">exceptions</span><span class="s3">[</span><span class="s1">exc_id</span><span class="s3">] = </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">locinfo</span>
        <span class="s2">return </span><span class="s1">exc_id</span>

    <span class="s2">def </span><span class="s1">get_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">exc_id</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get information about a user exception. Returns a tuple of 
        (exception type, exception args, location information). 
 
        Parameters 
        ---------- 
        id : integer 
            The ID of the exception to look up 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exceptions</span><span class="s3">[</span><span class="s1">exc_id</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;unknown error %d in native function&quot; </span><span class="s3">% </span><span class="s1">exc_id</span>
            <span class="s1">exc </span><span class="s3">= </span><span class="s1">SystemError</span>
            <span class="s1">exc_args </span><span class="s3">= (</span><span class="s1">msg</span><span class="s3">,)</span>
            <span class="s1">locinfo </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">locinfo</span>


<span class="s5"># The structure type constructed by PythonAPI.serialize_uncached()</span>
<span class="s5"># i.e a {i8* pickle_buf, i32 pickle_bufsz, i8* hash_buf, i8* fn, i32 alloc_flag}</span>
<span class="s1">PICKLE_BUF_IDX </span><span class="s3">= </span><span class="s6">0</span>
<span class="s1">PICKLE_BUFSZ_IDX </span><span class="s3">= </span><span class="s6">1</span>
<span class="s1">HASH_BUF_IDX </span><span class="s3">= </span><span class="s6">2</span>
<span class="s1">UNWRAP_FUNC_IDX </span><span class="s3">= </span><span class="s6">3</span>
<span class="s1">ALLOC_FLAG_IDX </span><span class="s3">= </span><span class="s6">4</span>
<span class="s1">excinfo_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">LiteralStructType</span><span class="s3">(</span>
    <span class="s3">[</span><span class="s1">GENERIC_POINTER</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">, </span><span class="s1">GENERIC_POINTER</span><span class="s3">, </span><span class="s1">GENERIC_POINTER</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">])</span>
<span class="s1">excinfo_ptr_t </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">excinfo_t</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">CPUCallConv</span><span class="s3">(</span><span class="s1">BaseCallConv</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The calling convention for CPU targets. 
    The implemented function signature is: 
 
        retcode_t (&lt;Python return type&gt;*, excinfo **, ... &lt;Python arguments&gt;) 
 
    The return code will be one of the RETCODE_* constants. 
    If RETCODE_USEREXC, the exception info pointer will be filled with 
    a pointer to a constant struct describing the raised exception. 
 
    Caller is responsible for allocating slots for the return value 
    and the exception info pointer (passed as first and second arguments, 
    respectively). 
    &quot;&quot;&quot;</span>
    <span class="s1">_status_ids </span><span class="s3">= </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_make_call_helper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">return_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">):</span>
        <span class="s1">retptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">retptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">, </span><span class="s1">\</span>
            <span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">.</span><span class="s1">type</span><span class="s3">), </span><span class="s1">str</span><span class="s3">(</span><span class="s1">retptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">retval</span><span class="s3">, </span><span class="s1">retptr</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_OK</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build_excinfo_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">):</span>
        <span class="s5"># Build excinfo struct</span>
        <span class="s2">if </span><span class="s1">loc </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">fname </span><span class="s3">= </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">_raw_function_name</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">fname </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s5"># could be exec(&lt;string&gt;) or REPL, try func_name</span>
                <span class="s1">fname </span><span class="s3">= </span><span class="s1">func_name</span>

            <span class="s1">locinfo </span><span class="s3">= (</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line</span><span class="s3">)</span>
            <span class="s2">if None in </span><span class="s1">locinfo</span><span class="s3">:</span>
                <span class="s1">locinfo </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">locinfo </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">exc </span><span class="s3">= (</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">locinfo</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">exc</span>

    <span class="s2">def </span><span class="s1">set_static_user_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                            <span class="s1">func_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">exc </span><span class="s2">is not None and not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc should be None or exception class, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc</span><span class="s3">,))</span>
        <span class="s2">if </span><span class="s1">exc_args </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc_args should be None or tuple, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc_args</span><span class="s3">,))</span>
        <span class="s5"># None is indicative of no args, set the exc_args to an empty tuple</span>
        <span class="s5"># as PyObject_CallObject(exc, exc_args) requires the second argument to</span>
        <span class="s5"># be a tuple (or nullptr, but doing this makes it consistent)</span>
        <span class="s2">if </span><span class="s1">exc_args </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">exc_args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">()</span>

        <span class="s5"># An exception in Numba is defined as the excinfo_t struct defined</span>
        <span class="s5"># above. Some arguments in this struct are not used, depending on</span>
        <span class="s5"># which kind of exception is being raised. A static exception uses</span>
        <span class="s5"># only the first three members whilst a dynamic exception uses all</span>
        <span class="s5"># members:</span>
        <span class="s5">#</span>
        <span class="s5">#             static exc - last 2 args are NULL and 0</span>
        <span class="s5">#             vvv  vvv  vvv</span>
        <span class="s5"># excinfo_t: {i8*, i32, i8*, i8*, i32}</span>
        <span class="s5">#                       ^^^  ^^^  ^^^</span>
        <span class="s5">#                       dynamic exc only - first 2 args are used for</span>
        <span class="s5">#                                          static info</span>
        <span class="s5">#</span>
        <span class="s5"># Comment below details how the struct is used in the case of a dynamic</span>
        <span class="s5"># exception. For dynamic exceptions, see</span>
        <span class="s5"># CPUCallConv::set_dynamic_user_exc</span>
        <span class="s5">#</span>
        <span class="s5"># {i8*, ___, ___, ___, ___}</span>
        <span class="s5">#   ^  serialized info about the exception (loc, kind, compile time</span>
        <span class="s5">#                                           args)</span>
        <span class="s5">#</span>
        <span class="s5"># {___, i32, ___, ___, ___}</span>
        <span class="s5">#        ^  len(serialized_exception)</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, i8*, ___, ___}</span>
        <span class="s5">#             ^  Store a list of native values in a dynamic exception.</span>
        <span class="s5">#                Or a hash(serialized_exception) in a static exc.</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, ___, i8*, ___}</span>
        <span class="s5">#                  ^  &quot;NULL&quot; as this member is not used in a static exc</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, ___, ___, i32}</span>
        <span class="s5">#                       ^  Number of dynamic args in the exception. For</span>
        <span class="s5">#                          static exceptions, this value is &quot;0&quot;</span>

        <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">build_excinfo_struct</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
        <span class="s1">struct_gv </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">serialize_object</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">)</span>
        <span class="s1">excptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">store </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">struct_gv</span><span class="s3">, </span><span class="s1">excptr</span><span class="s3">)</span>
        <span class="s1">md </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">add_metadata</span><span class="s3">([</span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IntType</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)(</span><span class="s6">1</span><span class="s3">)])</span>
        <span class="s1">store</span><span class="s3">.</span><span class="s1">set_metadata</span><span class="s3">(</span><span class="s4">&quot;numba_exception_output&quot;</span><span class="s3">, </span><span class="s1">md</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">func_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">try_info </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s4">'_in_try_block'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_static_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">=</span><span class="s1">exc_args</span><span class="s3">,</span>
                                 <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">=</span><span class="s1">func_name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">check_try_status</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">try_info</span><span class="s3">:</span>
            <span class="s5"># This is a hack for old-style impl.</span>
            <span class="s5"># We will branch directly to the exception handler.</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">branch</span><span class="s3">(</span><span class="s1">try_info</span><span class="s3">[</span><span class="s4">'target'</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># Return from the current function</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_USEREXC</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unpack_dynamic_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s1">excinfo_ptr </span><span class="s3">= </span><span class="s1">status</span><span class="s3">.</span><span class="s1">excinfoptr</span>

        <span class="s5"># load the serialized exception buffer from the module and create</span>
        <span class="s5"># a python bytes object</span>
        <span class="s1">picklebuf </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">), </span><span class="s1">PICKLE_BUF_IDX</span><span class="s3">)</span>
        <span class="s1">picklebuf_sz </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">), </span><span class="s1">PICKLE_BUFSZ_IDX</span><span class="s3">)</span>
        <span class="s1">static_exc_bytes </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">bytes_from_string_and_size</span><span class="s3">(</span>
            <span class="s1">picklebuf</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sext</span><span class="s3">(</span><span class="s1">picklebuf_sz</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">py_ssize_t</span><span class="s3">))</span>

        <span class="s5"># Load dynamic args (i8*) and the unwrap function</span>
        <span class="s1">dyn_args </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">), </span><span class="s1">HASH_BUF_IDX</span><span class="s3">)</span>
        <span class="s1">func_ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">), </span><span class="s1">UNWRAP_FUNC_IDX</span><span class="s3">)</span>

        <span class="s5"># Convert the unwrap function to a function pointer and call it.</span>
        <span class="s5"># Function returns a python tuple with dynamic arguments converted to</span>
        <span class="s5"># CPython objects</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">PYOBJECT</span><span class="s3">, [</span><span class="s1">GENERIC_POINTER</span><span class="s3">])</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">func_ptr</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">())</span>
        <span class="s1">py_tuple </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, [</span><span class="s1">dyn_args</span><span class="s3">])</span>

        <span class="s5"># We check at this stage if creating the Python tuple was successful</span>
        <span class="s5"># or not. Note the exception is raised by calling PyErr_SetString</span>
        <span class="s5"># directly as the current function is the CPython wrapper.</span>
        <span class="s1">failed </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">is_null</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">py_tuple</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">if_unlikely</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">failed</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">'Error creating Python tuple from runtime exception '</span>
                   <span class="s4">'arguments'</span><span class="s3">)</span>
            <span class="s1">pyapi</span><span class="s3">.</span><span class="s1">err_set_string</span><span class="s3">(</span><span class="s4">&quot;PyExc_RuntimeError&quot;</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">)</span>
            <span class="s5"># Return NULL to indicate an error was raised</span>
            <span class="s1">fnty </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">.</span><span class="s1">function_type</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">):</span>
                <span class="s5"># in some ufuncs, the return type is void</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">fnty</span><span class="s3">.</span><span class="s1">return_type</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret_void</span><span class="s3">()</span>

        <span class="s5"># merge static and dynamic variables</span>
        <span class="s1">excinfo </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">build_dynamic_excinfo_struct</span><span class="s3">(</span><span class="s1">static_exc_bytes</span><span class="s3">, </span><span class="s1">py_tuple</span><span class="s3">)</span>

        <span class="s5"># At this point, one can free the entire excinfo_ptr struct</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">enable_nrt</span><span class="s3">:</span>
            <span class="s5"># One can safely emit a free instruction as it is only executed</span>
            <span class="s5"># if its in a dynamic exception branch</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">free</span><span class="s3">(</span>
                <span class="s1">builder</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">voidptr</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">excinfo</span>

    <span class="s2">def </span><span class="s1">unpack_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s5"># Emit code that checks the alloc flag (last excinfo member)</span>
        <span class="s5"># if alloc_flag &gt; 0:</span>
        <span class="s5">#     (dynamic) unpack the exception to retrieve runtime information</span>
        <span class="s5">#               and merge with static info</span>
        <span class="s5"># else:</span>
        <span class="s5">#     (static) unserialize the exception using pythonapi.unserialize</span>

        <span class="s1">excinfo_ptr </span><span class="s3">= </span><span class="s1">status</span><span class="s3">.</span><span class="s1">excinfoptr</span>
        <span class="s1">alloc_flag </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">),</span>
                                           <span class="s1">ALLOC_FLAG_IDX</span><span class="s3">)</span>
        <span class="s1">gt </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;'</span><span class="s3">, </span><span class="s1">alloc_flag</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s6">0</span><span class="s3">))</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_else</span><span class="s3">(</span><span class="s1">gt</span><span class="s3">) </span><span class="s2">as </span><span class="s3">(</span><span class="s1">then</span><span class="s3">, </span><span class="s1">otherwise</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">then</span><span class="s3">:</span>
                <span class="s1">dyn_exc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">unpack_dynamic_exception</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">status</span><span class="s3">)</span>
                <span class="s1">bb_then </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">block</span>
            <span class="s2">with </span><span class="s1">otherwise</span><span class="s3">:</span>
                <span class="s1">static_exc </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">unserialize</span><span class="s3">(</span><span class="s1">excinfo_ptr</span><span class="s3">)</span>
                <span class="s1">bb_else </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">block</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">phi</span><span class="s3">(</span><span class="s1">static_exc</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
        <span class="s1">phi</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">dyn_exc</span><span class="s3">, </span><span class="s1">bb_then</span><span class="s3">)</span>
        <span class="s1">phi</span><span class="s3">.</span><span class="s1">add_incoming</span><span class="s3">(</span><span class="s1">static_exc</span><span class="s3">, </span><span class="s1">bb_else</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">phi</span>

    <span class="s2">def </span><span class="s1">emit_unwrap_dynamic_exception_fn</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">st_type</span><span class="s3">, </span><span class="s1">nb_types</span><span class="s3">):</span>
        <span class="s5"># Create a function that converts a list of runtime arguments to a tuple</span>
        <span class="s5"># of PyObjects. i.e.:</span>
        <span class="s5">#</span>
        <span class="s5">#   @njit('void(float, int64)')</span>
        <span class="s5">#   def func(a, b):</span>
        <span class="s5">#       raise ValueError(a, 123, b)</span>
        <span class="s5">#</span>
        <span class="s5"># The last three arguments of the exception info structure will hold:</span>
        <span class="s5">#   {___, ___, i8*, i8*, i32}</span>
        <span class="s5">#               ^ A ptr to a {f32, i64} struct</span>
        <span class="s5">#                    ^ function ptr that converts i8* -&gt; {f32, i64}* -&gt;</span>
        <span class="s5">#                      python tuple</span>
        <span class="s5">#                          ^ Number of dynamic arguments = 2</span>
        <span class="s5">#</span>

        <span class="s1">_hash </span><span class="s3">= </span><span class="s1">hashlib</span><span class="s3">.</span><span class="s1">sha1</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">st_type</span><span class="s3">).</span><span class="s1">encode</span><span class="s3">()).</span><span class="s1">hexdigest</span><span class="s3">()</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s4">f'__excinfo_unwrap_args</span><span class="s2">{</span><span class="s1">_hash</span><span class="s2">}</span><span class="s4">'</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">module</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">globals</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">GENERIC_POINTER</span><span class="s3">, [</span><span class="s1">GENERIC_POINTER</span><span class="s3">])</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">fnty</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s5"># prevent the function from being inlined</span>
        <span class="s1">fn</span><span class="s3">.</span><span class="s1">attributes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">'nounwind'</span><span class="s3">)</span>
        <span class="s1">fn</span><span class="s3">.</span><span class="s1">attributes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">'noinline'</span><span class="s3">)</span>

        <span class="s1">bb_entry </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">.</span><span class="s1">append_basic_block</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">builder </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">IRBuilder</span><span class="s3">(</span><span class="s1">bb_entry</span><span class="s3">)</span>
        <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>

        <span class="s5"># i8* -&gt; {native arg1 type, native arg2 type, ...}</span>
        <span class="s1">st_type_ptr </span><span class="s3">= </span><span class="s1">st_type</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">()</span>
        <span class="s1">st_ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">st_type_ptr</span><span class="s3">)</span>
        <span class="s5"># compile time values are stored as None</span>
        <span class="s1">nb_types </span><span class="s3">= [</span><span class="s1">typ </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">nb_types </span><span class="s2">if </span><span class="s1">typ </span><span class="s2">is not None</span><span class="s3">]</span>

        <span class="s5"># convert native values into CPython objects</span>
        <span class="s1">objs </span><span class="s3">= []</span>
        <span class="s1">env_manager </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_env_manager</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                                                   <span class="s1">return_pyobject</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">nb_types</span><span class="s3">):</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">st_ptr</span><span class="s3">), </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">from_native_value</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">env_manager</span><span class="s3">=</span><span class="s1">env_manager</span><span class="s3">)</span>

            <span class="s5"># If object cannot be boxed, raise an exception</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s3">== </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">type</span><span class="s3">):</span>
                <span class="s5"># When not supported, abort compilation</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">f'Cannot convert native </span><span class="s2">{</span><span class="s1">typ</span><span class="s2">} </span><span class="s4">to a Python object.'</span>
                <span class="s2">raise </span><span class="s1">errors</span><span class="s3">.</span><span class="s1">TypingError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

            <span class="s1">objs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

        <span class="s5"># at this point, a pointer to the list of runtime values can be freed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">free</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">,</span>
                              <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">))</span>

        <span class="s5"># Create a tuple of CPython objects</span>
        <span class="s1">tup </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">tuple_pack</span><span class="s3">(</span><span class="s1">objs</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret</span><span class="s3">(</span><span class="s1">tup</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">fn</span>

    <span class="s2">def </span><span class="s1">emit_wrap_args_insts</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">struct_type</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create an anonymous struct containing the given LLVM *values*. 
        &quot;&quot;&quot;</span>
        <span class="s1">st_size </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">py_ssize_t</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">struct_type</span><span class="s3">))</span>

        <span class="s1">st_ptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">allocate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">st_size</span><span class="s3">),</span>
            <span class="s1">struct_type</span><span class="s3">.</span><span class="s1">as_pointer</span><span class="s3">())</span>

        <span class="s5"># skip compile-time values</span>
        <span class="s1">exc_args </span><span class="s3">= [</span><span class="s1">arg </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">exc_args </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)]</span>

        <span class="s1">zero </span><span class="s3">= </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">exc_args</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">st_ptr</span><span class="s3">, [</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)]))</span>

        <span class="s2">return </span><span class="s1">st_ptr</span>

    <span class="s2">def </span><span class="s1">set_dynamic_user_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">nb_types</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                             <span class="s1">func_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the required bits to emit an exception with dynamic (runtime) 
        values 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">BaseException</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc should be an exception class, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc</span><span class="s3">,))</span>
        <span class="s2">if </span><span class="s1">exc_args </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;exc_args should be None or tuple, got %r&quot;</span>
                            <span class="s3">% (</span><span class="s1">exc_args</span><span class="s3">,))</span>

        <span class="s5"># An exception in Numba is defined as the excinfo_t struct defined</span>
        <span class="s5"># above. Some arguments in this struct are not used, depending on</span>
        <span class="s5"># which kind of exception is being raised. A static exception uses</span>
        <span class="s5"># only the first three members whilst a dynamic exception uses all</span>
        <span class="s5"># members:</span>
        <span class="s5">#</span>
        <span class="s5">#             static exc - last 2 args are NULL and 0</span>
        <span class="s5">#             vvv  vvv  vvv</span>
        <span class="s5"># excinfo_t: {i8*, i32, i8*, i8*, i32}</span>
        <span class="s5">#                       ^^^  ^^^  ^^^</span>
        <span class="s5">#                       dynamic exc only - first 2 args are used for</span>
        <span class="s5">#                                          static info</span>
        <span class="s5">#</span>
        <span class="s5"># Comment below details how the struct is used in the case of a dynamic</span>
        <span class="s5"># exception. For static exception, see CPUCallConv::set_static_user_exc</span>
        <span class="s5">#</span>
        <span class="s5"># {i8*, ___, ___, ___, ___}</span>
        <span class="s5">#   ^  serialized info about the exception (loc, kind, compile time</span>
        <span class="s5">#                                           args)</span>
        <span class="s5">#</span>
        <span class="s5"># {___, i32, ___, ___, ___}</span>
        <span class="s5">#        ^  len(serialized_exception)</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, i8*, ___, ___}</span>
        <span class="s5">#             ^  Store a list of native values in a dynamic exception.</span>
        <span class="s5">#                Or a hash(serialized_exception) in a static exc.</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, ___, i8*, ___}</span>
        <span class="s5">#                  ^  Pointer to function that convert native values</span>
        <span class="s5">#                     into PyObject*. NULL in the case of a static</span>
        <span class="s5">#                     exception</span>
        <span class="s5">#</span>
        <span class="s5"># {___, ___, ___, ___, i32}</span>
        <span class="s5">#                       ^  Number of dynamic args in the exception.</span>
        <span class="s5">#                          Default is &quot;0&quot;</span>
        <span class="s5">#</span>
        <span class="s5"># The following code will:</span>
        <span class="s5"># 1) Serialize compile time information and store them in the first</span>
        <span class="s5">#    two args {i8*, i32, ___, ___, ___} of excinfo_t</span>
        <span class="s5"># 2) Emit the required code for converting native values to CPython</span>
        <span class="s5">#    objects. Those objects are stored in the last three args</span>
        <span class="s5">#    {___, ___, i8*, i8*, i32} of excinfo_t</span>
        <span class="s5"># 3) Allocate a new excinfo_t struct</span>
        <span class="s5"># 4) Fill excinfo_t struct and copy the pointer to the excinfo** arg</span>

        <span class="s5"># serialize comp. time args</span>
        <span class="s1">pyapi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_python_api</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">build_excinfo_struct</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
        <span class="s1">excinfo_pp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">struct_gv </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">serialize_object</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">))</span>

        <span class="s5"># Create the struct for runtime args and emit a function to convert it</span>
        <span class="s5"># into a Python tuple</span>
        <span class="s1">struct_type </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">LiteralStructType</span><span class="s3">([</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">exc_args </span><span class="s2">if</span>
                                            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)])</span>
        <span class="s1">st_ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">emit_wrap_args_insts</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">pyapi</span><span class="s3">, </span><span class="s1">struct_type</span><span class="s3">,</span>
                                           <span class="s1">exc_args</span><span class="s3">)</span>
        <span class="s1">unwrap_fn </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">emit_unwrap_dynamic_exception_fn</span><span class="s3">(</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">struct_type</span><span class="s3">, </span><span class="s1">nb_types</span><span class="s3">)</span>

        <span class="s5"># allocate the excinfo struct</span>
        <span class="s1">exc_size </span><span class="s3">= </span><span class="s1">pyapi</span><span class="s3">.</span><span class="s1">py_ssize_t</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_abi_sizeof</span><span class="s3">(</span><span class="s1">excinfo_t</span><span class="s3">))</span>
        <span class="s1">excinfo_p </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">nrt</span><span class="s3">.</span><span class="s1">allocate</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc_size</span><span class="s3">),</span>
            <span class="s1">excinfo_ptr_t</span><span class="s3">)</span>

        <span class="s5"># fill the args</span>
        <span class="s1">zero </span><span class="s3">= </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">exc_fields </span><span class="s3">= (</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">struct_gv</span><span class="s3">, </span><span class="s1">PICKLE_BUF_IDX</span><span class="s3">),</span>
                      <span class="s1">builder</span><span class="s3">.</span><span class="s1">extract_value</span><span class="s3">(</span><span class="s1">struct_gv</span><span class="s3">, </span><span class="s1">PICKLE_BUFSZ_IDX</span><span class="s3">),</span>
                      <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">st_ptr</span><span class="s3">, </span><span class="s1">GENERIC_POINTER</span><span class="s3">),</span>
                      <span class="s1">builder</span><span class="s3">.</span><span class="s1">bitcast</span><span class="s3">(</span><span class="s1">unwrap_fn</span><span class="s3">, </span><span class="s1">GENERIC_POINTER</span><span class="s3">),</span>
                      <span class="s1">int32_t</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">struct_type</span><span class="s3">)))</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">exc_fields</span><span class="s3">):</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">gep</span><span class="s3">(</span><span class="s1">excinfo_p</span><span class="s3">, [</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">)]))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">excinfo_p</span><span class="s3">, </span><span class="s1">excinfo_pp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_dynamic_user_exc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">nb_types</span><span class="s3">,</span>
                                <span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Same as ::return_user_exc but for dynamic exceptions 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_dynamic_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">, </span><span class="s1">nb_types</span><span class="s3">,</span>
                                  <span class="s1">loc</span><span class="s3">=</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">=</span><span class="s1">func_name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">RETCODE_USEREXC</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_try_state</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">__eh_try_state</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span>
                <span class="s1">builder</span><span class="s3">, </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s4">'try_state'</span><span class="s3">, </span><span class="s1">zfill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">builder</span><span class="s3">.</span><span class="s1">__eh_try_state </span><span class="s3">= </span><span class="s1">ptr</span>
            <span class="s2">return </span><span class="s1">ptr</span>

    <span class="s2">def </span><span class="s1">check_try_status</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">try_state_ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_try_state</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">try_depth </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">try_state_ptr</span><span class="s3">)</span>
        <span class="s5"># try_depth &gt; 0</span>
        <span class="s1">in_try </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_unsigned</span><span class="s3">(</span><span class="s4">'&gt;'</span><span class="s3">, </span><span class="s1">try_depth</span><span class="s3">, </span><span class="s1">try_depth</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">0</span><span class="s3">))</span>

        <span class="s1">excinfoptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">excinfo </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfoptr</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">TryStatus</span><span class="s3">(</span><span class="s1">in_try</span><span class="s3">=</span><span class="s1">in_try</span><span class="s3">, </span><span class="s1">excinfo</span><span class="s3">=</span><span class="s1">excinfo</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">set_try_status</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">try_state_ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_try_state</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s5"># Increment try depth</span>
        <span class="s1">old </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">try_state_ptr</span><span class="s3">)</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">old</span><span class="s3">, </span><span class="s1">old</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s1">try_state_ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unset_try_status</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">):</span>
        <span class="s1">try_state_ptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_try_state</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s5"># Decrement try depth</span>
        <span class="s1">old </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">try_state_ptr</span><span class="s3">)</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">old</span><span class="s3">, </span><span class="s1">old</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s1">try_state_ptr</span><span class="s3">)</span>

        <span class="s5"># Needs to reset the exception state so that the exception handler</span>
        <span class="s5"># will run normally.</span>
        <span class="s1">excinfoptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">null </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">excinfoptr</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">pointee</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">null</span><span class="s3">, </span><span class="s1">excinfoptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">return_status_propagate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">):</span>
        <span class="s1">trystatus </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">check_try_status</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">)</span>
        <span class="s1">excptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">status</span><span class="s3">.</span><span class="s1">excinfoptr</span><span class="s3">, </span><span class="s1">excptr</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">if_then</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">trystatus</span><span class="s3">.</span><span class="s1">in_try</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">status</span><span class="s3">.</span><span class="s1">code</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_return_errcode_raw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">):</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">ret</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_return_status</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">excinfoptr</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a return *code* and *excinfoptr*, get a Status instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">norm </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_OK</span><span class="s3">)</span>
        <span class="s1">none </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_NONE</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_EXC</span><span class="s3">)</span>
        <span class="s1">is_stop_iteration </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_STOPIT</span><span class="s3">)</span>
        <span class="s1">ok </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">or_</span><span class="s3">(</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">none</span><span class="s3">)</span>
        <span class="s1">err </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">not_</span><span class="s3">(</span><span class="s1">ok</span><span class="s3">)</span>
        <span class="s1">is_user_exc </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">icmp_signed</span><span class="s3">(</span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">RETCODE_USEREXC</span><span class="s3">)</span>
        <span class="s1">excinfoptr </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">select</span><span class="s3">(</span><span class="s1">is_user_exc</span><span class="s3">, </span><span class="s1">excinfoptr</span><span class="s3">,</span>
                                    <span class="s1">ir</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span><span class="s1">excinfo_ptr_t</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">Undefined</span><span class="s3">))</span>

        <span class="s1">status </span><span class="s3">= </span><span class="s1">Status</span><span class="s3">(</span><span class="s1">code</span><span class="s3">=</span><span class="s1">code</span><span class="s3">,</span>
                        <span class="s1">is_ok</span><span class="s3">=</span><span class="s1">ok</span><span class="s3">,</span>
                        <span class="s1">is_error</span><span class="s3">=</span><span class="s1">err</span><span class="s3">,</span>
                        <span class="s1">is_python_exc</span><span class="s3">=</span><span class="s1">exc</span><span class="s3">,</span>
                        <span class="s1">is_none</span><span class="s3">=</span><span class="s1">none</span><span class="s3">,</span>
                        <span class="s1">is_user_exc</span><span class="s3">=</span><span class="s1">is_user_exc</span><span class="s3">,</span>
                        <span class="s1">is_stop_iteration</span><span class="s3">=</span><span class="s1">is_stop_iteration</span><span class="s3">,</span>
                        <span class="s1">excinfoptr</span><span class="s3">=</span><span class="s1">excinfoptr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">status</span>

    <span class="s2">def </span><span class="s1">get_function_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">restype</span><span class="s3">, </span><span class="s1">argtypes</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the implemented Function type for *restype* and *argtypes*. 
        &quot;&quot;&quot;</span>
        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">argtypes</span><span class="s3">)</span>
        <span class="s1">argtypes </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arginfo</span><span class="s3">.</span><span class="s1">argument_types</span><span class="s3">)</span>
        <span class="s1">resptr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_return_type</span><span class="s3">(</span><span class="s1">restype</span><span class="s3">)</span>
        <span class="s1">fnty </span><span class="s3">= </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">(</span><span class="s1">errcode_t</span><span class="s3">,</span>
                               <span class="s3">[</span><span class="s1">resptr</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">excinfo_ptr_t</span><span class="s3">)]</span>
                               <span class="s3">+ </span><span class="s1">argtypes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">fnty</span>

    <span class="s2">def </span><span class="s1">decorate_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">fe_argtypes</span><span class="s3">, </span><span class="s1">noalias</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set names of function arguments, and add useful attributes to them. 
        &quot;&quot;&quot;</span>
        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">fe_argtypes</span><span class="s3">)</span>
        <span class="s1">arginfo</span><span class="s3">.</span><span class="s1">assign_names</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">),</span>
                             <span class="s3">[</span><span class="s4">'arg.' </span><span class="s3">+ </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">])</span>
        <span class="s1">retarg </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_argument</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
        <span class="s1">retarg</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s4">&quot;retptr&quot;</span>
        <span class="s1">retarg</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;nocapture&quot;</span><span class="s3">)</span>
        <span class="s1">retarg</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;noalias&quot;</span><span class="s3">)</span>
        <span class="s1">excarg </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
        <span class="s1">excarg</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s4">&quot;excinfo&quot;</span>
        <span class="s1">excarg</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;nocapture&quot;</span><span class="s3">)</span>
        <span class="s1">excarg</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;noalias&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">noalias</span><span class="s3">:</span>
            <span class="s1">args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">):</span>
                    <span class="s1">a</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;nocapture&quot;</span><span class="s3">)</span>
                    <span class="s1">a</span><span class="s3">.</span><span class="s1">add_attribute</span><span class="s3">(</span><span class="s4">&quot;noalias&quot;</span><span class="s3">)</span>

        <span class="s5"># Add metadata to mark functions that may need NRT</span>
        <span class="s5"># thus disabling aggressive refct pruning in removerefctpass.py</span>
        <span class="s2">def </span><span class="s1">type_may_always_need_nrt</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">):</span>
            <span class="s5"># Returns True if it's a non-Array type that is contains MemInfo</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                <span class="s1">dmm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">data_model_manager</span>
                <span class="s2">if </span><span class="s1">dmm</span><span class="s3">[</span><span class="s1">ty</span><span class="s3">].</span><span class="s1">contains_nrt_meminfo</span><span class="s3">():</span>
                    <span class="s2">return True</span>
            <span class="s2">return False</span>

        <span class="s1">args_may_always_need_nrt </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span>
            <span class="s1">map</span><span class="s3">(</span><span class="s1">type_may_always_need_nrt</span><span class="s3">, </span><span class="s1">fe_argtypes</span><span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">args_may_always_need_nrt</span><span class="s3">:</span>
            <span class="s1">nmd </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">add_named_metadata</span><span class="s3">(</span>
                <span class="s4">'numba_args_may_always_need_nrt'</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">nmd</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">add_metadata</span><span class="s3">([</span><span class="s1">fn</span><span class="s3">]))</span>

    <span class="s2">def </span><span class="s1">get_arguments</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the Python-level arguments of LLVM *func*. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">2</span><span class="s3">:]</span>

    <span class="s2">def </span><span class="s1">_get_return_argument</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_excinfo_argument</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">call_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">argtys</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                      <span class="s1">attrs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call the Numba-compiled *callee*. 
        Parameters: 
        ----------- 
        attrs: LLVM style string or iterable of individual attributes, default 
               is None which specifies no attributes. Examples: 
               LLVM style string: &quot;noinline fast&quot; 
               Equivalent iterable: (&quot;noinline&quot;, &quot;fast&quot;) 
        &quot;&quot;&quot;</span>
        <span class="s5"># XXX better fix for callees that are not function values</span>
        <span class="s5">#     (pointers to function; thus have no `.args` attribute)</span>
        <span class="s1">retty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_argument</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">function_type</span><span class="s3">).</span><span class="s1">pointee</span>

        <span class="s1">retvaltmp </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">retty</span><span class="s3">)</span>
        <span class="s5"># initialize return value to zeros</span>
        <span class="s1">builder</span><span class="s3">.</span><span class="s1">store</span><span class="s3">(</span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">get_null_value</span><span class="s3">(</span><span class="s1">retty</span><span class="s3">), </span><span class="s1">retvaltmp</span><span class="s3">)</span>

        <span class="s1">excinfoptr </span><span class="s3">= </span><span class="s1">cgutils</span><span class="s3">.</span><span class="s1">alloca_once</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">excinfo_t</span><span class="s3">),</span>
                                         <span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;excinfo&quot;</span><span class="s3">)</span>

        <span class="s1">arginfo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_arg_packer</span><span class="s3">(</span><span class="s1">argtys</span><span class="s3">)</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">arginfo</span><span class="s3">.</span><span class="s1">as_arguments</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))</span>
        <span class="s1">realargs </span><span class="s3">= [</span><span class="s1">retvaltmp</span><span class="s3">, </span><span class="s1">excinfoptr</span><span class="s3">] + </span><span class="s1">args</span>
        <span class="s5"># deal with attrs, it's fine to specify a load in a string like</span>
        <span class="s5"># &quot;noinline fast&quot; as per LLVM or equally as an iterable of individual</span>
        <span class="s5"># attributes.</span>
        <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">_attrs </span><span class="s3">= ()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">_attrs </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;attrs must be an iterable of strings or None&quot;</span><span class="s3">)</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">realargs</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=</span><span class="s1">_attrs</span><span class="s3">)</span>
        <span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_return_status</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">code</span><span class="s3">,</span>
                                         <span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">excinfoptr</span><span class="s3">))</span>
        <span class="s1">retval </span><span class="s3">= </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">retvaltmp</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_returned_value</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">resty</span><span class="s3">, </span><span class="s1">retval</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">status</span><span class="s3">, </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">ErrorModel</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">call_conv</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">call_conv </span><span class="s3">= </span><span class="s1">call_conv</span>

    <span class="s2">def </span><span class="s1">fp_zero_division</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">raise_on_fp_zero_division</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">.</span><span class="s1">return_user_exc</span><span class="s3">(</span><span class="s1">builder</span><span class="s3">, </span><span class="s1">ZeroDivisionError</span><span class="s3">, </span><span class="s1">exc_args</span><span class="s3">,</span>
                                           <span class="s1">loc</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">PythonErrorModel</span><span class="s3">(</span><span class="s1">ErrorModel</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The Python error model.  Any invalid FP input raises an exception. 
    &quot;&quot;&quot;</span>
    <span class="s1">raise_on_fp_zero_division </span><span class="s3">= </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">NumpyErrorModel</span><span class="s3">(</span><span class="s1">ErrorModel</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    In the Numpy error model, floating-point errors don't raise an 
    exception.  The FPU exception state is inspected by Numpy at the 
    end of a ufunc's execution and a warning is raised if appropriate. 
 
    Note there's no easy way to set the FPU exception state from LLVM. 
    Instructions known to set an FP exception can be optimized away: 
        https://llvm.org/bugs/show_bug.cgi?id=6050 
        http://lists.llvm.org/pipermail/llvm-dev/2014-September/076918.html 
        http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140929/237997.html 
    &quot;&quot;&quot;</span>
    <span class="s1">raise_on_fp_zero_division </span><span class="s3">= </span><span class="s2">False</span>


<span class="s1">error_models </span><span class="s3">= {</span>
    <span class="s4">'python'</span><span class="s3">: </span><span class="s1">PythonErrorModel</span><span class="s3">,</span>
    <span class="s4">'numpy'</span><span class="s3">: </span><span class="s1">NumpyErrorModel</span><span class="s3">,</span>
<span class="s3">}</span>


<span class="s2">def </span><span class="s1">create_error_model</span><span class="s3">(</span><span class="s1">model_name</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an error model instance for the given target context. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">error_models</span><span class="s3">[</span><span class="s1">model_name</span><span class="s3">](</span><span class="s1">context</span><span class="s3">.</span><span class="s1">call_conv</span><span class="s3">)</span>
</pre>
</body>
</html>