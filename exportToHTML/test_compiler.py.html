<html>
<head>
<title>test_compiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_compiler.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">sqrt</span>
<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">cuda</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">, </span><span class="s1">int16</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int64</span><span class="s2">, </span><span class="s1">uint32</span><span class="s2">, </span><span class="s1">void</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cuda </span><span class="s0">import </span><span class="s2">(</span><span class="s1">compile</span><span class="s2">, </span><span class="s1">compile_for_current_device</span><span class="s2">, </span><span class="s1">compile_ptx</span><span class="s2">,</span>
                        <span class="s1">compile_ptx_for_current_device</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">cudadrv </span><span class="s0">import </span><span class="s1">runtime</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">skip_on_cudasim</span><span class="s2">, </span><span class="s1">unittest</span><span class="s2">, </span><span class="s1">CUDATestCase</span>


<span class="s3"># A test function at the module scope to ensure we get the name right for the C</span>
<span class="s3"># ABI whether a function is at module or local scope.</span>
<span class="s0">def </span><span class="s1">f_module</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>


<span class="s2">@</span><span class="s1">skip_on_cudasim</span><span class="s2">(</span><span class="s4">'Compilation unsupported in the simulator'</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TestCompile</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_global_kernel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">grid</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">r</span><span class="s2">):</span>
                <span class="s1">r</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">x</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

        <span class="s1">args </span><span class="s2">= (</span><span class="s1">float32</span><span class="s2">[:], </span><span class="s1">float32</span><span class="s2">[:], </span><span class="s1">float32</span><span class="s2">[:])</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

        <span class="s3"># Kernels should not have a func_retval parameter</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIn</span><span class="s2">(</span><span class="s4">'func_retval'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># .visible .func is used to denote a device function</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIn</span><span class="s2">(</span><span class="s4">'.visible .func'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># .visible .entry would denote the presence of a global function</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'.visible .entry'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># Return type for kernels should always be void</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">void</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_device_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">add</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>

        <span class="s1">args </span><span class="s2">= (</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">add</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># Device functions take a func_retval parameter for storing the</span>
        <span class="s3"># returned value in by reference</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'func_retval'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># .visible .func is used to denote a device function</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'.visible .func'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># .visible .entry would denote the presence of a global function</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIn</span><span class="s2">(</span><span class="s4">'.visible .entry'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s3"># Inferred return type as expected?</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">)</span>

        <span class="s3"># Check that function's output matches signature</span>
        <span class="s1">sig_int32 </span><span class="s2">= </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">)</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">add</span><span class="s2">, </span><span class="s1">sig_int32</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">)</span>

        <span class="s1">sig_int16 </span><span class="s2">= </span><span class="s1">int16</span><span class="s2">(</span><span class="s1">int16</span><span class="s2">, </span><span class="s1">int16</span><span class="s2">)</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">add</span><span class="s2">, </span><span class="s1">sig_int16</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">int16</span><span class="s2">)</span>
        <span class="s3"># Using string as signature</span>
        <span class="s1">sig_string </span><span class="s2">= </span><span class="s4">&quot;uint32(uint32, uint32)&quot;</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">add</span><span class="s2">, </span><span class="s1">sig_string</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">uint32</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_fastmath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">d</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">sqrt</span><span class="s2">((</span><span class="s1">x </span><span class="s2">* </span><span class="s1">y </span><span class="s2">+ </span><span class="s1">z</span><span class="s2">) / </span><span class="s1">d</span><span class="s2">)</span>

        <span class="s1">args </span><span class="s2">= (</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># Without fastmath, fma contraction is enabled by default, but ftz and</span>
        <span class="s3"># approximate div / sqrt is not.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'fma.rn.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'div.rn.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'sqrt.rn.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">fastmath</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># With fastmath, ftz and approximate div / sqrt are enabled</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'fma.rn.ftz.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'div.approx.ftz.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s4">'sqrt.approx.ftz.f32'</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_debug_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">):</span>
        <span class="s3"># A debug_info section should exist in the PTX. Whitespace varies</span>
        <span class="s3"># between CUDA toolkit versions.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">'</span><span class="s0">\\</span><span class="s4">.section</span><span class="s0">\\</span><span class="s4">s+</span><span class="s0">\\</span><span class="s4">.debug_info'</span><span class="s2">)</span>
        <span class="s3"># A .file directive should be produced and include the name of the</span>
        <span class="s3"># source. The path and whitespace may vary, so we accept anything</span>
        <span class="s3"># ending in the filename of this module.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">'</span><span class="s0">\\</span><span class="s4">.file.*test_compiler.py&quot;'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_device_function_with_debug</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># See Issue #6719 - this ensures that compilation with debug succeeds</span>
        <span class="s3"># with CUDA 11.2 / NVVM 7.0 onwards. Previously it failed because NVVM</span>
        <span class="s3"># IR version metadata was not added when compiling device functions,</span>
        <span class="s3"># and NVVM assumed DBG version 1.0 if not specified, which is</span>
        <span class="s3"># incompatible with the 3.0 IR we use. This was specified only for</span>
        <span class="s3"># kernels.</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s0">pass</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_debug_info</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_kernel_with_debug</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># Inspired by (but not originally affected by) Issue #6719</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s0">pass</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (), </span><span class="s1">debug</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_debug_info</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">check_line_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">):</span>
        <span class="s3"># A .file directive should be produced and include the name of the</span>
        <span class="s3"># source. The path and whitespace may vary, so we accept anything</span>
        <span class="s3"># ending in the filename of this module.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">'</span><span class="s0">\\</span><span class="s4">.file.*test_compiler.py&quot;'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_device_function_with_line_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s0">pass</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">lineinfo</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_line_info</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_kernel_with_line_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
            <span class="s0">pass</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (), </span><span class="s1">lineinfo</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_line_info</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_non_void_return_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaisesRegex</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s4">'must have void return type'</span><span class="s2">):</span>
            <span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (</span><span class="s1">uint32</span><span class="s2">[::</span><span class="s5">1</span><span class="s2">], </span><span class="s1">uint32</span><span class="s2">[::</span><span class="s5">1</span><span class="s2">]))</span>

    <span class="s0">def </span><span class="s1">test_c_abi_disallowed_for_kernel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaisesRegex</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">,</span>
                                    <span class="s4">&quot;The C ABI is not supported for kernels&quot;</span><span class="s2">):</span>
            <span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;c&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_unsupported_abi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>

        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaisesRegex</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">,</span>
                                    <span class="s4">&quot;Unsupported ABI: fastcall&quot;</span><span class="s2">):</span>
            <span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, (</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;fastcall&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_c_abi_device_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;c&quot;</span><span class="s2">)</span>
        <span class="s3"># There should be no more than two parameters</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertNotIn</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">&quot;param_2&quot;</span><span class="s2">)</span>

        <span class="s3"># The function name should match the Python function name (not the</span>
        <span class="s3"># qualname, which includes additional info), and its return value</span>
        <span class="s3"># should be 32 bits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">r&quot;\.visible\s+\.func\s+\(\.param\s+\.b32\s+&quot;</span>
                              <span class="s4">r&quot;func_retval0\)\s+f\(&quot;</span><span class="s2">)</span>

        <span class="s3"># If we compile for 64-bit integers, the return type should be 64 bits</span>
        <span class="s3"># wide</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">int64</span><span class="s2">(</span><span class="s1">int64</span><span class="s2">, </span><span class="s1">int64</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;c&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">r&quot;\.visible\s+\.func\s+\(\.param\s+\.b64&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_c_abi_device_function_module_scope</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f_module</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                 <span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;c&quot;</span><span class="s2">)</span>

        <span class="s3"># The function name should match the Python function name, and its</span>
        <span class="s3"># return value should be 32 bits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">r&quot;\.visible\s+\.func\s+\(\.param\s+\.b32\s+&quot;</span>
                              <span class="s4">r&quot;func_retval0\)\s+f_module\(&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_c_abi_with_abi_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">abi_info </span><span class="s2">= {</span><span class="s4">'abi_name'</span><span class="s2">: </span><span class="s4">'_Z4funcii'</span><span class="s2">}</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">f_module</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                 <span class="s1">abi</span><span class="s2">=</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s1">abi_info</span><span class="s2">=</span><span class="s1">abi_info</span><span class="s2">)</span>

        <span class="s3"># The function name should match the one given in the ABI info, and its</span>
        <span class="s3"># return value should be 32 bits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">r&quot;\.visible\s+\.func\s+\(\.param\s+\.b32\s+&quot;</span>
                              <span class="s4">r&quot;func_retval0\)\s+_Z4funcii\(&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compile_defaults_to_c_abi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">f_module</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># The function name should match the Python function name, and its</span>
        <span class="s3"># return value should be 32 bits</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertRegex</span><span class="s2">(</span><span class="s1">ptx</span><span class="s2">, </span><span class="s4">r&quot;\.visible\s+\.func\s+\(\.param\s+\.b32\s+&quot;</span>
                              <span class="s4">r&quot;func_retval0\)\s+f_module\(&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compile_to_ltoir</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">runtime</span><span class="s2">.</span><span class="s1">get_version</span><span class="s2">() &lt; (</span><span class="s5">11</span><span class="s2">, </span><span class="s5">5</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">skipTest</span><span class="s2">(</span><span class="s4">&quot;-gen-lto unavailable in this toolkit version&quot;</span><span class="s2">)</span>

        <span class="s1">ltoir</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">f_module</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                               <span class="s1">output</span><span class="s2">=</span><span class="s4">&quot;ltoir&quot;</span><span class="s2">)</span>

        <span class="s3"># There are no tools to interpret the LTOIR output, but we can check</span>
        <span class="s3"># that we appear to have obtained an LTOIR file. This magic number is</span>
        <span class="s3"># not documented, but is expected to remain consistent.</span>
        <span class="s1">LTOIR_MAGIC </span><span class="s2">= </span><span class="s5">0x7F4E43ED</span>
        <span class="s1">header </span><span class="s2">= </span><span class="s1">int</span><span class="s2">.</span><span class="s1">from_bytes</span><span class="s2">(</span><span class="s1">ltoir</span><span class="s2">[:</span><span class="s5">4</span><span class="s2">], </span><span class="s1">byteorder</span><span class="s2">=</span><span class="s4">'little'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">header</span><span class="s2">, </span><span class="s1">LTOIR_MAGIC</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">resty</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compile_to_invalid_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">illegal_output </span><span class="s2">= </span><span class="s4">&quot;illegal&quot;</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">f&quot;Unsupported output type: </span><span class="s0">{</span><span class="s1">illegal_output</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">assertRaisesRegex</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">compile</span><span class="s2">(</span><span class="s1">f_module</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">(</span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">), </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                    <span class="s1">output</span><span class="s2">=</span><span class="s1">illegal_output</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">skip_on_cudasim</span><span class="s2">(</span><span class="s4">'Compilation unsupported in the simulator'</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TestCompileForCurrentDevice</span><span class="s2">(</span><span class="s1">CUDATestCase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_check_ptx_for_current_device</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">compile_function</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">add</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">y</span>

        <span class="s1">args </span><span class="s2">= (</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">float32</span><span class="s2">)</span>
        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_function</span><span class="s2">(</span><span class="s1">add</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># Check we target the current device's compute capability, or the</span>
        <span class="s3"># closest compute capability supported by the current toolkit.</span>
        <span class="s1">device_cc </span><span class="s2">= </span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">get_current_device</span><span class="s2">().</span><span class="s1">compute_capability</span>
        <span class="s1">cc </span><span class="s2">= </span><span class="s1">cuda</span><span class="s2">.</span><span class="s1">cudadrv</span><span class="s2">.</span><span class="s1">nvvm</span><span class="s2">.</span><span class="s1">find_closest_arch</span><span class="s2">(</span><span class="s1">device_cc</span><span class="s2">)</span>
        <span class="s1">target </span><span class="s2">= </span><span class="s4">f'.target sm_</span><span class="s0">{</span><span class="s1">cc</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s0">}{</span><span class="s1">cc</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s4">'</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertIn</span><span class="s2">(</span><span class="s1">target</span><span class="s2">, </span><span class="s1">ptx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compile_ptx_for_current_device</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ptx_for_current_device</span><span class="s2">(</span><span class="s1">compile_ptx_for_current_device</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compile_for_current_device</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_ptx_for_current_device</span><span class="s2">(</span><span class="s1">compile_for_current_device</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">skip_on_cudasim</span><span class="s2">(</span><span class="s4">'Compilation unsupported in the simulator'</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">TestCompileOnlyTests</span><span class="s2">(</span><span class="s1">unittest</span><span class="s2">.</span><span class="s1">TestCase</span><span class="s2">):</span>
    <span class="s6">'''For tests where we can only check correctness by examining the compiler 
    output rather than observing the effects of execution.'''</span>

    <span class="s0">def </span><span class="s1">test_nanosleep</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">use_nanosleep</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s3"># Sleep for a constant time</span>
            <span class="s1">cuda</span><span class="s2">.</span><span class="s1">nanosleep</span><span class="s2">(</span><span class="s5">32</span><span class="s2">)</span>
            <span class="s3"># Sleep for a variable time</span>
            <span class="s1">cuda</span><span class="s2">.</span><span class="s1">nanosleep</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s1">ptx</span><span class="s2">, </span><span class="s1">resty </span><span class="s2">= </span><span class="s1">compile_ptx</span><span class="s2">(</span><span class="s1">use_nanosleep</span><span class="s2">, (</span><span class="s1">uint32</span><span class="s2">,), </span><span class="s1">cc</span><span class="s2">=(</span><span class="s5">7</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>

        <span class="s1">nanosleep_count </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">ptx</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s4">'nanosleep.u32' </span><span class="s0">in </span><span class="s1">line</span><span class="s2">:</span>
                <span class="s1">nanosleep_count </span><span class="s2">+= </span><span class="s5">1</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s5">2</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assertEqual</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">, </span><span class="s1">nanosleep_count</span><span class="s2">,</span>
                         <span class="s2">(</span><span class="s4">f'Got </span><span class="s0">{</span><span class="s1">nanosleep_count</span><span class="s0">} </span><span class="s4">nanosleep instructions, '</span>
                          <span class="s4">f'expected </span><span class="s0">{</span><span class="s1">expected</span><span class="s0">}</span><span class="s4">'</span><span class="s2">))</span>


<span class="s0">if </span><span class="s1">__name__ </span><span class="s2">== </span><span class="s4">'__main__'</span><span class="s2">:</span>
    <span class="s1">unittest</span><span class="s2">.</span><span class="s1">main</span><span class="s2">()</span>
</pre>
</body>
</html>