<html>
<head>
<title>base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">permutations</span><span class="s2">, </span><span class="s1">takewhile</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">cached_property</span>

<span class="s0">from </span><span class="s1">llvmlite </span><span class="s0">import </span><span class="s1">ir </span><span class="s0">as </span><span class="s1">llvmir</span>
<span class="s0">from </span><span class="s1">llvmlite</span><span class="s2">.</span><span class="s1">ir </span><span class="s0">import </span><span class="s1">Constant</span>
<span class="s0">import </span><span class="s1">llvmlite</span><span class="s2">.</span><span class="s1">binding </span><span class="s0">as </span><span class="s1">ll</span>

<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">types</span><span class="s2">, </span><span class="s1">utils</span><span class="s2">, </span><span class="s1">datamodel</span><span class="s2">, </span><span class="s1">debuginfo</span><span class="s2">, </span><span class="s1">funcdesc</span><span class="s2">, </span><span class="s1">config</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">, </span><span class="s1">imputils</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">event</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">targetconfig</span>
<span class="s0">from </span><span class="s1">numba </span><span class="s0">import </span><span class="s1">_dynfunc</span><span class="s2">, </span><span class="s1">_helperlib</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">compiler_lock </span><span class="s0">import </span><span class="s1">global_compiler_lock</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">pythonapi </span><span class="s0">import </span><span class="s1">PythonAPI</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">imputils </span><span class="s0">import </span><span class="s2">(</span><span class="s1">user_function</span><span class="s2">, </span><span class="s1">user_generator</span><span class="s2">,</span>
                       <span class="s1">builtin_registry</span><span class="s2">, </span><span class="s1">impl_ret_borrowed</span><span class="s2">,</span>
                       <span class="s1">RegistryLoader</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">cpython </span><span class="s0">import </span><span class="s1">builtins</span>

<span class="s1">GENERIC_POINTER </span><span class="s2">= </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">PointerType</span><span class="s2">(</span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s3">8</span><span class="s2">))</span>
<span class="s1">PYOBJECT </span><span class="s2">= </span><span class="s1">GENERIC_POINTER</span>
<span class="s1">void_ptr </span><span class="s2">= </span><span class="s1">GENERIC_POINTER</span>


<span class="s0">class </span><span class="s1">OverloadSelector</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    An object matching an actual signature against a registry of formal 
    signatures and choosing the best candidate, if any. 
 
    In the current implementation: 
    - a &quot;signature&quot; is a tuple of type classes or type instances 
    - the &quot;best candidate&quot; is the most specific match 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># A list of (formal args tuple, value)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">versions </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache </span><span class="s2">= {}</span>

    <span class="s0">def </span><span class="s1">find</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">out </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_find</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">[</span><span class="s1">sig</span><span class="s2">] = </span><span class="s1">out</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_find</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s1">candidates </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_select_compatible</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">candidates</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">candidates</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_best_signature</span><span class="s2">(</span><span class="s1">candidates</span><span class="s2">)]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">(</span><span class="s6">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s6">, </span><span class="s0">{</span><span class="s1">sig</span><span class="s0">}</span><span class="s6">'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_select_compatible</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Select all compatible signatures and their implementation. 
        &quot;&quot;&quot;</span>
        <span class="s1">out </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">ver_sig</span><span class="s2">, </span><span class="s1">impl </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">versions</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_match_arglist</span><span class="s2">(</span><span class="s1">ver_sig</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
                <span class="s1">out</span><span class="s2">[</span><span class="s1">ver_sig</span><span class="s2">] = </span><span class="s1">impl</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_best_signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">candidates</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns the best signature out of the candidates 
        &quot;&quot;&quot;</span>
        <span class="s1">ordered</span><span class="s2">, </span><span class="s1">genericity </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sort_signatures</span><span class="s2">(</span><span class="s1">candidates</span><span class="s2">)</span>
        <span class="s5"># check for ambiguous signatures</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ordered</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">firstscore </span><span class="s2">= </span><span class="s1">genericity</span><span class="s2">[</span><span class="s1">ordered</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]]</span>
            <span class="s1">same </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">takewhile</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">genericity</span><span class="s2">[</span><span class="s1">x</span><span class="s2">] == </span><span class="s1">firstscore</span><span class="s2">,</span>
                                  <span class="s1">ordered</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">same</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= [</span><span class="s6">&quot;{n} ambiguous signatures&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">n</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">same</span><span class="s2">))]</span>
                <span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">same</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">+= [</span><span class="s6">&quot;{0} =&gt; {1}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">, </span><span class="s1">candidates</span><span class="s2">[</span><span class="s1">sig</span><span class="s2">])]</span>
                <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaTypeError</span><span class="s2">(</span><span class="s6">'</span><span class="s0">\n</span><span class="s6">'</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">ordered</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_sort_signatures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">candidates</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sort signatures in ascending level of genericity. 
 
        Returns a 2-tuple: 
 
            * ordered list of signatures 
            * dictionary containing genericity scores 
        &quot;&quot;&quot;</span>
        <span class="s5"># score by genericity</span>
        <span class="s1">genericity </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">int</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">this</span><span class="s2">, </span><span class="s1">other </span><span class="s0">in </span><span class="s1">permutations</span><span class="s2">(</span><span class="s1">candidates</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">(), </span><span class="s1">r</span><span class="s2">=</span><span class="s3">2</span><span class="s2">):</span>
            <span class="s1">matched </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_match_arglist</span><span class="s2">(</span><span class="s1">formal_args</span><span class="s2">=</span><span class="s1">this</span><span class="s2">, </span><span class="s1">actual_args</span><span class="s2">=</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">matched</span><span class="s2">:</span>
                <span class="s5"># genericity score +1 for every another compatible signature</span>
                <span class="s1">genericity</span><span class="s2">[</span><span class="s1">this</span><span class="s2">] += </span><span class="s3">1</span>
        <span class="s5"># order candidates in ascending level of genericity</span>
        <span class="s1">ordered </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">candidates</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">genericity</span><span class="s2">[</span><span class="s1">x</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">ordered</span><span class="s2">, </span><span class="s1">genericity</span>

    <span class="s0">def </span><span class="s1">_match_arglist</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">formal_args</span><span class="s2">, </span><span class="s1">actual_args</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns True if the signature is &quot;matching&quot;. 
        A formal signature is &quot;matching&quot; if the actual signature matches exactly 
        or if the formal signature is a compatible generic signature. 
        &quot;&quot;&quot;</span>
        <span class="s5"># normalize VarArg</span>
        <span class="s0">if </span><span class="s1">formal_args </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">formal_args</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">VarArg</span><span class="s2">):</span>
            <span class="s1">ndiff </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">actual_args</span><span class="s2">) - </span><span class="s1">len</span><span class="s2">(</span><span class="s1">formal_args</span><span class="s2">) + </span><span class="s3">1</span>
            <span class="s1">formal_args </span><span class="s2">= </span><span class="s1">formal_args</span><span class="s2">[:-</span><span class="s3">1</span><span class="s2">] + (</span><span class="s1">formal_args</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">,) * </span><span class="s1">ndiff</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">formal_args</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">actual_args</span><span class="s2">):</span>
            <span class="s0">return False</span>

        <span class="s0">for </span><span class="s1">formal</span><span class="s2">, </span><span class="s1">actual </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">formal_args</span><span class="s2">, </span><span class="s1">actual_args</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_match</span><span class="s2">(</span><span class="s1">formal</span><span class="s2">, </span><span class="s1">actual</span><span class="s2">):</span>
                <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_match</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">formal</span><span class="s2">, </span><span class="s1">actual</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">formal </span><span class="s2">== </span><span class="s1">actual</span><span class="s2">:</span>
            <span class="s5"># formal argument matches actual arguments</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">== </span><span class="s1">formal</span><span class="s2">:</span>
            <span class="s5"># formal argument is any</span>
            <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">formal</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">formal</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">formal</span><span class="s2">):</span>
                <span class="s5"># formal arg is a type class and actual arg is a subclass</span>
                <span class="s0">return True</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">formal</span><span class="s2">):</span>
                <span class="s5"># formal arg is a type class of which actual arg is an instance</span>
                <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add a formal signature and its associated value. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">), (</span><span class="s1">value</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">versions</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">sig</span><span class="s2">, </span><span class="s1">value</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">runonce</span>
<span class="s0">def </span><span class="s1">_load_global_helpers</span><span class="s2">():</span>
    <span class="s4">&quot;&quot;&quot; 
    Execute once to install special symbols into the LLVM symbol table. 
    &quot;&quot;&quot;</span>
    <span class="s5"># This is Py_None's real C name</span>
    <span class="s1">ll</span><span class="s2">.</span><span class="s1">add_symbol</span><span class="s2">(</span><span class="s6">&quot;_Py_NoneStruct&quot;</span><span class="s2">, </span><span class="s1">id</span><span class="s2">(</span><span class="s0">None</span><span class="s2">))</span>

    <span class="s5"># Add Numba C helper functions</span>
    <span class="s0">for </span><span class="s1">c_helpers </span><span class="s0">in </span><span class="s2">(</span><span class="s1">_helperlib</span><span class="s2">.</span><span class="s1">c_helpers</span><span class="s2">, </span><span class="s1">_dynfunc</span><span class="s2">.</span><span class="s1">c_helpers</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">py_name</span><span class="s2">, </span><span class="s1">c_address </span><span class="s0">in </span><span class="s1">c_helpers</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">c_name </span><span class="s2">= </span><span class="s6">&quot;numba_&quot; </span><span class="s2">+ </span><span class="s1">py_name</span>
            <span class="s1">ll</span><span class="s2">.</span><span class="s1">add_symbol</span><span class="s2">(</span><span class="s1">c_name</span><span class="s2">, </span><span class="s1">c_address</span><span class="s2">)</span>

    <span class="s5"># Add all built-in exception classes</span>
    <span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">builtins</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">type</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">BaseException</span><span class="s2">):</span>
            <span class="s1">ll</span><span class="s2">.</span><span class="s1">add_symbol</span><span class="s2">(</span><span class="s6">&quot;PyExc_%s&quot; </span><span class="s2">% (</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">), </span><span class="s1">id</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">BaseContext</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
 
    Notes on Structure 
    ------------------ 
 
    Most objects are lowered as plain-old-data structure in the generated 
    llvm.  They are passed around by reference (a pointer to the structure). 
    Only POD structure can live across function boundaries by copying the 
    data. 
    &quot;&quot;&quot;</span>
    <span class="s5"># True if the target requires strict alignment</span>
    <span class="s5"># Causes exception to be raised if the record members are not aligned.</span>
    <span class="s1">strict_alignment </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># Force powi implementation as math.pow call</span>
    <span class="s1">implement_powi_as_math_call </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">implement_pow_as_math_call </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># Emit Debug info</span>
    <span class="s1">enable_debuginfo </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">DIBuilder </span><span class="s2">= </span><span class="s1">debuginfo</span><span class="s2">.</span><span class="s1">DIBuilder</span>

    <span class="s5"># Bound checking</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">enable_boundscheck</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">config</span><span class="s2">.</span><span class="s1">BOUNDSCHECK </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">config</span><span class="s2">.</span><span class="s1">BOUNDSCHECK</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_boundscheck</span>

    <span class="s2">@</span><span class="s1">enable_boundscheck</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s0">def </span><span class="s1">enable_boundscheck</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_boundscheck </span><span class="s2">= </span><span class="s1">value</span>

    <span class="s5"># NRT</span>
    <span class="s1">enable_nrt </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># Auto parallelization</span>
    <span class="s1">auto_parallel </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># PYCC</span>
    <span class="s1">aot_mode </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># Error model for various operations (only FP exceptions currently)</span>
    <span class="s1">error_model </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s5"># Whether dynamic globals (CPU runtime addresses) is allowed</span>
    <span class="s1">allow_dynamic_globals </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># Fast math flags</span>
    <span class="s1">fastmath </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s5"># python execution environment</span>
    <span class="s1">environment </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s5"># the function descriptor</span>
    <span class="s1">fndesc </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typing_context</span><span class="s2">, </span><span class="s1">target</span><span class="s2">):</span>
        <span class="s1">_load_global_helpers</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">address_size </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">MACHINE_BITS</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context </span><span class="s2">= </span><span class="s1">typing_context</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">target_extension </span><span class="s0">import </span><span class="s1">target_registry</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_name </span><span class="s2">= </span><span class="s1">target</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target </span><span class="s2">= </span><span class="s1">target_registry</span><span class="s2">[</span><span class="s1">target</span><span class="s2">]</span>

        <span class="s5"># A mapping of installed registries to their loaders</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_registries </span><span class="s2">= {}</span>
        <span class="s5"># Declarations loaded from registries and other sources</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_defns </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">OverloadSelector</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_getattrs </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">OverloadSelector</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_setattrs </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">OverloadSelector</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_casts </span><span class="s2">= </span><span class="s1">OverloadSelector</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_constants </span><span class="s2">= </span><span class="s1">OverloadSelector</span><span class="s2">()</span>
        <span class="s5"># Other declarations</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_generators </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">special_ops </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cached_internal_func </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pid </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_codelib_stack </span><span class="s2">= []</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_boundscheck </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager </span><span class="s2">= </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">default_manager</span>

        <span class="s5"># Initialize</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">init</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">init</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        For subclasses to add initializer 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">refresh</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Refresh context with new declarations from known registries. 
        Useful for third-party extensions. 
        &quot;&quot;&quot;</span>
        <span class="s5"># load target specific registries</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">load_additional_registries</span><span class="s2">()</span>

        <span class="s5"># Populate the builtin registry, this has to happen after loading</span>
        <span class="s5"># additional registries as some of the &quot;additional&quot; registries write</span>
        <span class="s5"># their implementations into the builtin_registry and would be missed if</span>
        <span class="s5"># this ran first.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">install_registry</span><span class="s2">(</span><span class="s1">builtin_registry</span><span class="s2">)</span>

        <span class="s5"># Also refresh typing context, since @overload declarations can</span>
        <span class="s5"># affect it.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">.</span><span class="s1">refresh</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">load_additional_registries</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Load target-specific registries.  Can be overridden by subclasses. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">mangler</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, *, </span><span class="s1">abi_tags</span><span class="s2">=(), </span><span class="s1">uid</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Perform name mangling. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">funcdesc</span><span class="s2">.</span><span class="s1">default_mangler</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">abi_tags</span><span class="s2">=</span><span class="s1">abi_tags</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">=</span><span class="s1">uid</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_env_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Get the environment name given a FunctionDescriptor. 
 
        Use this instead of the ``fndesc.env_name`` so that the target-context 
        can provide necessary mangling of the symbol to meet ABI requirements. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">env_name</span>

    <span class="s0">def </span><span class="s1">declare_env_global</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">envname</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Declare the Environment pointer as a global of the module. 
 
        The pointer is initialized to NULL.  It must be filled by the runtime 
        with the actual address of the Env before the associated function 
        can be executed. 
 
        Parameters 
        ---------- 
        module : 
            The LLVM Module 
        envname : str 
            The name of the global variable. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">envname </span><span class="s0">not in </span><span class="s1">module</span><span class="s2">.</span><span class="s1">globals</span><span class="s2">:</span>
            <span class="s1">gv </span><span class="s2">= </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">GlobalVariable</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">voidptr_t</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">envname</span><span class="s2">)</span>
            <span class="s1">gv</span><span class="s2">.</span><span class="s1">linkage </span><span class="s2">= </span><span class="s6">'common'</span>
            <span class="s1">gv</span><span class="s2">.</span><span class="s1">initializer </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_null_value</span><span class="s2">(</span><span class="s1">gv</span><span class="s2">.</span><span class="s1">type</span><span class="s2">.</span><span class="s1">pointee</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">module</span><span class="s2">.</span><span class="s1">globals</span><span class="s2">[</span><span class="s1">envname</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">get_arg_packer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fe_args</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">ArgPacker</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">, </span><span class="s1">fe_args</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_data_packer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fe_types</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">datamodel</span><span class="s2">.</span><span class="s1">DataPacker</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">, </span><span class="s1">fe_types</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">target_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">nonconst_module_attrs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        All module attrs are constant for targets using BaseContext. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">nrt</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">runtime</span><span class="s2">.</span><span class="s1">context </span><span class="s0">import </span><span class="s1">NRTContext</span>
        <span class="s0">return </span><span class="s1">NRTContext</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">enable_nrt</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">subtarget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kws</span><span class="s2">):</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)  </span><span class="s5"># shallow copy</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kws</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">NameError</span><span class="s2">(</span><span class="s6">&quot;unknown option {0!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">k</span><span class="s2">))</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">codegen</span><span class="s2">() </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">codegen</span><span class="s2">():</span>
            <span class="s5"># We can't share functions across different codegens</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">cached_internal_func </span><span class="s2">= {}</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">install_registry</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">registry</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Install a *registry* (a imputils.Registry instance) of function 
        and attribute implementations. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">loader </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_registries</span><span class="s2">[</span><span class="s1">registry</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">loader </span><span class="s2">= </span><span class="s1">RegistryLoader</span><span class="s2">(</span><span class="s1">registry</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_registries</span><span class="s2">[</span><span class="s1">registry</span><span class="s2">] = </span><span class="s1">loader</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">insert_func_defn</span><span class="s2">(</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">new_registrations</span><span class="s2">(</span><span class="s6">'functions'</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_getattr_defn</span><span class="s2">(</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">new_registrations</span><span class="s2">(</span><span class="s6">'getattrs'</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_setattr_defn</span><span class="s2">(</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">new_registrations</span><span class="s2">(</span><span class="s6">'setattrs'</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_cast_defn</span><span class="s2">(</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">new_registrations</span><span class="s2">(</span><span class="s6">'casts'</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_get_constant_defn</span><span class="s2">(</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">new_registrations</span><span class="s2">(</span><span class="s6">'constants'</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">insert_func_defn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">defns</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">defns</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_defns</span><span class="s2">[</span><span class="s1">func</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_getattr_defn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">defns</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">defns</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_getattrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_setattr_defn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">defns</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">defns</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_setattrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_cast_defn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">defns</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">defns</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_casts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_get_constant_defn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">defns</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">defns</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_constants</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">insert_user_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">libs</span><span class="s2">=()):</span>
        <span class="s1">impl </span><span class="s2">= </span><span class="s1">user_function</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">libs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_defns</span><span class="s2">[</span><span class="s1">func</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">insert_generator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">genty</span><span class="s2">, </span><span class="s1">gendesc</span><span class="s2">, </span><span class="s1">libs</span><span class="s2">=()):</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">genty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">)</span>
        <span class="s1">impl </span><span class="s2">= </span><span class="s1">user_generator</span><span class="s2">(</span><span class="s1">gendesc</span><span class="s2">, </span><span class="s1">libs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_generators</span><span class="s2">[</span><span class="s1">genty</span><span class="s2">] = </span><span class="s1">gendesc</span><span class="s2">, </span><span class="s1">impl</span>

    <span class="s0">def </span><span class="s1">remove_user_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Remove user function *func*. 
        KeyError is raised if the function isn't known to us. 
        &quot;&quot;&quot;</span>
        <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defns</span><span class="s2">[</span><span class="s1">func</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">get_external_function_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">):</span>
        <span class="s1">argtypes </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_argument_type</span><span class="s2">(</span><span class="s1">aty</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">aty </span><span class="s0">in </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">argtypes</span><span class="s2">]</span>
        <span class="s5"># don't wrap in pointer</span>
        <span class="s1">restype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_argument_type</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">restype</span><span class="s2">)</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">restype</span><span class="s2">, </span><span class="s1">argtypes</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">fnty</span>

    <span class="s0">def </span><span class="s1">declare_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">):</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">get_function_type</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">restype</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">argtypes</span><span class="s2">)</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">mangled_name</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">decorate_function</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">argtypes</span><span class="s2">, </span><span class="s1">noalias</span><span class="s2">=</span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">noalias</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">inline</span><span class="s2">:</span>
            <span class="s1">fn</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s6">'alwaysinline'</span><span class="s2">)</span>
            <span class="s5"># alwaysinline overrides optnone</span>
            <span class="s1">fn</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s6">'noinline'</span><span class="s2">)</span>
            <span class="s1">fn</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s6">'optnone'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">fn</span>

    <span class="s0">def </span><span class="s1">declare_external_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">):</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_external_function_type</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">)</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">mangled_name</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">is_declaration</span>
        <span class="s0">for </span><span class="s1">ak</span><span class="s2">, </span><span class="s1">av </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">fndesc</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s1">av</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s6">&quot;arg.%s&quot; </span><span class="s2">% </span><span class="s1">ak</span>
        <span class="s0">return </span><span class="s1">fn</span>

    <span class="s0">def </span><span class="s1">insert_const_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">string</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Insert constant *string* (a str object) into module *mod*. 
        &quot;&quot;&quot;</span>
        <span class="s1">stringtype </span><span class="s2">= </span><span class="s1">GENERIC_POINTER</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s6">&quot;.const.%s&quot; </span><span class="s2">% </span><span class="s1">string</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">make_bytearray</span><span class="s2">(</span><span class="s1">string</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s6">&quot;utf-8&quot;</span><span class="s2">) + </span><span class="s7">b&quot;</span><span class="s0">\x00</span><span class="s7">&quot;</span><span class="s2">)</span>
        <span class="s1">gv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">insert_unique_const</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">text</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Constant</span><span class="s2">.</span><span class="s1">bitcast</span><span class="s2">(</span><span class="s1">gv</span><span class="s2">, </span><span class="s1">stringtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">insert_const_bytes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Insert constant *byte* (a `bytes` object) into module *mod*. 
        &quot;&quot;&quot;</span>
        <span class="s1">stringtype </span><span class="s2">= </span><span class="s1">GENERIC_POINTER</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s6">&quot;.bytes.%s&quot; </span><span class="s2">% (</span><span class="s1">name </span><span class="s0">or </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">bytes</span><span class="s2">))</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">make_bytearray</span><span class="s2">(</span><span class="s1">bytes</span><span class="s2">)</span>
        <span class="s1">gv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">insert_unique_const</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">text</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Constant</span><span class="s2">.</span><span class="s1">bitcast</span><span class="s2">(</span><span class="s1">gv</span><span class="s2">, </span><span class="s1">stringtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">insert_unique_const</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Insert a unique internal constant named *name*, with LLVM value 
        *val*, into module *mod*. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">gv </span><span class="s2">= </span><span class="s1">mod</span><span class="s2">.</span><span class="s1">get_global</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">global_constant</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">gv</span>

    <span class="s0">def </span><span class="s1">get_argument_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">get_argument_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">get_return_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">get_return_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">get_data_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a LLVM data representation of the Numba type *ty* that is safe 
        for storage.  Record data are stored as byte array. 
 
        The return value is a llvmlite.ir.Type object, or None if the type 
        is an opaque pointer (???). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">get_data_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">get_value_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">pack_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Pack value into the array storage at *ptr*. 
        If *align* is given, it is the guaranteed alignment for *ptr* 
        (by default, the standard ABI alignment). 
        &quot;&quot;&quot;</span>
        <span class="s1">dataval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">as_data</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">builder</span><span class="s2">.</span><span class="s1">store</span><span class="s2">(</span><span class="s1">dataval</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s1">align</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">unpack_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Unpack value from the array storage at *ptr*. 
        If *align* is given, it is the guaranteed alignment for *ptr* 
        (by default, the standard ABI alignment). 
        &quot;&quot;&quot;</span>
        <span class="s1">dm </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">dm</span><span class="s2">.</span><span class="s1">load_from_data_pointer</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">align</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_constant_generic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a LLVM constant representing value *val* of Numba type *ty*. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">impl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_constants</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">ty</span><span class="s2">,))</span>
            <span class="s0">return </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">NotImplementedError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;Cannot lower constant of type '%s'&quot; </span><span class="s2">% (</span><span class="s1">ty</span><span class="s2">,))</span>

    <span class="s0">def </span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Same as get_constant_generic(), but without specifying *builder*. 
        Works only for simple types. 
        &quot;&quot;&quot;</span>
        <span class="s5"># HACK: pass builder=None to preserve get_constant() API</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_constant_undef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s1">lty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">lty</span><span class="s2">, </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">Undefined</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_constant_null</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s1">lty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">lty</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">_firstcall</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the implementation of function *fn* for signature *sig*. 
        The return value is a callable with the signature (builder, args). 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">sig </span><span class="s0">is not None</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">as_function</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">):</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">get_impl_key</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">)</span>
            <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defns</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">fn</span>
            <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defns</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_wrap_impl</span><span class="s2">(</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">), </span><span class="s1">self</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">):</span>
            <span class="s5"># It's a type instance =&gt; try to find a definition for the type class</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">), </span><span class="s1">sig</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">NotImplementedError</span><span class="s2">:</span>
                <span class="s5"># Raise exception for the type instance, for a better error message</span>
                <span class="s0">pass</span>

        <span class="s5"># Automatically refresh the context to load new registries if we are</span>
        <span class="s5"># calling the first time.</span>
        <span class="s0">if </span><span class="s1">_firstcall</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">refresh</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">_firstcall</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;No definition for lowering %s%s&quot; </span><span class="s2">% (</span><span class="s1">key</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">get_generator_desc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">genty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_generators</span><span class="s2">[</span><span class="s1">genty</span><span class="s2">][</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">get_generator_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">genty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        &quot;&quot;&quot;</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_generators</span><span class="s2">[</span><span class="s1">genty</span><span class="s2">][</span><span class="s3">1</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">add_linking_libs</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s6">'libs'</span><span class="s2">, ()))</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">get_bound_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">) == </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">type</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">get_getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the getattr() implementation for the given type and attribute name. 
        The return value is a callable with the signature 
        (context, builder, typ, val, attr). 
        &quot;&quot;&quot;</span>
        <span class="s1">const_attr </span><span class="s2">= (</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">) </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nonconst_module_attrs</span>
        <span class="s1">is_module </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Module</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">is_module </span><span class="s0">and </span><span class="s1">const_attr</span><span class="s2">:</span>
            <span class="s5"># Implement getattr for module-level globals that we treat as</span>
            <span class="s5"># constants.</span>
            <span class="s5"># XXX We shouldn't have to retype this</span>
            <span class="s1">attrty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">.</span><span class="s1">resolve_module_constants</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">attrty </span><span class="s0">is None or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">attrty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Dummy</span><span class="s2">):</span>
                <span class="s5"># No implementation required for dummies (functions, modules...),</span>
                <span class="s5"># which are dealt with later</span>
                <span class="s0">return None</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">pyval </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">.</span><span class="s1">pymod</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">def </span><span class="s1">imp</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
                    <span class="s1">llval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant_generic</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">attrty</span><span class="s2">, </span><span class="s1">pyval</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">impl_ret_borrowed</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">attrty</span><span class="s2">, </span><span class="s1">llval</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">imp</span>

        <span class="s5"># Lookup specific getattr implementation for this type and attribute</span>
        <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getattrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">typ</span><span class="s2">,))</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s5"># Lookup generic getattr implementation for this type</span>
        <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getattrs</span><span class="s2">[</span><span class="s0">None</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">typ</span><span class="s2">,))</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">pass</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;No definition for lowering %s.%s&quot; </span><span class="s2">% (</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">get_setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the setattr() implementation for the given attribute name 
        and signature. 
        The return value is a callable with the signature (builder, args). 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) == </span><span class="s3">2</span>
        <span class="s1">typ </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
        <span class="s1">valty </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]</span>

        <span class="s0">def </span><span class="s1">wrap_setattr</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">wrapped</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">wrapped</span>

        <span class="s5"># Lookup specific setattr implementation for this type and attribute</span>
        <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_setattrs</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">wrap_setattr</span><span class="s2">(</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">valty</span><span class="s2">)))</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s5"># Lookup generic setattr implementation for this type</span>
        <span class="s1">overloads </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_setattrs</span><span class="s2">[</span><span class="s0">None</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">wrap_setattr</span><span class="s2">(</span><span class="s1">overloads</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">valty</span><span class="s2">)))</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">pass</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;No definition for lowering %s.%s = %s&quot;</span>
                                  <span class="s2">% (</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">valty</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">get_argument_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Argument representation to local value representation 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">from_argument</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_returned_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return value representation to local value representation 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">from_return</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_return_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Local value representation to return type representation 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">as_return</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_value_as_argument</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Prepare local value representation as argument type representation 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">as_argument</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_value_as_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">as_data</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_data_as_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">ty</span><span class="s2">].</span><span class="s1">from_data</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">pair_first</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Extract the first element of a heterogeneous pair. 
        &quot;&quot;&quot;</span>
        <span class="s1">pair </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">pair</span><span class="s2">.</span><span class="s1">first</span>

    <span class="s0">def </span><span class="s1">pair_second</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Extract the second element of a heterogeneous pair. 
        &quot;&quot;&quot;</span>
        <span class="s1">pair </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">pair</span><span class="s2">.</span><span class="s1">second</span>

    <span class="s0">def </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Cast a value of type *fromty* to type *toty*. 
        This implements implicit conversions as can happen due to the 
        granularity of the Numba type system, or lax Python semantics. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">fromty </span><span class="s0">is </span><span class="s1">types</span><span class="s2">.</span><span class="s1">_undef_var</span><span class="s2">:</span>
            <span class="s5"># Special case for undefined variable</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant_null</span><span class="s2">(</span><span class="s1">toty</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">fromty </span><span class="s2">== </span><span class="s1">toty </span><span class="s0">or </span><span class="s1">toty </span><span class="s2">== </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">val</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">impl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_casts</span><span class="s2">.</span><span class="s1">find</span><span class="s2">((</span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">errors</span><span class="s2">.</span><span class="s1">NumbaNotImplementedError</span><span class="s2">(</span>
                <span class="s6">&quot;Cannot cast %s to %s: %s&quot; </span><span class="s2">% (</span><span class="s1">fromty</span><span class="s2">, </span><span class="s1">toty</span><span class="s2">, </span><span class="s1">val</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">generic_compare</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">argtypes</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Compare the given LLVM values of the given Numba types using 
        the comparison *key* (e.g. '==').  The values are first cast to 
        a common safe conversion type. 
        &quot;&quot;&quot;</span>
        <span class="s1">at</span><span class="s2">, </span><span class="s1">bt </span><span class="s2">= </span><span class="s1">argtypes</span>
        <span class="s1">av</span><span class="s2">, </span><span class="s1">bv </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">ty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">.</span><span class="s1">unify_types</span><span class="s2">(</span><span class="s1">at</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">ty </span><span class="s0">is not None</span>
        <span class="s1">cav </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">av</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
        <span class="s1">cbv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">bv</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">)</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">.</span><span class="s1">resolve_value_type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s5"># the sig is homogeneous in the unified casted type</span>
        <span class="s1">cmpsig </span><span class="s2">= </span><span class="s1">fnty</span><span class="s2">.</span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">, (</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">), {})</span>
        <span class="s1">cmpfunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">cmpsig</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">add_linking_libs</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cmpfunc</span><span class="s2">, </span><span class="s6">'libs'</span><span class="s2">, ()))</span>
        <span class="s0">return </span><span class="s1">cmpfunc</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, (</span><span class="s1">cav</span><span class="s2">, </span><span class="s1">cbv</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">make_optional_none</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">valtype</span><span class="s2">):</span>
        <span class="s1">optval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">(</span><span class="s1">valtype</span><span class="s2">))</span>
        <span class="s1">optval</span><span class="s2">.</span><span class="s1">valid </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">false_bit</span>
        <span class="s0">return </span><span class="s1">optval</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">make_optional_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">valtype</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">optval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">(</span><span class="s1">valtype</span><span class="s2">))</span>
        <span class="s1">optval</span><span class="s2">.</span><span class="s1">valid </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">true_bit</span>
        <span class="s1">optval</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s0">return </span><span class="s1">optval</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">is_true</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the truth value of a value of the given Numba type. 
        &quot;&quot;&quot;</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">.</span><span class="s1">resolve_value_type</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">fnty</span><span class="s2">.</span><span class="s1">get_call_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">, (</span><span class="s1">typ</span><span class="s2">,), {})</span>
        <span class="s1">impl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_function</span><span class="s2">(</span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">impl</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, (</span><span class="s1">val</span><span class="s2">,))</span>

    <span class="s0">def </span><span class="s1">get_c_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dllimport</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a global value through its C-accessible *name*, with the given 
        LLVM type. 
        If *dllimport* is true, the symbol will be marked as imported 
        from a DLL (necessary for AOT compilation under Windows). 
        &quot;&quot;&quot;</span>
        <span class="s1">module </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">function</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">gv </span><span class="s2">= </span><span class="s1">module</span><span class="s2">.</span><span class="s1">globals</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">gv </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">add_global_variable</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">dllimport </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">aot_mode </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s6">'win32'</span><span class="s2">:</span>
                <span class="s1">gv</span><span class="s2">.</span><span class="s1">storage_class </span><span class="s2">= </span><span class="s6">&quot;dllimport&quot;</span>
        <span class="s0">return </span><span class="s1">gv</span>

    <span class="s0">def </span><span class="s1">call_external_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">callee</span><span class="s2">, </span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_as_argument</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">argtys</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)]</span>
        <span class="s1">retval </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">callee</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">retval</span>

    <span class="s0">def </span><span class="s1">get_function_pointer_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data_model_manager</span><span class="s2">[</span><span class="s1">typ</span><span class="s2">].</span><span class="s1">get_data_type</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">call_function_pointer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">funcptr</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">cconv</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">funcptr</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">cconv</span><span class="s2">=</span><span class="s1">cconv</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">print_string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">text</span><span class="s2">):</span>
        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">cstring </span><span class="s2">= </span><span class="s1">GENERIC_POINTER</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s3">32</span><span class="s2">), [</span><span class="s1">cstring</span><span class="s2">])</span>
        <span class="s1">puts </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s6">&quot;puts&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">puts</span><span class="s2">, [</span><span class="s1">text</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">debug_print</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">text</span><span class="s2">):</span>
        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">cstr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">insert_const_string</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">text</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">print_string</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">cstr</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">printf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">format_string</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">format_string</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">cstr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">insert_const_string</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">format_string</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">cstr </span><span class="s2">= </span><span class="s1">format_string</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">(</span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s3">32</span><span class="s2">), (</span><span class="s1">GENERIC_POINTER</span><span class="s2">,), </span><span class="s1">var_arg</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">get_or_insert_function</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s6">&quot;printf&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, (</span><span class="s1">cstr</span><span class="s2">,) + </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">args</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">get_struct_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">struct</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the LLVM struct type for the given Structure class *struct*. 
        &quot;&quot;&quot;</span>
        <span class="s1">fields </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">_fields</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">LiteralStructType</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_dummy_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Constant</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_dummy_type</span><span class="s2">(), </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_dummy_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">GENERIC_POINTER</span>

    <span class="s0">def </span><span class="s1">_compile_subroutine_no_cache</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">={},</span>
                                     <span class="s1">flags</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Invoke the compiler to compile a function to be used inside a 
        nopython function, but without generating code to call that 
        function. 
 
        Note this context's flags are not inherited. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Compile</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s1">compiler</span>

        <span class="s0">with </span><span class="s1">global_compiler_lock</span><span class="s2">:</span>
            <span class="s1">codegen </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">codegen</span><span class="s2">()</span>
            <span class="s1">library </span><span class="s2">= </span><span class="s1">codegen</span><span class="s2">.</span><span class="s1">create_library</span><span class="s2">(</span><span class="s1">impl</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">flags </span><span class="s0">is None</span><span class="s2">:</span>

                <span class="s1">cstk </span><span class="s2">= </span><span class="s1">targetconfig</span><span class="s2">.</span><span class="s1">ConfigStack</span><span class="s2">()</span>
                <span class="s1">flags </span><span class="s2">= </span><span class="s1">compiler</span><span class="s2">.</span><span class="s1">Flags</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">cstk</span><span class="s2">:</span>
                    <span class="s1">tls_flags </span><span class="s2">= </span><span class="s1">cstk</span><span class="s2">.</span><span class="s1">top</span><span class="s2">()</span>
                    <span class="s0">if </span><span class="s1">tls_flags</span><span class="s2">.</span><span class="s1">is_set</span><span class="s2">(</span><span class="s6">&quot;nrt&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">tls_flags</span><span class="s2">.</span><span class="s1">nrt</span><span class="s2">:</span>
                        <span class="s1">flags</span><span class="s2">.</span><span class="s1">nrt </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s1">flags</span><span class="s2">.</span><span class="s1">no_compile </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">flags</span><span class="s2">.</span><span class="s1">no_cpython_wrapper </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">flags</span><span class="s2">.</span><span class="s1">no_cfunc_wrapper </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s1">cres </span><span class="s2">= </span><span class="s1">compiler</span><span class="s2">.</span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">typing_context</span><span class="s2">, </span><span class="s1">self</span><span class="s2">,</span>
                                             <span class="s1">library</span><span class="s2">,</span>
                                             <span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">,</span>
                                             <span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">,</span>
                                             <span class="s1">locals</span><span class="s2">=</span><span class="s1">locals</span><span class="s2">)</span>

            <span class="s5"># Allow inlining the function inside callers.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">active_code_library</span><span class="s2">.</span><span class="s1">add_linking_library</span><span class="s2">(</span><span class="s1">cres</span><span class="s2">.</span><span class="s1">library</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">cres</span>

    <span class="s0">def </span><span class="s1">compile_subroutine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">={}, </span><span class="s1">flags</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                           <span class="s1">caching</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Compile the function *impl* for the given *sig* (in nopython mode). 
        Return an instance of CompileResult. 
 
        If *caching* evaluates True, the function keeps the compiled function 
        for reuse in *.cached_internal_func*. 
        &quot;&quot;&quot;</span>
        <span class="s1">cache_key </span><span class="s2">= (</span><span class="s1">impl</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">error_model</span><span class="s2">))</span>
        <span class="s0">if not </span><span class="s1">caching</span><span class="s2">:</span>
            <span class="s1">cached </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">impl</span><span class="s2">.</span><span class="s1">__closure__</span><span class="s2">:</span>
                <span class="s5"># XXX This obviously won't work if a cell's value is</span>
                <span class="s5"># unhashable.</span>
                <span class="s1">cache_key </span><span class="s2">+= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">cell_contents </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">impl</span><span class="s2">.</span><span class="s1">__closure__</span><span class="s2">)</span>
            <span class="s1">cached </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cached_internal_func</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">cache_key</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">cached </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_compile_subroutine_no_cache</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">,</span>
                                                     <span class="s1">locals</span><span class="s2">=</span><span class="s1">locals</span><span class="s2">,</span>
                                                     <span class="s1">flags</span><span class="s2">=</span><span class="s1">flags</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cached_internal_func</span><span class="s2">[</span><span class="s1">cache_key</span><span class="s2">] = </span><span class="s1">cres</span>

        <span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cached_internal_func</span><span class="s2">[</span><span class="s1">cache_key</span><span class="s2">]</span>
        <span class="s5"># Allow inlining the function inside callers.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">active_code_library</span><span class="s2">.</span><span class="s1">add_linking_library</span><span class="s2">(</span><span class="s1">cres</span><span class="s2">.</span><span class="s1">library</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cres</span>

    <span class="s0">def </span><span class="s1">compile_internal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">={}):</span>
        <span class="s4">&quot;&quot;&quot; 
        Like compile_subroutine(), but also call the function with the given 
        *args*. 
        &quot;&quot;&quot;</span>
        <span class="s1">cres </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compile_subroutine</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">impl</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_internal</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">cres</span><span class="s2">.</span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">call_internal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Given the function descriptor of an internally compiled function, 
        emit a call to that function with the given arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_internal_no_propagate</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">if_unlikely</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">status</span><span class="s2">.</span><span class="s1">is_error</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">return_status_propagate</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">status</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">imputils</span><span class="s2">.</span><span class="s1">fix_returning_optional</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">call_internal_no_propagate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Similar to `.call_internal()` but does not handle or propagate 
        the return status automatically. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Add call to the generated function</span>
        <span class="s1">llvm_mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">declare_function</span><span class="s2">(</span><span class="s1">llvm_mod</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">)</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">call_function</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                                                   <span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">status</span><span class="s2">, </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">call_unresolved</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Insert a function call to an unresolved symbol with the given *name*. 
 
        Note: this is used for recursive call. 
 
        In the mutual recursion case:: 
 
            @njit 
            def foo(): 
                ...  # calls bar() 
 
            @njit 
            def bar(): 
                ... # calls foo() 
 
            foo() 
 
        When foo() is called, the compilation of bar() is fully completed 
        (codegen'ed and loaded) before foo() is. Since MCJIT's eager compilation 
        doesn't allow loading modules with declare-only functions (which is 
        needed for foo() in bar()), the call_unresolved injects a global 
        variable that the &quot;linker&quot; can update even after the module is loaded by 
        MCJIT. The linker would allocate space for the global variable before 
        the bar() module is loaded. When later foo() module is defined, it will 
        update bar()'s reference to foo(). 
 
        The legacy lazy JIT and the new ORC JIT would allow a declare-only 
        function be used in a module as long as it is defined by the time of its 
        first use. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Insert an unresolved reference to the function being called.</span>
        <span class="s1">codegen </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">codegen</span><span class="s2">()</span>
        <span class="s1">fnty </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">get_function_type</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">codegen</span><span class="s2">.</span><span class="s1">insert_unresolved_ref</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fnty</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s5"># Normal call sequence</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">call_function</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">return_type</span><span class="s2">,</span>
                                                   <span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">if_unlikely</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">status</span><span class="s2">.</span><span class="s1">is_error</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">call_conv</span><span class="s2">.</span><span class="s1">return_status_propagate</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">status</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">imputils</span><span class="s2">.</span><span class="s1">fix_returning_optional</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">get_executable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">fndesc</span><span class="s2">, </span><span class="s1">env</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">get_python_api</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">PythonAPI</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">sentry_record_alignment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">rectyp</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Assumes offset starts from a properly aligned location 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strict_alignment</span><span class="s2">:</span>
            <span class="s1">offset </span><span class="s2">= </span><span class="s1">rectyp</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s1">elemty </span><span class="s2">= </span><span class="s1">rectyp</span><span class="s2">.</span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">elemty</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">NestedArray</span><span class="s2">):</span>
                <span class="s5"># For a NestedArray we need to consider the data type of</span>
                <span class="s5"># elements of the array for alignment, not the array structure</span>
                <span class="s5"># itself</span>
                <span class="s1">elemty </span><span class="s2">= </span><span class="s1">elemty</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s1">align </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_abi_alignment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_data_type</span><span class="s2">(</span><span class="s1">elemty</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">offset </span><span class="s2">% </span><span class="s1">align</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s6">&quot;{rec}.{attr} of type {type} is not aligned&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                    <span class="s1">rec</span><span class="s2">=</span><span class="s1">rectyp</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">=</span><span class="s1">attr</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s1">elemty</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_helper_class</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s6">'value'</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a helper class for the given *typ*. 
        &quot;&quot;&quot;</span>
        <span class="s5"># XXX handle all types: complex, array, etc.</span>
        <span class="s5"># XXX should it be a method on the model instead? this would allow a default kind...</span>
        <span class="s0">return </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">create_struct_proxy</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_make_helper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s6">'value'</span><span class="s2">):</span>
        <span class="s1">cls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_helper_class</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">=</span><span class="s1">ref</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a helper object to access the *typ*'s members, 
        for the given value or reference. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s6">'value'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">make_data_helper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        As make_helper(), but considers the value as stored in memory, 
        rather than a live value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">=</span><span class="s1">ref</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s6">'data'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">make_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">arrayobj</span>
        <span class="s0">return </span><span class="s1">arrayobj</span><span class="s2">.</span><span class="s1">make_array</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">populate_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Populate array structure. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numba</span><span class="s2">.</span><span class="s1">np </span><span class="s0">import </span><span class="s1">arrayobj</span>
        <span class="s0">return </span><span class="s1">arrayobj</span><span class="s2">.</span><span class="s1">populate_array</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">make_complex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a helper object to access the given complex numbers' members. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">Complex</span><span class="s2">), </span><span class="s1">typ</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_helper</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">make_tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Create a tuple of the given *typ* containing the *values*. 
        &quot;&quot;&quot;</span>
        <span class="s1">tup </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant_undef</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">values</span><span class="s2">):</span>
            <span class="s1">tup </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">insert_value</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">tup</span>

    <span class="s0">def </span><span class="s1">make_constant_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">ary</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Create an array structure reifying the given constant array. 
        A low-level contiguous array constant is created in the LLVM IR. 
        &quot;&quot;&quot;</span>
        <span class="s1">datatype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_data_type</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s5"># don't freeze ary of non-contig or bigger than 1MB</span>
        <span class="s1">size_limit </span><span class="s2">= </span><span class="s3">10</span><span class="s2">**</span><span class="s3">6</span>

        <span class="s0">if </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">allow_dynamic_globals </span><span class="s0">and</span>
                <span class="s2">(</span><span class="s1">typ</span><span class="s2">.</span><span class="s1">layout </span><span class="s0">not in </span><span class="s6">'FC' </span><span class="s0">or </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">nbytes </span><span class="s2">&gt; </span><span class="s1">size_limit</span><span class="s2">)):</span>
            <span class="s5"># get pointer from the ary</span>
            <span class="s1">dataptr </span><span class="s2">= </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">add_dynamic_addr</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">dataptr</span><span class="s2">, </span><span class="s1">info</span><span class="s2">=</span><span class="s1">str</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">dataptr</span><span class="s2">)))</span>
            <span class="s1">rt_addr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">add_dynamic_addr</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s1">id</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">), </span><span class="s1">info</span><span class="s2">=</span><span class="s1">str</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">)))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># Handle data: reify the flattened array in &quot;C&quot; or &quot;F&quot; order as a</span>
            <span class="s5"># global array of bytes.</span>
            <span class="s1">flat </span><span class="s2">= </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">typ</span><span class="s2">.</span><span class="s1">layout</span><span class="s2">)</span>
            <span class="s5"># Note: we use `bytearray(flat.data)` instead of `bytearray(flat)` to</span>
            <span class="s5">#       workaround issue #1850 which is due to numpy issue #3147</span>
            <span class="s1">consts </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">create_constant_array</span><span class="s2">(</span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">IntType</span><span class="s2">(</span><span class="s3">8</span><span class="s2">), </span><span class="s1">bytearray</span><span class="s2">(</span><span class="s1">flat</span><span class="s2">.</span><span class="s1">data</span><span class="s2">))</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">global_constant</span><span class="s2">(</span><span class="s1">builder</span><span class="s2">, </span><span class="s6">&quot;.const.array.data&quot;</span><span class="s2">, </span><span class="s1">consts</span><span class="s2">)</span>
            <span class="s5"># Ensure correct data alignment (issue #1933)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">align </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_abi_alignment</span><span class="s2">(</span><span class="s1">datatype</span><span class="s2">)</span>
            <span class="s5"># No reference to parent ndarray</span>
            <span class="s1">rt_addr </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s5"># Handle shape</span>
        <span class="s1">llintp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
        <span class="s1">shapevals </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">s</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">]</span>
        <span class="s1">cshape </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">create_constant_array</span><span class="s2">(</span><span class="s1">llintp</span><span class="s2">, </span><span class="s1">shapevals</span><span class="s2">)</span>

        <span class="s5"># Handle strides</span>
        <span class="s1">stridevals </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">s</span><span class="s2">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">strides</span><span class="s2">]</span>
        <span class="s1">cstrides </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">create_constant_array</span><span class="s2">(</span><span class="s1">llintp</span><span class="s2">, </span><span class="s1">stridevals</span><span class="s2">)</span>

        <span class="s5"># Create array structure</span>
        <span class="s1">cary </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_array</span><span class="s2">(</span><span class="s1">typ</span><span class="s2">)(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">)</span>

        <span class="s1">intp_itemsize </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">, </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">populate_array</span><span class="s2">(</span><span class="s1">cary</span><span class="s2">,</span>
                            <span class="s1">data</span><span class="s2">=</span><span class="s1">builder</span><span class="s2">.</span><span class="s1">bitcast</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">cary</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">type</span><span class="s2">),</span>
                            <span class="s1">shape</span><span class="s2">=</span><span class="s1">cshape</span><span class="s2">,</span>
                            <span class="s1">strides</span><span class="s2">=</span><span class="s1">cstrides</span><span class="s2">,</span>
                            <span class="s1">itemsize</span><span class="s2">=</span><span class="s1">intp_itemsize</span><span class="s2">,</span>
                            <span class="s1">parent</span><span class="s2">=</span><span class="s1">rt_addr</span><span class="s2">,</span>
                            <span class="s1">meminfo</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">cary</span><span class="s2">.</span><span class="s1">_getvalue</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">add_dynamic_addr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">intaddr</span><span class="s2">, </span><span class="s1">info</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns dynamic address as a void pointer `i8*`. 
 
        Internally, a global variable is added to inform the lowerer about 
        the usage of dynamic addresses.  Caching will be disabled. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">allow_dynamic_globals</span><span class="s2">, </span><span class="s6">&quot;dyn globals disabled in this target&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">intaddr</span><span class="s2">, </span><span class="s1">int</span><span class="s2">), </span><span class="s6">'dyn addr not of int type'</span>
        <span class="s1">mod </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">module</span>
        <span class="s1">llvoidptr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_value_type</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">voidptr</span><span class="s2">)</span>
        <span class="s1">addr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_constant</span><span class="s2">(</span><span class="s1">types</span><span class="s2">.</span><span class="s1">uintp</span><span class="s2">, </span><span class="s1">intaddr</span><span class="s2">).</span><span class="s1">inttoptr</span><span class="s2">(</span><span class="s1">llvoidptr</span><span class="s2">)</span>
        <span class="s5"># Use a unique name by embedding the address value</span>
        <span class="s1">symname </span><span class="s2">= </span><span class="s6">'numba.dynamic.globals.{:x}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">intaddr</span><span class="s2">)</span>
        <span class="s1">gv </span><span class="s2">= </span><span class="s1">cgutils</span><span class="s2">.</span><span class="s1">add_global_variable</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">llvoidptr</span><span class="s2">, </span><span class="s1">symname</span><span class="s2">)</span>
        <span class="s5"># Use linkonce linkage to allow merging with other GV of the same name.</span>
        <span class="s5"># And, avoid optimization from assuming its value.</span>
        <span class="s1">gv</span><span class="s2">.</span><span class="s1">linkage </span><span class="s2">= </span><span class="s6">'linkonce'</span>
        <span class="s1">gv</span><span class="s2">.</span><span class="s1">initializer </span><span class="s2">= </span><span class="s1">addr</span>
        <span class="s0">return </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">gv</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_abi_sizeof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the ABI size of LLVM type *ty*. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">), </span><span class="s6">&quot;Expected LLVM type&quot;</span>
        <span class="s0">return </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">get_abi_size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_data</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_abi_alignment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the ABI alignment of LLVM type *ty*. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ty</span><span class="s2">, </span><span class="s1">llvmir</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">), </span><span class="s6">&quot;Expected LLVM type&quot;</span>
        <span class="s0">return </span><span class="s1">ty</span><span class="s2">.</span><span class="s1">get_abi_alignment</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_data</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_preferred_array_alignment</span><span class="s2">(</span><span class="s1">context</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get preferred array alignment for Numba type *ty*. 
        &quot;&quot;&quot;</span>
        <span class="s5"># AVX prefers 32-byte alignment</span>
        <span class="s0">return </span><span class="s3">32</span>

    <span class="s0">def </span><span class="s1">post_lowering</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">library</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Run target specific post-lowering transformation here. 
        &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">create_module</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Create a LLVM module 
 
        The default implementation in BaseContext always raises a 
        ``NotImplementedError`` exception. Subclasses should implement 
        this method. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">active_code_library</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Get the active code library 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_codelib_stack</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">contextmanager</span>
    <span class="s0">def </span><span class="s1">push_code_library</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lib</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Push the active code library for the context 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_codelib_stack</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_codelib_stack</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">add_linking_libs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">libs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Add iterable of linking libraries to the *active_code_library*. 
        &quot;&quot;&quot;</span>
        <span class="s1">colib </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">active_code_library</span>
        <span class="s0">for </span><span class="s1">lib </span><span class="s0">in </span><span class="s1">libs</span><span class="s2">:</span>
            <span class="s1">colib</span><span class="s2">.</span><span class="s1">add_linking_library</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_ufunc_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc_key</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Get the ufunc implementation for a given ufunc object. 
 
        The default implementation in BaseContext always raises a 
        ``NotImplementedError`` exception. Subclasses may raise ``KeyError`` 
        to signal that the given ``ufunc_key`` is not available. 
 
        Parameters 
        ---------- 
        ufunc_key : NumPy ufunc 
 
        Returns 
        ------- 
        res : dict[str, callable] 
            A mapping of a NumPy ufunc type signature to a lower-level 
            implementation. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s6">does not support ufunc&quot;</span><span class="s2">)</span>

<span class="s0">class </span><span class="s1">_wrap_impl</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    A wrapper object to call an implementation function with some predefined 
    (context, signature) arguments. 
    The wrapper also forwards attribute queries, which is important. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">imp</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_callable </span><span class="s2">= </span><span class="s1">_wrap_missing_loc</span><span class="s2">(</span><span class="s1">imp</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_imp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callable</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_context </span><span class="s2">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_sig </span><span class="s2">= </span><span class="s1">sig</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_imp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sig</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">=</span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_context</span><span class="s2">.</span><span class="s1">add_linking_libs</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'libs'</span><span class="s2">, ()))</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_imp</span><span class="s2">, </span><span class="s1">item</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s6">&quot;&lt;wrapped %s&gt;&quot; </span><span class="s2">% </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callable</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">_has_loc</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Does function *fn* take ``loc`` argument? 
    &quot;&quot;&quot;</span>
    <span class="s1">sig </span><span class="s2">= </span><span class="s1">utils</span><span class="s2">.</span><span class="s1">pysignature</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s6">'loc' </span><span class="s0">in </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">parameters</span>


<span class="s0">class </span><span class="s1">_wrap_missing_loc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">func </span><span class="s2">= </span><span class="s1">fn </span><span class="s5"># store this to help with debug</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Wrap function for missing ``loc`` keyword argument. 
        Otherwise, return the original *fn*. 
        &quot;&quot;&quot;</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s0">if not </span><span class="s1">_has_loc</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">wrapper</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s6">'loc'</span><span class="s2">)     </span><span class="s5"># drop unused loc</span>
                <span class="s0">return </span><span class="s1">fn</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s5"># Copy the following attributes from the wrapped.</span>
            <span class="s5"># Following similar implementation as functools.wraps but</span>
            <span class="s5"># ignore attributes if not available (i.e fix py2.7)</span>
            <span class="s1">attrs </span><span class="s2">= </span><span class="s6">'__name__'</span><span class="s2">, </span><span class="s6">'libs'</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">attrs</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">val </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">wrapper</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">wrapper</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">fn</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s6">&quot;&lt;wrapped %s&gt;&quot; </span><span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>


<span class="s2">@</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">runonce</span>
<span class="s0">def </span><span class="s1">_initialize_llvm_lock_event</span><span class="s2">():</span>
    <span class="s4">&quot;&quot;&quot;Initial event triggers for LLVM lock 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">enter_fn</span><span class="s2">():</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">start_event</span><span class="s2">(</span><span class="s6">&quot;numba:llvm_lock&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">exit_fn</span><span class="s2">():</span>
        <span class="s1">event</span><span class="s2">.</span><span class="s1">end_event</span><span class="s2">(</span><span class="s6">&quot;numba:llvm_lock&quot;</span><span class="s2">)</span>

    <span class="s1">ll</span><span class="s2">.</span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">register_lock_callback</span><span class="s2">(</span><span class="s1">enter_fn</span><span class="s2">, </span><span class="s1">exit_fn</span><span class="s2">)</span>


<span class="s1">_initialize_llvm_lock_event</span><span class="s2">()</span>
</pre>
</body>
</html>